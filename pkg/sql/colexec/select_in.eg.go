// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"sort"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecop"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/cockroach/pkg/util/json"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ apd.Context
	_ duration.Duration
	_ = coldataext.CompareDatum
	_ json.JSON
)

// Remove unused warnings.
var (
	_ = colexecerror.InternalError
)

// Enum used to represent comparison results.
type comparisonResult int

const (
	siTrue comparisonResult = iota
	siFalse
	siNull
)

func GetInProjectionOperator(
	allocator *colmem.Allocator,
	t *types.T,
	input colexecop.Operator,
	colIdx int,
	resultIdx int,
	datumTuple *tree.DTuple,
	negate bool,
) (colexecop.Operator, error) {
	input = colexecutils.NewVectorTypeEnforcer(allocator, input, types.Bool, resultIdx)
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpBool{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowBool(t, datumTuple)
			return obj, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpBytes{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowBytes(t, datumTuple)
			return obj, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpDecimal{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowDecimal(t, datumTuple)
			return obj, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			obj := &projectInOpInt16{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt16(t, datumTuple)
			return obj, nil
		case 32:
			obj := &projectInOpInt32{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt32(t, datumTuple)
			return obj, nil
		case -1:
		default:
			obj := &projectInOpInt64{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt64(t, datumTuple)
			return obj, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpFloat64{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowFloat64(t, datumTuple)
			return obj, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpTimestamp{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowTimestamp(t, datumTuple)
			return obj, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpInterval{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInterval(t, datumTuple)
			return obj, nil
		}
	case types.JsonFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpJSON{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowJSON(t, datumTuple)
			return obj, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpDatum{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				allocator:      allocator,
				colIdx:         colIdx,
				outputIdx:      resultIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowDatum(t, datumTuple)
			return obj, nil
		}
	}
	return nil, errors.Errorf("unhandled type: %s", t.Name())
}

func GetInOperator(
	t *types.T, input colexecop.Operator, colIdx int, datumTuple *tree.DTuple, negate bool,
) (colexecop.Operator, error) {
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpBool{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowBool(t, datumTuple)
			return obj, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpBytes{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowBytes(t, datumTuple)
			return obj, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpDecimal{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowDecimal(t, datumTuple)
			return obj, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			obj := &selectInOpInt16{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt16(t, datumTuple)
			return obj, nil
		case 32:
			obj := &selectInOpInt32{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt32(t, datumTuple)
			return obj, nil
		case -1:
		default:
			obj := &selectInOpInt64{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInt64(t, datumTuple)
			return obj, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpFloat64{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowFloat64(t, datumTuple)
			return obj, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpTimestamp{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowTimestamp(t, datumTuple)
			return obj, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpInterval{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowInterval(t, datumTuple)
			return obj, nil
		}
	case types.JsonFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpJSON{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowJSON(t, datumTuple)
			return obj, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpDatum{
				OneInputHelper: colexecop.MakeOneInputHelper(input),
				colIdx:         colIdx,
				negate:         negate,
			}
			obj.filterRow, obj.hasNulls = fillDatumRowDatum(t, datumTuple)
			return obj, nil
		}
	}
	return nil, errors.Errorf("unhandled type: %s", t.Name())
}

type selectInOpBool struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []bool
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpBool{}

type projectInOpBool struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []bool
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpBool{}

func fillDatumRowBool(t *types.T, datumTuple *tree.DTuple) ([]bool, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []bool
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(bool)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowBool(filterRow []bool, targetCol coldata.Bools) {
	less := func(i, j int) bool {
		var cmpResult int

		if !filterRow[i] && filterRow[j] {
			cmpResult = -1
		} else if filterRow[i] && !filterRow[j] {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInBool(
	targetElem bool, targetCol coldata.Bools, filterRow []bool, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowBool, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		if !targetElem && filterRow[i] {
			cmpResult = -1
		} else if targetElem && !filterRow[i] {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBool) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowBool because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowBool(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBool) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bool()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowBool because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowBool(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpBytes struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpBytes{}

type projectInOpBytes struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpBytes{}

func fillDatumRowBytes(t *types.T, datumTuple *tree.DTuple) ([][]byte, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result [][]byte
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.([]byte)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowBytes(filterRow [][]byte, targetCol *coldata.Bytes) {
	less := func(i, j int) bool {
		var cmpResult int
		cmpResult = bytes.Compare(filterRow[i], filterRow[j])
		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInBytes(
	targetElem []byte, targetCol *coldata.Bytes, filterRow [][]byte, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowBytes, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int
		cmpResult = bytes.Compare(targetElem, filterRow[i])
		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBytes) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowBytes because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowBytes(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBytes) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bytes()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowBytes because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowBytes(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				v := col.Get(i)
				cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDecimal struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpDecimal{}

type projectInOpDecimal struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpDecimal{}

func fillDatumRowDecimal(t *types.T, datumTuple *tree.DTuple) ([]apd.Decimal, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []apd.Decimal
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(apd.Decimal)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowDecimal(filterRow []apd.Decimal, targetCol coldata.Decimals) {
	less := func(i, j int) bool {
		var cmpResult int
		cmpResult = tree.CompareDecimals(&filterRow[i], &filterRow[j])
		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInDecimal(
	targetElem apd.Decimal, targetCol coldata.Decimals, filterRow []apd.Decimal, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowDecimal, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int
		cmpResult = tree.CompareDecimals(&targetElem, &filterRow[i])
		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDecimal) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowDecimal because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowDecimal(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDecimal) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Decimal()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowDecimal because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowDecimal(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt16 struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []int16
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpInt16{}

type projectInOpInt16 struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int16
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpInt16{}

func fillDatumRowInt16(t *types.T, datumTuple *tree.DTuple) ([]int16, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []int16
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(int16)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowInt16(filterRow []int16, targetCol coldata.Int16s) {
	less := func(i, j int) bool {
		var cmpResult int

		{
			a, b := int64(filterRow[i]), int64(filterRow[j])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInInt16(
	targetElem int16, targetCol coldata.Int16s, filterRow []int16, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowInt16, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		{
			a, b := int64(targetElem), int64(filterRow[i])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt16) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowInt16 because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowInt16(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt16) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int16()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowInt16 because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowInt16(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt32 struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []int32
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpInt32{}

type projectInOpInt32 struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int32
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpInt32{}

func fillDatumRowInt32(t *types.T, datumTuple *tree.DTuple) ([]int32, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []int32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(int32)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowInt32(filterRow []int32, targetCol coldata.Int32s) {
	less := func(i, j int) bool {
		var cmpResult int

		{
			a, b := int64(filterRow[i]), int64(filterRow[j])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInInt32(
	targetElem int32, targetCol coldata.Int32s, filterRow []int32, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowInt32, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		{
			a, b := int64(targetElem), int64(filterRow[i])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt32) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowInt32 because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowInt32(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt32) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int32()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowInt32 because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowInt32(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt64 struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []int64
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpInt64{}

type projectInOpInt64 struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int64
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpInt64{}

func fillDatumRowInt64(t *types.T, datumTuple *tree.DTuple) ([]int64, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []int64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(int64)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowInt64(filterRow []int64, targetCol coldata.Int64s) {
	less := func(i, j int) bool {
		var cmpResult int

		{
			a, b := int64(filterRow[i]), int64(filterRow[j])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInInt64(
	targetElem int64, targetCol coldata.Int64s, filterRow []int64, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowInt64, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		{
			a, b := int64(targetElem), int64(filterRow[i])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt64) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowInt64 because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowInt64(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt64) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int64()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowInt64 because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowInt64(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpFloat64 struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []float64
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpFloat64{}

type projectInOpFloat64 struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []float64
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpFloat64{}

func fillDatumRowFloat64(t *types.T, datumTuple *tree.DTuple) ([]float64, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []float64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(float64)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowFloat64(filterRow []float64, targetCol coldata.Float64s) {
	less := func(i, j int) bool {
		var cmpResult int

		{
			a, b := float64(filterRow[i]), float64(filterRow[j])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInFloat64(
	targetElem float64, targetCol coldata.Float64s, filterRow []float64, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowFloat64, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		{
			a, b := float64(targetElem), float64(filterRow[i])
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat64) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowFloat64 because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowFloat64(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpFloat64) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Float64()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowFloat64 because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowFloat64(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpTimestamp struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpTimestamp{}

type projectInOpTimestamp struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpTimestamp{}

func fillDatumRowTimestamp(t *types.T, datumTuple *tree.DTuple) ([]time.Time, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []time.Time
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(time.Time)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowTimestamp(filterRow []time.Time, targetCol coldata.Times) {
	less := func(i, j int) bool {
		var cmpResult int

		if filterRow[i].Before(filterRow[j]) {
			cmpResult = -1
		} else if filterRow[j].Before(filterRow[i]) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInTimestamp(
	targetElem time.Time, targetCol coldata.Times, filterRow []time.Time, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowTimestamp, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		if targetElem.Before(filterRow[i]) {
			cmpResult = -1
		} else if filterRow[i].Before(targetElem) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpTimestamp) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowTimestamp because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowTimestamp(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpTimestamp) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Timestamp()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowTimestamp because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowTimestamp(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInterval struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []duration.Duration
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpInterval{}

type projectInOpInterval struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []duration.Duration
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpInterval{}

func fillDatumRowInterval(t *types.T, datumTuple *tree.DTuple) ([]duration.Duration, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []duration.Duration
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(duration.Duration)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowInterval(filterRow []duration.Duration, targetCol coldata.Durations) {
	less := func(i, j int) bool {
		var cmpResult int
		cmpResult = filterRow[i].Compare(filterRow[j])
		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInInterval(
	targetElem duration.Duration, targetCol coldata.Durations, filterRow []duration.Duration, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowInterval, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int
		cmpResult = targetElem.Compare(filterRow[i])
		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInterval) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowInterval because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowInterval(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					v := col.Get(i)
					if cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInterval) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Interval()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowInterval because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowInterval(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					//gcassert:bce
					v := col.Get(i)
					cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				//gcassert:bce
				v := col.Get(i)
				cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpJSON struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []json.JSON
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpJSON{}

type projectInOpJSON struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []json.JSON
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpJSON{}

func fillDatumRowJSON(t *types.T, datumTuple *tree.DTuple) ([]json.JSON, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []json.JSON
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(json.JSON)
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowJSON(filterRow []json.JSON, targetCol *coldata.JSONs) {
	less := func(i, j int) bool {
		var cmpResult int

		var err error
		cmpResult, err = filterRow[i].Compare(filterRow[j])
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInJSON(
	targetElem json.JSON, targetCol *coldata.JSONs, filterRow []json.JSON, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowJSON, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		var err error
		cmpResult, err = targetElem.Compare(filterRow[i])
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpJSON) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.JSON()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowJSON because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowJSON(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInJSON(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInJSON(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInJSON(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if cmpInJSON(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpJSON) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.JSON()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowJSON because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowJSON(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInJSON(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInJSON(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInJSON(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				v := col.Get(i)
				cmpRes := cmpInJSON(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDatum struct {
	colexecop.OneInputHelper
	colIdx    int
	filterRow []interface{}
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &selectInOpDatum{}

type projectInOpDatum struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []interface{}
	hasNulls  bool
	negate    bool
	sorted    bool
}

var _ colexecop.Operator = &projectInOpDatum{}

func fillDatumRowDatum(t *types.T, datumTuple *tree.DTuple) ([]interface{}, bool) {
	conv := colconv.GetDatumToPhysicalFn(t)
	var result []interface{}
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw := conv(d)
			converted := convRaw.(interface{})
			result = append(result, converted)
		}
	}
	return result, hasNulls
}

func sortDatumRowDatum(filterRow []interface{}, targetCol coldata.DatumVec) {
	less := func(i, j int) bool {
		var cmpResult int

		cmpResult = coldataext.CompareDatum(filterRow[i], targetCol, filterRow[j])

		return cmpResult < 0
	}
	if !sort.SliceIsSorted(filterRow, less) {
		sort.Slice(filterRow, less)
	}
}

func cmpInDatum(
	targetElem interface{}, targetCol coldata.DatumVec, filterRow []interface{}, hasNulls bool,
) comparisonResult {
	// Filter row input was already sorted in sortDatumRowDatum, so we can
	// perform a binary search.
	lo := 0
	hi := len(filterRow)
	for lo < hi {
		i := (lo + hi) / 2
		var cmpResult int

		cmpResult = coldataext.CompareDatum(targetElem, targetCol, filterRow[i])

		if cmpResult == 0 {
			return siTrue
		} else if cmpResult > 0 {
			lo = i + 1
		} else {
			hi = i
		}
	}

	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDatum) Next() coldata.Batch {
	for {
		batch := si.Input.Next()
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()

		// Sort si.filterRow once. We perform the sort here instead of in
		// fillDatumRowDatum because the compare overload requires the eval
		// context of a coldata.DatumVec target column.
		if !si.sorted {
			sortDatumRowDatum(si.filterRow, col)
			si.sorted = true
		}

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDatum) Next() coldata.Batch {
	batch := pi.Input.Next()
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Datum()

	// Sort pi.filterRow once. We perform the sort here instead of in
	// fillDatumRowDatum because the compare overload requires the eval context
	// of a coldata.DatumVec target column.
	if !pi.sorted {
		sortDatumRowDatum(pi.filterRow, col)
		pi.sorted = true
	}

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			_ = col.Get(n - 1)
			for i := 0; i < n; i++ {
				v := col.Get(i)
				cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}
