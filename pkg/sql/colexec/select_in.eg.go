// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// Remove unused warnings.
var (
	_ = colexecerror.InternalError
)

// Enum used to represent comparison results.
type comparisonResult int

const (
	siTrue comparisonResult = iota
	siFalse
	siNull
)

func GetInProjectionOperator(
	allocator *colmem.Allocator,
	t *types.T,
	input colexecbase.Operator,
	colIdx int,
	resultIdx int,
	datumTuple *tree.DTuple,
	negate bool,
) (colexecbase.Operator, error) {
	input = newVectorTypeEnforcer(allocator, input, types.Bool, resultIdx)
	var err error
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpBool{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowBool(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpBytes{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpDecimal{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			obj := &projectInOpInt16{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		case 32:
			obj := &projectInOpInt32{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		case -1:
		default:
			obj := &projectInOpInt64{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpFloat64{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpTimestamp{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowTimestamp(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpInterval{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInterval(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &projectInOpDatum{
				OneInputNode: NewOneInputNode(input),
				allocator:    allocator,
				colIdx:       colIdx,
				outputIdx:    resultIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowDatum(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	}
	return nil, errors.Errorf("unhandled type: %s", t.Name())
}

func GetInOperator(
	t *types.T, input colexecbase.Operator, colIdx int, datumTuple *tree.DTuple, negate bool,
) (colexecbase.Operator, error) {
	var err error
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpBool{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowBool(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpBytes{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpDecimal{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			obj := &selectInOpInt16{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		case 32:
			obj := &selectInOpInt32{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		case -1:
		default:
			obj := &selectInOpInt64{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpFloat64{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpTimestamp{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowTimestamp(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpInterval{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowInterval(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			obj := &selectInOpDatum{
				OneInputNode: NewOneInputNode(input),
				colIdx:       colIdx,
				negate:       negate,
			}
			obj.filterRow, obj.hasNulls, err = fillDatumRowDatum(t, datumTuple)
			if err != nil {
				return nil, err
			}
			return obj, nil
		}
	}
	return nil, errors.Errorf("unhandled type: %s", t.Name())
}

type selectInOpBool struct {
	OneInputNode
	colIdx    int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpBool{}

type projectInOpBool struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpBool{}

func fillDatumRowBool(t *types.T, datumTuple *tree.DTuple) ([]bool, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []bool
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(bool)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBool(
	targetElem bool, targetCol coldata.Bools, filterRow []bool, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			if !targetElem && filterRow[i] {
				cmpResult = -1
			} else if targetElem && !filterRow[i] {
				cmpResult = 1
			} else {
				cmpResult = 0
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBool) Init() {
	si.input.Init()
}

func (pi *projectInOpBool) Init() {
	pi.input.Init()
}

func (si *selectInOpBool) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bool()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInBool(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBool) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bool()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInBool(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpBytes struct {
	OneInputNode
	colIdx    int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpBytes{}

type projectInOpBytes struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpBytes{}

func fillDatumRowBytes(t *types.T, datumTuple *tree.DTuple) ([][]byte, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result [][]byte
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.([]byte)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBytes(
	targetElem []byte, targetCol *coldata.Bytes, filterRow [][]byte, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int
			cmpResult = bytes.Compare(targetElem, filterRow[i])
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBytes) Init() {
	si.input.Init()
}

func (pi *projectInOpBytes) Init() {
	pi.input.Init()
}

func (si *selectInOpBytes) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bytes()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInBytes(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBytes) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bytes()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInBytes(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDecimal struct {
	OneInputNode
	colIdx    int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpDecimal{}

type projectInOpDecimal struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpDecimal{}

func fillDatumRowDecimal(t *types.T, datumTuple *tree.DTuple) ([]apd.Decimal, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []apd.Decimal
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(apd.Decimal)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInDecimal(
	targetElem apd.Decimal, targetCol coldata.Decimals, filterRow []apd.Decimal, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int
			cmpResult = tree.CompareDecimals(&targetElem, &filterRow[i])
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDecimal) Init() {
	si.input.Init()
}

func (pi *projectInOpDecimal) Init() {
	pi.input.Init()
}

func (si *selectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Decimal()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInDecimal(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Decimal()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInDecimal(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt16 struct {
	OneInputNode
	colIdx    int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpInt16{}

type projectInOpInt16 struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpInt16{}

func fillDatumRowInt16(t *types.T, datumTuple *tree.DTuple) ([]int16, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []int16
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int16)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt16(
	targetElem int16, targetCol coldata.Int16s, filterRow []int16, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(targetElem), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt16) Init() {
	si.input.Init()
}

func (pi *projectInOpInt16) Init() {
	pi.input.Init()
}

func (si *selectInOpInt16) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int16()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInInt16(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt16) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int16()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt16(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt32 struct {
	OneInputNode
	colIdx    int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpInt32{}

type projectInOpInt32 struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpInt32{}

func fillDatumRowInt32(t *types.T, datumTuple *tree.DTuple) ([]int32, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []int32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt32(
	targetElem int32, targetCol coldata.Int32s, filterRow []int32, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(targetElem), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt32) Init() {
	si.input.Init()
}

func (pi *projectInOpInt32) Init() {
	pi.input.Init()
}

func (si *selectInOpInt32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int32()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInInt32(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt32) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int32()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt32(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt64 struct {
	OneInputNode
	colIdx    int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpInt64{}

type projectInOpInt64 struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpInt64{}

func fillDatumRowInt64(t *types.T, datumTuple *tree.DTuple) ([]int64, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []int64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt64(
	targetElem int64, targetCol coldata.Int64s, filterRow []int64, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(targetElem), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt64) Init() {
	si.input.Init()
}

func (pi *projectInOpInt64) Init() {
	pi.input.Init()
}

func (si *selectInOpInt64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int64()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInInt64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInt64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpFloat64 struct {
	OneInputNode
	colIdx    int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpFloat64{}

type projectInOpFloat64 struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpFloat64{}

func fillDatumRowFloat64(t *types.T, datumTuple *tree.DTuple) ([]float64, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []float64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInFloat64(
	targetElem float64, targetCol coldata.Float64s, filterRow []float64, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := float64(targetElem), float64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else if a == b {
					cmpResult = 0
				} else if math.IsNaN(a) {
					if math.IsNaN(b) {
						cmpResult = 0
					} else {
						cmpResult = -1
					}
				} else {
					cmpResult = 1
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat64) Init() {
	si.input.Init()
}

func (pi *projectInOpFloat64) Init() {
	pi.input.Init()
}

func (si *selectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float64()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInFloat64(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Float64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInFloat64(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpTimestamp struct {
	OneInputNode
	colIdx    int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpTimestamp{}

type projectInOpTimestamp struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpTimestamp{}

func fillDatumRowTimestamp(t *types.T, datumTuple *tree.DTuple) ([]time.Time, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []time.Time
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(time.Time)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInTimestamp(
	targetElem time.Time, targetCol coldata.Times, filterRow []time.Time, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			if targetElem.Before(filterRow[i]) {
				cmpResult = -1
			} else if filterRow[i].Before(targetElem) {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpTimestamp) Init() {
	si.input.Init()
}

func (pi *projectInOpTimestamp) Init() {
	pi.input.Init()
}

func (si *selectInOpTimestamp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Timestamp()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInTimestamp(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpTimestamp) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Timestamp()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInTimestamp(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInterval struct {
	OneInputNode
	colIdx    int
	filterRow []duration.Duration
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpInterval{}

type projectInOpInterval struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []duration.Duration
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpInterval{}

func fillDatumRowInterval(t *types.T, datumTuple *tree.DTuple) ([]duration.Duration, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []duration.Duration
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(duration.Duration)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInterval(
	targetElem duration.Duration, targetCol coldata.Durations, filterRow []duration.Duration, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int
			cmpResult = targetElem.Compare(filterRow[i])
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInterval) Init() {
	si.input.Init()
}

func (pi *projectInOpInterval) Init() {
	pi.input.Init()
}

func (si *selectInOpInterval) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Interval()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if !nulls.NullAt(i) && cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i) //gcassert:inline
					if cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1) //gcassert:inline
				for i := 0; i < n; i++ {
					v := col.Get(i) //gcassert:inline
					if cmpInInterval(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInterval) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Interval()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i) //gcassert:inline
					cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:n]
			for i := 0; i < n; i++ {
				v := col.Get(i) //gcassert:inline
				cmpRes := cmpInInterval(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDatum struct {
	OneInputNode
	colIdx    int
	filterRow []interface{}
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &selectInOpDatum{}

type projectInOpDatum struct {
	OneInputNode
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	filterRow []interface{}
	hasNulls  bool
	negate    bool
}

var _ colexecbase.Operator = &projectInOpDatum{}

func fillDatumRowDatum(t *types.T, datumTuple *tree.DTuple) ([]interface{}, bool, error) {
	conv := GetDatumToPhysicalFn(t)
	var result []interface{}
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(interface{})
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInDatum(
	targetElem interface{}, targetCol coldata.DatumVec, filterRow []interface{}, hasNulls bool,
) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			cmpResult = targetElem.(*coldataext.Datum).CompareDatum(targetCol, filterRow[i])

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDatum) Init() {
	si.input.Init()
}

func (pi *projectInOpDatum) Init() {
	pi.input.Init()
}

func (si *selectInOpDatum) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return coldata.ZeroBatch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Datum()
		var idx int
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if !nulls.NullAt(i) && cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(i)
					if cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					v := col.Get(i)
					if cmpInDatum(v, col, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = i
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDatum) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if batch.Length() == 0 {
		return coldata.ZeroBatch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Datum()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projNulls.UnsetNulls()
	}

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col.Slice(0, n)
			for i := 0; i < n; i++ {
				if nulls.NullAt(i) {
					projNulls.SetNull(i)
				} else {
					v := col.Get(i)
					cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(i)
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(i)
				cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col.Slice(0, n)
			for i := 0; i < n; i++ {
				v := col.Get(i)
				cmpRes := cmpInDatum(v, col, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(i)
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}
