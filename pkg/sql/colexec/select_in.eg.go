// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

// Enum used to represent comparison results
type comparisonResult int

const (
	siTrue comparisonResult = iota
	siFalse
	siNull
)

func GetInProjectionOperator(
	allocator *Allocator,
	ct *types.T,
	input Operator,
	colIdx int,
	resultIdx int,
	datumTuple *tree.DTuple,
	negate bool,
) (Operator, error) {
	var err error
	switch t := typeconv.FromColumnType(ct); t {
	case coltypes.Bool:
		obj := &projectInOpBool{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBool(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Bytes:
		obj := &projectInOpBytes{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Decimal:
		obj := &projectInOpDecimal{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int16:
		obj := &projectInOpInt16{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int32:
		obj := &projectInOpInt32{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int64:
		obj := &projectInOpInt64{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Float64:
		obj := &projectInOpFloat64{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Timestamp:
		obj := &projectInOpTimestamp{
			OneInputNode: NewOneInputNode(input),
			allocator:    allocator,
			colIdx:       colIdx,
			outputIdx:    resultIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowTimestamp(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	default:
		return nil, errors.Errorf("unhandled type: %s", t)
	}
}

func GetInOperator(
	ct *types.T, input Operator, colIdx int, datumTuple *tree.DTuple, negate bool,
) (Operator, error) {
	var err error
	switch t := typeconv.FromColumnType(ct); t {
	case coltypes.Bool:
		obj := &selectInOpBool{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBool(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Bytes:
		obj := &selectInOpBytes{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Decimal:
		obj := &selectInOpDecimal{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int16:
		obj := &selectInOpInt16{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int32:
		obj := &selectInOpInt32{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Int64:
		obj := &selectInOpInt64{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Float64:
		obj := &selectInOpFloat64{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case coltypes.Timestamp:
		obj := &selectInOpTimestamp{
			OneInputNode: NewOneInputNode(input),
			colIdx:       colIdx,
			negate:       negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowTimestamp(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	default:
		return nil, errors.Errorf("unhandled type: %s", t)
	}
}

type selectInOpBool struct {
	OneInputNode
	colIdx    int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

type projectInOpBool struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpBool{}

func fillDatumRowBool(ct *types.T, datumTuple *tree.DTuple) ([]bool, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []bool
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(bool)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBool(target bool, filterRow []bool, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			if !target && filterRow[i] {
				cmpResult = -1
			} else if target && !filterRow[i] {
				cmpResult = 1
			} else {
				cmpResult = 0
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBool) Init() {
	si.input.Init()
}

func (pi *projectInOpBool) Init() {
	pi.input.Init()
}

func (si *selectInOpBool) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInBool(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInBool(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInBool(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInBool(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBool) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bool()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInBool(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInBool(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInBool(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInBool(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpBytes struct {
	OneInputNode
	colIdx    int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

type projectInOpBytes struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpBytes{}

func fillDatumRowBytes(ct *types.T, datumTuple *tree.DTuple) ([][]byte, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result [][]byte
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.([]byte)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInBytes(target []byte, filterRow [][]byte, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int
			cmpResult = bytes.Compare(target, filterRow[i])
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBytes) Init() {
	si.input.Init()
}

func (pi *projectInOpBytes) Init() {
	pi.input.Init()
}

func (si *selectInOpBytes) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(int(i))
					if !nulls.NullAt(uint16(i)) && cmpInBytes(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					v := col.Get(i)
					if !nulls.NullAt(uint16(i)) && cmpInBytes(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col.Get(int(i))
					if cmpInBytes(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					v := col.Get(i)
					if cmpInBytes(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpBytes) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Bytes()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col.Get(int(i))
					cmpRes := cmpInBytes(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col.Slice(0, int(n))
			for i := 0; i < col.Len(); i++ {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col.Get(i)
					cmpRes := cmpInBytes(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col.Get(int(i))
				cmpRes := cmpInBytes(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col.Slice(0, int(n))
			for i := 0; i < col.Len(); i++ {
				v := col.Get(i)
				cmpRes := cmpInBytes(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpDecimal struct {
	OneInputNode
	colIdx    int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

type projectInOpDecimal struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpDecimal{}

func fillDatumRowDecimal(ct *types.T, datumTuple *tree.DTuple) ([]apd.Decimal, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []apd.Decimal
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(apd.Decimal)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInDecimal(target apd.Decimal, filterRow []apd.Decimal, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int
			cmpResult = tree.CompareDecimals(&target, &filterRow[i])
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDecimal) Init() {
	si.input.Init()
}

func (pi *projectInOpDecimal) Init() {
	pi.input.Init()
}

func (si *selectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInDecimal(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInDecimal(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInDecimal(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInDecimal(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Decimal()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInDecimal(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInDecimal(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInDecimal(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInDecimal(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt16 struct {
	OneInputNode
	colIdx    int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

type projectInOpInt16 struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpInt16{}

func fillDatumRowInt16(ct *types.T, datumTuple *tree.DTuple) ([]int16, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []int16
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int16)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt16(target int16, filterRow []int16, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(target), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt16) Init() {
	si.input.Init()
}

func (pi *projectInOpInt16) Init() {
	pi.input.Init()
}

func (si *selectInOpInt16) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInInt16(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInInt16(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInInt16(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInInt16(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt16) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int16()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInInt16(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInInt16(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInInt16(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInInt16(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt32 struct {
	OneInputNode
	colIdx    int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

type projectInOpInt32 struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpInt32{}

func fillDatumRowInt32(ct *types.T, datumTuple *tree.DTuple) ([]int32, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []int32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt32(target int32, filterRow []int32, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(target), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt32) Init() {
	si.input.Init()
}

func (pi *projectInOpInt32) Init() {
	pi.input.Init()
}

func (si *selectInOpInt32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInInt32(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInInt32(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInInt32(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInInt32(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt32) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int32()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInInt32(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInInt32(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInInt32(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInInt32(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpInt64 struct {
	OneInputNode
	colIdx    int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

type projectInOpInt64 struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpInt64{}

func fillDatumRowInt64(ct *types.T, datumTuple *tree.DTuple) ([]int64, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []int64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInInt64(target int64, filterRow []int64, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := int64(target), int64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else {
					cmpResult = 0
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt64) Init() {
	si.input.Init()
}

func (pi *projectInOpInt64) Init() {
	pi.input.Init()
}

func (si *selectInOpInt64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInInt64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInInt64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInInt64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInInt64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpInt64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Int64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInInt64(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInInt64(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInInt64(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInInt64(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpFloat64 struct {
	OneInputNode
	colIdx    int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

type projectInOpFloat64 struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpFloat64{}

func fillDatumRowFloat64(ct *types.T, datumTuple *tree.DTuple) ([]float64, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []float64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInFloat64(target float64, filterRow []float64, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			{
				a, b := float64(target), float64(filterRow[i])
				if a < b {
					cmpResult = -1
				} else if a > b {
					cmpResult = 1
				} else if a == b {
					cmpResult = 0
				} else if math.IsNaN(a) {
					if math.IsNaN(b) {
						cmpResult = 0
					} else {
						cmpResult = -1
					}
				} else {
					cmpResult = 1
				}
			}

			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat64) Init() {
	si.input.Init()
}

func (pi *projectInOpFloat64) Init() {
	pi.input.Init()
}

func (si *selectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInFloat64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInFloat64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInFloat64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInFloat64(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Float64()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInFloat64(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInFloat64(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInFloat64(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInFloat64(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}

type selectInOpTimestamp struct {
	OneInputNode
	colIdx    int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
}

type projectInOpTimestamp struct {
	OneInputNode
	allocator *Allocator
	colIdx    int
	outputIdx int
	filterRow []time.Time
	hasNulls  bool
	negate    bool
}

var _ Operator = &projectInOpTimestamp{}

func fillDatumRowTimestamp(ct *types.T, datumTuple *tree.DTuple) ([]time.Time, bool, error) {
	conv := typeconv.GetDatumToPhysicalFn(ct)
	var result []time.Time
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(time.Time)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func cmpInTimestamp(target time.Time, filterRow []time.Time, hasNulls bool) comparisonResult {
	for i := range filterRow {
		var cmp bool

		{
			var cmpResult int

			if target.Before(filterRow[i]) {
				cmpResult = -1
			} else if filterRow[i].Before(target) {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
			cmp = cmpResult == 0
		}

		if cmp {
			return siTrue
		}
	}
	if hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpTimestamp) Init() {
	si.input.Init()
}

func (pi *projectInOpTimestamp) Init() {
	pi.input.Init()
}

func (si *selectInOpTimestamp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Timestamp()
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if !nulls.NullAt(uint16(i)) && cmpInTimestamp(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if !nulls.NullAt(uint16(i)) && cmpInTimestamp(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					v := col[int(i)]
					if cmpInTimestamp(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					v := col[i]
					if cmpInTimestamp(v, si.filterRow, si.hasNulls) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (pi *projectInOpTimestamp) Next(ctx context.Context) coldata.Batch {
	batch := pi.input.Next(ctx)
	if pi.outputIdx == batch.Width() {
		pi.allocator.AppendColumn(batch, coltypes.Bool)
	}
	if batch.Length() == 0 {
		return batch
	}

	vec := batch.ColVec(pi.colIdx)
	col := vec.Timestamp()

	projVec := batch.ColVec(pi.outputIdx)
	projCol := projVec.Bool()
	projNulls := projVec.Nulls()

	n := batch.Length()

	cmpVal := siTrue
	if pi.negate {
		cmpVal = siFalse
	}

	if vec.MaybeHasNulls() {
		nulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[int(i)]
					cmpRes := cmpInTimestamp(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				if nulls.NullAt(uint16(i)) {
					projNulls.SetNull(uint16(i))
				} else {
					v := col[i]
					cmpRes := cmpInTimestamp(v, pi.filterRow, pi.hasNulls)
					if cmpRes == siNull {
						projNulls.SetNull(uint16(i))
					} else {
						projCol[i] = cmpRes == cmpVal
					}
				}
			}
		}
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				v := col[int(i)]
				cmpRes := cmpInTimestamp(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		} else {
			col = col[0:int(n)]
			for i := range col {
				v := col[i]
				cmpRes := cmpInTimestamp(v, pi.filterRow, pi.hasNulls)
				if cmpRes == siNull {
					projNulls.SetNull(uint16(i))
				} else {
					projCol[i] = cmpRes == cmpVal
				}
			}
		}
	}
	return batch
}
