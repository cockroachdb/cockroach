// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/server/telemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sqltelemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

type projBitandInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projBitandInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projBitandInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projBitandInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projBitandInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projBitandInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projBitandInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projBitandInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projBitandInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) & int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) & int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projBitandDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projBitandDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitandDatumConstDatumOp) Init() {
	p.input.Init()
}

type projBitorInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projBitorInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projBitorInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projBitorInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projBitorInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projBitorInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projBitorInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projBitorInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projBitorInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) | int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) | int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projBitorDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projBitorDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitorDatumConstDatumOp) Init() {
	p.input.Init()
}

type projBitxorInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projBitxorInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projBitxorInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projBitxorInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projBitxorInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projBitxorInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projBitxorInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projBitxorInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projBitxorInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					projCol[i] = int64(p.constArg) ^ int64(arg)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				projCol[i] = int64(p.constArg) ^ int64(arg)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projBitxorDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projBitxorDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projBitxorDatumConstDatumOp) Init() {
	p.input.Init()
}

type projPlusDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projPlusDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projPlusDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projPlusDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Add(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projPlusInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projPlusInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projPlusInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt16ConstDatumOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt16ConstDatumOp) Init() {
	p.input.Init()
}

type projPlusInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projPlusInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projPlusInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projPlusInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt32ConstDatumOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt32ConstDatumOp) Init() {
	p.input.Init()
}

type projPlusInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projPlusInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projPlusInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) + int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) + int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) < 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projPlusInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Add(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt64ConstDatumOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusInt64ConstDatumOp) Init() {
	p.input.Init()
}

type projPlusFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projPlusFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) + float64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) + float64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) + float64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) + float64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projPlusTimestampConstIntervalOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projPlusTimestampConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(p.constArg, arg)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(p.constArg, arg)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = duration.Add(p.constArg, arg)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = duration.Add(p.constArg, arg)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusTimestampConstIntervalOp) Init() {
	p.input.Init()
}

type projPlusIntervalConstTimestampOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projPlusIntervalConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(arg, p.constArg)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(arg, p.constArg)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = duration.Add(arg, p.constArg)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = duration.Add(arg, p.constArg)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalConstTimestampOp) Init() {
	p.input.Init()
}

type projPlusIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projPlusIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Add(arg)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Add(arg)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.Add(arg)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.Add(arg)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projPlusIntervalConstDatumOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projPlusIntervalConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: p.constArg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: p.constArg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusIntervalConstDatumOp) Init() {
	p.input.Init()
}

type projPlusDatumConstIntervalOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projPlusDatumConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInterval{Duration: arg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInterval{Duration: arg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumConstIntervalOp) Init() {
	p.input.Init()
}

type projPlusDatumConstInt16Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projPlusDatumConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumConstInt16Op) Init() {
	p.input.Init()
}

type projPlusDatumConstInt32Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projPlusDatumConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumConstInt32Op) Init() {
	p.input.Init()
}

type projPlusDatumConstInt64Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projPlusDatumConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPlusDatumConstInt64Op) Init() {
	p.input.Init()
}

type projMinusDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projMinusDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projMinusDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projMinusDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Sub(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projMinusInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projMinusInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projMinusInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projMinusInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projMinusInt16ConstDatumOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt16ConstDatumOp) Init() {
	p.input.Init()
}

type projMinusInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projMinusInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projMinusInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projMinusInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projMinusInt32ConstDatumOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt32ConstDatumOp) Init() {
	p.input.Init()
}

type projMinusInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projMinusInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projMinusInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						result := int64(p.constArg) - int64(arg)
						if (result < int64(p.constArg)) != (int64(arg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					result := int64(p.constArg) - int64(arg)
					if (result < int64(p.constArg)) != (int64(arg) > 0) {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projMinusInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Sub(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projMinusInt64ConstDatumOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64ConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInt(p.constArg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusInt64ConstDatumOp) Init() {
	p.input.Init()
}

type projMinusFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projMinusFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) - float64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) - float64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) - float64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) - float64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projMinusTimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projMinusTimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					nanos := p.constArg.Sub(arg).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					nanos := p.constArg.Sub(arg).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				nanos := p.constArg.Sub(arg).Nanoseconds()
				projCol[i] = duration.MakeDuration(nanos, 0, 0)

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				nanos := p.constArg.Sub(arg).Nanoseconds()
				projCol[i] = duration.MakeDuration(nanos, 0, 0)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusTimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projMinusTimestampConstIntervalOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projMinusTimestampConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Timestamp()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(p.constArg, arg.Mul(-1))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = duration.Add(p.constArg, arg.Mul(-1))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = duration.Add(p.constArg, arg.Mul(-1))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = duration.Add(p.constArg, arg.Mul(-1))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusTimestampConstIntervalOp) Init() {
	p.input.Init()
}

type projMinusIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMinusIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Sub(arg)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Sub(arg)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.Sub(arg)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.Sub(arg)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projMinusIntervalConstDatumOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMinusIntervalConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

					_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: p.constArg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DInterval{Duration: p.constArg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_nonDatumArgAsColdataExtDatum := &coldataext.Datum{Datum: _nonDatumArgAsDatum}

				_res, err := _nonDatumArgAsColdataExtDatum.BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusIntervalConstDatumOp) Init() {
	p.input.Init()
}

type projMinusDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstDatumOp) Init() {
	p.input.Init()
}

type projMinusDatumConstIntervalOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInterval{Duration: arg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInterval{Duration: arg}
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstIntervalOp) Init() {
	p.input.Init()
}

type projMinusDatumConstBytesOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DBytes(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DBytes(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DBytes(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DBytes(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstBytesOp) Init() {
	p.input.Init()
}

type projMinusDatumConstInt16Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstInt16Op) Init() {
	p.input.Init()
}

type projMinusDatumConstInt32Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstInt32Op) Init() {
	p.input.Init()
}

type projMinusDatumConstInt64Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projMinusDatumConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMinusDatumConstInt64Op) Init() {
	p.input.Init()
}

type projMultDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projMultDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projMultDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projMultDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					_, err := tree.ExactCtx.Mul(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalConstIntervalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					f, err := p.constArg.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg.MulFloat(f)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					f, err := p.constArg.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = arg.MulFloat(f)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				f, err := p.constArg.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg.MulFloat(f)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				f, err := p.constArg.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = arg.MulFloat(f)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultDecimalConstIntervalOp) Init() {
	p.input.Init()
}

type projMultInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projMultInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projMultInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projMultInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projMultInt16ConstIntervalOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16ConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt16ConstIntervalOp) Init() {
	p.input.Init()
}

type projMultInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projMultInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projMultInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projMultInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projMultInt32ConstIntervalOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32ConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt32ConstIntervalOp) Init() {
	p.input.Init()
}

type projMultInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projMultInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projMultInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						_left, _right := int64(p.constArg), int64(arg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					_left, _right := int64(p.constArg), int64(arg)
					result := _left * _right
					if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
						if _left != 0 && _right != 0 {
							sameSign := (_left < 0) == (_right < 0)
							if (result < 0) == sameSign {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							} else if result/_right != _left {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
						}
					}
					projCol[i] = result
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projMultInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.ExactCtx.Mul(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projMultInt64ConstIntervalOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64ConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = arg.Mul(int64(p.constArg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultInt64ConstIntervalOp) Init() {
	p.input.Init()
}

type projMultFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projMultFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) * float64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = float64(p.constArg) * float64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) * float64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					projCol[i] = float64(p.constArg) * float64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projMultFloat64ConstIntervalOp struct {
	projConstOpBase
	constArg float64
}

func (p projMultFloat64ConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.MulFloat(float64(p.constArg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = arg.MulFloat(float64(p.constArg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = arg.MulFloat(float64(p.constArg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = arg.MulFloat(float64(p.constArg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultFloat64ConstIntervalOp) Init() {
	p.input.Init()
}

type projMultIntervalConstInt16Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultIntervalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalConstInt16Op) Init() {
	p.input.Init()
}

type projMultIntervalConstInt32Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultIntervalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalConstInt32Op) Init() {
	p.input.Init()
}

type projMultIntervalConstInt64Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultIntervalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.Mul(int64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalConstInt64Op) Init() {
	p.input.Init()
}

type projMultIntervalConstFloat64Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultIntervalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.MulFloat(float64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]
					projCol[i] = p.constArg.MulFloat(float64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]
				projCol[i] = p.constArg.MulFloat(float64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]
				projCol[i] = p.constArg.MulFloat(float64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalConstFloat64Op) Init() {
	p.input.Init()
}

type projMultIntervalConstDecimalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultIntervalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					f, err := arg.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = p.constArg.MulFloat(f)
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					f, err := arg.Float64()
					if err != nil {
						colexecerror.InternalError(err)
					}
					projCol[i] = p.constArg.MulFloat(f)
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				f, err := arg.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = p.constArg.MulFloat(f)
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				f, err := arg.Float64()
				if err != nil {
					colexecerror.InternalError(err)
				}
				projCol[i] = p.constArg.MulFloat(f)
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projMultIntervalConstDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projDivDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projDivDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projDivDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projDivInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projDivInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projDivInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projDivInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projDivInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projDivInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projDivInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projDivInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projDivInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projDivInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projDivInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Quo(&projCol[i], leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projDivInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Quo(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projDivFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projDivFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(p.constArg) / float64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(p.constArg) / float64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = float64(p.constArg) / float64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = float64(p.constArg) / float64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projDivIntervalConstInt64Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projDivIntervalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = p.constArg.Div(int64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = p.constArg.Div(int64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				if arg == 0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = p.constArg.Div(int64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				if arg == 0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = p.constArg.Div(int64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivIntervalConstInt64Op) Init() {
	p.input.Init()
}

type projDivIntervalConstFloat64Op struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projDivIntervalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Interval()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = p.constArg.DivFloat(float64(arg))
				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = p.constArg.DivFloat(float64(arg))
				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				if arg == 0.0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = p.constArg.DivFloat(float64(arg))
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				if arg == 0.0 {
					colexecerror.ExpectedError(tree.ErrDivByZero)
				}
				projCol[i] = p.constArg.DivFloat(float64(arg))
			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projDivIntervalConstFloat64Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projFloorDivDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projFloorDivInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projFloorDivInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projFloorDivInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projFloorDivInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projFloorDivInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projFloorDivInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projFloorDivInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projFloorDivInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projFloorDivInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) // int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) // int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projFloorDivInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projFloorDivFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projFloorDivFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(p.constArg) / float64(arg))
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(p.constArg) / float64(arg))
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Trunc(float64(p.constArg) / float64(arg))
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Trunc(float64(p.constArg) / float64(arg))
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projFloorDivFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projModDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projModDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projModDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projModDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projModInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projModInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projModInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projModInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projModInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projModInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projModInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projModInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projModInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projModInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projModInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projModInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projModInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projModInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projModInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projModInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projModInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projModInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projModInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projModInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projModInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projModInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(p.constArg) % int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = int64(p.constArg) % int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projModInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projModInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg.IsZero() {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.HighPrecisionCtx.Rem(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projModFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projModFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(p.constArg), float64(arg))
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						if arg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(p.constArg), float64(arg))
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Mod(float64(p.constArg), float64(arg))
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					if arg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}

					projCol[i] = math.Mod(float64(p.constArg), float64(arg))
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projModFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projPowDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projPowDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projPowDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(arg))
					if _, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, tmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projPowDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					_, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					_, err := tree.DecimalCtx.Pow(&projCol[i], &p.constArg, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projPowInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projPowInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projPowInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projPowInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projPowInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projPowInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projPowInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projPowInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projPowInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projPowInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projPowInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
						leftTmpDec.SetInt64(int64(int64(p.constArg)))
						rightTmpDec.SetInt64(int64(int64(arg)))
						if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					leftTmpDec, rightTmpDec := &_overloadHelper.tmpDec1, &_overloadHelper.tmpDec2
					leftTmpDec.SetInt64(int64(int64(p.constArg)))
					rightTmpDec.SetInt64(int64(int64(arg)))
					if _, err := tree.DecimalCtx.Pow(leftTmpDec, leftTmpDec, rightTmpDec); err != nil {
						colexecerror.ExpectedError(err)
					}
					resultInt, err := leftTmpDec.Int64()
					if err != nil {
						colexecerror.ExpectedError(tree.ErrIntOutOfRange)
					}
					projCol[i] = resultInt
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projPowInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Decimal()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					tmpDec := &_overloadHelper.tmpDec1
					tmpDec.SetInt64(int64(p.constArg))
					_, err := tree.DecimalCtx.Pow(&projCol[i], tmpDec, &arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projPowFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projPowFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Float64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = math.Pow(float64(p.constArg), float64(arg))
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{

						projCol[i] = math.Pow(float64(p.constArg), float64(arg))
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{

					projCol[i] = math.Pow(float64(p.constArg), float64(arg))
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{

					projCol[i] = math.Pow(float64(p.constArg), float64(arg))
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projPowFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projConcatBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projConcatBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bytes()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var r = []byte{}
						r = append(r, p.constArg...)
						r = append(r, arg...)
						projCol.Set(i, r)
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var r = []byte{}
						r = append(r, p.constArg...)
						r = append(r, arg...)
						projCol.Set(i, r)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var r = []byte{}
					r = append(r, p.constArg...)
					r = append(r, arg...)
					projCol.Set(i, r)
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var r = []byte{}
					r = append(r, p.constArg...)
					r = append(r, arg...)
					projCol.Set(i, r)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projConcatBytesConstBytesOp) Init() {
	p.input.Init()
}

type projConcatDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projConcatDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, arg)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projConcatDatumConstDatumOp) Init() {
	p.input.Init()
}

type projLShiftInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projLShiftInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projLShiftInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projLShiftInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projLShiftInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projLShiftInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projLShiftInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projLShiftInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projLShiftInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) << int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) << int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projLShiftDatumConstInt16Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projLShiftDatumConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumConstInt16Op) Init() {
	p.input.Init()
}

type projLShiftDatumConstInt32Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projLShiftDatumConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumConstInt32Op) Init() {
	p.input.Init()
}

type projLShiftDatumConstInt64Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projLShiftDatumConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLShiftDatumConstInt64Op) Init() {
	p.input.Init()
}

type projRShiftInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projRShiftInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projRShiftInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projRShiftInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projRShiftInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projRShiftInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projRShiftInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projRShiftInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projRShiftInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Int64()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						if int64(arg) < 0 || int64(arg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(p.constArg) >> int64(arg)
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					if int64(arg) < 0 || int64(arg) >= 64 {
						telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
						colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
					}
					projCol[i] = int64(p.constArg) >> int64(arg)
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projRShiftDatumConstInt16Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projRShiftDatumConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumConstInt16Op) Init() {
	p.input.Init()
}

type projRShiftDatumConstInt32Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projRShiftDatumConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumConstInt32Op) Init() {
	p.input.Init()
}

type projRShiftDatumConstInt64Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projRShiftDatumConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projRShiftDatumConstInt64Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumConstBytesOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchValDatumConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DString(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					_convertedNativeElem := tree.DString(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				_convertedNativeElem := tree.DString(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				_convertedNativeElem := tree.DString(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumConstBytesOp) Init() {
	p.input.Init()
}

type projJSONFetchValDatumConstInt16Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchValDatumConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumConstInt16Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumConstInt32Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchValDatumConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumConstInt32Op) Init() {
	p.input.Init()
}

type projJSONFetchValDatumConstInt64Op struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchValDatumConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Datum()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol.Set(i, _res)

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		} else {
			col = col[0:n]
			_ = projCol.Get(n - 1)
			for i := 0; i < n; i++ {
				arg := col[i]

				_convertedNativeElem := tree.DInt(arg)
				var _nonDatumArgAsDatum tree.Datum
				_nonDatumArgAsDatum = &_convertedNativeElem

				_res, err := p.constArg.(*coldataext.Datum).BinFn(_overloadHelper.binFn, _overloadHelper.evalCtx, _nonDatumArgAsDatum)
				if err != nil {
					colexecerror.ExpectedError(err)
				}
				projCol.Set(i, _res)

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projJSONFetchValDatumConstInt64Op) Init() {
	p.input.Init()
}

type projEQBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projEQBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQBoolConstBoolOp) Init() {
	p.input.Init()
}

type projEQBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projEQBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQBytesConstBytesOp) Init() {
	p.input.Init()
}

type projEQDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projEQDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projEQDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projEQDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projEQFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQTimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projEQTimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQTimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projEQIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projEQIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projEQDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projEQDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult == 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult == 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult == 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult == 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projEQDatumConstDatumOp) Init() {
	p.input.Init()
}

type projNEBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projNEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projNEBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projNEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projNEDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projNEDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projNEDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projNEDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projNEDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projNEFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projNETimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projNETimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNETimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projNEIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projNEIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projNEDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projNEDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult != 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult != 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult != 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult != 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projNEDatumConstDatumOp) Init() {
	p.input.Init()
}

type projLTBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projLTBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTBoolConstBoolOp) Init() {
	p.input.Init()
}

type projLTBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projLTBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTBytesConstBytesOp) Init() {
	p.input.Init()
}

type projLTDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projLTDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projLTDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projLTDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projLTDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projLTFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTTimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projLTTimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTTimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projLTIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projLTIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projLTDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projLTDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult < 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult < 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult < 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult < 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLTDatumConstDatumOp) Init() {
	p.input.Init()
}

type projLEBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projLEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projLEBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projLEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projLEDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projLEDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projLEDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projLEDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projLEDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projLEFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLETimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projLETimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLETimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projLEIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projLEIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projLEDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projLEDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult <= 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult <= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult <= 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult <= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projLEDatumConstDatumOp) Init() {
	p.input.Init()
}

type projGTBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projGTBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTBoolConstBoolOp) Init() {
	p.input.Init()
}

type projGTBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projGTBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTBytesConstBytesOp) Init() {
	p.input.Init()
}

type projGTDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projGTDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projGTDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projGTDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projGTDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projGTFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTTimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projGTTimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTTimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projGTIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projGTIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projGTDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projGTDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult > 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult > 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult > 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult > 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGTDatumConstDatumOp) Init() {
	p.input.Init()
}

type projGEBoolConstBoolOp struct {
	projConstOpBase
	constArg bool
}

func (p projGEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if !p.constArg && arg {
							cmpResult = -1
						} else if p.constArg && !arg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if !p.constArg && arg {
						cmpResult = -1
					} else if p.constArg && !arg {
						cmpResult = 1
					} else {
						cmpResult = 0
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projGEBytesConstBytesOp struct {
	projConstOpBase
	constArg []byte
}

func (p projGEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(p.constArg, arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col
			_ = 0
			_ = n
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int
					cmpResult = bytes.Compare(p.constArg, arg)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projGEDecimalConstInt16Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projGEDecimalConstInt32Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projGEDecimalConstInt64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(arg))
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projGEDecimalConstFloat64Op struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projGEDecimalConstDecimalOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&p.constArg, &arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = tree.CompareDecimals(&p.constArg, &arg)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt16ConstInt16Op struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt16ConstInt32Op struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt16ConstInt64Op struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt16ConstFloat64Op struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt16ConstDecimalOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt32ConstInt16Op struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt32ConstInt32Op struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt32ConstInt64Op struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt32ConstFloat64Op struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt32ConstDecimalOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt64ConstInt16Op struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt64ConstInt32Op struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt64ConstInt64Op struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(p.constArg), int64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := int64(p.constArg), int64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt64ConstFloat64Op struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if false {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt64ConstDecimalOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						tmpDec.SetInt64(int64(p.constArg))
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt16Op struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt32Op struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt64Op struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if false {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projGEFloat64ConstFloat64Op struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(p.constArg), float64(arg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						a, b := float64(p.constArg), float64(arg)
						if a < b {
							cmpResult = -1
						} else if a > b {
							cmpResult = 1
						} else if a == b {
							cmpResult = 0
						} else if math.IsNaN(a) {
							if math.IsNaN(b) {
								cmpResult = 0
							} else {
								cmpResult = -1
							}
						} else {
							cmpResult = 1
						}
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEFloat64ConstDecimalOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &_overloadHelper.tmpDec1
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					{
						tmpDec := &_overloadHelper.tmpDec1
						if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
							colexecerror.ExpectedError(err)
						}
						cmpResult = tree.CompareDecimals(tmpDec, &arg)
					}

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGETimestampConstTimestampOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projGETimestampConstTimestampOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int

						if p.constArg.Before(arg) {
							cmpResult = -1
						} else if arg.Before(p.constArg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int

					if p.constArg.Before(arg) {
						cmpResult = -1
					} else if arg.Before(p.constArg) {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGETimestampConstTimestampOp) Init() {
	p.input.Init()
}

type projGEIntervalConstIntervalOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projGEIntervalConstIntervalOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col[i]

					{
						var cmpResult int
						cmpResult = p.constArg.Compare(arg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col[0:n]
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col[i]

				{
					var cmpResult int
					cmpResult = p.constArg.Compare(arg)
					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEIntervalConstIntervalOp) Init() {
	p.input.Init()
}

type projGEDatumConstDatumOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projGEDatumConstDatumOp) Next(ctx context.Context) coldata.Batch {
	// In order to inline the templated code of overloads, we need to have a
	// `_overloadHelper` local variable of type `overloadHelper`.
	_overloadHelper := p.overloadHelper
	// However, the scratch is not used in all of the projection operators, so
	// we add this to go around "unused" error.
	_ = _overloadHelper
	batch := p.input.Next(ctx)
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over null values in the
		// output vector.
		projVec.Nulls().UnsetNulls()
	}
	projCol := projVec.Bool()
	if vec.Nulls().MaybeHasNulls() {
		colNulls := vec.Nulls()
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult >= 0
					}

				}
			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				if !colNulls.NullAt(i) {
					// We only want to perform the projection operation if the value is not null.
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

						projCol[i] = cmpResult >= 0
					}

				}
			}
		}
		colNullsCopy := colNulls.Copy()
		projVec.SetNulls(&colNullsCopy)
	} else {
		if sel := batch.Selection(); sel != nil {
			sel = sel[:n]
			for _, i := range sel {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult >= 0
				}

			}
		} else {
			col = col.Slice(0, n)
			_ = projCol[n-1]
			for i := 0; i < n; i++ {
				arg := col.Get(i)

				{
					var cmpResult int

					cmpResult = p.constArg.(*coldataext.Datum).CompareDatum(col, arg)

					projCol[i] = cmpResult >= 0
				}

			}
		}
	}
	// Although we didn't change the length of the batch, it is necessary to set
	// the length anyway (this helps maintaining the invariant of flat bytes).
	batch.SetLength(n)
	return batch
}

func (p projGEDatumConstDatumOp) Init() {
	p.input.Init()
}

// GetProjectionLConstOperator returns the appropriate constant
// projection operator for the given left and right column types and operation.
func GetProjectionLConstOperator(
	allocator *colmem.Allocator,
	leftType *types.T,
	rightType *types.T,
	outputType *types.T,
	op tree.Operator,
	input colexecbase.Operator,
	colIdx int,
	constArg tree.Datum,
	outputIdx int,
	binFn *tree.BinOp,
	evalCtx *tree.EvalContext,
) (colexecbase.Operator, error) {
	input = newVectorTypeEnforcer(allocator, input, outputType, outputIdx)
	projConstOpBase := projConstOpBase{
		OneInputNode:   NewOneInputNode(input),
		allocator:      allocator,
		colIdx:         colIdx,
		outputIdx:      outputIdx,
		overloadHelper: overloadHelper{binFn: binFn, evalCtx: evalCtx},
	}
	var (
		c   interface{}
		err error
	)
	c, err = GetDatumToPhysicalFn(leftType)(constArg)
	if err != nil {
		return nil, err
	}
	switch op.(type) {
	case tree.BinaryOperator:
		switch op {
		case tree.Bitand:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projBitandInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projBitandInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projBitandInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projBitandInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitandInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projBitandInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projBitandInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitandDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.Bitor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projBitorInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projBitorInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projBitorInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projBitorInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitorInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projBitorInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projBitorInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitorDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.Bitxor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projBitxorInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projBitxorInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projBitxorInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projBitxorInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projBitxorInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projBitxorInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projBitxorInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projBitxorDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.Plus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projPlusDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projPlusDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projPlusInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projPlusInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt16ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projPlusInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projPlusInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt32ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projPlusInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projPlusInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusInt64ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusTimestampConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusIntervalConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPlusDatumConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPlusDatumConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case 32:
							return &projPlusDatumConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case -1:
						default:
							return &projPlusDatumConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.Minus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projMinusDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projMinusDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projMinusInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projMinusInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt16ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projMinusInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projMinusInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt32ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projMinusInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projMinusInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusInt64ConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusTimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusTimestampConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusIntervalConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMinusDatumConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMinusDatumConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case 32:
							return &projMinusDatumConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case -1:
						default:
							return &projMinusDatumConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.Mult:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projMultDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projMultDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultDecimalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projMultInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projMultInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt16ConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projMultInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projMultInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt32ConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projMultInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projMultInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultInt64ConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultFloat64ConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projMultIntervalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						case 32:
							return &projMultIntervalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						case -1:
						default:
							return &projMultIntervalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultIntervalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projMultIntervalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			}
		case tree.Div:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projDivDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projDivDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projDivInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projDivInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projDivInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projDivInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projDivInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projDivInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projDivInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivIntervalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projDivIntervalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			}
		case tree.FloorDiv:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projFloorDivDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projFloorDivDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projFloorDivInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projFloorDivInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projFloorDivInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projFloorDivInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projFloorDivInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projFloorDivInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projFloorDivInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projFloorDivFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			}
		case tree.Mod:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projModDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projModDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projModInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projModInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projModInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projModInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projModInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projModInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projModInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projModFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			}
		case tree.Pow:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projPowDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projPowDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projPowInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projPowInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projPowInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projPowInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projPowInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projPowInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projPowInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projPowFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			}
		case tree.Concat:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projConcatBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projConcatDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.LShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projLShiftInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projLShiftInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projLShiftInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projLShiftInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projLShiftInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projLShiftInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLShiftDatumConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case 32:
							return &projLShiftDatumConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case -1:
						default:
							return &projLShiftDatumConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.RShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projRShiftInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projRShiftInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projRShiftInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projRShiftInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projRShiftInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projRShiftInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projRShiftDatumConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case 32:
							return &projRShiftDatumConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case -1:
						default:
							return &projRShiftDatumConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.JSONFetchVal:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projJSONFetchValDatumConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projJSONFetchValDatumConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case 32:
							return &projJSONFetchValDatumConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						case -1:
						default:
							return &projJSONFetchValDatumConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		}
	case tree.ComparisonOperator:
		switch op {
		case tree.EQ:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projEQDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projEQDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projEQInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projEQInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projEQInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projEQInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projEQInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projEQInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projEQFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projEQFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projEQFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQTimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projEQDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.NE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projNEDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projNEDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projNEInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projNEInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projNEInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projNEInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projNEInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projNEInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projNEFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projNEFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projNEFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNETimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projNEDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.LT:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projLTDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projLTDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projLTInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projLTInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projLTInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projLTInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projLTInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projLTInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLTFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projLTFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projLTFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTTimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLTDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.LE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projLEDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projLEDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projLEInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projLEInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projLEInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projLEInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projLEInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projLEInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projLEFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projLEFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projLEFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLETimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projLEDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.GT:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projGTDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projGTDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projGTInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projGTInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projGTInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projGTInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projGTInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projGTInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGTFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projGTFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projGTFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTTimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGTDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		case tree.GE:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BoolFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BoolFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEBoolConstBoolOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(bool),
							}, nil
						}
					}
				}
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEBytesConstBytesOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}, nil
						}
					}
				}
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEDecimalConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case 32:
							return &projGEDecimalConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						case -1:
						default:
							return &projGEDecimalConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDecimalConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDecimalConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt16ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case 32:
							return &projGEInt16ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						case -1:
						default:
							return &projGEInt16ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt16ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt16ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt32ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case 32:
							return &projGEInt32ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						case -1:
						default:
							return &projGEInt32ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt32ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt32ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEInt64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case 32:
							return &projGEInt64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						case -1:
						default:
							return &projGEInt64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEInt64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							return &projGEFloat64ConstInt16Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case 32:
							return &projGEFloat64ConstInt32Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						case -1:
						default:
							return &projGEFloat64ConstInt64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEFloat64ConstFloat64Op{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEFloat64ConstDecimalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGETimestampConstTimestampOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEIntervalConstIntervalOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							return &projGEDatumConstDatumOp{
								projConstOpBase: projConstOpBase,
								constArg:        &coldataext.Datum{Datum: c.(tree.Datum)},
							}, nil
						}
					}
				}
			}
		}
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), op, rightType.Name())
}
