// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecbase

import (
	"context"
	"fmt"
	"math"
	"time"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecop"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/cockroach/pkg/util/json"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var _ coldataext.Datum

func GetCastOperator(
	allocator *colmem.Allocator,
	input colexecop.Operator,
	colIdx int,
	resultIdx int,
	fromType *types.T,
	toType *types.T,
) (colexecop.Operator, error) {
	input = colexecutils.NewVectorTypeEnforcer(allocator, input, toType, resultIdx)
	if fromType.Family() == types.UnknownFamily {
		return &castOpNullAny{
			OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
			allocator:                allocator,
			colIdx:                   colIdx,
			outputIdx:                resultIdx,
		}, nil
	}
	if toType.Identical(fromType) {
		// We have an identity cast, so we use a custom identity cast operator.
		return &castIdentityOp{
			OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
			allocator:                allocator,
			colIdx:                   colIdx,
			outputIdx:                resultIdx,
		}, nil
	}
	switch fromType.Family() {
	case types.BoolFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castBoolFloatOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return &castBoolInt2Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case 32:
					return &castBoolInt4Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case -1:
				default:
					return &castBoolIntOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		}
	case types.DecimalFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castDecimalBoolOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return &castDecimalInt2Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case 32:
					return &castDecimalInt4Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case -1:
				default:
					return &castDecimalIntOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castDecimalFloatOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castDecimalDecimalOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		}
	case types.IntFamily:
		switch fromType.Width() {
		case 16:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 32:
					return &castInt2Int4Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case -1:
				default:
					return &castInt2IntOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt2BoolOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt2DecimalOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt2FloatOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		case 32:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return &castInt4Int2Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case -1:
				default:
					return &castInt4IntOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt4BoolOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt4DecimalOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castInt4FloatOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		case -1:
		default:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return &castIntInt2Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case 32:
					return &castIntInt4Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castIntBoolOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castIntDecimalOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castIntFloatOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		}
	case types.FloatFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castFloatBoolOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return &castFloatDecimalOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return &castFloatInt2Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case 32:
					return &castFloatInt4Op{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				case -1:
				default:
					return &castFloatIntOp{
						OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
						allocator:                allocator,
						colIdx:                   colIdx,
						outputIdx:                resultIdx,
						toType:                   toType,
					}, nil
				}
			}
		}
	}
	if typeconv.TypeFamilyToCanonicalTypeFamily(fromType.Family()) == typeconv.DatumVecCanonicalTypeFamily {
		switch toType.Family() {
		case types.BoolFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumBoolOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.IntFamily:
			switch toType.Width() {
			case 16:
				return &castDatumInt2Op{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			case 32:
				return &castDatumInt4Op{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			case -1:
			default:
				return &castDatumIntOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.FloatFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumFloatOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.DecimalFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumDecimalOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.DateFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumDateOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.TimestampFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumTimestampOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.IntervalFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumIntervalOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.StringFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumStringOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.BytesFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumBytesOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.TimestampTZFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumTimestamptzOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.UuidFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumUuidOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		case types.JsonFamily:
			switch toType.Width() {
			case -1:
			default:
				return &castDatumJsonbOp{
					OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
					allocator:                allocator,
					colIdx:                   colIdx,
					outputIdx:                resultIdx,
					toType:                   toType,
				}, nil
			}
		}

		if typeconv.TypeFamilyToCanonicalTypeFamily(toType.Family()) == typeconv.DatumVecCanonicalTypeFamily {
			return &castDatumDatumOp{
				OneInputInitCloserHelper: colexecop.MakeOneInputInitCloserHelper(input),
				allocator:                allocator,
				colIdx:                   colIdx,
				outputIdx:                resultIdx,
				toType:                   toType,
			}, nil
		}
	}
	return nil, errors.Errorf("unhandled cast %s -> %s", fromType, toType)
}

func IsCastSupported(fromType, toType *types.T) bool {
	if fromType.Family() == types.UnknownFamily {
		return true
	}
	if toType.Identical(fromType) {
		return true
	}
	switch fromType.Family() {
	case types.BoolFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return true
				case 32:
					return true
				case -1:
				default:
					return true
				}
			}
		}
	case types.DecimalFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return true
				case 32:
					return true
				case -1:
				default:
					return true
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			}
		}
	case types.IntFamily:
		switch fromType.Width() {
		case 16:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 32:
					return true
				case -1:
				default:
					return true
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			}
		case 32:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return true
				case -1:
				default:
					return true
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			}
		case -1:
		default:
			switch toType.Family() {
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return true
				case 32:
					return true
				}
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.FloatFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			}
		}
	case types.FloatFamily:
		switch fromType.Width() {
		case -1:
		default:
			switch toType.Family() {
			case types.BoolFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.DecimalFamily:
				switch toType.Width() {
				case -1:
				default:
					return true
				}
			case types.IntFamily:
				switch toType.Width() {
				case 16:
					return true
				case 32:
					return true
				case -1:
				default:
					return true
				}
			}
		}
	}
	if typeconv.TypeFamilyToCanonicalTypeFamily(fromType.Family()) == typeconv.DatumVecCanonicalTypeFamily {
		switch toType.Family() {
		case types.BoolFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.IntFamily:
			switch toType.Width() {
			case 16:
				return true
			case 32:
				return true
			case -1:
			default:
				return true
			}
		case types.FloatFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.DecimalFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.DateFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.TimestampFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.IntervalFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.StringFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.BytesFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.TimestampTZFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.UuidFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		case types.JsonFamily:
			switch toType.Width() {
			case -1:
			default:
				return true
			}
		}

		if typeconv.TypeFamilyToCanonicalTypeFamily(toType.Family()) == typeconv.DatumVecCanonicalTypeFamily {
			return true
		}
	}
	return false
}

type castOpNullAny struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
}

var _ colexecop.ClosableOperator = &castOpNullAny{}

func (c *castOpNullAny) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(c.colIdx)
	projVec := batch.ColVec(c.outputIdx)
	vecNulls := vec.Nulls()
	projNulls := projVec.Nulls()
	if projVec.MaybeHasNulls() {
		// We need to make sure that there are no left over nulls values in the
		// output vector.
		projNulls.UnsetNulls()
	}
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			if vecNulls.NullAt(i) {
				projNulls.SetNull(i)
			} else {
				colexecerror.InternalError(errors.Errorf("unexpected non-null at index %d", i))
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if vecNulls.NullAt(i) {
				projNulls.SetNull(i)
			} else {
				colexecerror.InternalError(fmt.Errorf("unexpected non-null at index %d", i))
			}
		}
	}
	return batch
}

// castIdentityOp is a special cast operator for the case when "from" and "to"
// types are identical. The job of this operator is to simply copy the input
// column into the output column, without performing the deselection step. Not
// performing the deselection is justified by the following:
// 1. to be in line with other cast operators
// 2. AND/OR projection operators cannot handle when a different batch is
//    returned than the one they fed into the projection chain (which might
//    contain casts)
// 3. performing the deselection would require copying over all vectors, not
//    just the output one.
// This operator should be planned rarely enough (if ever) to not be very
// important.
type castIdentityOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
}

var _ colexecop.ClosableOperator = &castIdentityOp{}

func (c *castIdentityOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		maxIdx := n
		if sel := batch.Selection(); sel != nil {
			// We don't want to perform the deselection during copying, so we
			// will copy everything up to (and including) the last selected
			// element, without the selection vector.
			maxIdx = sel[n-1] + 1
		}
		projVec.Copy(coldata.SliceArgs{
			Src:       batch.ColVec(c.colIdx),
			SrcEndIdx: maxIdx,
		})
	})
	return batch
}

type castBoolFloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castBoolFloatOp{}
var _ colexecop.ClosableOperator = &castBoolFloatOp{}

func (c *castBoolFloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castBoolFloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Bool()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castBoolInt2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castBoolInt2Op{}
var _ colexecop.ClosableOperator = &castBoolInt2Op{}

func (c *castBoolInt2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castBoolInt2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Bool()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castBoolInt4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castBoolInt4Op{}
var _ colexecop.ClosableOperator = &castBoolInt4Op{}

func (c *castBoolInt4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castBoolInt4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Bool()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castBoolIntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castBoolIntOp{}
var _ colexecop.ClosableOperator = &castBoolIntOp{}

func (c *castBoolIntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castBoolIntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Bool()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64

						r = 0
						if v {
							r = 1
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						r = 0
						if v {
							r = 1
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalBoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDecimalBoolOp{}
var _ colexecop.ClosableOperator = &castDecimalBoolOp{}

func (c *castDecimalBoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalBoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool
						r = v.Sign() != 0
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool
						r = v.Sign() != 0
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool
						r = v.Sign() != 0
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool
						r = v.Sign() != 0
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalInt2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator      *colmem.Allocator
	colIdx         int
	outputIdx      int
	toType         *types.T
	overloadHelper execgen.OverloadHelper
}

var _ colexecop.ResettableOperator = &castDecimalInt2Op{}
var _ colexecop.ClosableOperator = &castDecimalInt2Op{}

func (c *castDecimalInt2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalInt2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "execgen.OverloadHelper".
	_overloadHelper := c.overloadHelper
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}

							shifted := _i >> uint(15)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}
							r = int16(_i)

						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}

							shifted := _i >> uint(15)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}
							r = int16(_i)

						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}

							shifted := _i >> uint(15)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}
							r = int16(_i)

						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}

							shifted := _i >> uint(15)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
							}
							r = int16(_i)

						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalInt4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator      *colmem.Allocator
	colIdx         int
	outputIdx      int
	toType         *types.T
	overloadHelper execgen.OverloadHelper
}

var _ colexecop.ResettableOperator = &castDecimalInt4Op{}
var _ colexecop.ClosableOperator = &castDecimalInt4Op{}

func (c *castDecimalInt4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalInt4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "execgen.OverloadHelper".
	_overloadHelper := c.overloadHelper
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}

							shifted := _i >> uint(31)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}
							r = int32(_i)

						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}

							shifted := _i >> uint(31)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}
							r = int32(_i)

						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}

							shifted := _i >> uint(31)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}
							r = int32(_i)

						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}

							shifted := _i >> uint(31)
							if (_i >= 0 && shifted > 0) || (_i < 0 && shifted < -1) {
								colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
							}
							r = int32(_i)

						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalIntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator      *colmem.Allocator
	colIdx         int
	outputIdx      int
	toType         *types.T
	overloadHelper execgen.OverloadHelper
}

var _ colexecop.ResettableOperator = &castDecimalIntOp{}
var _ colexecop.ClosableOperator = &castDecimalIntOp{}

func (c *castDecimalIntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalIntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	// In order to inline the templated code of overloads, we need to have a
	// "_overloadHelper" local variable of type "execgen.OverloadHelper".
	_overloadHelper := c.overloadHelper
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							r = int64(_i)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							r = int64(_i)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							r = int64(_i)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							tmpDec := &_overloadHelper.TmpDec1
							_, err := tree.DecimalCtx.RoundToIntegralValue(tmpDec, &v)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							_i, err := tmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							r = int64(_i)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalFloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDecimalFloatOp{}
var _ colexecop.ClosableOperator = &castDecimalFloatOp{}

func (c *castDecimalFloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalFloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							f, err := v.Float64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrFloatOutOfRange)
							}
							r = f
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							f, err := v.Float64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrFloatOutOfRange)
							}
							r = f
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							f, err := v.Float64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrFloatOutOfRange)
							}
							r = f
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							f, err := v.Float64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrFloatOutOfRange)
							}
							r = f
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDecimalDecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDecimalDecimalOp{}
var _ colexecop.ClosableOperator = &castDecimalDecimalOp{}

func (c *castDecimalDecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDecimalDecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Decimal()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.Set(&v)
						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.Set(&v)
						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.Set(&v)
						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.Set(&v)
						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt2Int4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt2Int4Op{}
var _ colexecop.ClosableOperator = &castInt2Int4Op{}

func (c *castInt2Int4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt2Int4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int16()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32
						r = int32(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32
						r = int32(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32
						r = int32(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32
						r = int32(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt2IntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt2IntOp{}
var _ colexecop.ClosableOperator = &castInt2IntOp{}

func (c *castInt2IntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt2IntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int16()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt2BoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt2BoolOp{}
var _ colexecop.ClosableOperator = &castInt2BoolOp{}

func (c *castInt2BoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt2BoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int16()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt2DecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt2DecimalOp{}
var _ colexecop.ClosableOperator = &castInt2DecimalOp{}

func (c *castInt2DecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt2DecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int16()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt2FloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt2FloatOp{}
var _ colexecop.ClosableOperator = &castInt2FloatOp{}

func (c *castInt2FloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt2FloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int16()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt4Int2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt4Int2Op{}
var _ colexecop.ClosableOperator = &castInt4Int2Op{}

func (c *castInt4Int2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt4Int2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int32()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt4IntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt4IntOp{}
var _ colexecop.ClosableOperator = &castInt4IntOp{}

func (c *castInt4IntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt4IntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int32()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64
						r = int64(v)
						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt4BoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt4BoolOp{}
var _ colexecop.ClosableOperator = &castInt4BoolOp{}

func (c *castInt4BoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt4BoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int32()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt4DecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt4DecimalOp{}
var _ colexecop.ClosableOperator = &castInt4DecimalOp{}

func (c *castInt4DecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt4DecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int32()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castInt4FloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castInt4FloatOp{}
var _ colexecop.ClosableOperator = &castInt4FloatOp{}

func (c *castInt4FloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castInt4FloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int32()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castIntInt2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castIntInt2Op{}
var _ colexecop.ClosableOperator = &castIntInt2Op{}

func (c *castIntInt2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castIntInt2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int64()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						shifted := v >> uint(15)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt2OutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castIntInt4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castIntInt4Op{}
var _ colexecop.ClosableOperator = &castIntInt4Op{}

func (c *castIntInt4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castIntInt4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int64()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32

						shifted := v >> uint(31)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
						}
						r = int32(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						shifted := v >> uint(31)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
						}
						r = int32(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32

						shifted := v >> uint(31)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
						}
						r = int32(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						shifted := v >> uint(31)
						if (v >= 0 && shifted > 0) || (v < 0 && shifted < -1) {
							colexecerror.ExpectedError(tree.ErrInt4OutOfRange)
						}
						r = int32(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castIntBoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castIntBoolOp{}
var _ colexecop.ClosableOperator = &castIntBoolOp{}

func (c *castIntBoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castIntBoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int64()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castIntDecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castIntDecimalOp{}
var _ colexecop.ClosableOperator = &castIntDecimalOp{}

func (c *castIntDecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castIntDecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int64()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						r.SetInt64(int64(v))

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castIntFloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castIntFloatOp{}
var _ colexecop.ClosableOperator = &castIntFloatOp{}

func (c *castIntFloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castIntFloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Int64()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						r = float64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castFloatBoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castFloatBoolOp{}
var _ colexecop.ClosableOperator = &castFloatBoolOp{}

func (c *castFloatBoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castFloatBoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Float64()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						r = v != 0

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castFloatDecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castFloatDecimalOp{}
var _ colexecop.ClosableOperator = &castFloatDecimalOp{}

func (c *castFloatDecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castFloatDecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Float64()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						if _, err := r.SetFloat64(float64(v)); err != nil {
							colexecerror.ExpectedError(err)
						}

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						if _, err := r.SetFloat64(float64(v)); err != nil {
							colexecerror.ExpectedError(err)
						}

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						if _, err := r.SetFloat64(float64(v)); err != nil {
							colexecerror.ExpectedError(err)
						}

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						if _, err := r.SetFloat64(float64(v)); err != nil {
							colexecerror.ExpectedError(err)
						}

						if err := tree.LimitDecimalWidth(&r, int(c.toType.Precision()), int(c.toType.Scale())); err != nil {
							colexecerror.ExpectedError(err)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castFloatInt2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castFloatInt2Op{}
var _ colexecop.ClosableOperator = &castFloatInt2Op{}

func (c *castFloatInt2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castFloatInt2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Float64()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt16) || v >= float64(math.MaxInt16) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt16) || v >= float64(math.MaxInt16) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt16) || v >= float64(math.MaxInt16) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int16(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt16) || v >= float64(math.MaxInt16) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int16(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castFloatInt4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castFloatInt4Op{}
var _ colexecop.ClosableOperator = &castFloatInt4Op{}

func (c *castFloatInt4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castFloatInt4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Float64()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt32) || v >= float64(math.MaxInt32) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int32(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt32) || v >= float64(math.MaxInt32) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int32(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt32) || v >= float64(math.MaxInt32) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int32(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt32) || v >= float64(math.MaxInt32) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int32(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castFloatIntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castFloatIntOp{}
var _ colexecop.ClosableOperator = &castFloatIntOp{}

func (c *castFloatIntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castFloatIntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Float64()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt64) || v >= float64(math.MaxInt64) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt64) || v >= float64(math.MaxInt64) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt64) || v >= float64(math.MaxInt64) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int64(v)

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						if math.IsNaN(float64(v)) || v <= float64(math.MinInt64) || v >= float64(math.MaxInt64) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						r = int64(v)

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumBoolOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumBoolOp{}
var _ colexecop.ClosableOperator = &castDatumBoolOp{}

func (c *castDatumBoolOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumBoolOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Bool()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r bool

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(bool)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(bool)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r bool

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(bool)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r bool

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(bool)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumInt2Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumInt2Op{}
var _ colexecop.ClosableOperator = &castDatumInt2Op{}

func (c *castDatumInt2Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumInt2Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Int16()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int16)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int16)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int16)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int16

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int16)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumInt4Op struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumInt4Op{}
var _ colexecop.ClosableOperator = &castDatumInt4Op{}

func (c *castDatumInt4Op) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumInt4Op) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Int32()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int32)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int32)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int32)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int32

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int32)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumIntOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumIntOp{}
var _ colexecop.ClosableOperator = &castDatumIntOp{}

func (c *castDatumIntOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumIntOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumFloatOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumFloatOp{}
var _ colexecop.ClosableOperator = &castDatumFloatOp{}

func (c *castDatumFloatOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumFloatOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Float64()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(float64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(float64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(float64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r float64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(float64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumDecimalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumDecimalOp{}
var _ colexecop.ClosableOperator = &castDatumDecimalOp{}

func (c *castDatumDecimalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumDecimalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Decimal()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(apd.Decimal)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(apd.Decimal)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(apd.Decimal)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r apd.Decimal

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(apd.Decimal)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumDateOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumDateOp{}
var _ colexecop.ClosableOperator = &castDatumDateOp{}

func (c *castDatumDateOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumDateOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Int64()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r int64

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(int64)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumTimestampOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumTimestampOp{}
var _ colexecop.ClosableOperator = &castDatumTimestampOp{}

func (c *castDatumTimestampOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumTimestampOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Timestamp()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumIntervalOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumIntervalOp{}
var _ colexecop.ClosableOperator = &castDatumIntervalOp{}

func (c *castDatumIntervalOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumIntervalOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Interval()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r duration.Duration

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(duration.Duration)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r duration.Duration

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(duration.Duration)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r duration.Duration

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(duration.Duration)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r duration.Duration

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(duration.Duration)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumStringOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumStringOp{}
var _ colexecop.ClosableOperator = &castDatumStringOp{}

func (c *castDatumStringOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumStringOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Bytes()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumBytesOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumBytesOp{}
var _ colexecop.ClosableOperator = &castDatumBytesOp{}

func (c *castDatumBytesOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumBytesOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Bytes()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumTimestamptzOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumTimestamptzOp{}
var _ colexecop.ClosableOperator = &castDatumTimestamptzOp{}

func (c *castDatumTimestamptzOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumTimestamptzOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Timestamp()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					_ = outputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r time.Time

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(time.Time)
						}

						//gcassert:bce
						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumUuidOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumUuidOp{}
var _ colexecop.ClosableOperator = &castDatumUuidOp{}

func (c *castDatumUuidOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumUuidOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Bytes()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r []byte

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).([]byte)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumJsonbOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumJsonbOp{}
var _ colexecop.ClosableOperator = &castDatumJsonbOp{}

func (c *castDatumJsonbOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumJsonbOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.JSON()
			outputNulls := outputVec.Nulls()
			converter := colconv.GetDatumToPhysicalFn(c.toType)
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r json.JSON

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(json.JSON)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r json.JSON

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(json.JSON)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r json.JSON

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(json.JSON)
						}

						outputCol.Set(tupleIdx, r)
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r json.JSON

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = converter(_castedDatum).(json.JSON)
						}

						outputCol.Set(tupleIdx, r)
					}
				}
			}
		},
	)
	return batch
}

type castDatumDatumOp struct {
	colexecop.OneInputInitCloserHelper

	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
	toType    *types.T
}

var _ colexecop.ResettableOperator = &castDatumDatumOp{}
var _ colexecop.ClosableOperator = &castDatumDatumOp{}

func (c *castDatumDatumOp) Reset(ctx context.Context) {
	if r, ok := c.Input.(colexecop.Resetter); ok {
		r.Reset(ctx)
	}
}

func (c *castDatumDatumOp) Next() coldata.Batch {
	batch := c.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	sel := batch.Selection()
	inputVec := batch.ColVec(c.colIdx)
	outputVec := batch.ColVec(c.outputIdx)
	c.allocator.PerformOperation(
		[]coldata.Vec{outputVec}, func() {
			inputCol := inputVec.Datum()
			outputCol := outputVec.Datum()
			outputNulls := outputVec.Nulls()
			if inputVec.MaybeHasNulls() {
				inputNulls := inputVec.Nulls()
				outputNulls.Copy(inputNulls)
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						v := inputCol.Get(tupleIdx)
						var r interface{}

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = _castedDatum
						}

						outputCol.Set(tupleIdx, r)
						// Casting to datum-backed vector might produce a null value on
						// non-null tuple, so we need to check that case after the cast was
						// performed.
						if r == tree.DNull {
							outputNulls.SetNull(tupleIdx)
						}
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						if inputNulls.NullAt(tupleIdx) {
							continue
						}
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r interface{}

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = _castedDatum
						}

						outputCol.Set(tupleIdx, r)
						// Casting to datum-backed vector might produce a null value on
						// non-null tuple, so we need to check that case after the cast was
						// performed.
						if r == tree.DNull {
							outputNulls.SetNull(tupleIdx)
						}
					}
				}
			} else {
				// We need to make sure that there are no left over null values
				// in the output vector.
				outputNulls.UnsetNulls()
				if sel != nil {
					sel = sel[:n]
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = sel[i]
						v := inputCol.Get(tupleIdx)
						var r interface{}

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = _castedDatum
						}

						outputCol.Set(tupleIdx, r)
						// Casting to datum-backed vector might produce a null value on
						// non-null tuple, so we need to check that case after the cast was
						// performed.
						if r == tree.DNull {
							outputNulls.SetNull(tupleIdx)
						}
					}
				} else {
					// Remove bounds checks for inputCol[i] and outputCol[i].
					_ = inputCol.Get(n - 1)
					var tupleIdx int
					for i := 0; i < n; i++ {
						tupleIdx = i
						//gcassert:bce
						v := inputCol.Get(tupleIdx)
						var r interface{}

						{
							_castedDatum, err := v.(*coldataext.Datum).Cast(inputCol, c.toType)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
							r = _castedDatum
						}

						outputCol.Set(tupleIdx, r)
						// Casting to datum-backed vector might produce a null value on
						// non-null tuple, so we need to check that case after the cast was
						// performed.
						if r == tree.DNull {
							outputNulls.SetNull(tupleIdx)
						}
					}
				}
			}
		},
	)
	return batch
}
