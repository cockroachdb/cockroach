// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexeccmp

import (
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/errors"
)

type cmpExprAdapterBase struct {
	fn      tree.TwoArgFn
	evalCtx *tree.EvalContext
}

type cmpExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpExprAdapter{}

func (c *cmpExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpNegateExprAdapter{}

func (c *cmpNegateExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpFlippedExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpFlippedExprAdapter{}

func (c *cmpFlippedExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpFlippedNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpFlippedNegateExprAdapter{}

func (c *cmpFlippedNegateExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	if left == tree.DNull || right == tree.DNull {
		return tree.DNull, nil
	}
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpNullableExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpNullableExprAdapter{}

func (c *cmpNullableExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNullableNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpNullableNegateExprAdapter{}

func (c *cmpNullableNegateExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpNullableFlippedExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpNullableFlippedExprAdapter{}

func (c *cmpNullableFlippedExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(*b)
	return result, nil
}

type cmpNullableFlippedNegateExprAdapter struct {
	cmpExprAdapterBase
}

var _ ComparisonExprAdapter = &cmpNullableFlippedNegateExprAdapter{}

func (c *cmpNullableFlippedNegateExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	left, right = right, left
	d, err := c.fn(c.evalCtx, left, right)
	if d == tree.DNull || err != nil {
		return d, err
	}
	b, ok := d.(*tree.DBool)
	if !ok {
		return nil, errors.AssertionFailedf("%v is %T and not *DBool", d, d)
	}
	result := tree.MakeDBool(!*b)
	return result, nil
}

type cmpWithSubOperatorExprAdapter struct {
	cmpExprAdapterBase
	expr *tree.ComparisonExpr
}

var _ ComparisonExprAdapter = &cmpWithSubOperatorExprAdapter{}

func (c *cmpWithSubOperatorExprAdapter) Eval(left, right tree.Datum) (tree.Datum, error) {
	return tree.EvalComparisonExprWithSubOperator(c.evalCtx, c.expr, left, right)
}
