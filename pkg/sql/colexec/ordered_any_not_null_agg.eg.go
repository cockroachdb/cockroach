// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

func newAnyNotNullOrderedAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) (aggregateFuncAlloc, error) {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBoolOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBytesOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDecimalOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &anyNotNullInt16OrderedAggAlloc{aggAllocBase: allocBase}, nil
		case 32:
			return &anyNotNullInt32OrderedAggAlloc{aggAllocBase: allocBase}, nil
		case -1:
		default:
			return &anyNotNullInt64OrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullFloat64OrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullTimestampOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullIntervalOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDatumOrderedAggAlloc{aggAllocBase: allocBase}, nil
		}
	}
	return nil, errors.Errorf("unsupported any not null agg type %s", t.Name())
}

// anyNotNullBoolOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBoolOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Bools
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      bool
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBoolOrderedAgg{}

const sizeOfAnyNotNullBoolOrderedAgg = int64(unsafe.Sizeof(anyNotNullBoolOrderedAgg{}))

func (a *anyNotNullBoolOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bool()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBoolOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBoolOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBoolOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullBoolOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBoolOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullBoolOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBoolOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullBoolOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullBoolOrderedAggAlloc{}

func (a *anyNotNullBoolOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBoolOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBoolOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullBytesOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBytesOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         *coldata.Bytes
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      []byte
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBytesOrderedAgg{}

const sizeOfAnyNotNullBytesOrderedAgg = int64(unsafe.Sizeof(anyNotNullBytesOrderedAgg{}))

func (a *anyNotNullBytesOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bytes()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBytesOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBytesOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBytesOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullBytesOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBytesOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullBytesOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBytesOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullBytesOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullBytesOrderedAggAlloc{}

func (a *anyNotNullBytesOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBytesOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBytesOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDecimalOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDecimalOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Decimals
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      apd.Decimal
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDecimalOrderedAgg{}

const sizeOfAnyNotNullDecimalOrderedAgg = int64(unsafe.Sizeof(anyNotNullDecimalOrderedAgg{}))

func (a *anyNotNullDecimalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Decimal()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDecimalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDecimalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDecimalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullDecimalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx].Set(&a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDecimalOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDecimalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDecimalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullDecimalOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullDecimalOrderedAggAlloc{}

func (a *anyNotNullDecimalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDecimalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDecimalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt16OrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt16OrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Int16s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int16
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt16OrderedAgg{}

const sizeOfAnyNotNullInt16OrderedAgg = int64(unsafe.Sizeof(anyNotNullInt16OrderedAgg{}))

func (a *anyNotNullInt16OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int16()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt16OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt16OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt16OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt16OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt16OrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt16OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt16OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt16OrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt16OrderedAggAlloc{}

func (a *anyNotNullInt16OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt16OrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt16OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt32OrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt32OrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Int32s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int32
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt32OrderedAgg{}

const sizeOfAnyNotNullInt32OrderedAgg = int64(unsafe.Sizeof(anyNotNullInt32OrderedAgg{}))

func (a *anyNotNullInt32OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int32()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt32OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt32OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt32OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt32OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt32OrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt32OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt32OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt32OrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt32OrderedAggAlloc{}

func (a *anyNotNullInt32OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt32OrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt32OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt64OrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt64OrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Int64s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt64OrderedAgg{}

const sizeOfAnyNotNullInt64OrderedAgg = int64(unsafe.Sizeof(anyNotNullInt64OrderedAgg{}))

func (a *anyNotNullInt64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt64OrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt64OrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt64OrderedAggAlloc{}

func (a *anyNotNullInt64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullFloat64OrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullFloat64OrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Float64s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      float64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullFloat64OrderedAgg{}

const sizeOfAnyNotNullFloat64OrderedAgg = int64(unsafe.Sizeof(anyNotNullFloat64OrderedAgg{}))

func (a *anyNotNullFloat64OrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Float64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullFloat64OrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullFloat64OrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullFloat64OrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullFloat64OrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullFloat64OrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullFloat64OrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullFloat64OrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullFloat64OrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullFloat64OrderedAggAlloc{}

func (a *anyNotNullFloat64OrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullFloat64OrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullFloat64OrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullTimestampOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullTimestampOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Times
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      time.Time
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullTimestampOrderedAgg{}

const sizeOfAnyNotNullTimestampOrderedAgg = int64(unsafe.Sizeof(anyNotNullTimestampOrderedAgg{}))

func (a *anyNotNullTimestampOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Timestamp()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullTimestampOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullTimestampOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullTimestampOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullTimestampOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullTimestampOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullTimestampOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullTimestampOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullTimestampOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullTimestampOrderedAggAlloc{}

func (a *anyNotNullTimestampOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullTimestampOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullTimestampOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullIntervalOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullIntervalOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.Durations
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      duration.Duration
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullIntervalOrderedAgg{}

const sizeOfAnyNotNullIntervalOrderedAgg = int64(unsafe.Sizeof(anyNotNullIntervalOrderedAgg{}))

func (a *anyNotNullIntervalOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Interval()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullIntervalOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullIntervalOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullIntervalOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullIntervalOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col[a.curIdx] = a.curAgg
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullIntervalOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullIntervalOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullIntervalOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullIntervalOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullIntervalOrderedAggAlloc{}

func (a *anyNotNullIntervalOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullIntervalOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullIntervalOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDatumOrderedAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDatumOrderedAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.DatumVec
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      interface{}
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDatumOrderedAgg{}

const sizeOfAnyNotNullDatumOrderedAgg = int64(unsafe.Sizeof(anyNotNullDatumOrderedAgg{}))

func (a *anyNotNullDatumOrderedAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Datum()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDatumOrderedAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDatumOrderedAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDatumOrderedAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullDatumOrderedAgg) Compute(b coldata.Batch, inputIdxs []uint32) {

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1)
			groups := a.groups
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					_ = groups[inputLen-1]
					for i := 0; i < inputLen; i++ {
						if groups[i] {
							// If this is a new group, check if any non-nulls have been found for the
							// current group.
							if !a.foundNonNullForCurrentGroup {
								a.nulls.SetNull(a.curIdx)
							} else {
								a.col.Set(a.curIdx, a.curAgg)
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDatumOrderedAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDatumOrderedAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDatumOrderedAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullDatumOrderedAgg
}

var _ aggregateFuncAlloc = &anyNotNullDatumOrderedAggAlloc{}

func (a *anyNotNullDatumOrderedAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDatumOrderedAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDatumOrderedAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
