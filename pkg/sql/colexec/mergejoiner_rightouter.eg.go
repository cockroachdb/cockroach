// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"fmt"
	"math"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.UNSAFEGET

type mergeJoinRightOuterOp struct {
	mergeJoinBase
}

var _ InternalMemoryOperator = &mergeJoinRightOuterOp{}

func (o *mergeJoinRightOuterOp) probeBodyLSeltrueRSeltrue(
	ctx context.Context,
) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSeltrueRSelfalse(
	ctx context.Context,
) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

								curLIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
											lComplete = true
											break
										}
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := lSel[curLIdx]
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := lSel[curLIdx]
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSelfalseRSeltrue(
	ctx context.Context,
) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											rComplete = true
											break
										}
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
											break
										}
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := rSel[curRIdx]
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := rSel[curRIdx]
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = rSel[curRIdx]
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSelfalseRSelfalse(
	ctx context.Context,
) {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if lVec.Nulls().NullAt64(uint64(curLIdx)) {

								curLIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										if lVec.Nulls().NullAt64(uint64(curLIdx)) {
											lComplete = true
											break
										}
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if rVec.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
							if rVec.Nulls().NullAt64(uint64(curRIdx)) {

								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								continue
							}

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											rComplete = true
											break
										}
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										if rVec.Nulls().NullAt64(uint64(curRIdx)) {
											break
										}
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					lKeys := lVec.Bool()
					rKeys := rVec.Bool()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if !lVal && rVal {
									cmpResult = -1
								} else if lVal && !rVal {
									cmpResult = 1
								} else {
									cmpResult = 0
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if !newLVal && lVal {
												cmpResult = -1
											} else if newLVal && !lVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if !lVal && rVal {
										cmpResult = -1
									} else if lVal && !rVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if !newRVal && rVal {
												cmpResult = -1
											} else if newRVal && !rVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Bytes:
					lKeys := lVec.Bytes()
					rKeys := rVec.Bytes()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys.Get(int(lSelIdx))
							rSelIdx := curRIdx
							rVal := rKeys.Get(int(rSelIdx))

							var match bool

							{
								var cmpResult int
								cmpResult = bytes.Compare(lVal, rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys.Get(int(lSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newLVal, lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(lVal, rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys.Get(int(rSelIdx))

										{
											var cmpResult int
											cmpResult = bytes.Compare(newRVal, rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Decimal:
					lKeys := lVec.Decimal()
					rKeys := rVec.Decimal()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int
								cmpResult = tree.CompareDecimals(&lVal, &rVal)
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newLVal, &lVal)
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&lVal, &rVal)
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&newRVal, &rVal)
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int16:
					lKeys := lVec.Int16()
					rKeys := rVec.Int16()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int32:
					lKeys := lVec.Int32()
					rKeys := rVec.Int32()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Int64:
					lKeys := lVec.Int64()
					rKeys := rVec.Int64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := int64(lVal), int64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newLVal), int64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := int64(lVal), int64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := int64(newRVal), int64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Float64:
					lKeys := lVec.Float64()
					rKeys := rVec.Float64()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								{
									a, b := float64(lVal), float64(rVal)
									if a < b {
										cmpResult = -1
									} else if a > b {
										cmpResult = 1
									} else if a == b {
										cmpResult = 0
									} else if math.IsNaN(a) {
										if math.IsNaN(b) {
											cmpResult = 0
										} else {
											cmpResult = -1
										}
									} else {
										cmpResult = 1
									}
								}

								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newLVal), float64(lVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									{
										a, b := float64(lVal), float64(rVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											{
												a, b := float64(newRVal), float64(rVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				case coltypes.Timestamp:
					lKeys := lVec.Timestamp()
					rKeys := rVec.Timestamp()
					var lGroup, rGroup group
					for o.groups.nextGroupInCol(&lGroup, &rGroup) {
						curLIdx := lGroup.rowStartIdx
						curRIdx := rGroup.rowStartIdx
						curLLength := lGroup.rowEndIdx
						curRLength := rGroup.rowEndIdx
						areGroupsProcessed := false

						if rGroup.unmatched {
							if curRIdx+1 != curRLength {
								execerror.VectorizedInternalPanic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
							}
							// The row already does not have a match, so we don't need to do any
							// additional processing.
							o.groups.addRightOuterGroup(curLIdx, curRIdx)
							curRIdx++
							areGroupsProcessed = true
						}
						// Expand or filter each group based on the current equality column.
						for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

							lSelIdx := curLIdx
							lVal := lKeys[int(lSelIdx)]
							rSelIdx := curRIdx
							rVal := rKeys[int(rSelIdx)]

							var match bool

							{
								var cmpResult int

								if lVal.Before(rVal) {
									cmpResult = -1
								} else if rVal.Before(lVal) {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
								match = cmpResult == 0
							}

							if match {
								// Find the length of the groups on each side.
								lGroupLength, rGroupLength := 1, 1
								lComplete, rComplete := false, false
								beginLIdx, beginRIdx := curLIdx, curRIdx

								// Find the length of the group on the left.
								if curLLength == 0 {
									lGroupLength, lComplete = 0, true
								} else {
									curLIdx++
									for curLIdx < curLLength {
										lSelIdx := curLIdx
										newLVal := lKeys[int(lSelIdx)]

										{
											var cmpResult int

											if newLVal.Before(lVal) {
												cmpResult = -1
											} else if lVal.Before(newLVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											lComplete = true
											break
										}
										lGroupLength++
										curLIdx++
									}
								}

								// Find the length of the group on the right.
								if curRLength == 0 {
									rGroupLength, rComplete = 0, true
								} else {
									curRIdx++
									for curRIdx < curRLength {
										rSelIdx := curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											rComplete = true
											break
										}
										rGroupLength++
										curRIdx++
									}
								}

								// Last equality column and either group is incomplete. Save state
								// and have it handled in the next iteration.
								if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
									o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
									o.proberState.lIdx = lGroupLength + beginLIdx
									o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
									o.proberState.rIdx = rGroupLength + beginRIdx

									o.groups.finishedCol()
									break EqLoop
								}

								if eqColIdx < len(o.left.eqCols)-1 {
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else {
									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								}
							} else { // mismatch
								var incrementLeft bool

								{
									var cmpResult int

									if lVal.Before(rVal) {
										cmpResult = -1
									} else if rVal.Before(lVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									incrementLeft = cmpResult < 0
								}

								// Switch the direction of increment if we're sorted descendingly.
								incrementLeft = incrementLeft == (o.left.directions[eqColIdx] == execinfrapb.Ordering_Column_ASC)
								if incrementLeft {
									curLIdx++

								} else {
									curRIdx++

									// All the rows on the right within the current group will not get a match on
									// the left, so we're adding each of them as a right outer group.
									o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
									for curRIdx < curRLength {
										rSelIdx = curRIdx
										newRVal := rKeys[int(rSelIdx)]

										{
											var cmpResult int

											if newRVal.Before(rVal) {
												cmpResult = -1
											} else if rVal.Before(newRVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											match = cmpResult == 0
										}

										if !match {
											break
										}
										o.groups.addRightOuterGroup(curLIdx, curRIdx)
										curRIdx++
									}
								}

							}
						}

						if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
							// The current group is not the last one within the column, so it cannot be
							// extended into the next batch, and we need to process it right now. Any
							// unprocessed row in the right group will not get a match, so each one of
							// them becomes a new unmatched group with a corresponding null group.
							for curRIdx < curRLength {
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
							}
						}
						// Both o.proberState.lIdx and o.proberState.rIdx should point to the
						// last elements processed in their respective batches.
						o.proberState.lIdx = curLIdx
						o.proberState.rIdx = curRIdx
					}
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroups takes a []group and expands each group into the output by
// repeating each row in the group numRepeats times. For example, given an
// input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is
// repeated numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinRightOuterOp) buildLeftGroups(
	leftGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	outputBatchSize := int(o.outputBatchSize)
	o.allocator.performOperation(
		o.output.ColVecs()[:len(input.outCols)],
		func() {
			// Loop over every column.
		LeftColLoop:
			for outColIdx, inColIdx := range input.outCols {
				outStartIdx := int(destStartIdx)
				out := o.output.ColVec(outColIdx)
				var src coldata.Vec
				if batch.Width() > int(inColIdx) {
					src = batch.ColVec(int(inColIdx))
				}
				colType := input.sourceTypes[inColIdx]

				if sel != nil {
					if src != nil && src.MaybeHasNulls() {

						switch colType {
						case coltypes.Bool:
							var srcCol []bool
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Bytes:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Decimal:
							var srcCol []apd.Decimal
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int16:
							var srcCol []int16
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int32:
							var srcCol []int32
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int64:
							var srcCol []int64
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Float64:
							var srcCol []float64
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Timestamp:
							var srcCol []time.Time
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						default:
							execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
						}
					} else {

						switch colType {
						case coltypes.Bool:
							var srcCol []bool
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Bytes:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Decimal:
							var srcCol []apd.Decimal
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int16:
							var srcCol []int16
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int32:
							var srcCol []int32
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int64:
							var srcCol []int64
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Float64:
							var srcCol []float64
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Timestamp:
							var srcCol []time.Time
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx
									srcStartIdx = int(sel[srcStartIdx])

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						default:
							execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
						}
					}
				} else {
					if src != nil && src.MaybeHasNulls() {

						switch colType {
						case coltypes.Bool:
							var srcCol []bool
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Bytes:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Decimal:
							var srcCol []apd.Decimal
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int16:
							var srcCol []int16
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int32:
							var srcCol []int32
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int64:
							var srcCol []int64
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Float64:
							var srcCol []float64
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Timestamp:
							var srcCol []time.Time
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										if src.Nulls().NullAt64(uint64(srcStartIdx)) {
											out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
											outStartIdx += toAppend
										} else {
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						default:
							execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
						}
					} else {

						switch colType {
						case coltypes.Bool:
							var srcCol []bool
							if src != nil {
								srcCol = src.Bool()
							}
							outCol := out.Bool()
							var val bool
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Bytes:
							var srcCol *coldata.Bytes
							if src != nil {
								srcCol = src.Bytes()
							}
							outCol := out.Bytes()
							var val []byte
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol.Get(srcStartIdx)
											for i := 0; i < toAppend; i++ {
												outCol.Set(outStartIdx, val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Decimal:
							var srcCol []apd.Decimal
							if src != nil {
								srcCol = src.Decimal()
							}
							outCol := out.Decimal()
							var val apd.Decimal
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx].Set(&val)
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int16:
							var srcCol []int16
							if src != nil {
								srcCol = src.Int16()
							}
							outCol := out.Int16()
							var val int16
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int32:
							var srcCol []int32
							if src != nil {
								srcCol = src.Int32()
							}
							outCol := out.Int32()
							var val int32
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Int64:
							var srcCol []int64
							if src != nil {
								srcCol = src.Int64()
							}
							outCol := out.Int64()
							var val int64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Float64:
							var srcCol []float64
							if src != nil {
								srcCol = src.Float64()
							}
							outCol := out.Float64()
							var val float64
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						case coltypes.Timestamp:
							var srcCol []time.Time
							if src != nil {
								srcCol = src.Timestamp()
							}
							outCol := out.Timestamp()
							var val time.Time
							var srcStartIdx int

							// Loop over every group.
							for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
								leftGroup := &leftGroups[o.builderState.left.groupsIdx]
								// If curSrcStartIdx is uninitialized, start it at the group's start idx.
								// Otherwise continue where we left off.
								if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
									o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
								}
								// Loop over every row in the group.
								for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
									// Repeat each row numRepeats times.
									srcStartIdx = o.builderState.left.curSrcStartIdx

									repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
									toAppend := repeatsLeft
									if outStartIdx+toAppend > outputBatchSize {
										toAppend = outputBatchSize - outStartIdx
									}

									if leftGroup.nullGroup {
										out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
										outStartIdx += toAppend
									} else {
										{
											val = srcCol[srcStartIdx]
											for i := 0; i < toAppend; i++ {
												outCol[outStartIdx] = val
												outStartIdx++
											}
										}
									}

									if toAppend < repeatsLeft {
										// We didn't materialize all the rows in the group so save state and
										// move to the next column.
										o.builderState.left.numRepeatsIdx += toAppend
										if outColIdx == len(input.outCols)-1 {
											return
										}
										o.builderState.left.setBuilderColumnState(initialBuilderState)
										continue LeftColLoop
									}

									o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
								}
								o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
							}
							o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
						default:
							execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
						}
					}
				}
				o.builderState.left.setBuilderColumnState(initialBuilderState)
			}
			o.builderState.left.reset()
		},
	)
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not
// expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinRightOuterOp) buildRightGroups(
	rightGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	outputBatchSize := int(o.outputBatchSize)

	// Loop over every column.
RightColLoop:
	for outColIdx, inColIdx := range input.outCols {
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(outColIdx + colOffset)
		var src coldata.Vec
		if batch.Width() > int(inColIdx) {
			src = batch.ColVec(int(inColIdx))
		}
		colType := input.sourceTypes[inColIdx]

		if sel != nil {
			if src != nil && src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					var srcCol []bool
					if src != nil {
						srcCol = src.Bool()
					}
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					var srcCol *coldata.Bytes
					if src != nil {
						srcCol = src.Bytes()
					}
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol.Get(int(sel[o.builderState.right.curSrcStartIdx]))
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										o.allocator.performOperation(
											[]coldata.Vec{out},
											func() {
												outCol.Set(outStartIdx, v)
											},
										)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					var srcCol []apd.Decimal
					if src != nil {
						srcCol = src.Decimal()
					}
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx].Set(&v)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					var srcCol []int16
					if src != nil {
						srcCol = src.Int16()
					}
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					var srcCol []int32
					if src != nil {
						srcCol = src.Int32()
					}
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					var srcCol []int64
					if src != nil {
						srcCol = src.Int64()
					}
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					var srcCol []float64
					if src != nil {
						srcCol = src.Float64()
					}
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Timestamp:
					var srcCol []time.Time
					if src != nil {
						srcCol = src.Timestamp()
					}
					outCol := out.Timestamp()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt(sel[o.builderState.right.curSrcStartIdx]) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					var srcCol []bool
					if src != nil {
						srcCol = src.Bool()
					}
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					var srcCol *coldata.Bytes
					if src != nil {
						srcCol = src.Bytes()
					}
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol.Get(int(sel[o.builderState.right.curSrcStartIdx]))
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										o.allocator.performOperation(
											[]coldata.Vec{out},
											func() {
												outCol.Set(outStartIdx, v)
											},
										)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					var srcCol []apd.Decimal
					if src != nil {
						srcCol = src.Decimal()
					}
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx].Set(&v)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					var srcCol []int16
					if src != nil {
						srcCol = src.Int16()
					}
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					var srcCol []int32
					if src != nil {
						srcCol = src.Int32()
					}
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					var srcCol []int64
					if src != nil {
						srcCol = src.Int64()
					}
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					var srcCol []float64
					if src != nil {
						srcCol = src.Float64()
					}
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Timestamp:
					var srcCol []time.Time
					if src != nil {
						srcCol = src.Timestamp()
					}
					outCol := out.Timestamp()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[int(sel[o.builderState.right.curSrcStartIdx])]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src != nil && src.MaybeHasNulls() {

				switch colType {
				case coltypes.Bool:
					var srcCol []bool
					if src != nil {
						srcCol = src.Bool()
					}
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					var srcCol *coldata.Bytes
					if src != nil {
						srcCol = src.Bytes()
					}
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol.Get(o.builderState.right.curSrcStartIdx)
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										o.allocator.performOperation(
											[]coldata.Vec{out},
											func() {
												outCol.Set(outStartIdx, v)
											},
										)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					var srcCol []apd.Decimal
					if src != nil {
						srcCol = src.Decimal()
					}
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx].Set(&v)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					var srcCol []int16
					if src != nil {
						srcCol = src.Int16()
					}
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					var srcCol []int32
					if src != nil {
						srcCol = src.Int32()
					}
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					var srcCol []int64
					if src != nil {
						srcCol = src.Int64()
					}
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					var srcCol []float64
					if src != nil {
						srcCol = src.Float64()
					}
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Timestamp:
					var srcCol []time.Time
					if src != nil {
						srcCol = src.Timestamp()
					}
					outCol := out.Timestamp()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									if src.Nulls().NullAt64(uint64(o.builderState.right.curSrcStartIdx)) {
										out.Nulls().SetNull(uint16(outStartIdx))
									} else {
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case coltypes.Bool:
					var srcCol []bool
					if src != nil {
						srcCol = src.Bool()
					}
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Bytes:
					var srcCol *coldata.Bytes
					if src != nil {
						srcCol = src.Bytes()
					}
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol.Get(o.builderState.right.curSrcStartIdx)
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										o.allocator.performOperation(
											[]coldata.Vec{out},
											func() {
												outCol.Set(outStartIdx, v)
											},
										)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Decimal:
					var srcCol []apd.Decimal
					if src != nil {
						srcCol = src.Decimal()
					}
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx].Set(&v)
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int16:
					var srcCol []int16
					if src != nil {
						srcCol = src.Int16()
					}
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int32:
					var srcCol []int32
					if src != nil {
						srcCol = src.Int32()
					}
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Int64:
					var srcCol []int64
					if src != nil {
						srcCol = src.Int64()
					}
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Float64:
					var srcCol []float64
					if src != nil {
						srcCol = src.Float64()
					}
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case coltypes.Timestamp:
					var srcCol []time.Time
					if src != nil {
						srcCol = src.Timestamp()
					}
					outCol := out.Timestamp()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							{
								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									{
										v := srcCol[o.builderState.right.curSrcStartIdx]
										// We are in the fast path (we're setting a single element), so in
										// order to not kill the performance, we only update the memory
										// account in case of Bytes type (other types will not change the
										// amount of memory accounted for).
										outCol[outStartIdx] = v
									}
								} else {
									o.allocator.Copy(
										out,
										coldata.CopySliceArgs{
											SliceArgs: coldata.SliceArgs{
												ColType:     colType,
												Src:         src,
												Sel:         sel,
												DestIdx:     uint64(outStartIdx),
												SrcStartIdx: uint64(o.builderState.right.curSrcStartIdx),
												SrcEndIdx:   uint64(o.builderState.right.curSrcStartIdx + toAppend),
											},
										},
									)
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if outColIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.right.reset()
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinRightOuterOp) probe(ctx context.Context) {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue(ctx)
		} else {
			o.probeBodyLSeltrueRSelfalse(ctx)
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue(ctx)
		} else {
			o.probeBodyLSelfalseRSelfalse(ctx)
		}
	}
}

// setBuilderSourceToBufferedGroup sets up the builder state to use the
// buffered group.
func (o *mergeJoinRightOuterOp) setBuilderSourceToBufferedGroup(
	ctx context.Context,
) {
	lGroupEndIdx := int(o.proberState.lBufferedGroup.length)
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.rGroups = o.builderState.rGroups[:1]
	rGroupEndIdx := int(o.proberState.rBufferedGroup.length)
	o.builderState.lGroups[0] = group{
		rowStartIdx: 0,
		rowEndIdx:   lGroupEndIdx,
		numRepeats:  rGroupEndIdx,
		toBuild:     lGroupEndIdx * rGroupEndIdx,
	}
	o.builderState.rGroups[0] = group{
		rowStartIdx: 0,
		rowEndIdx:   rGroupEndIdx,
		numRepeats:  lGroupEndIdx,
		toBuild:     rGroupEndIdx * lGroupEndIdx,
	}

	o.builderState.lBatch = o.proberState.lBufferedGroup
	o.builderState.rBatch = o.proberState.rBufferedGroup

	// We cannot yet reset the buffered groups because the builder will be taking
	// input from them. The actual reset will take place on the next call to
	// initProberState().
	o.proberState.lBufferedGroup.needToReset = true
	o.proberState.rBufferedGroup.needToReset = true
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinRightOuterOp) exhaustLeftSource(ctx context.Context) {
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinRightOuterOp) exhaustRightSource() {
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.lGroups[0] = group{
		rowStartIdx: o.proberState.rIdx,
		rowEndIdx:   o.proberState.rLength,
		numRepeats:  1,
		toBuild:     o.proberState.rLength - o.proberState.rIdx,
		nullGroup:   true,
	}
	o.builderState.rGroups = o.builderState.rGroups[:1]
	o.builderState.rGroups[0] = group{
		rowStartIdx: o.proberState.rIdx,
		rowEndIdx:   o.proberState.rLength,
		numRepeats:  1,
		toBuild:     o.proberState.rLength - o.proberState.rIdx,
		unmatched:   true,
	}

	o.proberState.rIdx = o.proberState.rLength
}

// build creates the cross product, and writes it to the output member.
func (o *mergeJoinRightOuterOp) build() {
	if o.output.Width() != 0 {
		outStartIdx := o.builderState.outCount
		o.buildLeftGroups(o.builderState.lGroups, 0 /* colOffset */, &o.left, o.builderState.lBatch, outStartIdx)
		o.buildRightGroups(o.builderState.rGroups, len(o.left.outCols), &o.right, o.builderState.rBatch, outStartIdx)
	}
	o.builderState.outCount = o.calculateOutputCount(o.builderState.lGroups)
}

// calculateOutputCount uses the toBuild field of each group and the output
// batch size to determine the output count. Note that as soon as a group is
// materialized partially or fully to output, its toBuild field is updated
// accordingly.
func (o *mergeJoinRightOuterOp) calculateOutputCount(
	groups []group,
) uint16 {
	count := int(o.builderState.outCount)

	for i := 0; i < len(groups); i++ {
		count += groups[i].toBuild
		groups[i].toBuild = 0
		if count > int(o.outputBatchSize) {
			groups[i].toBuild = count - int(o.outputBatchSize)
			count = int(o.outputBatchSize)
			return uint16(count)
		}
	}
	o.builderState.outFinished = true
	return uint16(count)
}

func (o *mergeJoinRightOuterOp) Next(ctx context.Context) coldata.Batch {
	o.output.ResetInternalBatch()
	for {
		switch o.state {
		case mjEntry:
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			o.outputReady = true
			// First we make sure that batches of the builder state are always set. This
			// is needed because the batches are accessed outside of _LEFT_SWITCH and
			// _RIGHT_SWITCH (before the merge joiner figures out whether there are any
			// groups to be built).
			o.builderState.lBatch = o.proberState.lBatch
			o.builderState.rBatch = o.proberState.rBatch
			// Next, we need to make sure that builder state is set up for a case when
			// neither exhaustLeftSource nor exhaustRightSource is called below. In such
			// scenario the merge joiner is done, so it'll be outputting zero-length
			// batches from now on.
			o.builderState.lGroups = o.builderState.lGroups[:0]
			o.builderState.rGroups = o.builderState.rGroups[:0]
			// At least one of the sources is finished. If it was the left one,
			// then we need to emit remaining tuples from the right source with
			// nulls corresponding to the left one. But if the right source is
			// finished, then there is nothing left to do.
			if o.proberState.rIdx < o.proberState.rLength {
				o.exhaustRightSource()
				// We unset o.outputReady here because we want to put as many unmatched
				// tuples from the right into the output batch. Once outCount reaches the
				// desired output batch size, the output will be returned.
				o.outputReady = false
			}
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup(ctx)
			o.state = mjBuild
		case mjProbe:
			o.probe(ctx)
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build()

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = uint16(0)
				o.outputReady = false
				return o.output
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}
