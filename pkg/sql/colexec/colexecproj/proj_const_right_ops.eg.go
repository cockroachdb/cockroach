// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecproj

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v3"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/server/telemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/colconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexeccmp"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecop"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree/treebin"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree/treecmp"
	"github.com/cockroachdb/cockroach/pkg/sql/sqltelemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/cockroach/pkg/util/json"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ apd.Context
	_ duration.Duration
	_ sqltelemetry.EnumTelemetryType
	_ telemetry.Counter
	_ json.JSON
	_ = coldataext.CompareDatum
)

type projBitandInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitandInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitandInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitandInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) & int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) & int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandDatumDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projBitandDatumDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitorInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitorInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitorInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) | int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) | int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorDatumDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projBitorDatumDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projBitxorInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projBitxorInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projBitxorInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						projCol[i] = int64(arg) ^ int64(p.constArg)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					projCol[i] = int64(arg) ^ int64(p.constArg)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorDatumDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projBitxorDatumDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Add(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Add(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projPlusInt16DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projPlusInt32DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPlusInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPlusInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPlusInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) + int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) + int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPlusInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projPlusInt64DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projPlusFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) + float64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) + float64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) + float64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) + float64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusTimestampIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projPlusTimestampIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						t_res := duration.Add(arg, p.constArg)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						t_res := duration.Add(arg, p.constArg)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					t_res := duration.Add(arg, p.constArg)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					t_res := duration.Add(arg, p.constArg)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projPlusIntervalTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						t_res := duration.Add(p.constArg, arg)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						t_res := duration.Add(p.constArg, arg)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					t_res := duration.Add(p.constArg, arg)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					t_res := duration.Add(p.constArg, arg)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projPlusIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.Add(p.constArg)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.Add(p.constArg)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.Add(p.constArg)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.Add(p.constArg)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projPlusIntervalDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumIntervalConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg duration.Duration
}

func (p projPlusDatumIntervalConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: p.constArg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: p.constArg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt16ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int16
}

func (p projPlusDatumInt16ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt32ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int32
}

func (p projPlusDatumInt32ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt64ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int64
}

func (p projPlusDatumInt64ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Sub(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Sub(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projMinusInt16DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projMinusInt32DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							result := int64(arg) - int64(p.constArg)
							if (result < int64(arg)) != (int64(p.constArg) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						result := int64(arg) - int64(p.constArg)
						if (result < int64(arg)) != (int64(p.constArg) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMinusInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64DatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projMinusInt64DatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(arg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(arg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projMinusFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) - float64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) - float64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) - float64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) - float64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusTimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projMinusTimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						nanos := arg.Sub(p.constArg).Nanoseconds()
						projCol[i] = duration.MakeDuration(nanos, 0, 0)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						nanos := arg.Sub(p.constArg).Nanoseconds()
						projCol[i] = duration.MakeDuration(nanos, 0, 0)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					nanos := arg.Sub(p.constArg).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					nanos := arg.Sub(p.constArg).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusTimestampIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMinusTimestampIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						t_res := duration.Add(arg, p.constArg.Mul(-1))
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						t_res := duration.Add(arg, p.constArg.Mul(-1))
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					t_res := duration.Add(arg, p.constArg.Mul(-1))
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					t_res := duration.Add(arg, p.constArg.Mul(-1))
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMinusIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.Sub(p.constArg)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.Sub(p.constArg)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.Sub(p.constArg)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.Sub(p.constArg)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusIntervalDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projMinusIntervalDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projMinusJSONBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// RemoveString.
						_j, _, _err := arg.RemoveString(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// RemoveString.
						_j, _, _err := arg.RemoveString(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// RemoveString.
					_j, _, _err := arg.RemoveString(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// RemoveString.
					_j, _, _err := arg.RemoveString(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMinusJSONInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMinusJSONInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMinusJSONInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _, _err := arg.RemoveIndex(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _, _err := arg.RemoveIndex(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projMinusDatumDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumIntervalConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg duration.Duration
}

func (p projMinusDatumIntervalConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: p.constArg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: p.constArg}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: p.constArg}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumBytesConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg []byte
}

func (p projMinusDatumBytesConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DString(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DString(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DString(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_convertedNativeElem := tree.DString(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt16ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int16
}

func (p projMinusDatumInt16ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt32ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int32
}

func (p projMinusDatumInt32ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt64ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int64
}

func (p projMinusDatumInt64ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Mul(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							_, err := tree.ExactCtx.Mul(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultDecimalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						f, err := arg.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = p.constArg.MulFloat(f)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						f, err := arg.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = p.constArg.MulFloat(f)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					f, err := arg.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = p.constArg.MulFloat(f)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					f, err := arg.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = p.constArg.MulFloat(f)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16IntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultInt16IntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32IntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultInt32IntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							_left, _right := int64(arg), int64(p.constArg)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						_left, _right := int64(arg), int64(p.constArg)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64IntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultInt64IntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = p.constArg.Mul(int64(arg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = p.constArg.Mul(int64(arg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projMultFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) * float64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							projCol[i] = float64(arg) * float64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) * float64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						projCol[i] = float64(arg) * float64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultFloat64IntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projMultFloat64IntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = p.constArg.MulFloat(float64(arg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = p.constArg.MulFloat(float64(arg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = p.constArg.MulFloat(float64(arg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = p.constArg.MulFloat(float64(arg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projMultIntervalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projMultIntervalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projMultIntervalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.Mul(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.Mul(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projMultIntervalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)
						projCol[i] = arg.MulFloat(float64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)
						projCol[i] = arg.MulFloat(float64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)
					projCol[i] = arg.MulFloat(float64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)
					projCol[i] = arg.MulFloat(float64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projMultIntervalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						f, err := p.constArg.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg.MulFloat(f)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						f, err := p.constArg.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg.MulFloat(f)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					f, err := p.constArg.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg.MulFloat(f)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					f, err := p.constArg.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg.MulFloat(f)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projDivInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projDivFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = float64(arg) / float64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = float64(arg) / float64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg) / float64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg) / float64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projDivIntervalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projDivIntervalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projDivIntervalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.Div(int64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					if p.constArg == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.Div(int64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projDivIntervalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.DivFloat(float64(p.constArg))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg.DivFloat(float64(p.constArg))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					if p.constArg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.DivFloat(float64(p.constArg))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					if p.constArg == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg.DivFloat(float64(p.constArg))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projFloorDivInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projFloorDivInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projFloorDivInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) / int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) / int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projFloorDivInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projFloorDivFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Trunc(float64(arg) / float64(p.constArg))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Trunc(float64(arg) / float64(p.constArg))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg) / float64(p.constArg))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg) / float64(p.constArg))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projModDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projModDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projModDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projModInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projModInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projModInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projModInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projModInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projModInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projModInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projModInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projModInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg) % int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg) % int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projModInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projModFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Mod(float64(arg), float64(p.constArg))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							if p.constArg == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Mod(float64(arg), float64(p.constArg))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg), float64(p.constArg))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						if p.constArg == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg), float64(p.constArg))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPowDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPowDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPowDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(p.constArg))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							_, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							_, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projPowInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projPowInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projPowInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg)))
							rightTmpDec.SetInt64(int64(int64(p.constArg)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg)))
						rightTmpDec.SetInt64(int64(int64(p.constArg)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projPowInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projPowFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{

							projCol[i] = math.Pow(float64(arg), float64(p.constArg))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{

							projCol[i] = math.Pow(float64(arg), float64(p.constArg))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{

						projCol[i] = math.Pow(float64(arg), float64(p.constArg))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{

						projCol[i] = math.Pow(float64(arg), float64(p.constArg))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projConcatBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var r = []byte{}
							r = append(r, arg...)
							r = append(r, p.constArg...)
							projCol.Set(i, r)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var r = []byte{}
							r = append(r, arg...)
							r = append(r, p.constArg...)
							projCol.Set(i, r)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var r = []byte{}
						r = append(r, arg...)
						r = append(r, p.constArg...)
						projCol.Set(i, r)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var r = []byte{}
						r = append(r, arg...)
						r = append(r, p.constArg...)
						projCol.Set(i, r)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projConcatJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.Concat(p.constArg)
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}

						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.Concat(p.constArg)
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}

						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.Concat(p.constArg)
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}

					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_j, _err := arg.Concat(p.constArg)
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}

					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatDatumDatumConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg interface{}
}

func (p projConcatDatumDatumConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), p.constArg.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLShiftInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLShiftInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLShiftInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) << int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) << int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt16ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int16
}

func (p projLShiftDatumInt16ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt32ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int32
}

func (p projLShiftDatumInt32ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt64ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int64
}

func (p projLShiftDatumInt64ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projRShiftInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projRShiftInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projRShiftInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg) >> int64(p.constArg)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						if int64(p.constArg) < 0 || int64(p.constArg) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg) >> int64(p.constArg)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt16ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int16
}

func (p projRShiftDatumInt16ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt32ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int32
}

func (p projRShiftDatumInt32ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt64ConstOp struct {
	projConstOpBase
	colexecbase.BinaryOverloadHelper
	constArg int64
}

func (p projRShiftDatumInt64ConstOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_convertedNativeElem := tree.DInt(p.constArg)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_convertedNativeElem := tree.DInt(p.constArg)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projJSONFetchValJSONBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projJSONFetchValJSONInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projJSONFetchValJSONInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projJSONFetchValJSONInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projJSONFetchTextJSONBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg.FetchValKey(*(*string)(unsafe.Pointer(&p.constArg)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projJSONFetchTextJSONInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projJSONFetchTextJSONInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projJSONFetchTextJSONInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						_j, _err := arg.FetchValIdx(int(p.constArg))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					_j, _err := arg.FetchValIdx(int(p.constArg))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValPathJSONDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchValPathJSONDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _path)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _path)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _path)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _path)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextPathJSONDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projJSONFetchTextPathJSONDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _path.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}

						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _path.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}

						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _path.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					_path, _err := tree.GetJSONPath(arg, *tree.MustBeDArray(p.constArg.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _path.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projEQBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projEQBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projEQFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projEQFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projEQFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projEQFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projEQFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQTimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projEQTimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projEQIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projEQJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projEQDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projNEBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projNEBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projNEFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projNEFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projNEFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projNEFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projNEFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNETimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projNETimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projNEIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projNEJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projNEDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projLTBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projLTBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLTFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLTFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLTFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLTFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLTFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTTimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projLTTimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projLTIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projLTJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projLTDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projLEBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projLEBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projLEFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projLEFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projLEFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projLEFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projLEFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLETimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projLETimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projLEIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projLEJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projLEDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projGTBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projGTBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGTFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGTFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGTFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGTFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGTFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTTimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projGTTimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projGTIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projGTJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projGTDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEBoolBoolConstOp struct {
	projConstOpBase
	constArg bool
}

func (p projGEBoolBoolConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Bools
	col = vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if !arg && p.constArg {
								cmpResult = -1
							} else if arg && !p.constArg {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEBytesBytesConstOp struct {
	projConstOpBase
	constArg []byte
}

func (p projGEBytesBytesConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.Bytes
	col = vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg, p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEDecimalInt16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEDecimalInt32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEDecimalInt64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(p.constArg))
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(p.constArg))
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalFloat64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEDecimalFloat64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalDecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEDecimalDecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Decimals
	col = vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg, &p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt16Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt16Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt16Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEInt16Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEInt16DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int16s
	col = vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt32Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt32Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt32Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEInt32Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEInt32DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int32s
	col = vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEInt64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEInt64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEInt64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg), int64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEInt64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEInt64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Int64s
	col = vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg))
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg))
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int16ConstOp struct {
	projConstOpBase
	constArg int16
}

func (p projGEFloat64Int16ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int32ConstOp struct {
	projConstOpBase
	constArg int32
}

func (p projGEFloat64Int32ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int64ConstOp struct {
	projConstOpBase
	constArg int64
}

func (p projGEFloat64Int64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Float64ConstOp struct {
	projConstOpBase
	constArg float64
}

func (p projGEFloat64Float64ConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg), float64(p.constArg)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64DecimalConstOp struct {
	projConstOpBase
	constArg apd.Decimal
}

func (p projGEFloat64DecimalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Float64s
	col = vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &p.constArg)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGETimestampTimestampConstOp struct {
	projConstOpBase
	constArg time.Time
}

func (p projGETimestampTimestampConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Times
	col = vec.Timestamp()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int

							if arg.Before(p.constArg) {
								cmpResult = -1
							} else if p.constArg.Before(arg) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int

						if arg.Before(p.constArg) {
							cmpResult = -1
						} else if p.constArg.Before(arg) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEIntervalIntervalConstOp struct {
	projConstOpBase
	constArg duration.Duration
}

func (p projGEIntervalIntervalConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.Durations
	col = vec.Interval()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						//gcassert:bce
						arg := col.Get(i)

						{
							var cmpResult int
							cmpResult = arg.Compare(p.constArg)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = arg.Compare(p.constArg)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEJSONJSONConstOp struct {
	projConstOpBase
	constArg json.JSON
}

func (p projGEJSONJSONConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col *coldata.JSONs
	col = vec.JSON()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg.Compare(p.constArg)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg.Compare(p.constArg)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDatumDatumConstOp struct {
	projConstOpBase
	constArg interface{}
}

func (p projGEDatumDatumConstOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	vec := batch.ColVec(p.colIdx)
	var col coldata.DatumVec
	col = vec.Datum()
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		// Capture col to force bounds check to work. See
		// https://github.com/golang/go/issues/39756
		col := col
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec.Nulls().MaybeHasNulls() {
			colNulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					if !colNulls.NullAt(i) {
						// We only want to perform the projection operation if the value is not null.
						arg := col.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*colNulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col.Get(n - 1)
				for i := 0; i < n; i++ {
					arg := col.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg, col, p.constArg)

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

// GetProjectionRConstOperator returns the appropriate constant
// projection operator for the given left and right column types and operation.
func GetProjectionRConstOperator(
	allocator *colmem.Allocator,
	inputTypes []*types.T,
	constType *types.T,
	outputType *types.T,
	op tree.Operator,
	input colexecop.Operator,
	colIdx int,
	constArg tree.Datum,
	outputIdx int,
	evalCtx *tree.EvalContext,
	binFn tree.TwoArgFn,
	cmpExpr *tree.ComparisonExpr,
) (colexecop.Operator, error) {
	input = colexecutils.NewVectorTypeEnforcer(allocator, input, outputType, outputIdx)
	projConstOpBase := projConstOpBase{
		OneInputHelper: colexecop.MakeOneInputHelper(input),
		allocator:      allocator,
		colIdx:         colIdx,
		outputIdx:      outputIdx,
	}
	c := colconv.GetDatumToPhysicalFn(constType)(constArg)
	leftType, rightType := inputTypes[colIdx], constType
	switch op := op.(type) {
	case treebin.BinaryOperator:
		switch op.Symbol {
		case treebin.Bitand:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitandInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitandInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitandInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitandInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitandInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitandInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitandDatumDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Bitor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitorInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitorInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitorInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitorInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitorInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitorInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitorDatumDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Bitxor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitxorInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitxorInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projBitxorInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitxorDatumDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Plus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPlusDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPlusDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPlusInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPlusInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt16DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPlusInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPlusInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt32DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPlusInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPlusInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt64DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusTimestampIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalTimestampConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusDatumIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusDatumInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projPlusDatumInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projPlusDatumInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Minus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMinusDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMinusDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMinusInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMinusInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt16DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMinusInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMinusInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt32DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMinusInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMinusInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt64DatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusTimestampTimestampConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(time.Time),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusTimestampIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusIntervalIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusIntervalDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusJSONBytesConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusJSONInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMinusJSONInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMinusJSONInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumBytesConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusDatumInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projMinusDatumInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projMinusDatumInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Mult:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMultDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMultDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultDecimalIntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMultInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMultInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt16IntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMultInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMultInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt32IntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMultInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMultInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt64IntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultFloat64IntervalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(duration.Duration),
							}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultIntervalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projMultIntervalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projMultIntervalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultIntervalFloat64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultIntervalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.Div:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projDivDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projDivDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projDivInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projDivInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projDivInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projDivInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projDivInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projDivInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivIntervalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projDivIntervalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projDivIntervalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivIntervalFloat64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.FloorDiv:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projFloorDivDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projFloorDivDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projFloorDivInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projFloorDivInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projFloorDivInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.Mod:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projModDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projModDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projModInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projModInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projModInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projModInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projModInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projModInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.Pow:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowDecimalInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPowDecimalInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPowDecimalInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowDecimalDecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPowInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPowInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt16DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPowInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPowInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt32DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projPowInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projPowInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt64DecimalConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(apd.Decimal),
							}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowFloat64Float64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(float64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.Concat:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatBytesBytesConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}
							return op, nil
						}
					}
				}
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.JsonFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatJSONJSONConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(json.JSON),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatDatumDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.LShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projLShiftInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projLShiftInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projLShiftInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftDatumInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projLShiftDatumInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projLShiftDatumInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.RShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt16Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projRShiftInt16Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt16Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt32Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projRShiftInt32Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt32Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt64Int16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projRShiftInt64Int32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt64Int64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftDatumInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projRShiftDatumInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projRShiftDatumInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchVal:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchValJSONBytesConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projJSONFetchValJSONInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projJSONFetchValJSONInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projJSONFetchValJSONInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchText:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchTextJSONBytesConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.([]byte),
							}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projJSONFetchTextJSONInt16ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int16),
							}
							return op, nil
						case 32:
							op := &projJSONFetchTextJSONInt32ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int32),
							}
							return op, nil
						case -1:
						default:
							op := &projJSONFetchTextJSONInt64ConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        c.(int64),
							}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchValPath:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchValPathJSONDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchTextPath:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchTextPathJSONDatumConstOp{
								projConstOpBase: projConstOpBase,
								constArg:        constArg,
							}
							return op, nil
						}
					}
				}
			}
		}
	case treecmp.ComparisonOperator:
		if leftType.Family() != types.TupleFamily && rightType.Family() != types.TupleFamily {
			// Tuple comparison has special null-handling semantics, so we will
			// fallback to the default comparison operator if either of the
			// input vectors is of a tuple type.
			switch op.Symbol {
			case treecmp.EQ:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projEQDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projEQDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projEQInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projEQInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projEQInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projEQInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projEQInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projEQInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projEQFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projEQFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQTimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			case treecmp.NE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projNEDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projNEDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projNEInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projNEInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projNEInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projNEInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projNEInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projNEInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projNEFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projNEFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNETimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			case treecmp.LT:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLTDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLTDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLTInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLTInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLTInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLTInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLTInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLTInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLTFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLTFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTTimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			case treecmp.LE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLEDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLEDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLEInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLEInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLEInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLEInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLEInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLEInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projLEFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projLEFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLETimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			case treecmp.GT:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGTDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGTDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGTInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGTInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGTInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGTInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGTInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGTInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGTFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGTFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTTimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			case treecmp.GE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEBoolBoolConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(bool),
								}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEBytesBytesConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.([]byte),
								}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEDecimalInt16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGEDecimalInt32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGEDecimalInt64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDecimalFloat64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDecimalDecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt16Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGEInt16Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGEInt16Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt16Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt16DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt32Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGEInt32Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGEInt32Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt32Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt32DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGEInt64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGEInt64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEFloat64Int16ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int16),
								}, nil
							case 32:
								return &projGEFloat64Int32ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int32),
								}, nil
							case -1:
							default:
								return &projGEFloat64Int64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(int64),
								}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEFloat64Float64ConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(float64),
								}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEFloat64DecimalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(apd.Decimal),
								}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGETimestampTimestampConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(time.Time),
								}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEIntervalIntervalConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(duration.Duration),
								}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEJSONJSONConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(json.JSON),
								}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDatumDatumConstOp{
									projConstOpBase: projConstOpBase,
									constArg:        c.(interface{}),
								}, nil
							}
						}
					}
				}
			}
		}
		return &defaultCmpRConstProjOp{
			projConstOpBase:     projConstOpBase,
			adapter:             colexeccmp.NewComparisonExprAdapter(cmpExpr, evalCtx),
			constArg:            constArg,
			toDatumConverter:    colconv.NewVecToDatumConverter(len(inputTypes), []int{colIdx}, true /* willRelease */),
			datumToVecConverter: colconv.GetDatumToPhysicalFn(outputType),
		}, nil
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), op, rightType.Name())
}
