// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexecproj

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v3"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/server/telemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/colconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecbase"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexeccmp"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecop"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree/treebin"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree/treecmp"
	"github.com/cockroachdb/cockroach/pkg/sql/sqltelemetry"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ duration.Duration
	_ = coldataext.CompareDatum
	_ sqltelemetry.EnumTelemetryType
	_ telemetry.Counter
	_ apd.Context
)

// projConstOpBase contains all of the fields for projections with a constant,
// except for the constant itself.
// NOTE: this struct should be declared in proj_const_ops_tmpl.go, but if we do
// so, it'll be redeclared because we execute that template twice. To go
// around the problem we specify it here.
type projConstOpBase struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	colIdx    int
	outputIdx int
}

// projOpBase contains all of the fields for non-constant projections.
type projOpBase struct {
	colexecop.OneInputHelper
	allocator *colmem.Allocator
	col1Idx   int
	col2Idx   int
	outputIdx int
}

type projBitandInt16Int16Op struct {
	projOpBase
}

func (p projBitandInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt16Int32Op struct {
	projOpBase
}

func (p projBitandInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt16Int64Op struct {
	projOpBase
}

func (p projBitandInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int16Op struct {
	projOpBase
}

func (p projBitandInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int32Op struct {
	projOpBase
}

func (p projBitandInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt32Int64Op struct {
	projOpBase
}

func (p projBitandInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int16Op struct {
	projOpBase
}

func (p projBitandInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int32Op struct {
	projOpBase
}

func (p projBitandInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandInt64Int64Op struct {
	projOpBase
}

func (p projBitandInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) & int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) & int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitandDatumDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projBitandDatumDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int16Op struct {
	projOpBase
}

func (p projBitorInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int32Op struct {
	projOpBase
}

func (p projBitorInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt16Int64Op struct {
	projOpBase
}

func (p projBitorInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int16Op struct {
	projOpBase
}

func (p projBitorInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int32Op struct {
	projOpBase
}

func (p projBitorInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt32Int64Op struct {
	projOpBase
}

func (p projBitorInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int16Op struct {
	projOpBase
}

func (p projBitorInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int32Op struct {
	projOpBase
}

func (p projBitorInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorInt64Int64Op struct {
	projOpBase
}

func (p projBitorInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) | int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) | int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitorDatumDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projBitorDatumDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int16Op struct {
	projOpBase
}

func (p projBitxorInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int32Op struct {
	projOpBase
}

func (p projBitxorInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt16Int64Op struct {
	projOpBase
}

func (p projBitxorInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int16Op struct {
	projOpBase
}

func (p projBitxorInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int32Op struct {
	projOpBase
}

func (p projBitxorInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt32Int64Op struct {
	projOpBase
}

func (p projBitxorInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int16Op struct {
	projOpBase
}

func (p projBitxorInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int32Op struct {
	projOpBase
}

func (p projBitxorInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorInt64Int64Op struct {
	projOpBase
}

func (p projBitxorInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						projCol[i] = int64(arg1) ^ int64(arg2)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					projCol[i] = int64(arg1) ^ int64(arg2)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projBitxorDatumDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projBitxorDatumDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt16Op struct {
	projOpBase
}

func (p projPlusDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt32Op struct {
	projOpBase
}

func (p projPlusDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalInt64Op struct {
	projOpBase
}

func (p projPlusDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Add(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDecimalDecimalOp struct {
	projOpBase
}

func (p projPlusDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Add(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int16Op struct {
	projOpBase
}

func (p projPlusInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int32Op struct {
	projOpBase
}

func (p projPlusInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16Int64Op struct {
	projOpBase
}

func (p projPlusInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16DecimalOp struct {
	projOpBase
}

func (p projPlusInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt16DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusInt16DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int16Op struct {
	projOpBase
}

func (p projPlusInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int32Op struct {
	projOpBase
}

func (p projPlusInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32Int64Op struct {
	projOpBase
}

func (p projPlusInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32DecimalOp struct {
	projOpBase
}

func (p projPlusInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt32DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusInt32DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int16Op struct {
	projOpBase
}

func (p projPlusInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int32Op struct {
	projOpBase
}

func (p projPlusInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64Int64Op struct {
	projOpBase
}

func (p projPlusInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) + int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) < 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) + int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) < 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64DecimalOp struct {
	projOpBase
}

func (p projPlusInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Add(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusInt64DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusInt64DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusFloat64Float64Op struct {
	projOpBase
}

func (p projPlusFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) + float64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) + float64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) + float64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) + float64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusTimestampIntervalOp struct {
	projOpBase
}

func (p projPlusTimestampIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						t_res := duration.Add(arg1, arg2)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						t_res := duration.Add(arg1, arg2)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					t_res := duration.Add(arg1, arg2)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					t_res := duration.Add(arg1, arg2)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalTimestampOp struct {
	projOpBase
}

func (p projPlusIntervalTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						t_res := duration.Add(arg2, arg1)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						t_res := duration.Add(arg2, arg1)
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					t_res := duration.Add(arg2, arg1)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					t_res := duration.Add(arg2, arg1)
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalIntervalOp struct {
	projOpBase
}

func (p projPlusIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.Add(arg2)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.Add(arg2)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.Add(arg2)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.Add(arg2)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusIntervalDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusIntervalDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg1}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg1}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumIntervalOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusDatumIntervalOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg2}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg2}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt16Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusDatumInt16Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt32Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusDatumInt32Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPlusDatumInt64Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projPlusDatumInt64Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt16Op struct {
	projOpBase
}

func (p projMinusDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt32Op struct {
	projOpBase
}

func (p projMinusDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalInt64Op struct {
	projOpBase
}

func (p projMinusDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDecimalDecimalOp struct {
	projOpBase
}

func (p projMinusDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Sub(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int16Op struct {
	projOpBase
}

func (p projMinusInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int32Op struct {
	projOpBase
}

func (p projMinusInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16Int64Op struct {
	projOpBase
}

func (p projMinusInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16DecimalOp struct {
	projOpBase
}

func (p projMinusInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt16DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusInt16DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int16Op struct {
	projOpBase
}

func (p projMinusInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int32Op struct {
	projOpBase
}

func (p projMinusInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32Int64Op struct {
	projOpBase
}

func (p projMinusInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32DecimalOp struct {
	projOpBase
}

func (p projMinusInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt32DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusInt32DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int16Op struct {
	projOpBase
}

func (p projMinusInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int32Op struct {
	projOpBase
}

func (p projMinusInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64Int64Op struct {
	projOpBase
}

func (p projMinusInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							result := int64(arg1) - int64(arg2)
							if (result < int64(arg1)) != (int64(arg2) > 0) {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						result := int64(arg1) - int64(arg2)
						if (result < int64(arg1)) != (int64(arg2) > 0) {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64DecimalOp struct {
	projOpBase
}

func (p projMinusInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Sub(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusInt64DatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusInt64DatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg1)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg1)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusFloat64Float64Op struct {
	projOpBase
}

func (p projMinusFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) - float64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) - float64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) - float64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) - float64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusTimestampTimestampOp struct {
	projOpBase
}

func (p projMinusTimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						nanos := arg1.Sub(arg2).Nanoseconds()
						projCol[i] = duration.MakeDuration(nanos, 0, 0)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						nanos := arg1.Sub(arg2).Nanoseconds()
						projCol[i] = duration.MakeDuration(nanos, 0, 0)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					nanos := arg1.Sub(arg2).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					nanos := arg1.Sub(arg2).Nanoseconds()
					projCol[i] = duration.MakeDuration(nanos, 0, 0)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusTimestampIntervalOp struct {
	projOpBase
}

func (p projMinusTimestampIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Timestamp()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						t_res := duration.Add(arg1, arg2.Mul(-1))
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						t_res := duration.Add(arg1, arg2.Mul(-1))
						rounded_res := t_res.Round(time.Microsecond)
						if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
							colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
						}
						projCol[i] = t_res
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					t_res := duration.Add(arg1, arg2.Mul(-1))
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					t_res := duration.Add(arg1, arg2.Mul(-1))
					rounded_res := t_res.Round(time.Microsecond)
					if rounded_res.After(tree.MaxSupportedTime) || rounded_res.Before(tree.MinSupportedTime) {
						colexecerror.ExpectedError(errors.Newf("timestamp %q exceeds supported timestamp bounds", t_res.Format(time.RFC3339)))
					}
					projCol[i] = t_res
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusIntervalIntervalOp struct {
	projOpBase
}

func (p projMinusIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.Sub(arg2)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.Sub(arg2)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.Sub(arg2)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.Sub(arg2)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusIntervalDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusIntervalDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg1}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg1}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg1}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, _nonDatumArgAsDatum.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONBytesOp struct {
	projOpBase
}

func (p projMinusJSONBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// RemoveString.
						_j, _, _err := arg1.RemoveString(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// RemoveString.
						_j, _, _err := arg1.RemoveString(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// RemoveString.
					_j, _, _err := arg1.RemoveString(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// RemoveString.
					_j, _, _err := arg1.RemoveString(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt16Op struct {
	projOpBase
}

func (p projMinusJSONInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt32Op struct {
	projOpBase
}

func (p projMinusJSONInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusJSONInt64Op struct {
	projOpBase
}

func (p projMinusJSONInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _, _err := arg1.RemoveIndex(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _, _err := arg1.RemoveIndex(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumIntervalOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumIntervalOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg2}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInterval{Duration: arg2}
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInterval{Duration: arg2}
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumBytesOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumBytesOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DString(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DString(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DString(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DString(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt16Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumInt16Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt32Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumInt32Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMinusDatumInt64Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projMinusDatumInt64Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt16Op struct {
	projOpBase
}

func (p projMultDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt32Op struct {
	projOpBase
}

func (p projMultDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalInt64Op struct {
	projOpBase
}

func (p projMultDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalDecimalOp struct {
	projOpBase
}

func (p projMultDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						_, err := tree.ExactCtx.Mul(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultDecimalIntervalOp struct {
	projOpBase
}

func (p projMultDecimalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						f, err := arg1.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg2.MulFloat(f)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						f, err := arg1.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg2.MulFloat(f)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					f, err := arg1.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg2.MulFloat(f)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					f, err := arg1.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg2.MulFloat(f)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int16Op struct {
	projOpBase
}

func (p projMultInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt8 || _left < math.MinInt8 || _right > math.MaxInt8 || _right < math.MinInt8 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int32Op struct {
	projOpBase
}

func (p projMultInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16Int64Op struct {
	projOpBase
}

func (p projMultInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16DecimalOp struct {
	projOpBase
}

func (p projMultInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt16IntervalOp struct {
	projOpBase
}

func (p projMultInt16IntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int16Op struct {
	projOpBase
}

func (p projMultInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int32Op struct {
	projOpBase
}

func (p projMultInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt16 || _left < math.MinInt16 || _right > math.MaxInt16 || _right < math.MinInt16 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32Int64Op struct {
	projOpBase
}

func (p projMultInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32DecimalOp struct {
	projOpBase
}

func (p projMultInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt32IntervalOp struct {
	projOpBase
}

func (p projMultInt32IntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int16Op struct {
	projOpBase
}

func (p projMultInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int32Op struct {
	projOpBase
}

func (p projMultInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64Int64Op struct {
	projOpBase
}

func (p projMultInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							_left, _right := int64(arg1), int64(arg2)
							result := _left * _right
							if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
								if _left != 0 && _right != 0 {
									sameSign := (_left < 0) == (_right < 0)
									if (result < 0) == sameSign {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									} else if result/_right != _left {
										colexecerror.ExpectedError(tree.ErrIntOutOfRange)
									}
								}
							}
							projCol[i] = result
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						_left, _right := int64(arg1), int64(arg2)
						result := _left * _right
						if _left > math.MaxInt32 || _left < math.MinInt32 || _right > math.MaxInt32 || _right < math.MinInt32 {
							if _left != 0 && _right != 0 {
								sameSign := (_left < 0) == (_right < 0)
								if (result < 0) == sameSign {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								} else if result/_right != _left {
									colexecerror.ExpectedError(tree.ErrIntOutOfRange)
								}
							}
						}
						projCol[i] = result
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64DecimalOp struct {
	projOpBase
}

func (p projMultInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.ExactCtx.Mul(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultInt64IntervalOp struct {
	projOpBase
}

func (p projMultInt64IntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg2.Mul(int64(arg1))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg2.Mul(int64(arg1))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultFloat64Float64Op struct {
	projOpBase
}

func (p projMultFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) * float64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							projCol[i] = float64(arg1) * float64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) * float64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						projCol[i] = float64(arg1) * float64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultFloat64IntervalOp struct {
	projOpBase
}

func (p projMultFloat64IntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg2.MulFloat(float64(arg1))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg2.MulFloat(float64(arg1))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg2.MulFloat(float64(arg1))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg2.MulFloat(float64(arg1))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt16Op struct {
	projOpBase
}

func (p projMultIntervalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt32Op struct {
	projOpBase
}

func (p projMultIntervalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalInt64Op struct {
	projOpBase
}

func (p projMultIntervalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.Mul(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.Mul(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalFloat64Op struct {
	projOpBase
}

func (p projMultIntervalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)
						projCol[i] = arg1.MulFloat(float64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)
						projCol[i] = arg1.MulFloat(float64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)
					projCol[i] = arg1.MulFloat(float64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)
					projCol[i] = arg1.MulFloat(float64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projMultIntervalDecimalOp struct {
	projOpBase
}

func (p projMultIntervalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						f, err := arg2.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg1.MulFloat(f)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						f, err := arg2.Float64()
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						projCol[i] = arg1.MulFloat(f)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					f, err := arg2.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg1.MulFloat(f)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					f, err := arg2.Float64()
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					projCol[i] = arg1.MulFloat(f)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt16Op struct {
	projOpBase
}

func (p projDivDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt32Op struct {
	projOpBase
}

func (p projDivDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalInt64Op struct {
	projOpBase
}

func (p projDivDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivDecimalDecimalOp struct {
	projOpBase
}

func (p projDivDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int16Op struct {
	projOpBase
}

func (p projDivInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int32Op struct {
	projOpBase
}

func (p projDivInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16Int64Op struct {
	projOpBase
}

func (p projDivInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt16DecimalOp struct {
	projOpBase
}

func (p projDivInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int16Op struct {
	projOpBase
}

func (p projDivInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int32Op struct {
	projOpBase
}

func (p projDivInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32Int64Op struct {
	projOpBase
}

func (p projDivInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt32DecimalOp struct {
	projOpBase
}

func (p projDivInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int16Op struct {
	projOpBase
}

func (p projDivInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int32Op struct {
	projOpBase
}

func (p projDivInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64Int64Op struct {
	projOpBase
}

func (p projDivInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Quo(&projCol[i], &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivInt64DecimalOp struct {
	projOpBase
}

func (p projDivInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Quo(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivFloat64Float64Op struct {
	projOpBase
}

func (p projDivFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = float64(arg1) / float64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = float64(arg1) / float64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg1) / float64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = float64(arg1) / float64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt16Op struct {
	projOpBase
}

func (p projDivIntervalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt32Op struct {
	projOpBase
}

func (p projDivIntervalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalInt64Op struct {
	projOpBase
}

func (p projDivIntervalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.Div(int64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					if arg2 == 0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.Div(int64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projDivIntervalFloat64Op struct {
	projOpBase
}

func (p projDivIntervalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Interval()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.DivFloat(float64(arg2))
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = arg1.DivFloat(float64(arg2))
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.DivFloat(float64(arg2))
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					if arg2 == 0.0 {
						colexecerror.ExpectedError(tree.ErrDivByZero)
					}
					projCol[i] = arg1.DivFloat(float64(arg2))
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt16Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt32Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalInt64Op struct {
	projOpBase
}

func (p projFloorDivDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivDecimalDecimalOp struct {
	projOpBase
}

func (p projFloorDivDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int16Op struct {
	projOpBase
}

func (p projFloorDivInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int32Op struct {
	projOpBase
}

func (p projFloorDivInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16Int64Op struct {
	projOpBase
}

func (p projFloorDivInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt16DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int16Op struct {
	projOpBase
}

func (p projFloorDivInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int32Op struct {
	projOpBase
}

func (p projFloorDivInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32Int64Op struct {
	projOpBase
}

func (p projFloorDivInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt32DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int16Op struct {
	projOpBase
}

func (p projFloorDivInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int32Op struct {
	projOpBase
}

func (p projFloorDivInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64Int64Op struct {
	projOpBase
}

func (p projFloorDivInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) / int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) / int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivInt64DecimalOp struct {
	projOpBase
}

func (p projFloorDivInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.QuoInteger(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projFloorDivFloat64Float64Op struct {
	projOpBase
}

func (p projFloorDivFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Trunc(float64(arg1) / float64(arg2))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt16Op struct {
	projOpBase
}

func (p projModDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt32Op struct {
	projOpBase
}

func (p projModDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalInt64Op struct {
	projOpBase
}

func (p projModDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModDecimalDecimalOp struct {
	projOpBase
}

func (p projModDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int16Op struct {
	projOpBase
}

func (p projModInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int32Op struct {
	projOpBase
}

func (p projModInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16Int64Op struct {
	projOpBase
}

func (p projModInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt16DecimalOp struct {
	projOpBase
}

func (p projModInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int16Op struct {
	projOpBase
}

func (p projModInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int32Op struct {
	projOpBase
}

func (p projModInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32Int64Op struct {
	projOpBase
}

func (p projModInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt32DecimalOp struct {
	projOpBase
}

func (p projModInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int16Op struct {
	projOpBase
}

func (p projModInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int32Op struct {
	projOpBase
}

func (p projModInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64Int64Op struct {
	projOpBase
}

func (p projModInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) == 0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}
							projCol[i] = int64(arg1) % int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) == 0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}
						projCol[i] = int64(arg1) % int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModInt64DecimalOp struct {
	projOpBase
}

func (p projModInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2.IsZero() {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2.IsZero() {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.HighPrecisionCtx.Rem(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projModFloat64Float64Op struct {
	projOpBase
}

func (p projModFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Mod(float64(arg1), float64(arg2))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							if arg2 == 0.0 {
								colexecerror.ExpectedError(tree.ErrDivByZero)
							}

							projCol[i] = math.Mod(float64(arg1), float64(arg2))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg1), float64(arg2))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						if arg2 == 0.0 {
							colexecerror.ExpectedError(tree.ErrDivByZero)
						}

						projCol[i] = math.Mod(float64(arg1), float64(arg2))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt16Op struct {
	projOpBase
}

func (p projPowDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt32Op struct {
	projOpBase
}

func (p projPowDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalInt64Op struct {
	projOpBase
}

func (p projPowDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg2))
						if _, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &tmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowDecimalDecimalOp struct {
	projOpBase
}

func (p projPowDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						_, err := tree.DecimalCtx.Pow(&projCol[i], &arg1, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int16Op struct {
	projOpBase
}

func (p projPowInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int32Op struct {
	projOpBase
}

func (p projPowInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16Int64Op struct {
	projOpBase
}

func (p projPowInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt16DecimalOp struct {
	projOpBase
}

func (p projPowInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int16Op struct {
	projOpBase
}

func (p projPowInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int32Op struct {
	projOpBase
}

func (p projPowInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32Int64Op struct {
	projOpBase
}

func (p projPowInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt32DecimalOp struct {
	projOpBase
}

func (p projPowInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int16Op struct {
	projOpBase
}

func (p projPowInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int32Op struct {
	projOpBase
}

func (p projPowInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64Int64Op struct {
	projOpBase
}

func (p projPowInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
							leftTmpDec.SetInt64(int64(int64(arg1)))
							rightTmpDec.SetInt64(int64(int64(arg2)))
							if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
								colexecerror.ExpectedError(err)
							}
							resultInt, err := leftTmpDec.Int64()
							if err != nil {
								colexecerror.ExpectedError(tree.ErrIntOutOfRange)
							}
							projCol[i] = resultInt
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var leftTmpDec, rightTmpDec apd.Decimal //gcassert:noescape
						leftTmpDec.SetInt64(int64(int64(arg1)))
						rightTmpDec.SetInt64(int64(int64(arg2)))
						if _, err := tree.DecimalCtx.Pow(&leftTmpDec, &leftTmpDec, &rightTmpDec); err != nil {
							colexecerror.ExpectedError(err)
						}
						resultInt, err := leftTmpDec.Int64()
						if err != nil {
							colexecerror.ExpectedError(tree.ErrIntOutOfRange)
						}
						projCol[i] = resultInt
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowInt64DecimalOp struct {
	projOpBase
}

func (p projPowInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Decimal()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						var tmpDec apd.Decimal //gcassert:noescape
						tmpDec.SetInt64(int64(arg1))
						_, err := tree.DecimalCtx.Pow(&projCol[i], &tmpDec, &arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projPowFloat64Float64Op struct {
	projOpBase
}

func (p projPowFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Float64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{

							projCol[i] = math.Pow(float64(arg1), float64(arg2))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{

							projCol[i] = math.Pow(float64(arg1), float64(arg2))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{

						projCol[i] = math.Pow(float64(arg1), float64(arg2))
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{

						projCol[i] = math.Pow(float64(arg1), float64(arg2))
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatBytesBytesOp struct {
	projOpBase
}

func (p projConcatBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var r = []byte{}
							r = append(r, arg1...)
							r = append(r, arg2...)
							projCol.Set(i, r)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var r = []byte{}
							r = append(r, arg1...)
							r = append(r, arg2...)
							projCol.Set(i, r)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var r = []byte{}
						r = append(r, arg1...)
						r = append(r, arg2...)
						projCol.Set(i, r)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var r = []byte{}
						r = append(r, arg1...)
						r = append(r, arg2...)
						projCol.Set(i, r)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatJSONJSONOp struct {
	projOpBase
}

func (p projConcatJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.Concat(arg2)
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}

						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.Concat(arg2)
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}

						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.Concat(arg2)
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}

					projCol.Set(i, _j)
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.Concat(arg2)
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}

					projCol.Set(i, _j)
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projConcatDatumDatumOp struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projConcatDatumDatumOp) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), arg2.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int16Op struct {
	projOpBase
}

func (p projLShiftInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int32Op struct {
	projOpBase
}

func (p projLShiftInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt16Int64Op struct {
	projOpBase
}

func (p projLShiftInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int16Op struct {
	projOpBase
}

func (p projLShiftInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int32Op struct {
	projOpBase
}

func (p projLShiftInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt32Int64Op struct {
	projOpBase
}

func (p projLShiftInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int16Op struct {
	projOpBase
}

func (p projLShiftInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int32Op struct {
	projOpBase
}

func (p projLShiftInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftInt64Int64Op struct {
	projOpBase
}

func (p projLShiftInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) << int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeLShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) << int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt16Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projLShiftDatumInt16Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt32Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projLShiftDatumInt32Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLShiftDatumInt64Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projLShiftDatumInt64Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int16Op struct {
	projOpBase
}

func (p projRShiftInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int32Op struct {
	projOpBase
}

func (p projRShiftInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt16Int64Op struct {
	projOpBase
}

func (p projRShiftInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int16Op struct {
	projOpBase
}

func (p projRShiftInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int32Op struct {
	projOpBase
}

func (p projRShiftInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt32Int64Op struct {
	projOpBase
}

func (p projRShiftInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int16Op struct {
	projOpBase
}

func (p projRShiftInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int32Op struct {
	projOpBase
}

func (p projRShiftInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftInt64Int64Op struct {
	projOpBase
}

func (p projRShiftInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Int64()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							if int64(arg2) < 0 || int64(arg2) >= 64 {
								telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
								colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
							}
							projCol[i] = int64(arg1) >> int64(arg2)
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						if int64(arg2) < 0 || int64(arg2) >= 64 {
							telemetry.Inc(sqltelemetry.LargeRShiftArgumentCounter)
							colexecerror.ExpectedError(tree.ErrShiftArgOutOfRange)
						}
						projCol[i] = int64(arg1) >> int64(arg2)
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt16Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projRShiftDatumInt16Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt32Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projRShiftDatumInt32Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projRShiftDatumInt64Op struct {
	projOpBase
	colexecbase.BinaryOverloadHelper
}

func (p projRShiftDatumInt64Op) Next() coldata.Batch {
	_overloadHelper := p.BinaryOverloadHelper
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Datum()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_convertedNativeElem := tree.DInt(arg2)
						var _nonDatumArgAsDatum tree.Datum
						_nonDatumArgAsDatum = &_convertedNativeElem

						_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
						if err != nil {
							colexecerror.ExpectedError(err)
						}
						if _res == tree.DNull {
							_outNulls.SetNull(i)
						}
						projCol.Set(i, _res)

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_convertedNativeElem := tree.DInt(arg2)
					var _nonDatumArgAsDatum tree.Datum
					_nonDatumArgAsDatum = &_convertedNativeElem

					_res, err := _overloadHelper.BinFn(_overloadHelper.EvalCtx, arg1.(tree.Datum), _nonDatumArgAsDatum.(tree.Datum))
					if err != nil {
						colexecerror.ExpectedError(err)
					}
					if _res == tree.DNull {
						_outNulls.SetNull(i)
					}
					projCol.Set(i, _res)

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONBytesOp struct {
	projOpBase
}

func (p projJSONFetchValJSONBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt16Op struct {
	projOpBase
}

func (p projJSONFetchValJSONInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt32Op struct {
	projOpBase
}

func (p projJSONFetchValJSONInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValJSONInt64Op struct {
	projOpBase
}

func (p projJSONFetchValJSONInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _j)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _j)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONBytesOp struct {
	projOpBase
}

func (p projJSONFetchTextJSONBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
						// is safe since we know the bytes won't change out from under us during
						// FetchValKey.
						_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					// Get an unsafe string handle onto the bytes, to avoid a spurious copy. This
					// is safe since we know the bytes won't change out from under us during
					// FetchValKey.
					_j, _err := arg1.FetchValKey(*(*string)(unsafe.Pointer(&arg2)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt16Op struct {
	projOpBase
}

func (p projJSONFetchTextJSONInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt32Op struct {
	projOpBase
}

func (p projJSONFetchTextJSONInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextJSONInt64Op struct {
	projOpBase
}

func (p projJSONFetchTextJSONInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						_j, _err := arg1.FetchValIdx(int(arg2))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _j == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _j.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					_j, _err := arg1.FetchValIdx(int(arg2))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _j == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _j.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchValPathJSONDatumOp struct {
	projOpBase
}

func (p projJSONFetchValPathJSONDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.JSON()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _path)
						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, _path)
						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _path)
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {
						projCol.Set(i, _path)
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projJSONFetchTextPathJSONDatumOp struct {
	projOpBase
}

func (p projJSONFetchTextPathJSONDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bytes()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _path.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}

						}
					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _path == nil {
							_outNulls.SetNull(i)
						} else {

							_text, _err := _path.AsText()
							if _err != nil {
								colexecerror.ExpectedError(_err)
							}
							if _text == nil {
								_outNulls.SetNull(i)
							} else {
								projCol.Set(i, []byte(*_text))
							}

						}
					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _path.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					_path, _err := tree.GetJSONPath(arg1, *tree.MustBeDArray(arg2.(tree.Datum)))
					if _err != nil {
						colexecerror.ExpectedError(_err)
					}
					if _path == nil {
						_outNulls.SetNull(i)
					} else {

						_text, _err := _path.AsText()
						if _err != nil {
							colexecerror.ExpectedError(_err)
						}
						if _text == nil {
							_outNulls.SetNull(i)
						} else {
							projCol.Set(i, []byte(*_text))
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQBoolBoolOp struct {
	projOpBase
}

func (p projEQBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQBytesBytesOp struct {
	projOpBase
}

func (p projEQBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt16Op struct {
	projOpBase
}

func (p projEQDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt32Op struct {
	projOpBase
}

func (p projEQDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalInt64Op struct {
	projOpBase
}

func (p projEQDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalFloat64Op struct {
	projOpBase
}

func (p projEQDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDecimalDecimalOp struct {
	projOpBase
}

func (p projEQDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int16Op struct {
	projOpBase
}

func (p projEQInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int32Op struct {
	projOpBase
}

func (p projEQInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Int64Op struct {
	projOpBase
}

func (p projEQInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16Float64Op struct {
	projOpBase
}

func (p projEQInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt16DecimalOp struct {
	projOpBase
}

func (p projEQInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int16Op struct {
	projOpBase
}

func (p projEQInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int32Op struct {
	projOpBase
}

func (p projEQInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Int64Op struct {
	projOpBase
}

func (p projEQInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32Float64Op struct {
	projOpBase
}

func (p projEQInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt32DecimalOp struct {
	projOpBase
}

func (p projEQInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int16Op struct {
	projOpBase
}

func (p projEQInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int32Op struct {
	projOpBase
}

func (p projEQInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Int64Op struct {
	projOpBase
}

func (p projEQInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64Float64Op struct {
	projOpBase
}

func (p projEQInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQInt64DecimalOp struct {
	projOpBase
}

func (p projEQInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int16Op struct {
	projOpBase
}

func (p projEQFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int32Op struct {
	projOpBase
}

func (p projEQFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Int64Op struct {
	projOpBase
}

func (p projEQFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64Float64Op struct {
	projOpBase
}

func (p projEQFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQFloat64DecimalOp struct {
	projOpBase
}

func (p projEQFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQTimestampTimestampOp struct {
	projOpBase
}

func (p projEQTimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQIntervalIntervalOp struct {
	projOpBase
}

func (p projEQIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQJSONJSONOp struct {
	projOpBase
}

func (p projEQJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projEQDatumDatumOp struct {
	projOpBase
}

func (p projEQDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult == 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult == 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult == 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult == 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEBoolBoolOp struct {
	projOpBase
}

func (p projNEBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEBytesBytesOp struct {
	projOpBase
}

func (p projNEBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt16Op struct {
	projOpBase
}

func (p projNEDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt32Op struct {
	projOpBase
}

func (p projNEDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalInt64Op struct {
	projOpBase
}

func (p projNEDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalFloat64Op struct {
	projOpBase
}

func (p projNEDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDecimalDecimalOp struct {
	projOpBase
}

func (p projNEDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int16Op struct {
	projOpBase
}

func (p projNEInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int32Op struct {
	projOpBase
}

func (p projNEInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Int64Op struct {
	projOpBase
}

func (p projNEInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16Float64Op struct {
	projOpBase
}

func (p projNEInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt16DecimalOp struct {
	projOpBase
}

func (p projNEInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int16Op struct {
	projOpBase
}

func (p projNEInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int32Op struct {
	projOpBase
}

func (p projNEInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Int64Op struct {
	projOpBase
}

func (p projNEInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32Float64Op struct {
	projOpBase
}

func (p projNEInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt32DecimalOp struct {
	projOpBase
}

func (p projNEInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int16Op struct {
	projOpBase
}

func (p projNEInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int32Op struct {
	projOpBase
}

func (p projNEInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Int64Op struct {
	projOpBase
}

func (p projNEInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64Float64Op struct {
	projOpBase
}

func (p projNEInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEInt64DecimalOp struct {
	projOpBase
}

func (p projNEInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int16Op struct {
	projOpBase
}

func (p projNEFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int32Op struct {
	projOpBase
}

func (p projNEFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Int64Op struct {
	projOpBase
}

func (p projNEFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64Float64Op struct {
	projOpBase
}

func (p projNEFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEFloat64DecimalOp struct {
	projOpBase
}

func (p projNEFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNETimestampTimestampOp struct {
	projOpBase
}

func (p projNETimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEIntervalIntervalOp struct {
	projOpBase
}

func (p projNEIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEJSONJSONOp struct {
	projOpBase
}

func (p projNEJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projNEDatumDatumOp struct {
	projOpBase
}

func (p projNEDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult != 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult != 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult != 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult != 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTBoolBoolOp struct {
	projOpBase
}

func (p projLTBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTBytesBytesOp struct {
	projOpBase
}

func (p projLTBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt16Op struct {
	projOpBase
}

func (p projLTDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt32Op struct {
	projOpBase
}

func (p projLTDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalInt64Op struct {
	projOpBase
}

func (p projLTDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalFloat64Op struct {
	projOpBase
}

func (p projLTDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDecimalDecimalOp struct {
	projOpBase
}

func (p projLTDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int16Op struct {
	projOpBase
}

func (p projLTInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int32Op struct {
	projOpBase
}

func (p projLTInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Int64Op struct {
	projOpBase
}

func (p projLTInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16Float64Op struct {
	projOpBase
}

func (p projLTInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt16DecimalOp struct {
	projOpBase
}

func (p projLTInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int16Op struct {
	projOpBase
}

func (p projLTInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int32Op struct {
	projOpBase
}

func (p projLTInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Int64Op struct {
	projOpBase
}

func (p projLTInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32Float64Op struct {
	projOpBase
}

func (p projLTInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt32DecimalOp struct {
	projOpBase
}

func (p projLTInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int16Op struct {
	projOpBase
}

func (p projLTInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int32Op struct {
	projOpBase
}

func (p projLTInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Int64Op struct {
	projOpBase
}

func (p projLTInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64Float64Op struct {
	projOpBase
}

func (p projLTInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTInt64DecimalOp struct {
	projOpBase
}

func (p projLTInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int16Op struct {
	projOpBase
}

func (p projLTFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int32Op struct {
	projOpBase
}

func (p projLTFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Int64Op struct {
	projOpBase
}

func (p projLTFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64Float64Op struct {
	projOpBase
}

func (p projLTFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTFloat64DecimalOp struct {
	projOpBase
}

func (p projLTFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTTimestampTimestampOp struct {
	projOpBase
}

func (p projLTTimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTIntervalIntervalOp struct {
	projOpBase
}

func (p projLTIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTJSONJSONOp struct {
	projOpBase
}

func (p projLTJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLTDatumDatumOp struct {
	projOpBase
}

func (p projLTDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult < 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult < 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult < 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult < 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEBoolBoolOp struct {
	projOpBase
}

func (p projLEBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEBytesBytesOp struct {
	projOpBase
}

func (p projLEBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt16Op struct {
	projOpBase
}

func (p projLEDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt32Op struct {
	projOpBase
}

func (p projLEDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalInt64Op struct {
	projOpBase
}

func (p projLEDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalFloat64Op struct {
	projOpBase
}

func (p projLEDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDecimalDecimalOp struct {
	projOpBase
}

func (p projLEDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int16Op struct {
	projOpBase
}

func (p projLEInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int32Op struct {
	projOpBase
}

func (p projLEInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Int64Op struct {
	projOpBase
}

func (p projLEInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16Float64Op struct {
	projOpBase
}

func (p projLEInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt16DecimalOp struct {
	projOpBase
}

func (p projLEInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int16Op struct {
	projOpBase
}

func (p projLEInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int32Op struct {
	projOpBase
}

func (p projLEInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Int64Op struct {
	projOpBase
}

func (p projLEInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32Float64Op struct {
	projOpBase
}

func (p projLEInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt32DecimalOp struct {
	projOpBase
}

func (p projLEInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int16Op struct {
	projOpBase
}

func (p projLEInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int32Op struct {
	projOpBase
}

func (p projLEInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Int64Op struct {
	projOpBase
}

func (p projLEInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64Float64Op struct {
	projOpBase
}

func (p projLEInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEInt64DecimalOp struct {
	projOpBase
}

func (p projLEInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int16Op struct {
	projOpBase
}

func (p projLEFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int32Op struct {
	projOpBase
}

func (p projLEFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Int64Op struct {
	projOpBase
}

func (p projLEFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64Float64Op struct {
	projOpBase
}

func (p projLEFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEFloat64DecimalOp struct {
	projOpBase
}

func (p projLEFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLETimestampTimestampOp struct {
	projOpBase
}

func (p projLETimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEIntervalIntervalOp struct {
	projOpBase
}

func (p projLEIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEJSONJSONOp struct {
	projOpBase
}

func (p projLEJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projLEDatumDatumOp struct {
	projOpBase
}

func (p projLEDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult <= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult <= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult <= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult <= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTBoolBoolOp struct {
	projOpBase
}

func (p projGTBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTBytesBytesOp struct {
	projOpBase
}

func (p projGTBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt16Op struct {
	projOpBase
}

func (p projGTDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt32Op struct {
	projOpBase
}

func (p projGTDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalInt64Op struct {
	projOpBase
}

func (p projGTDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalFloat64Op struct {
	projOpBase
}

func (p projGTDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDecimalDecimalOp struct {
	projOpBase
}

func (p projGTDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int16Op struct {
	projOpBase
}

func (p projGTInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int32Op struct {
	projOpBase
}

func (p projGTInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Int64Op struct {
	projOpBase
}

func (p projGTInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16Float64Op struct {
	projOpBase
}

func (p projGTInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt16DecimalOp struct {
	projOpBase
}

func (p projGTInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int16Op struct {
	projOpBase
}

func (p projGTInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int32Op struct {
	projOpBase
}

func (p projGTInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Int64Op struct {
	projOpBase
}

func (p projGTInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32Float64Op struct {
	projOpBase
}

func (p projGTInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt32DecimalOp struct {
	projOpBase
}

func (p projGTInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int16Op struct {
	projOpBase
}

func (p projGTInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int32Op struct {
	projOpBase
}

func (p projGTInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Int64Op struct {
	projOpBase
}

func (p projGTInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64Float64Op struct {
	projOpBase
}

func (p projGTInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTInt64DecimalOp struct {
	projOpBase
}

func (p projGTInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int16Op struct {
	projOpBase
}

func (p projGTFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int32Op struct {
	projOpBase
}

func (p projGTFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Int64Op struct {
	projOpBase
}

func (p projGTFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64Float64Op struct {
	projOpBase
}

func (p projGTFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTFloat64DecimalOp struct {
	projOpBase
}

func (p projGTFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTTimestampTimestampOp struct {
	projOpBase
}

func (p projGTTimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTIntervalIntervalOp struct {
	projOpBase
}

func (p projGTIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTJSONJSONOp struct {
	projOpBase
}

func (p projGTJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGTDatumDatumOp struct {
	projOpBase
}

func (p projGTDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult > 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult > 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult > 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult > 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEBoolBoolOp struct {
	projOpBase
}

func (p projGEBoolBoolOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if !arg1 && arg2 {
								cmpResult = -1
							} else if arg1 && !arg2 {
								cmpResult = 1
							} else {
								cmpResult = 0
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEBytesBytesOp struct {
	projOpBase
}

func (p projGEBytesBytesOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = bytes.Compare(arg1, arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt16Op struct {
	projOpBase
}

func (p projGEDecimalInt16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt32Op struct {
	projOpBase
}

func (p projGEDecimalInt32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalInt64Op struct {
	projOpBase
}

func (p projGEDecimalInt64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg2))
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg2))
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalFloat64Op struct {
	projOpBase
}

func (p projGEDecimalFloat64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, &tmpDec)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDecimalDecimalOp struct {
	projOpBase
}

func (p projGEDecimalDecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = tree.CompareDecimals(&arg1, &arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int16Op struct {
	projOpBase
}

func (p projGEInt16Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int32Op struct {
	projOpBase
}

func (p projGEInt16Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Int64Op struct {
	projOpBase
}

func (p projGEInt16Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16Float64Op struct {
	projOpBase
}

func (p projGEInt16Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt16DecimalOp struct {
	projOpBase
}

func (p projGEInt16DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int16Op struct {
	projOpBase
}

func (p projGEInt32Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int32Op struct {
	projOpBase
}

func (p projGEInt32Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Int64Op struct {
	projOpBase
}

func (p projGEInt32Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32Float64Op struct {
	projOpBase
}

func (p projGEInt32Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt32DecimalOp struct {
	projOpBase
}

func (p projGEInt32DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int16Op struct {
	projOpBase
}

func (p projGEInt64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int32Op struct {
	projOpBase
}

func (p projGEInt64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Int64Op struct {
	projOpBase
}

func (p projGEInt64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := int64(arg1), int64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else {
									cmpResult = 0
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64Float64Op struct {
	projOpBase
}

func (p projGEInt64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if false {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEInt64DecimalOp struct {
	projOpBase
}

func (p projGEInt64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								tmpDec.SetInt64(int64(arg1))
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							tmpDec.SetInt64(int64(arg1))
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int16Op struct {
	projOpBase
}

func (p projGEFloat64Int16Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int32Op struct {
	projOpBase
}

func (p projGEFloat64Int32Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Int64Op struct {
	projOpBase
}

func (p projGEFloat64Int64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if false {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64Float64Op struct {
	projOpBase
}

func (p projGEFloat64Float64Op) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								a, b := float64(arg1), float64(arg2)
								if a < b {
									cmpResult = -1
								} else if a > b {
									cmpResult = 1
								} else if a == b {
									cmpResult = 0
								} else if math.IsNaN(a) {
									if math.IsNaN(b) {
										cmpResult = 0
									} else {
										cmpResult = -1
									}
								} else {
									cmpResult = 1
								}
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEFloat64DecimalOp struct {
	projOpBase
}

func (p projGEFloat64DecimalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							{
								var tmpDec apd.Decimal //gcassert:noescape
								if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
									colexecerror.ExpectedError(err)
								}
								cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						{
							var tmpDec apd.Decimal //gcassert:noescape
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								colexecerror.ExpectedError(err)
							}
							cmpResult = tree.CompareDecimals(&tmpDec, &arg2)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGETimestampTimestampOp struct {
	projOpBase
}

func (p projGETimestampTimestampOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Timestamp()
		col2 := vec2.Timestamp()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int

							if arg1.Before(arg2) {
								cmpResult = -1
							} else if arg2.Before(arg1) {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int

						if arg1.Before(arg2) {
							cmpResult = -1
						} else if arg2.Before(arg1) {
							cmpResult = 1
						} else {
							cmpResult = 0
						}
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEIntervalIntervalOp struct {
	projOpBase
}

func (p projGEIntervalIntervalOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Interval()
		col2 := vec2.Interval()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						//gcassert:bce
						arg1 := col1.Get(i)
						//gcassert:bce
						arg2 := col2.Get(i)

						{
							var cmpResult int
							cmpResult = arg1.Compare(arg2)
							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					//gcassert:bce
					arg1 := col1.Get(i)
					//gcassert:bce
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = arg1.Compare(arg2)
						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEJSONJSONOp struct {
	projOpBase
}

func (p projGEJSONJSONOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.JSON()
		col2 := vec2.JSON()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							var err error
							cmpResult, err = arg1.Compare(arg2)
							if err != nil {
								colexecerror.ExpectedError(err)
							}

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						var err error
						cmpResult, err = arg1.Compare(arg2)
						if err != nil {
							colexecerror.ExpectedError(err)
						}

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

type projGEDatumDatumOp struct {
	projOpBase
}

func (p projGEDatumDatumOp) Next() coldata.Batch {
	batch := p.Input.Next()
	n := batch.Length()
	if n == 0 {
		return coldata.ZeroBatch
	}
	projVec := batch.ColVec(p.outputIdx)
	p.allocator.PerformOperation([]coldata.Vec{projVec}, func() {
		if projVec.MaybeHasNulls() {
			// We need to make sure that there are no left over null values in the
			// output vector.
			projVec.Nulls().UnsetNulls()
		}
		projCol := projVec.Bool()
		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Datum()
		col2 := vec2.Datum()
		// Some operators can result in NULL with non-NULL inputs, like the JSON
		// fetch value operator, ->. Therefore, _outNulls is defined to allow
		// updating the output Nulls from within _ASSIGN functions when the result
		// of a projection is Null.
		_outNulls := projVec.Nulls()
		if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
			col1Nulls := vec1.Nulls()
			col2Nulls := vec2.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult >= 0
						}

					}
				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					if !col1Nulls.NullAt(i) && !col2Nulls.NullAt(i) {
						// We only want to perform the projection operation if both values are not
						// null.
						arg1 := col1.Get(i)
						arg2 := col2.Get(i)

						{
							var cmpResult int

							cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

							projCol[i] = cmpResult >= 0
						}

					}
				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
			projVec.SetNulls(_outNulls.Or(*col1Nulls).Or(*col2Nulls))
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult >= 0
					}

				}
			} else {
				_ = projCol.Get(n - 1)
				_ = col1.Get(n - 1)
				_ = col2.Get(n - 1)
				for i := 0; i < n; i++ {
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int

						cmpResult = coldataext.CompareDatum(arg1, col1, arg2)

						projCol[i] = cmpResult >= 0
					}

				}
			}
			// _outNulls has been updated from within the _ASSIGN function to include
			// any NULLs that resulted from the projection.
			// If $hasNulls is true, union _outNulls with the set of input Nulls.
			// If $hasNulls is false, then there are no input Nulls. _outNulls is
			// projVec.Nulls() so there is no need to call projVec.SetNulls().
		}
		// Although we didn't change the length of the batch, it is necessary to set
		// the length anyway (this helps maintaining the invariant of flat bytes).
		batch.SetLength(n)
	})
	return batch
}

// GetProjectionOperator returns the appropriate projection operator for the
// given left and right column types and operation.
func GetProjectionOperator(
	allocator *colmem.Allocator,
	inputTypes []*types.T,
	outputType *types.T,
	op tree.Operator,
	input colexecop.Operator,
	col1Idx int,
	col2Idx int,
	outputIdx int,
	evalCtx *tree.EvalContext,
	binFn tree.TwoArgFn,
	cmpExpr *tree.ComparisonExpr,
) (colexecop.Operator, error) {
	input = colexecutils.NewVectorTypeEnforcer(allocator, input, outputType, outputIdx)
	projOpBase := projOpBase{
		OneInputHelper: colexecop.MakeOneInputHelper(input),
		allocator:      allocator,
		col1Idx:        col1Idx,
		col2Idx:        col2Idx,
		outputIdx:      outputIdx,
	}

	leftType, rightType := inputTypes[col1Idx], inputTypes[col2Idx]
	switch op := op.(type) {
	case treebin.BinaryOperator:
		switch op.Symbol {
		case treebin.Bitand:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitandInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitandInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitandInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitandInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitandInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitandInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitandInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitandDatumDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Bitor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitorInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitorInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitorInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitorInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitorInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitorInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitorInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitorDatumDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Bitxor:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitxorInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitxorInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projBitxorInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projBitxorInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projBitxorInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projBitxorDatumDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Plus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPlusDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPlusDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPlusInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPlusInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt16DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPlusInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPlusInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt32DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPlusInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPlusInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusInt64DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusTimestampIntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalTimestampOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalIntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusIntervalDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPlusDatumIntervalOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPlusDatumInt16Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projPlusDatumInt32Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projPlusDatumInt64Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Minus:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMinusDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMinusDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMinusInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMinusInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt16DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMinusInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMinusInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt32DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMinusInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMinusInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusInt64DatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.TimestampTZFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.TimestampTZFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusTimestampTimestampOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusTimestampIntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusIntervalIntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusIntervalDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusJSONBytesOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusJSONInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMinusJSONInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMinusJSONInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumIntervalOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMinusDatumBytesOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMinusDatumInt16Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projMinusDatumInt32Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projMinusDatumInt64Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.Mult:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMultDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMultDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultDecimalIntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMultInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMultInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt16IntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMultInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMultInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt32IntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMultInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMultInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultInt64IntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntervalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultFloat64IntervalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projMultIntervalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projMultIntervalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projMultIntervalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultIntervalFloat64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projMultIntervalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.Div:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projDivDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projDivDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projDivInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projDivInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projDivInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projDivInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projDivInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projDivInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntervalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projDivIntervalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projDivIntervalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projDivIntervalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projDivIntervalFloat64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.FloorDiv:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projFloorDivDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projFloorDivDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projFloorDivInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projFloorDivInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projFloorDivInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projFloorDivInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projFloorDivInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projFloorDivFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.Mod:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projModDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projModDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projModInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projModInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projModInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projModInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projModInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projModInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projModInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projModFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.Pow:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.DecimalFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowDecimalInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPowDecimalInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPowDecimalInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowDecimalDecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPowInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPowInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt16DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPowInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPowInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt32DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projPowInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projPowInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projPowInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					case types.DecimalFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowInt64DecimalOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.FloatFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.FloatFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projPowFloat64Float64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.Concat:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.BytesFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatBytesBytesOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.JsonFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatJSONJSONOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projConcatDatumDatumOp{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.LShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projLShiftInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projLShiftInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projLShiftInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projLShiftInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projLShiftDatumInt16Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projLShiftDatumInt32Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projLShiftDatumInt64Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.RShift:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.IntFamily:
				switch leftType.Width() {
				case 16:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt16Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projRShiftInt16Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt16Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case 32:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt32Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projRShiftInt32Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt32Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftInt64Int16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projRShiftInt64Int32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projRShiftInt64Int64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projRShiftDatumInt16Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case 32:
							op := &projRShiftDatumInt32Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						case -1:
						default:
							op := &projRShiftDatumInt64Op{projOpBase: projOpBase}
							op.BinaryOverloadHelper = colexecbase.BinaryOverloadHelper{BinFn: binFn, EvalCtx: evalCtx}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchVal:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchValJSONBytesOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projJSONFetchValJSONInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projJSONFetchValJSONInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projJSONFetchValJSONInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchText:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case types.BytesFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchTextJSONBytesOp{projOpBase: projOpBase}
							return op, nil
						}
					case types.IntFamily:
						switch rightType.Width() {
						case 16:
							op := &projJSONFetchTextJSONInt16Op{projOpBase: projOpBase}
							return op, nil
						case 32:
							op := &projJSONFetchTextJSONInt32Op{projOpBase: projOpBase}
							return op, nil
						case -1:
						default:
							op := &projJSONFetchTextJSONInt64Op{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchValPath:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchValPathJSONDatumOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		case treebin.JSONFetchTextPath:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
			case types.JsonFamily:
				switch leftType.Width() {
				case -1:
				default:
					switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
					case typeconv.DatumVecCanonicalTypeFamily:
						switch rightType.Width() {
						case -1:
						default:
							op := &projJSONFetchTextPathJSONDatumOp{projOpBase: projOpBase}
							return op, nil
						}
					}
				}
			}
		}
	case treecmp.ComparisonOperator:
		if leftType.Family() != types.TupleFamily && rightType.Family() != types.TupleFamily {
			// Tuple comparison has special null-handling semantics, so we will
			// fallback to the default comparison operator if either of the
			// input vectors is of a tuple type.
			switch op.Symbol {
			case treecmp.EQ:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projEQDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projEQDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projEQInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projEQInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projEQInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projEQInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projEQInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projEQInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projEQFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projEQFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projEQFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQTimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projEQDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			case treecmp.NE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projNEDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projNEDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projNEInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projNEInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projNEInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projNEInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projNEInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projNEInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projNEFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projNEFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projNEFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNETimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projNEDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			case treecmp.LT:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLTDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLTDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLTInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLTInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLTInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLTInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLTInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLTInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLTFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLTFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLTFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTTimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLTDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			case treecmp.LE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLEDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLEDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLEInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLEInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLEInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLEInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLEInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLEInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projLEFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projLEFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projLEFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLETimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projLEDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			case treecmp.GT:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGTDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGTDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGTInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGTInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGTInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGTInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGTInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGTInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGTFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGTFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGTFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTTimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGTDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			case treecmp.GE:
				switch typeconv.TypeFamilyToCanonicalTypeFamily(leftType.Family()) {
				case types.BoolFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BoolFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEBoolBoolOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.BytesFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.BytesFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEBytesBytesOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.DecimalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEDecimalInt16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGEDecimalInt32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGEDecimalInt64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDecimalFloat64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDecimalDecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntFamily:
					switch leftType.Width() {
					case 16:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt16Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGEInt16Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGEInt16Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt16Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt16DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case 32:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt32Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGEInt32Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGEInt32Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt32Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt32DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEInt64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGEInt64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGEInt64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEInt64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.FloatFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntFamily:
							switch rightType.Width() {
							case 16:
								return &projGEFloat64Int16Op{projOpBase: projOpBase}, nil
							case 32:
								return &projGEFloat64Int32Op{projOpBase: projOpBase}, nil
							case -1:
							default:
								return &projGEFloat64Int64Op{projOpBase: projOpBase}, nil
							}
						case types.FloatFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEFloat64Float64Op{projOpBase: projOpBase}, nil
							}
						case types.DecimalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEFloat64DecimalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.TimestampTZFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.TimestampTZFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGETimestampTimestampOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.IntervalFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.IntervalFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEIntervalIntervalOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case types.JsonFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case types.JsonFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEJSONJSONOp{projOpBase: projOpBase}, nil
							}
						}
					}
				case typeconv.DatumVecCanonicalTypeFamily:
					switch leftType.Width() {
					case -1:
					default:
						switch typeconv.TypeFamilyToCanonicalTypeFamily(rightType.Family()) {
						case typeconv.DatumVecCanonicalTypeFamily:
							switch rightType.Width() {
							case -1:
							default:
								return &projGEDatumDatumOp{projOpBase: projOpBase}, nil
							}
						}
					}
				}
			}
		}
		return &defaultCmpProjOp{
			projOpBase:          projOpBase,
			adapter:             colexeccmp.NewComparisonExprAdapter(cmpExpr, evalCtx),
			toDatumConverter:    colconv.NewVecToDatumConverter(len(inputTypes), []int{col1Idx, col2Idx}, true /* willRelease */),
			datumToVecConverter: colconv.GetDatumToPhysicalFn(outputType),
		}, nil
	}
	return nil, errors.Errorf("couldn't find overload for %s %s %s", leftType.Name(), op, rightType.Name())
}
