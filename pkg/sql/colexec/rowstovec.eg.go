// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"github.com/cockroachdb/apd/v3"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/rowenc"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/cockroach/pkg/util/encoding"
	"github.com/cockroachdb/cockroach/pkg/util/json"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ = typeconv.DatumVecCanonicalTypeFamily
	_ apd.Context
	_ duration.Duration
	_ encoding.Direction
	_ json.JSON
)

// EncDatumRowsToColVec converts one column from EncDatumRows to a column
// vector. columnIdx is the 0-based index of the column in the EncDatumRows.
func EncDatumRowsToColVec(
	allocator *colmem.Allocator,
	rows rowenc.EncDatumRows,
	vec coldata.Vec,
	columnIdx int,
	t *types.T,
	alloc *tree.DatumAlloc,
) {
	allocator.PerformOperation(
		[]coldata.Vec{vec},
		func() {
			switch t.Family() {
			case types.BoolFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Bool()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := bool(*datum.(*tree.DBool))
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.IntFamily:
				switch t.Width() {
				case 16:
					col := vec.Int16()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := int16(*datum.(*tree.DInt))
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				case 32:
					col := vec.Int32()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := int32(*datum.(*tree.DInt))
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				case -1:
				default:
					col := vec.Int64()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := int64(*datum.(*tree.DInt))
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.FloatFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Float64()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := float64(*datum.(*tree.DFloat))
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.DecimalFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Decimal()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DDecimal).Decimal
								col.Set(i, v)
							}
						}
					}
				}
			case types.DateFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Int64()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DDate).UnixEpochDaysWithOrig()
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.TimestampFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Timestamp()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DTimestamp).Time
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.IntervalFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Interval()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DInterval).Duration
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.StringFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Bytes()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {
								// Handle other STRING-related OID types, like oid.T_name.
								wrapper, ok := datum.(*tree.DOidWrapper)
								if ok {
									datum = wrapper.Wrapped
								}
								v := encoding.UnsafeConvertStringToBytes(string(*datum.(*tree.DString)))
								col.Set(i, v)
							}
						}
					}
				}
			case types.BytesFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Bytes()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := encoding.UnsafeConvertStringToBytes(string(*datum.(*tree.DBytes)))
								col.Set(i, v)
							}
						}
					}
				}
			case types.TimestampTZFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Timestamp()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DTimestampTZ).Time
								//gcassert:bce
								col.Set(i, v)
							}
						}
					}
				}
			case types.UuidFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Bytes()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DUuid).UUID.GetBytesMut()
								col.Set(i, v)
							}
						}
					}
				}
			case types.JsonFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.JSON()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum.(*tree.DJSON).JSON
								col.Set(i, v)
							}
						}
					}
				}
			case types.EncodedKeyFamily:
				switch t.Width() {
				case -1:
				default:
					col := vec.Bytes()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := encoding.UnsafeConvertStringToBytes(string(*datum.(*tree.DEncodedKey)))
								col.Set(i, v)
							}
						}
					}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
			default:
				switch t.Width() {
				case -1:
				default:
					col := vec.Datum()
					if len(rows) > 0 {
						_ = col.Get(len(rows) - 1)
						for i := range rows {
							row := rows[i]
							if row[columnIdx].Datum == nil {
								if err := row[columnIdx].EnsureDecoded(t, alloc); err != nil {
									colexecerror.InternalError(err)
								}
							}
							datum := row[columnIdx].Datum
							if datum == tree.DNull {
								vec.Nulls().SetNull(i)
							} else {

								v := datum
								col.Set(i, v)
							}
						}
					}
				}
			}
		},
	)
}
