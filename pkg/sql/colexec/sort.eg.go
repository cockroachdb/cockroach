// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"context"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/colexecutils"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/execinfrapb"
	"github.com/cockroachdb/cockroach/pkg/sql/memsize"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

// Workaround for bazel auto-generated code. goimports does not automatically
// pick up the right packages when run within the bazel sandbox.
var (
	_ = coldataext.CompareDatum
	_ tree.AggType
)

func isSorterSupported(t *types.T, dir execinfrapb.Ordering_Column_Direction) bool {
	switch dir {
	case execinfrapb.Ordering_Column_ASC:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
		case types.BoolFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.BytesFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.DecimalFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.IntFamily:
			switch t.Width() {
			case 16:
				return true
			case 32:
				return true
			case -1:
			default:
				return true
			}
		case types.FloatFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.TimestampTZFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.IntervalFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.JsonFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		}
	case execinfrapb.Ordering_Column_DESC:
		switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
		case types.BoolFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.BytesFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.DecimalFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.IntFamily:
			switch t.Width() {
			case 16:
				return true
			case 32:
				return true
			case -1:
			default:
				return true
			}
		case types.FloatFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.TimestampTZFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.IntervalFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case types.JsonFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		case typeconv.DatumVecCanonicalTypeFamily:
			switch t.Width() {
			case -1:
			default:
				return true
			}
		}
	}
	return false
}

func newSingleSorter(
	t *types.T, dir execinfrapb.Ordering_Column_Direction, hasNulls bool,
) colSorter {
	switch hasNulls {
	case true:
		switch dir {
		case execinfrapb.Ordering_Column_ASC:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
			case types.BoolFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBoolAscWithNullsOp{}
				}
			case types.BytesFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBytesAscWithNullsOp{}
				}
			case types.DecimalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDecimalAscWithNullsOp{}
				}
			case types.IntFamily:
				switch t.Width() {
				case 16:
					return &sortInt16AscWithNullsOp{}
				case 32:
					return &sortInt32AscWithNullsOp{}
				case -1:
				default:
					return &sortInt64AscWithNullsOp{}
				}
			case types.FloatFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortFloat64AscWithNullsOp{}
				}
			case types.TimestampTZFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortTimestampAscWithNullsOp{}
				}
			case types.IntervalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortIntervalAscWithNullsOp{}
				}
			case types.JsonFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortJSONAscWithNullsOp{}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDatumAscWithNullsOp{}
				}
			}
		case execinfrapb.Ordering_Column_DESC:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
			case types.BoolFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBoolDescWithNullsOp{}
				}
			case types.BytesFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBytesDescWithNullsOp{}
				}
			case types.DecimalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDecimalDescWithNullsOp{}
				}
			case types.IntFamily:
				switch t.Width() {
				case 16:
					return &sortInt16DescWithNullsOp{}
				case 32:
					return &sortInt32DescWithNullsOp{}
				case -1:
				default:
					return &sortInt64DescWithNullsOp{}
				}
			case types.FloatFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortFloat64DescWithNullsOp{}
				}
			case types.TimestampTZFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortTimestampDescWithNullsOp{}
				}
			case types.IntervalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortIntervalDescWithNullsOp{}
				}
			case types.JsonFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortJSONDescWithNullsOp{}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDatumDescWithNullsOp{}
				}
			}
		}
	case false:
		switch dir {
		case execinfrapb.Ordering_Column_ASC:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
			case types.BoolFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBoolAscOp{}
				}
			case types.BytesFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBytesAscOp{}
				}
			case types.DecimalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDecimalAscOp{}
				}
			case types.IntFamily:
				switch t.Width() {
				case 16:
					return &sortInt16AscOp{}
				case 32:
					return &sortInt32AscOp{}
				case -1:
				default:
					return &sortInt64AscOp{}
				}
			case types.FloatFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortFloat64AscOp{}
				}
			case types.TimestampTZFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortTimestampAscOp{}
				}
			case types.IntervalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortIntervalAscOp{}
				}
			case types.JsonFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortJSONAscOp{}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDatumAscOp{}
				}
			}
		case execinfrapb.Ordering_Column_DESC:
			switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
			case types.BoolFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBoolDescOp{}
				}
			case types.BytesFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortBytesDescOp{}
				}
			case types.DecimalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDecimalDescOp{}
				}
			case types.IntFamily:
				switch t.Width() {
				case 16:
					return &sortInt16DescOp{}
				case 32:
					return &sortInt32DescOp{}
				case -1:
				default:
					return &sortInt64DescOp{}
				}
			case types.FloatFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortFloat64DescOp{}
				}
			case types.TimestampTZFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortTimestampDescOp{}
				}
			case types.IntervalFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortIntervalDescOp{}
				}
			case types.JsonFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortJSONDescOp{}
				}
			case typeconv.DatumVecCanonicalTypeFamily:
				switch t.Width() {
				case -1:
				default:
					return &sortDatumDescOp{}
				}
			}
		}
	}
	colexecerror.InternalError(errors.AssertionFailedf("isSorterSupported should have caught this"))
	// This code is unreachable, but the compiler cannot infer that.
	return nil
}

type sortBoolAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Bools
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortBoolAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBoolAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBoolAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBoolAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBoolAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if !arg1 && arg2 {
			cmpResult = -1
		} else if arg1 && !arg2 {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortBoolAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortBytesAscWithNullsOp struct {
	allocator          *colmem.Allocator
	sortCol            *coldata.Bytes
	abbreviatedSortCol []uint64
	nulls              *coldata.Nulls
	order              []int
	cancelChecker      colexecutils.CancelChecker
}

func (s *sortBytesAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bytes()
	s.allocator.AdjustMemoryUsage(memsize.Uint64 * int64(s.sortCol.Len()))
	s.abbreviatedSortCol = s.sortCol.Abbreviated()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBytesAscWithNullsOp) reset() {
	s.allocator.AdjustMemoryUsage(0 - memsize.Uint64*int64(s.sortCol.Len()))
	s.abbreviatedSortCol = nil
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBytesAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBytesAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBytesAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	// If the type can be abbreviated as a uint64, compare the abbreviated
	// values first. If they are not equal, we are done with the comparison. If
	// they are equal, we must fallback to a full comparison of the datums.
	abbr1 := s.abbreviatedSortCol[order1]
	abbr2 := s.abbreviatedSortCol[order2]
	if abbr1 != abbr2 {
		return abbr1 < abbr2
	}

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = bytes.Compare(arg1, arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortBytesAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortDecimalAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Decimals
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDecimalAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDecimalAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDecimalAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDecimalAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDecimalAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&arg1, &arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortDecimalAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt16AscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int16s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt16AscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt16AscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt16AscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt16AscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt16AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt16AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt32AscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int32s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt32AscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt32AscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt32AscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt32AscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt32AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt32AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt64AscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt64AscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt64AscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt64AscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt64AscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt64AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt64AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat64AscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Float64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortFloat64AscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortFloat64AscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortFloat64AscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortFloat64AscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortFloat64AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := float64(arg1), float64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortFloat64AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortTimestampAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Times
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortTimestampAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Timestamp()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortTimestampAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortTimestampAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortTimestampAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortTimestampAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if arg1.Before(arg2) {
			cmpResult = -1
		} else if arg2.Before(arg1) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortTimestampAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortTimestampAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortIntervalAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Durations
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortIntervalAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Interval()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortIntervalAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortIntervalAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortIntervalAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortIntervalAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = arg1.Compare(arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortIntervalAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortIntervalAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortJSONAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       *coldata.JSONs
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortJSONAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.JSON()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortJSONAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortJSONAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortJSONAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortJSONAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		var err error
		cmpResult, err = arg1.Compare(arg2)
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortJSONAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortJSONAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortDatumAscWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.DatumVec
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDatumAscWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Datum()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDatumAscWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDatumAscWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDatumAscWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDatumAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		cmpResult = coldataext.CompareDatum(arg1, s.sortCol, arg2)

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortDatumAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDatumAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortBoolDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Bools
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortBoolDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBoolDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBoolDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBoolDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBoolDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if !arg1 && arg2 {
			cmpResult = -1
		} else if arg1 && !arg2 {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortBoolDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortBytesDescWithNullsOp struct {
	allocator          *colmem.Allocator
	sortCol            *coldata.Bytes
	abbreviatedSortCol []uint64
	nulls              *coldata.Nulls
	order              []int
	cancelChecker      colexecutils.CancelChecker
}

func (s *sortBytesDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bytes()
	s.allocator.AdjustMemoryUsage(memsize.Uint64 * int64(s.sortCol.Len()))
	s.abbreviatedSortCol = s.sortCol.Abbreviated()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBytesDescWithNullsOp) reset() {
	s.allocator.AdjustMemoryUsage(0 - memsize.Uint64*int64(s.sortCol.Len()))
	s.abbreviatedSortCol = nil
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBytesDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBytesDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBytesDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	// If the type can be abbreviated as a uint64, compare the abbreviated
	// values first. If they are not equal, we are done with the comparison. If
	// they are equal, we must fallback to a full comparison of the datums.
	abbr1 := s.abbreviatedSortCol[order1]
	abbr2 := s.abbreviatedSortCol[order2]
	if abbr1 != abbr2 {
		return abbr1 > abbr2
	}

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = bytes.Compare(arg1, arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortBytesDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortDecimalDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Decimals
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDecimalDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDecimalDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDecimalDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDecimalDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDecimalDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&arg1, &arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortDecimalDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt16DescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int16s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt16DescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt16DescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt16DescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt16DescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt16DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt16DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt32DescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int32s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt32DescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt32DescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt32DescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt32DescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt32DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt32DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt64DescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt64DescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt64DescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt64DescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt64DescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt64DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt64DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat64DescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Float64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortFloat64DescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortFloat64DescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortFloat64DescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortFloat64DescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortFloat64DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := float64(arg1), float64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortFloat64DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortTimestampDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Times
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortTimestampDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Timestamp()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortTimestampDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortTimestampDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortTimestampDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortTimestampDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if arg1.Before(arg2) {
			cmpResult = -1
		} else if arg2.Before(arg1) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortTimestampDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortTimestampDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortIntervalDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Durations
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortIntervalDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Interval()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortIntervalDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortIntervalDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortIntervalDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortIntervalDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = arg1.Compare(arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortIntervalDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortIntervalDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortJSONDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       *coldata.JSONs
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortJSONDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.JSON()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortJSONDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortJSONDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortJSONDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortJSONDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		var err error
		cmpResult, err = arg1.Compare(arg2)
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortJSONDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortJSONDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortDatumDescWithNullsOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.DatumVec
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDatumDescWithNullsOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Datum()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDatumDescWithNullsOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDatumDescWithNullsOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDatumDescWithNullsOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDatumDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		cmpResult = coldataext.CompareDatum(arg1, s.sortCol, arg2)

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortDatumDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDatumDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortBoolAscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Bools
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortBoolAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBoolAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBoolAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBoolAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBoolAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if !arg1 && arg2 {
			cmpResult = -1
		} else if arg1 && !arg2 {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortBoolAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolAscOp) Len() int {
	return len(s.order)
}

type sortBytesAscOp struct {
	allocator          *colmem.Allocator
	sortCol            *coldata.Bytes
	abbreviatedSortCol []uint64
	nulls              *coldata.Nulls
	order              []int
	cancelChecker      colexecutils.CancelChecker
}

func (s *sortBytesAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bytes()
	s.allocator.AdjustMemoryUsage(memsize.Uint64 * int64(s.sortCol.Len()))
	s.abbreviatedSortCol = s.sortCol.Abbreviated()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBytesAscOp) reset() {
	s.allocator.AdjustMemoryUsage(0 - memsize.Uint64*int64(s.sortCol.Len()))
	s.abbreviatedSortCol = nil
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBytesAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBytesAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBytesAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	// If the type can be abbreviated as a uint64, compare the abbreviated
	// values first. If they are not equal, we are done with the comparison. If
	// they are equal, we must fallback to a full comparison of the datums.
	abbr1 := s.abbreviatedSortCol[order1]
	abbr2 := s.abbreviatedSortCol[order2]
	if abbr1 != abbr2 {
		return abbr1 < abbr2
	}

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = bytes.Compare(arg1, arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortBytesAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesAscOp) Len() int {
	return len(s.order)
}

type sortDecimalAscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Decimals
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDecimalAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDecimalAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDecimalAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDecimalAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDecimalAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&arg1, &arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortDecimalAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalAscOp) Len() int {
	return len(s.order)
}

type sortInt16AscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int16s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt16AscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt16AscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt16AscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt16AscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt16AscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt16AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16AscOp) Len() int {
	return len(s.order)
}

type sortInt32AscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int32s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt32AscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt32AscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt32AscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt32AscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt32AscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt32AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32AscOp) Len() int {
	return len(s.order)
}

type sortInt64AscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt64AscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt64AscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt64AscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt64AscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt64AscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortInt64AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64AscOp) Len() int {
	return len(s.order)
}

type sortFloat64AscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Float64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortFloat64AscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortFloat64AscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortFloat64AscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortFloat64AscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortFloat64AscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := float64(arg1), float64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortFloat64AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64AscOp) Len() int {
	return len(s.order)
}

type sortTimestampAscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Times
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortTimestampAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Timestamp()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortTimestampAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortTimestampAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortTimestampAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortTimestampAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if arg1.Before(arg2) {
			cmpResult = -1
		} else if arg2.Before(arg1) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortTimestampAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortTimestampAscOp) Len() int {
	return len(s.order)
}

type sortIntervalAscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Durations
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortIntervalAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Interval()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortIntervalAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortIntervalAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortIntervalAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortIntervalAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = arg1.Compare(arg2)
		lt = cmpResult < 0
	}

	return lt
}

func (s *sortIntervalAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortIntervalAscOp) Len() int {
	return len(s.order)
}

type sortJSONAscOp struct {
	allocator     *colmem.Allocator
	sortCol       *coldata.JSONs
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortJSONAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.JSON()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortJSONAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortJSONAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortJSONAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortJSONAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		var err error
		cmpResult, err = arg1.Compare(arg2)
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortJSONAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortJSONAscOp) Len() int {
	return len(s.order)
}

type sortDatumAscOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.DatumVec
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDatumAscOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Datum()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDatumAscOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDatumAscOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDatumAscOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDatumAscOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		cmpResult = coldataext.CompareDatum(arg1, s.sortCol, arg2)

		lt = cmpResult < 0
	}

	return lt
}

func (s *sortDatumAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDatumAscOp) Len() int {
	return len(s.order)
}

type sortBoolDescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Bools
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortBoolDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBoolDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBoolDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBoolDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBoolDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if !arg1 && arg2 {
			cmpResult = -1
		} else if arg1 && !arg2 {
			cmpResult = 1
		} else {
			cmpResult = 0
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortBoolDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolDescOp) Len() int {
	return len(s.order)
}

type sortBytesDescOp struct {
	allocator          *colmem.Allocator
	sortCol            *coldata.Bytes
	abbreviatedSortCol []uint64
	nulls              *coldata.Nulls
	order              []int
	cancelChecker      colexecutils.CancelChecker
}

func (s *sortBytesDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Bytes()
	s.allocator.AdjustMemoryUsage(memsize.Uint64 * int64(s.sortCol.Len()))
	s.abbreviatedSortCol = s.sortCol.Abbreviated()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortBytesDescOp) reset() {
	s.allocator.AdjustMemoryUsage(0 - memsize.Uint64*int64(s.sortCol.Len()))
	s.abbreviatedSortCol = nil
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortBytesDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortBytesDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortBytesDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	// If the type can be abbreviated as a uint64, compare the abbreviated
	// values first. If they are not equal, we are done with the comparison. If
	// they are equal, we must fallback to a full comparison of the datums.
	abbr1 := s.abbreviatedSortCol[order1]
	abbr2 := s.abbreviatedSortCol[order2]
	if abbr1 != abbr2 {
		return abbr1 > abbr2
	}

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = bytes.Compare(arg1, arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortBytesDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesDescOp) Len() int {
	return len(s.order)
}

type sortDecimalDescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Decimals
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDecimalDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDecimalDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDecimalDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDecimalDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDecimalDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = tree.CompareDecimals(&arg1, &arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortDecimalDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalDescOp) Len() int {
	return len(s.order)
}

type sortInt16DescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int16s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt16DescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt16DescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt16DescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt16DescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt16DescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt16DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16DescOp) Len() int {
	return len(s.order)
}

type sortInt32DescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int32s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt32DescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt32DescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt32DescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt32DescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt32DescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt32DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32DescOp) Len() int {
	return len(s.order)
}

type sortInt64DescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Int64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortInt64DescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortInt64DescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortInt64DescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortInt64DescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortInt64DescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := int64(arg1), int64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else {
				cmpResult = 0
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortInt64DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64DescOp) Len() int {
	return len(s.order)
}

type sortFloat64DescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Float64s
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortFloat64DescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortFloat64DescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortFloat64DescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortFloat64DescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortFloat64DescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		{
			a, b := float64(arg1), float64(arg2)
			if a < b {
				cmpResult = -1
			} else if a > b {
				cmpResult = 1
			} else if a == b {
				cmpResult = 0
			} else if math.IsNaN(a) {
				if math.IsNaN(b) {
					cmpResult = 0
				} else {
					cmpResult = -1
				}
			} else {
				cmpResult = 1
			}
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortFloat64DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64DescOp) Len() int {
	return len(s.order)
}

type sortTimestampDescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Times
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortTimestampDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Timestamp()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortTimestampDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortTimestampDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortTimestampDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortTimestampDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		if arg1.Before(arg2) {
			cmpResult = -1
		} else if arg2.Before(arg1) {
			cmpResult = 1
		} else {
			cmpResult = 0
		}
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortTimestampDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortTimestampDescOp) Len() int {
	return len(s.order)
}

type sortIntervalDescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.Durations
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortIntervalDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Interval()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortIntervalDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortIntervalDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortIntervalDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortIntervalDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int
		cmpResult = arg1.Compare(arg2)
		lt = cmpResult > 0
	}

	return lt
}

func (s *sortIntervalDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortIntervalDescOp) Len() int {
	return len(s.order)
}

type sortJSONDescOp struct {
	allocator     *colmem.Allocator
	sortCol       *coldata.JSONs
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortJSONDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.JSON()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortJSONDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortJSONDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortJSONDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortJSONDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		var err error
		cmpResult, err = arg1.Compare(arg2)
		if err != nil {
			colexecerror.ExpectedError(err)
		}

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortJSONDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortJSONDescOp) Len() int {
	return len(s.order)
}

type sortDatumDescOp struct {
	allocator     *colmem.Allocator
	sortCol       coldata.DatumVec
	nulls         *coldata.Nulls
	order         []int
	cancelChecker colexecutils.CancelChecker
}

func (s *sortDatumDescOp) init(
	ctx context.Context, allocator *colmem.Allocator, col coldata.Vec, order []int,
) {
	s.allocator = allocator
	s.sortCol = col.Datum()
	s.nulls = col.Nulls()
	s.order = order
	s.cancelChecker.Init(ctx)
}

func (s *sortDatumDescOp) reset() {
	s.sortCol = nil
	s.nulls = nil
	s.order = nil
	s.allocator = nil
}

func (s *sortDatumDescOp) sort() {
	n := s.sortCol.Len()
	s.quickSort(0, n, maxDepth(n))
}

func (s *sortDatumDescOp) sortPartitions(partitions []int) {
	if len(partitions) < 1 {
		colexecerror.InternalError(errors.AssertionFailedf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd int
		if i == len(partitions)-1 {
			partitionEnd = len(order)
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := partitionEnd - partitionStart
		s.quickSort(0, n, maxDepth(n))
	}
}

func (s *sortDatumDescOp) Less(i, j int) bool {

	order1 := s.order[i]
	order2 := s.order[j]

	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(order1)
	arg2 := s.sortCol.Get(order2)

	{
		var cmpResult int

		cmpResult = coldataext.CompareDatum(arg1, s.sortCol, arg2)

		lt = cmpResult > 0
	}

	return lt
}

func (s *sortDatumDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDatumDescOp) Len() int {
	return len(s.order)
}
