// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"time"
	"unsafe"

	"github.com/cockroachdb/apd/v2"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

func newAnyNotNullHashAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) (aggregateFuncAlloc, error) {
	allocBase := aggAllocBase{allocator: allocator, allocSize: allocSize}
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBoolHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBytesHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDecimalHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &anyNotNullInt16HashAggAlloc{aggAllocBase: allocBase}, nil
		case 32:
			return &anyNotNullInt32HashAggAlloc{aggAllocBase: allocBase}, nil
		case -1:
		default:
			return &anyNotNullInt64HashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullFloat64HashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullTimestampHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullIntervalHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDatumHashAggAlloc{aggAllocBase: allocBase}, nil
		}
	}
	return nil, errors.Errorf("unsupported any not null agg type %s", t.Name())
}

// anyNotNullBoolHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBoolHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Bools
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      bool
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBoolHashAgg{}

const sizeOfAnyNotNullBoolHashAgg = int64(unsafe.Sizeof(anyNotNullBoolHashAgg{}))

func (a *anyNotNullBoolHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Bool()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBoolHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBoolHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBoolHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullBoolHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBoolHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullBoolHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBoolHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullBoolHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullBoolHashAggAlloc{}

func (a *anyNotNullBoolHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBoolHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBoolHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullBytesHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBytesHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         *coldata.Bytes
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      []byte
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBytesHashAgg{}

const sizeOfAnyNotNullBytesHashAgg = int64(unsafe.Sizeof(anyNotNullBytesHashAgg{}))

func (a *anyNotNullBytesHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Bytes()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBytesHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBytesHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBytesHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullBytesHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBytesHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullBytesHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBytesHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullBytesHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullBytesHashAggAlloc{}

func (a *anyNotNullBytesHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBytesHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBytesHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDecimalHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDecimalHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Decimals
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      apd.Decimal
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDecimalHashAgg{}

const sizeOfAnyNotNullDecimalHashAgg = int64(unsafe.Sizeof(anyNotNullDecimalHashAgg{}))

func (a *anyNotNullDecimalHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Decimal()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDecimalHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDecimalHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDecimalHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullDecimalHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDecimalHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDecimalHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDecimalHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullDecimalHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullDecimalHashAggAlloc{}

func (a *anyNotNullDecimalHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDecimalHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDecimalHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt16HashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt16HashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Int16s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int16
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt16HashAgg{}

const sizeOfAnyNotNullInt16HashAgg = int64(unsafe.Sizeof(anyNotNullInt16HashAgg{}))

func (a *anyNotNullInt16HashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Int16()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt16HashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt16HashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt16HashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt16HashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt16HashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt16HashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt16HashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt16HashAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt16HashAggAlloc{}

func (a *anyNotNullInt16HashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt16HashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt16HashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt32HashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt32HashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Int32s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int32
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt32HashAgg{}

const sizeOfAnyNotNullInt32HashAgg = int64(unsafe.Sizeof(anyNotNullInt32HashAgg{}))

func (a *anyNotNullInt32HashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Int32()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt32HashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt32HashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt32HashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt32HashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt32HashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt32HashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt32HashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt32HashAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt32HashAggAlloc{}

func (a *anyNotNullInt32HashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt32HashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt32HashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt64HashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt64HashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Int64s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt64HashAgg{}

const sizeOfAnyNotNullInt64HashAgg = int64(unsafe.Sizeof(anyNotNullInt64HashAgg{}))

func (a *anyNotNullInt64HashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Int64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt64HashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt64HashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt64HashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullInt64HashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt64HashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt64HashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt64HashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullInt64HashAgg
}

var _ aggregateFuncAlloc = &anyNotNullInt64HashAggAlloc{}

func (a *anyNotNullInt64HashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt64HashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt64HashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullFloat64HashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullFloat64HashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Float64s
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      float64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullFloat64HashAgg{}

const sizeOfAnyNotNullFloat64HashAgg = int64(unsafe.Sizeof(anyNotNullFloat64HashAgg{}))

func (a *anyNotNullFloat64HashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Float64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullFloat64HashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullFloat64HashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullFloat64HashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullFloat64HashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullFloat64HashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullFloat64HashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullFloat64HashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullFloat64HashAgg
}

var _ aggregateFuncAlloc = &anyNotNullFloat64HashAggAlloc{}

func (a *anyNotNullFloat64HashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullFloat64HashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullFloat64HashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullTimestampHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullTimestampHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Times
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      time.Time
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullTimestampHashAgg{}

const sizeOfAnyNotNullTimestampHashAgg = int64(unsafe.Sizeof(anyNotNullTimestampHashAgg{}))

func (a *anyNotNullTimestampHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Timestamp()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullTimestampHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullTimestampHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullTimestampHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullTimestampHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullTimestampHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullTimestampHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullTimestampHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullTimestampHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullTimestampHashAggAlloc{}

func (a *anyNotNullTimestampHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullTimestampHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullTimestampHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullIntervalHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullIntervalHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.Durations
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      duration.Duration
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullIntervalHashAgg{}

const sizeOfAnyNotNullIntervalHashAgg = int64(unsafe.Sizeof(anyNotNullIntervalHashAgg{}))

func (a *anyNotNullIntervalHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Interval()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullIntervalHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullIntervalHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullIntervalHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullIntervalHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1) //gcassert:inline
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i) //gcassert:inline
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullIntervalHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullIntervalHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullIntervalHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullIntervalHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullIntervalHashAggAlloc{}

func (a *anyNotNullIntervalHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullIntervalHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullIntervalHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDatumHashAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDatumHashAgg struct {
	allocator                   *colmem.Allocator
	vec                         coldata.Vec
	col                         coldata.DatumVec
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      interface{}
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDatumHashAgg{}

const sizeOfAnyNotNullDatumHashAgg = int64(unsafe.Sizeof(anyNotNullDatumHashAgg{}))

func (a *anyNotNullDatumHashAgg) Init(groups []bool, vec coldata.Vec) {
	a.vec = vec
	a.col = vec.Datum()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDatumHashAgg) Reset() {
	a.curIdx = 0
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDatumHashAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDatumHashAgg) SetOutputIndex(idx int) {
	a.curIdx = idx
}

func (a *anyNotNullDatumHashAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.foundNonNullForCurrentGroup {
		// We have already seen non-null for the current group, and since there
		// is at most a single group when performing hash aggregation, we can
		// finish computing.
		return
	}

	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			// Capture col to force bounds check to work. See
			// https://github.com/golang/go/issues/39756
			col := col
			_ = col.Get(inputLen - 1)
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				} else {
					for i := 0; i < inputLen; i++ {

						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be
							// the output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
							// We have already seen non-null for the current group, and since there
							// is at most a single group when performing hash aggregation, we can
							// finish computing.
							return
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDatumHashAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDatumHashAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDatumHashAggAlloc struct {
	aggAllocBase
	aggFuncs []anyNotNullDatumHashAgg
}

var _ aggregateFuncAlloc = &anyNotNullDatumHashAggAlloc{}

func (a *anyNotNullDatumHashAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDatumHashAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDatumHashAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
