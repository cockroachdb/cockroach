// Copyright 2017 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package sql

import "fmt"

// planPhysicalProps describes known ordering information for the rows generated by
// this node. The ordering information includes columns the output is ordered
// by and columns for which we know all rows have the same value. See
// physicalProps for more details.
func planPhysicalProps(plan planNode) physicalProps {
	switch n := plan.(type) {
	case *explainPlanNode:
		return planPhysicalProps(n.run.results)
	case *limitNode:
		return planPhysicalProps(n.plan)
	case *max1RowNode:
		return planPhysicalProps(n.plan)
	case *spoolNode:
		return planPhysicalProps(n.source)
	case *saveTableNode:
		return planPhysicalProps(n.source)
	case *indexJoinNode:
		return n.props
	case *serializeNode:
		return planPhysicalProps(n.source)
	case *deleteNode:
		if n.run.rowsNeeded {
			return planPhysicalProps(n.source)
		}
	case *projectSetNode:
		return n.props

	case *filterNode:
		return n.props

	case *groupNode:
		return n.props

	case *distinctNode:
		return n.props

	case *windowNode:
		// TODO: window partitions can be ordered if the source is ordered
		// appropriately.
	case *joinNode:
		return n.props
	case *unionNode:
		// TODO(knz): this can be ordered if the source is ordered already.
	case *insertNode:
		// TODO(knz): RETURNING is ordered by the PK.
	case *updateNode, *upsertNode:
		// After an update, the original order may have been destroyed.
		// For example, if the PK is updated by a SET expression.
		// So we can't assume any ordering.
		//
		// TODO(knz/radu): this can be refined by an analysis which
		// determines whether the columns that participate in the ordering
		// of the source are being updated. If they are not, the source
		// ordering can be propagated.

	case *scanNode:
		return n.props
	case *ordinalityNode:
		return n.props
	case *renderNode:
		return n.props
	case *sortNode:
		return sortPhysicalProps(n)
	case *lookupJoinNode:
		return n.props
	case *zigzagJoinNode:
		return n.props

	// Every other node simply has no guarantees on its output rows.
	case *applyJoinNode:
	case *bufferNode:
	case *scanBufferNode:
	case *recursiveCTENode:
	case *CreateUserNode:
	case *DropUserNode:
	case *alterIndexNode:
	case *alterSequenceNode:
	case *alterTableNode:
	case *alterUserSetPasswordNode:
	case *cancelQueriesNode:
	case *cancelSessionsNode:
	case *changePrivilegesNode:
	case *commentOnColumnNode:
	case *commentOnDatabaseNode:
	case *commentOnIndexNode:
	case *commentOnTableNode:
	case *controlJobsNode:
	case *createDatabaseNode:
	case *createIndexNode:
	case *createSequenceNode:
	case *createStatsNode:
	case *createTableNode:
	case *createViewNode:
	case *delayedNode:
	case *deleteRangeNode:
	case *dropDatabaseNode:
	case *dropIndexNode:
	case *dropSequenceNode:
	case *dropTableNode:
	case *dropViewNode:
	case *errorIfRowsNode:
	case *exportNode:
	case *explainDistSQLNode:
	case *explainVecNode:
	case *hookFnNode:
	case *relocateNode:
	case *renameColumnNode:
	case *renameDatabaseNode:
	case *renameIndexNode:
	case *renameTableNode:
	case *rowCountNode:
	case *rowSourceToPlanNode:
	case *scatterNode:
	case *scrubNode:
	case *sequenceSelectNode:
	case *setClusterSettingNode:
	case *setVarNode:
	case *setZoneConfigNode:
	case *showFingerprintsNode:
	case *showTraceNode:
	case *showTraceReplicaNode:
	case *splitNode:
	case *unsplitNode:
	case *unsplitAllNode:
	case *truncateNode:
	case *unaryNode:
	case *valuesNode:
	case *virtualTableNode:
	case *zeroNode:
	default:
		panic(fmt.Sprintf("unhandled node type: %T", plan))
	}

	return physicalProps{}
}

func sortPhysicalProps(n *sortNode) physicalProps {
	return physicalProps{
		ordering: n.ordering,
	}
}
