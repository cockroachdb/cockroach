# Copyright 2017 The Cockroach Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

REPO_ROOT := ../../..
include $(REPO_ROOT)/build/common.mk

SQLPARSER_TARGETS = \
	sql.go \
	helpmap_test.go \
	help_messages.go \
	../lex/tokens.go \
	../lex/keywords.go \
	../lex/reserved_keywords.go

.DEFAULT_GOAL := all
.PHONY: all
all: $(SQLPARSER_TARGETS)

# Running `make generate` from the root will call this target via `go generate`.
# Update this if you add new generated files.
.PHONY: generate
generate: $(SQLPARSER_TARGETS)

.PHONY: maintainer-clean
maintainer-clean:
	rm -f $(SQLPARSER_TARGETS)
	rm -rf gen

.INTERMEDIATE: gen/sql.go
gen/sql.go: gen/sql.y $(BOOTSTRAP_TARGET)
	set -euo pipefail; \
	  ret=$$(cd gen && goyacc -p sql -o sql.go sql.y); \
	  if expr "$$ret" : ".*conflicts" >/dev/null; then \
	    echo "$$ret"; exit 1; \
	  fi

# The lex package needs to know about all tokens, because the encode
# functions and lexing predicates need to know about keywords, and
# keywords map to the token constants. Therefore, generate the
# constant tokens in the lex package primarily.
../lex/tokens.go: gen/sql.go
	(echo "// Code generated by make. DO NOT EDIT."; \
	 echo "// GENERATED FILE DO NOT EDIT"; \
	 echo; \
	 echo "package lex"; \
	 echo; \
	 grep '^const [A-Z][_A-Z0-9]* ' $^) > $@


# The lex package is now the primary source for the token constant
# definitions. Modify the code generated by goyacc here to refer to
# the definitions in the lex package.
sql.go: gen/sql.go
	(echo "// Code generated by goyacc. DO NOT EDIT."; \
	 echo "// GENERATED FILE DO NOT EDIT"; \
	 cat $^ | \
	 sed -E 's/^const ([A-Z][_A-Z0-9]*) =.*$$/const \1 = lex.\1/g') > $@

# This modifies the grammar to:
# - improve the types used by the generated parser for non-terminals
# - expand the help rules.
#
# For types:
# Determine the types that will be migrated to union types by looking
# at the accessors of sqlSymUnion. The first step in this pipeline
# prints every return type of a sqlSymUnion accessor on a separate line.
# The next step regular expression escapes these types. The third step
# joins all of the lines into a single line with a '|' character to be
# used as a regexp "or" meta-character. Finally, the last '|' character
# is stripped from the string.
# Then translate the original syntax file, with the types determined
# above being replaced with the union type in their type declarations.
.INTERMEDIATE: gen/sql.y
gen/sql.y: sql.y replace_help_rules.awk
	mkdir -p gen
	set -euo pipefail; \
	TYPES=$$(awk '/func.*sqlSymUnion/ {print $$(NF - 1)}' sql.y | \
	        sed -e 's/[]\/$$*.^|[]/\\&/g' | \
	        tr '\n' '|' | \
	        sed -E '$$s/.$$//'); \
	sed -E "s_(type|token) <($$TYPES)>_\1 <union> /* <\2> */_" < sql.y | \
	awk -f replace_help_rules.awk > $@

../lex/reserved_keywords.go: sql.y reserved_keywords.awk
	awk -f reserved_keywords.awk < $< > $@.tmp || rm $@.tmp
	mv -f $@.tmp $@
	gofmt -s -w $@

../lex/keywords.go: sql.y all_keywords.awk
	awk -f all_keywords.awk < $< > $@.tmp || rm $@.tmp
	mv -f $@.tmp $@
	gofmt -s -w $@

# This target will print unreserved_keywords which are not actually
# used in the grammar.
unused_unreserved_keywords: sql.y unreserved_keywords.awk
	@for kw in $$(awk -f unreserved_keywords.awk < $<); do \
	  if [ $$(grep -c $${kw} $<) -le 2 ]; then \
	    echo $${kw}; \
	  fi \
	done

helpmap_test.go: gen/sql.y help_gen_test.sh
	@./help_gen_test.sh < $< >$@.tmp || rm $@.tmp
	mv -f $@.tmp $@
	gofmt -s -w $@

help_messages.go: sql.y help.awk
	awk -f help.awk < $< > $@.tmp || rm $@.tmp
	mv -f $@.tmp $@
	gofmt -s -w $@
