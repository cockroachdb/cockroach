// Code generated by irgen/irgen base/base.tmpl.go tests/prims.def. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package base

import "math"

// node is a generic ADT node type, with slots for references to other nodes and
// enumeration values. Values that don't fit and values of other types go in the
// extra field.
type node struct {
	refs [20]*node
	nums [20]numvalslot
	strs [20]string
	extra
}

// enum is the type to define the tag part for working copies of IR
// node with sum and enum types.
type enum uint32

// numvalslot is the type used to store integer values in persistent IR nodes.
// must be larger than or as large as enum.
type numvalslot uint64

type extra interface {
	extraRefs() []*node
}

// Allocator allocates nodes in batches. Construct Allocators with NewAllocator
// and pass them by value.
type Allocator struct {
	nodes []node
}

// MakeAllocator constructs a new Allocator.
func MakeAllocator() Allocator {
	nodes := make([]node, 16)
	return Allocator{nodes}
}

// NewAllocator allocates a new Allocator.
func NewAllocator() *Allocator {
	a := MakeAllocator()
	return &a
}

// new allocates a new node. Users of this package should use the appropriate
// R() method, which is type safe.
func (a *Allocator) new() *node {
	nodes := a.nodes
	if len(nodes) == 0 {
		nodes = make([]node, 256)
	}
	x := &nodes[0]
	a.nodes = nodes[1:]
	return x
}

// ---- All ---- //

// All is the type of a reference to an immutable record.
type All struct{ ref *node }

const All_Slot_B_Type = 1
const All_Slot_B_Num = 5
const All_Slot_B_BitSize = 1
const All_Slot_B_BitOffset = 16
const All_Slot_B_ByteSize = 1
const All_Slot_B_ByteOffset = 2
const All_Slot_B_ValueMask = 0x1

const All_Slot_F32_Type = 1
const All_Slot_F32_Num = 4
const All_Slot_F32_BitSize = 32
const All_Slot_F32_BitOffset = 0
const All_Slot_F32_ByteSize = 4
const All_Slot_F32_ByteOffset = 0
const All_Slot_F32_ValueMask = 0xffffffff

const All_Slot_F64_Type = 1
const All_Slot_F64_Num = 2
const All_Slot_F64_BitSize = 64
const All_Slot_F64_BitOffset = 0
const All_Slot_F64_ByteSize = 8
const All_Slot_F64_ByteOffset = 0
const All_Slot_F64_ValueMask = 0xffffffffffffffff

const All_Slot_I16_Type = 1
const All_Slot_I16_Num = 4
const All_Slot_I16_BitSize = 16
const All_Slot_I16_BitOffset = 32
const All_Slot_I16_ByteSize = 2
const All_Slot_I16_ByteOffset = 4
const All_Slot_I16_ValueMask = 0xffff

const All_Slot_I32_Type = 1
const All_Slot_I32_Num = 3
const All_Slot_I32_BitSize = 32
const All_Slot_I32_BitOffset = 0
const All_Slot_I32_ByteSize = 4
const All_Slot_I32_ByteOffset = 0
const All_Slot_I32_ValueMask = 0xffffffff

const All_Slot_I64_Type = 1
const All_Slot_I64_Num = 0
const All_Slot_I64_BitSize = 64
const All_Slot_I64_BitOffset = 0
const All_Slot_I64_ByteSize = 8
const All_Slot_I64_ByteOffset = 0
const All_Slot_I64_ValueMask = 0xffffffffffffffff

const All_Slot_I8_Type = 1
const All_Slot_I8_Num = 5
const All_Slot_I8_BitSize = 8
const All_Slot_I8_BitOffset = 0
const All_Slot_I8_ByteSize = 1
const All_Slot_I8_ByteOffset = 0
const All_Slot_I8_ValueMask = 0xff

const All_Slot_S_Type = 2
const All_Slot_S_Num = 0
const All_Slot_S_BitSize = -1
const All_Slot_S_BitOffset = -1
const All_Slot_S_ByteSize = -1
const All_Slot_S_ByteOffset = -1
const All_Slot_S_ValueMask = -1

const All_Slot_U16_Type = 1
const All_Slot_U16_Num = 4
const All_Slot_U16_BitSize = 16
const All_Slot_U16_BitOffset = 48
const All_Slot_U16_ByteSize = 2
const All_Slot_U16_ByteOffset = 6
const All_Slot_U16_ValueMask = 0xffff

const All_Slot_U32_Type = 1
const All_Slot_U32_Num = 3
const All_Slot_U32_BitSize = 32
const All_Slot_U32_BitOffset = 32
const All_Slot_U32_ByteSize = 4
const All_Slot_U32_ByteOffset = 4
const All_Slot_U32_ValueMask = 0xffffffff

const All_Slot_U64_Type = 1
const All_Slot_U64_Num = 1
const All_Slot_U64_BitSize = 64
const All_Slot_U64_BitOffset = 0
const All_Slot_U64_ByteSize = 8
const All_Slot_U64_ByteOffset = 0
const All_Slot_U64_ValueMask = 0xffffffffffffffff

const All_Slot_U8_Type = 1
const All_Slot_U8_Num = 5
const All_Slot_U8_BitSize = 8
const All_Slot_U8_BitOffset = 8
const All_Slot_U8_ByteSize = 1
const All_Slot_U8_ByteOffset = 1
const All_Slot_U8_ValueMask = 0xff

// AllValue is the logical type of a record. Immutable records are stored in
// nodes.
type AllValue struct {
	B   bool    // 1
	I8  int8    // 2
	U8  uint8   // 3
	I16 int16   // 4
	U16 uint16  // 5
	I32 int32   // 6
	U32 uint32  // 7
	I64 int64   // 8
	U64 uint64  // 9
	S   string  // 10
	F32 float32 // 11
	F64 float64 // 12
}

// R constructs a reference to an immutable record.
func (x AllValue) R(a *Allocator) All {
	ref := a.new()

	if x.B {
		ref.nums[5] |= (numvalslot(1) << All_Slot_B_BitOffset)
	} else {
		ref.nums[5] &^= (numvalslot(1) << All_Slot_B_BitOffset)
	}
	ref.nums[5] = (ref.nums[5] &^ (All_Slot_I8_ValueMask << All_Slot_I8_BitOffset)) | (numvalslot(x.I8) << All_Slot_I8_BitOffset)
	ref.nums[5] = (ref.nums[5] &^ (All_Slot_U8_ValueMask << All_Slot_U8_BitOffset)) | (numvalslot(x.U8) << All_Slot_U8_BitOffset)
	ref.nums[4] = (ref.nums[4] &^ (All_Slot_I16_ValueMask << All_Slot_I16_BitOffset)) | (numvalslot(x.I16) << All_Slot_I16_BitOffset)
	ref.nums[4] = (ref.nums[4] &^ (All_Slot_U16_ValueMask << All_Slot_U16_BitOffset)) | (numvalslot(x.U16) << All_Slot_U16_BitOffset)
	ref.nums[3] = (ref.nums[3] &^ (All_Slot_I32_ValueMask << All_Slot_I32_BitOffset)) | (numvalslot(x.I32) << All_Slot_I32_BitOffset)
	ref.nums[3] = (ref.nums[3] &^ (All_Slot_U32_ValueMask << All_Slot_U32_BitOffset)) | (numvalslot(x.U32) << All_Slot_U32_BitOffset)
	ref.nums[0] = numvalslot(x.I64)
	ref.nums[1] = numvalslot(x.U64)
	ref.strs[0] = x.S
	ref.nums[4] = (ref.nums[4] &^ (All_Slot_F32_ValueMask << All_Slot_F32_BitOffset)) | (numvalslot(math.Float32bits(x.F32)) << All_Slot_F32_BitOffset)
	ref.nums[2] = numvalslot(math.Float64bits(x.F64))
	return All{ref}
}

// B returns the B field.
func (x All) B() bool { return !(0 == (x.ref.nums[5] >> All_Slot_B_BitOffset & All_Slot_B_ValueMask)) }

// I8 returns the I8 field.
func (x All) I8() int8 { return int8((x.ref.nums[5] >> All_Slot_I8_BitOffset) & All_Slot_I8_ValueMask) }

// U8 returns the U8 field.
func (x All) U8() uint8 {
	return uint8((x.ref.nums[5] >> All_Slot_U8_BitOffset) & All_Slot_U8_ValueMask)
}

// I16 returns the I16 field.
func (x All) I16() int16 {
	return int16((x.ref.nums[4] >> All_Slot_I16_BitOffset) & All_Slot_I16_ValueMask)
}

// U16 returns the U16 field.
func (x All) U16() uint16 {
	return uint16((x.ref.nums[4] >> All_Slot_U16_BitOffset) & All_Slot_U16_ValueMask)
}

// I32 returns the I32 field.
func (x All) I32() int32 {
	return int32((x.ref.nums[3] >> All_Slot_I32_BitOffset) & All_Slot_I32_ValueMask)
}

// U32 returns the U32 field.
func (x All) U32() uint32 {
	return uint32((x.ref.nums[3] >> All_Slot_U32_BitOffset) & All_Slot_U32_ValueMask)
}

// I64 returns the I64 field.
func (x All) I64() int64 { return int64(x.ref.nums[0]) }

// U64 returns the U64 field.
func (x All) U64() uint64 { return uint64(x.ref.nums[1]) }

// S returns the S field.
func (x All) S() string { return x.ref.strs[0] }

// F32 returns the F32 field.
func (x All) F32() float32 {
	return math.Float32frombits(uint32((x.ref.nums[4] >> All_Slot_F32_BitOffset) & All_Slot_F32_ValueMask))
}

// F64 returns the F64 field.
func (x All) F64() float64 { return math.Float64frombits(uint64(x.ref.nums[2])) }

// V unpacks a reference into a value.
func (x All) V() AllValue {
	return AllValue{
		B:   !(0 == (x.ref.nums[5] >> All_Slot_B_BitOffset & All_Slot_B_ValueMask)),
		I8:  int8((x.ref.nums[5] >> All_Slot_I8_BitOffset) & All_Slot_I8_ValueMask),
		U8:  uint8((x.ref.nums[5] >> All_Slot_U8_BitOffset) & All_Slot_U8_ValueMask),
		I16: int16((x.ref.nums[4] >> All_Slot_I16_BitOffset) & All_Slot_I16_ValueMask),
		U16: uint16((x.ref.nums[4] >> All_Slot_U16_BitOffset) & All_Slot_U16_ValueMask),
		I32: int32((x.ref.nums[3] >> All_Slot_I32_BitOffset) & All_Slot_I32_ValueMask),
		U32: uint32((x.ref.nums[3] >> All_Slot_U32_BitOffset) & All_Slot_U32_ValueMask),
		I64: int64(x.ref.nums[0]),
		U64: uint64(x.ref.nums[1]),
		S:   x.ref.strs[0],
		F32: math.Float32frombits(uint32((x.ref.nums[4] >> All_Slot_F32_BitOffset) & All_Slot_F32_ValueMask)),
		F64: math.Float64frombits(uint64(x.ref.nums[2])),
	}
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x AllValue) WithB(y bool) AllValue {
	x.B = y
	return x
}

// WithI8 constructs a new value where the value of I8 has been replaced by
// the argument.
func (x AllValue) WithI8(y int8) AllValue {
	x.I8 = y
	return x
}

// WithU8 constructs a new value where the value of U8 has been replaced by
// the argument.
func (x AllValue) WithU8(y uint8) AllValue {
	x.U8 = y
	return x
}

// WithI16 constructs a new value where the value of I16 has been replaced by
// the argument.
func (x AllValue) WithI16(y int16) AllValue {
	x.I16 = y
	return x
}

// WithU16 constructs a new value where the value of U16 has been replaced by
// the argument.
func (x AllValue) WithU16(y uint16) AllValue {
	x.U16 = y
	return x
}

// WithI32 constructs a new value where the value of I32 has been replaced by
// the argument.
func (x AllValue) WithI32(y int32) AllValue {
	x.I32 = y
	return x
}

// WithU32 constructs a new value where the value of U32 has been replaced by
// the argument.
func (x AllValue) WithU32(y uint32) AllValue {
	x.U32 = y
	return x
}

// WithI64 constructs a new value where the value of I64 has been replaced by
// the argument.
func (x AllValue) WithI64(y int64) AllValue {
	x.I64 = y
	return x
}

// WithU64 constructs a new value where the value of U64 has been replaced by
// the argument.
func (x AllValue) WithU64(y uint64) AllValue {
	x.U64 = y
	return x
}

// WithS constructs a new value where the value of S has been replaced by
// the argument.
func (x AllValue) WithS(y string) AllValue {
	x.S = y
	return x
}

// WithF32 constructs a new value where the value of F32 has been replaced by
// the argument.
func (x AllValue) WithF32(y float32) AllValue {
	x.F32 = y
	return x
}

// WithF64 constructs a new value where the value of F64 has been replaced by
// the argument.
func (x AllValue) WithF64(y float64) AllValue {
	x.F64 = y
	return x
}

// ---- SmallBefore ---- //

// SmallBefore is the type of a reference to an immutable record.
type SmallBefore struct{ ref *node }

const SmallBefore_Slot_A_Type = 1
const SmallBefore_Slot_A_Num = 2
const SmallBefore_Slot_A_BitSize = 1
const SmallBefore_Slot_A_BitOffset = 24
const SmallBefore_Slot_A_ByteSize = 1
const SmallBefore_Slot_A_ByteOffset = 3
const SmallBefore_Slot_A_ValueMask = 0x1

const SmallBefore_Slot_B_Type = 1
const SmallBefore_Slot_B_Num = 2
const SmallBefore_Slot_B_BitSize = 1
const SmallBefore_Slot_B_BitOffset = 25
const SmallBefore_Slot_B_ByteSize = 1
const SmallBefore_Slot_B_ByteOffset = 3
const SmallBefore_Slot_B_ValueMask = 0x1

const SmallBefore_Slot_C_Type = 1
const SmallBefore_Slot_C_Num = 2
const SmallBefore_Slot_C_BitSize = 8
const SmallBefore_Slot_C_BitOffset = 0
const SmallBefore_Slot_C_ByteSize = 1
const SmallBefore_Slot_C_ByteOffset = 0
const SmallBefore_Slot_C_ValueMask = 0xff

const SmallBefore_Slot_D_Type = 1
const SmallBefore_Slot_D_Num = 2
const SmallBefore_Slot_D_BitSize = 8
const SmallBefore_Slot_D_BitOffset = 8
const SmallBefore_Slot_D_ByteSize = 1
const SmallBefore_Slot_D_ByteOffset = 1
const SmallBefore_Slot_D_ValueMask = 0xff

const SmallBefore_Slot_E_Type = 1
const SmallBefore_Slot_E_Num = 2
const SmallBefore_Slot_E_BitSize = 8
const SmallBefore_Slot_E_BitOffset = 16
const SmallBefore_Slot_E_ByteSize = 1
const SmallBefore_Slot_E_ByteOffset = 2
const SmallBefore_Slot_E_ValueMask = 0xff

const SmallBefore_Slot_F_Type = 1
const SmallBefore_Slot_F_Num = 1
const SmallBefore_Slot_F_BitSize = 16
const SmallBefore_Slot_F_BitOffset = 32
const SmallBefore_Slot_F_ByteSize = 2
const SmallBefore_Slot_F_ByteOffset = 4
const SmallBefore_Slot_F_ValueMask = 0xffff

const SmallBefore_Slot_G_Type = 1
const SmallBefore_Slot_G_Num = 1
const SmallBefore_Slot_G_BitSize = 16
const SmallBefore_Slot_G_BitOffset = 48
const SmallBefore_Slot_G_ByteSize = 2
const SmallBefore_Slot_G_ByteOffset = 6
const SmallBefore_Slot_G_ValueMask = 0xffff

const SmallBefore_Slot_H_Type = 1
const SmallBefore_Slot_H_Num = 1
const SmallBefore_Slot_H_BitSize = 32
const SmallBefore_Slot_H_BitOffset = 0
const SmallBefore_Slot_H_ByteSize = 4
const SmallBefore_Slot_H_ByteOffset = 0
const SmallBefore_Slot_H_ValueMask = 0xffffffff

const SmallBefore_Slot_I_Type = 1
const SmallBefore_Slot_I_Num = 0
const SmallBefore_Slot_I_BitSize = 64
const SmallBefore_Slot_I_BitOffset = 0
const SmallBefore_Slot_I_ByteSize = 8
const SmallBefore_Slot_I_ByteOffset = 0
const SmallBefore_Slot_I_ValueMask = 0xffffffffffffffff

// SmallBeforeValue is the logical type of a record. Immutable records are stored in
// nodes.
type SmallBeforeValue struct {
	A bool   // 1
	B bool   // 2
	C uint8  // 3
	D uint8  // 4
	E uint8  // 5
	F uint16 // 6
	G uint16 // 7
	H uint32 // 8
	I uint64 // 9
}

// R constructs a reference to an immutable record.
func (x SmallBeforeValue) R(a *Allocator) SmallBefore {
	ref := a.new()

	if x.A {
		ref.nums[2] |= (numvalslot(1) << SmallBefore_Slot_A_BitOffset)
	} else {
		ref.nums[2] &^= (numvalslot(1) << SmallBefore_Slot_A_BitOffset)
	}
	if x.B {
		ref.nums[2] |= (numvalslot(1) << SmallBefore_Slot_B_BitOffset)
	} else {
		ref.nums[2] &^= (numvalslot(1) << SmallBefore_Slot_B_BitOffset)
	}
	ref.nums[2] = (ref.nums[2] &^ (SmallBefore_Slot_C_ValueMask << SmallBefore_Slot_C_BitOffset)) | (numvalslot(x.C) << SmallBefore_Slot_C_BitOffset)
	ref.nums[2] = (ref.nums[2] &^ (SmallBefore_Slot_D_ValueMask << SmallBefore_Slot_D_BitOffset)) | (numvalslot(x.D) << SmallBefore_Slot_D_BitOffset)
	ref.nums[2] = (ref.nums[2] &^ (SmallBefore_Slot_E_ValueMask << SmallBefore_Slot_E_BitOffset)) | (numvalslot(x.E) << SmallBefore_Slot_E_BitOffset)
	ref.nums[1] = (ref.nums[1] &^ (SmallBefore_Slot_F_ValueMask << SmallBefore_Slot_F_BitOffset)) | (numvalslot(x.F) << SmallBefore_Slot_F_BitOffset)
	ref.nums[1] = (ref.nums[1] &^ (SmallBefore_Slot_G_ValueMask << SmallBefore_Slot_G_BitOffset)) | (numvalslot(x.G) << SmallBefore_Slot_G_BitOffset)
	ref.nums[1] = (ref.nums[1] &^ (SmallBefore_Slot_H_ValueMask << SmallBefore_Slot_H_BitOffset)) | (numvalslot(x.H) << SmallBefore_Slot_H_BitOffset)
	ref.nums[0] = numvalslot(x.I)
	return SmallBefore{ref}
}

// A returns the A field.
func (x SmallBefore) A() bool {
	return !(0 == (x.ref.nums[2] >> SmallBefore_Slot_A_BitOffset & SmallBefore_Slot_A_ValueMask))
}

// B returns the B field.
func (x SmallBefore) B() bool {
	return !(0 == (x.ref.nums[2] >> SmallBefore_Slot_B_BitOffset & SmallBefore_Slot_B_ValueMask))
}

// C returns the C field.
func (x SmallBefore) C() uint8 {
	return uint8((x.ref.nums[2] >> SmallBefore_Slot_C_BitOffset) & SmallBefore_Slot_C_ValueMask)
}

// D returns the D field.
func (x SmallBefore) D() uint8 {
	return uint8((x.ref.nums[2] >> SmallBefore_Slot_D_BitOffset) & SmallBefore_Slot_D_ValueMask)
}

// E returns the E field.
func (x SmallBefore) E() uint8 {
	return uint8((x.ref.nums[2] >> SmallBefore_Slot_E_BitOffset) & SmallBefore_Slot_E_ValueMask)
}

// F returns the F field.
func (x SmallBefore) F() uint16 {
	return uint16((x.ref.nums[1] >> SmallBefore_Slot_F_BitOffset) & SmallBefore_Slot_F_ValueMask)
}

// G returns the G field.
func (x SmallBefore) G() uint16 {
	return uint16((x.ref.nums[1] >> SmallBefore_Slot_G_BitOffset) & SmallBefore_Slot_G_ValueMask)
}

// H returns the H field.
func (x SmallBefore) H() uint32 {
	return uint32((x.ref.nums[1] >> SmallBefore_Slot_H_BitOffset) & SmallBefore_Slot_H_ValueMask)
}

// I returns the I field.
func (x SmallBefore) I() uint64 { return uint64(x.ref.nums[0]) }

// V unpacks a reference into a value.
func (x SmallBefore) V() SmallBeforeValue {
	return SmallBeforeValue{
		A: !(0 == (x.ref.nums[2] >> SmallBefore_Slot_A_BitOffset & SmallBefore_Slot_A_ValueMask)),
		B: !(0 == (x.ref.nums[2] >> SmallBefore_Slot_B_BitOffset & SmallBefore_Slot_B_ValueMask)),
		C: uint8((x.ref.nums[2] >> SmallBefore_Slot_C_BitOffset) & SmallBefore_Slot_C_ValueMask),
		D: uint8((x.ref.nums[2] >> SmallBefore_Slot_D_BitOffset) & SmallBefore_Slot_D_ValueMask),
		E: uint8((x.ref.nums[2] >> SmallBefore_Slot_E_BitOffset) & SmallBefore_Slot_E_ValueMask),
		F: uint16((x.ref.nums[1] >> SmallBefore_Slot_F_BitOffset) & SmallBefore_Slot_F_ValueMask),
		G: uint16((x.ref.nums[1] >> SmallBefore_Slot_G_BitOffset) & SmallBefore_Slot_G_ValueMask),
		H: uint32((x.ref.nums[1] >> SmallBefore_Slot_H_BitOffset) & SmallBefore_Slot_H_ValueMask),
		I: uint64(x.ref.nums[0]),
	}
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x SmallBeforeValue) WithA(y bool) SmallBeforeValue {
	x.A = y
	return x
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x SmallBeforeValue) WithB(y bool) SmallBeforeValue {
	x.B = y
	return x
}

// WithC constructs a new value where the value of C has been replaced by
// the argument.
func (x SmallBeforeValue) WithC(y uint8) SmallBeforeValue {
	x.C = y
	return x
}

// WithD constructs a new value where the value of D has been replaced by
// the argument.
func (x SmallBeforeValue) WithD(y uint8) SmallBeforeValue {
	x.D = y
	return x
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x SmallBeforeValue) WithE(y uint8) SmallBeforeValue {
	x.E = y
	return x
}

// WithF constructs a new value where the value of F has been replaced by
// the argument.
func (x SmallBeforeValue) WithF(y uint16) SmallBeforeValue {
	x.F = y
	return x
}

// WithG constructs a new value where the value of G has been replaced by
// the argument.
func (x SmallBeforeValue) WithG(y uint16) SmallBeforeValue {
	x.G = y
	return x
}

// WithH constructs a new value where the value of H has been replaced by
// the argument.
func (x SmallBeforeValue) WithH(y uint32) SmallBeforeValue {
	x.H = y
	return x
}

// WithI constructs a new value where the value of I has been replaced by
// the argument.
func (x SmallBeforeValue) WithI(y uint64) SmallBeforeValue {
	x.I = y
	return x
}

// ---- BigBefore ---- //

// BigBefore is the type of a reference to an immutable record.
type BigBefore struct{ ref *node }

const BigBefore_Slot_A_Type = 1
const BigBefore_Slot_A_Num = 0
const BigBefore_Slot_A_BitSize = 64
const BigBefore_Slot_A_BitOffset = 0
const BigBefore_Slot_A_ByteSize = 8
const BigBefore_Slot_A_ByteOffset = 0
const BigBefore_Slot_A_ValueMask = 0xffffffffffffffff

const BigBefore_Slot_B_Type = 1
const BigBefore_Slot_B_Num = 1
const BigBefore_Slot_B_BitSize = 32
const BigBefore_Slot_B_BitOffset = 0
const BigBefore_Slot_B_ByteSize = 4
const BigBefore_Slot_B_ByteOffset = 0
const BigBefore_Slot_B_ValueMask = 0xffffffff

const BigBefore_Slot_C_Type = 1
const BigBefore_Slot_C_Num = 1
const BigBefore_Slot_C_BitSize = 16
const BigBefore_Slot_C_BitOffset = 32
const BigBefore_Slot_C_ByteSize = 2
const BigBefore_Slot_C_ByteOffset = 4
const BigBefore_Slot_C_ValueMask = 0xffff

const BigBefore_Slot_D_Type = 1
const BigBefore_Slot_D_Num = 1
const BigBefore_Slot_D_BitSize = 16
const BigBefore_Slot_D_BitOffset = 48
const BigBefore_Slot_D_ByteSize = 2
const BigBefore_Slot_D_ByteOffset = 6
const BigBefore_Slot_D_ValueMask = 0xffff

const BigBefore_Slot_E_Type = 1
const BigBefore_Slot_E_Num = 2
const BigBefore_Slot_E_BitSize = 8
const BigBefore_Slot_E_BitOffset = 0
const BigBefore_Slot_E_ByteSize = 1
const BigBefore_Slot_E_ByteOffset = 0
const BigBefore_Slot_E_ValueMask = 0xff

const BigBefore_Slot_F_Type = 1
const BigBefore_Slot_F_Num = 2
const BigBefore_Slot_F_BitSize = 8
const BigBefore_Slot_F_BitOffset = 8
const BigBefore_Slot_F_ByteSize = 1
const BigBefore_Slot_F_ByteOffset = 1
const BigBefore_Slot_F_ValueMask = 0xff

const BigBefore_Slot_G_Type = 1
const BigBefore_Slot_G_Num = 2
const BigBefore_Slot_G_BitSize = 8
const BigBefore_Slot_G_BitOffset = 16
const BigBefore_Slot_G_ByteSize = 1
const BigBefore_Slot_G_ByteOffset = 2
const BigBefore_Slot_G_ValueMask = 0xff

const BigBefore_Slot_H_Type = 1
const BigBefore_Slot_H_Num = 2
const BigBefore_Slot_H_BitSize = 1
const BigBefore_Slot_H_BitOffset = 24
const BigBefore_Slot_H_ByteSize = 1
const BigBefore_Slot_H_ByteOffset = 3
const BigBefore_Slot_H_ValueMask = 0x1

const BigBefore_Slot_I_Type = 1
const BigBefore_Slot_I_Num = 2
const BigBefore_Slot_I_BitSize = 1
const BigBefore_Slot_I_BitOffset = 25
const BigBefore_Slot_I_ByteSize = 1
const BigBefore_Slot_I_ByteOffset = 3
const BigBefore_Slot_I_ValueMask = 0x1

// BigBeforeValue is the logical type of a record. Immutable records are stored in
// nodes.
type BigBeforeValue struct {
	A uint64 // 1
	B uint32 // 2
	C uint16 // 3
	D uint16 // 4
	E uint8  // 5
	F uint8  // 6
	G uint8  // 7
	H bool   // 8
	I bool   // 9
}

// R constructs a reference to an immutable record.
func (x BigBeforeValue) R(a *Allocator) BigBefore {
	ref := a.new()

	ref.nums[0] = numvalslot(x.A)
	ref.nums[1] = (ref.nums[1] &^ (BigBefore_Slot_B_ValueMask << BigBefore_Slot_B_BitOffset)) | (numvalslot(x.B) << BigBefore_Slot_B_BitOffset)
	ref.nums[1] = (ref.nums[1] &^ (BigBefore_Slot_C_ValueMask << BigBefore_Slot_C_BitOffset)) | (numvalslot(x.C) << BigBefore_Slot_C_BitOffset)
	ref.nums[1] = (ref.nums[1] &^ (BigBefore_Slot_D_ValueMask << BigBefore_Slot_D_BitOffset)) | (numvalslot(x.D) << BigBefore_Slot_D_BitOffset)
	ref.nums[2] = (ref.nums[2] &^ (BigBefore_Slot_E_ValueMask << BigBefore_Slot_E_BitOffset)) | (numvalslot(x.E) << BigBefore_Slot_E_BitOffset)
	ref.nums[2] = (ref.nums[2] &^ (BigBefore_Slot_F_ValueMask << BigBefore_Slot_F_BitOffset)) | (numvalslot(x.F) << BigBefore_Slot_F_BitOffset)
	ref.nums[2] = (ref.nums[2] &^ (BigBefore_Slot_G_ValueMask << BigBefore_Slot_G_BitOffset)) | (numvalslot(x.G) << BigBefore_Slot_G_BitOffset)
	if x.H {
		ref.nums[2] |= (numvalslot(1) << BigBefore_Slot_H_BitOffset)
	} else {
		ref.nums[2] &^= (numvalslot(1) << BigBefore_Slot_H_BitOffset)
	}
	if x.I {
		ref.nums[2] |= (numvalslot(1) << BigBefore_Slot_I_BitOffset)
	} else {
		ref.nums[2] &^= (numvalslot(1) << BigBefore_Slot_I_BitOffset)
	}
	return BigBefore{ref}
}

// A returns the A field.
func (x BigBefore) A() uint64 { return uint64(x.ref.nums[0]) }

// B returns the B field.
func (x BigBefore) B() uint32 {
	return uint32((x.ref.nums[1] >> BigBefore_Slot_B_BitOffset) & BigBefore_Slot_B_ValueMask)
}

// C returns the C field.
func (x BigBefore) C() uint16 {
	return uint16((x.ref.nums[1] >> BigBefore_Slot_C_BitOffset) & BigBefore_Slot_C_ValueMask)
}

// D returns the D field.
func (x BigBefore) D() uint16 {
	return uint16((x.ref.nums[1] >> BigBefore_Slot_D_BitOffset) & BigBefore_Slot_D_ValueMask)
}

// E returns the E field.
func (x BigBefore) E() uint8 {
	return uint8((x.ref.nums[2] >> BigBefore_Slot_E_BitOffset) & BigBefore_Slot_E_ValueMask)
}

// F returns the F field.
func (x BigBefore) F() uint8 {
	return uint8((x.ref.nums[2] >> BigBefore_Slot_F_BitOffset) & BigBefore_Slot_F_ValueMask)
}

// G returns the G field.
func (x BigBefore) G() uint8 {
	return uint8((x.ref.nums[2] >> BigBefore_Slot_G_BitOffset) & BigBefore_Slot_G_ValueMask)
}

// H returns the H field.
func (x BigBefore) H() bool {
	return !(0 == (x.ref.nums[2] >> BigBefore_Slot_H_BitOffset & BigBefore_Slot_H_ValueMask))
}

// I returns the I field.
func (x BigBefore) I() bool {
	return !(0 == (x.ref.nums[2] >> BigBefore_Slot_I_BitOffset & BigBefore_Slot_I_ValueMask))
}

// V unpacks a reference into a value.
func (x BigBefore) V() BigBeforeValue {
	return BigBeforeValue{
		A: uint64(x.ref.nums[0]),
		B: uint32((x.ref.nums[1] >> BigBefore_Slot_B_BitOffset) & BigBefore_Slot_B_ValueMask),
		C: uint16((x.ref.nums[1] >> BigBefore_Slot_C_BitOffset) & BigBefore_Slot_C_ValueMask),
		D: uint16((x.ref.nums[1] >> BigBefore_Slot_D_BitOffset) & BigBefore_Slot_D_ValueMask),
		E: uint8((x.ref.nums[2] >> BigBefore_Slot_E_BitOffset) & BigBefore_Slot_E_ValueMask),
		F: uint8((x.ref.nums[2] >> BigBefore_Slot_F_BitOffset) & BigBefore_Slot_F_ValueMask),
		G: uint8((x.ref.nums[2] >> BigBefore_Slot_G_BitOffset) & BigBefore_Slot_G_ValueMask),
		H: !(0 == (x.ref.nums[2] >> BigBefore_Slot_H_BitOffset & BigBefore_Slot_H_ValueMask)),
		I: !(0 == (x.ref.nums[2] >> BigBefore_Slot_I_BitOffset & BigBefore_Slot_I_ValueMask)),
	}
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x BigBeforeValue) WithA(y uint64) BigBeforeValue {
	x.A = y
	return x
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x BigBeforeValue) WithB(y uint32) BigBeforeValue {
	x.B = y
	return x
}

// WithC constructs a new value where the value of C has been replaced by
// the argument.
func (x BigBeforeValue) WithC(y uint16) BigBeforeValue {
	x.C = y
	return x
}

// WithD constructs a new value where the value of D has been replaced by
// the argument.
func (x BigBeforeValue) WithD(y uint16) BigBeforeValue {
	x.D = y
	return x
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x BigBeforeValue) WithE(y uint8) BigBeforeValue {
	x.E = y
	return x
}

// WithF constructs a new value where the value of F has been replaced by
// the argument.
func (x BigBeforeValue) WithF(y uint8) BigBeforeValue {
	x.F = y
	return x
}

// WithG constructs a new value where the value of G has been replaced by
// the argument.
func (x BigBeforeValue) WithG(y uint8) BigBeforeValue {
	x.G = y
	return x
}

// WithH constructs a new value where the value of H has been replaced by
// the argument.
func (x BigBeforeValue) WithH(y bool) BigBeforeValue {
	x.H = y
	return x
}

// WithI constructs a new value where the value of I has been replaced by
// the argument.
func (x BigBeforeValue) WithI(y bool) BigBeforeValue {
	x.I = y
	return x
}

// Codegen parameters:
// {NumNumericSlots:20 NumericSlotSize:64 NumRefSlots:20 NumStrSlots:20 Pack:true}
//
