// Code generated by irgen/irgen base/sexpr.tmpl.go tests/example.def. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package base

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/pkg/errors"
)

type SexprFormatter interface {
	FormatSExpr(buf *bytes.Buffer)
}

func asString(x SexprFormatter) string {
	var buf bytes.Buffer
	x.FormatSExpr(&buf)
	return buf.String()
}

func FormatSExprBool(buf *bytes.Buffer, x bool)       { fmt.Fprintf(buf, "%v", x) }
func FormatSExprInt64(buf *bytes.Buffer, x int64)     { fmt.Fprintf(buf, "%v", x) }
func FormatSExprInt32(buf *bytes.Buffer, x int32)     { fmt.Fprintf(buf, "%v", x) }
func FormatSExprInt16(buf *bytes.Buffer, x int16)     { fmt.Fprintf(buf, "%v", x) }
func FormatSExprInt8(buf *bytes.Buffer, x int8)       { fmt.Fprintf(buf, "%v", x) }
func FormatSExprUint64(buf *bytes.Buffer, x uint64)   { fmt.Fprintf(buf, "%v", x) }
func FormatSExprUint32(buf *bytes.Buffer, x uint32)   { fmt.Fprintf(buf, "%v", x) }
func FormatSExprUint16(buf *bytes.Buffer, x uint16)   { fmt.Fprintf(buf, "%v", x) }
func FormatSExprUint8(buf *bytes.Buffer, x uint8)     { fmt.Fprintf(buf, "%v", x) }
func FormatSExprFloat32(buf *bytes.Buffer, x float32) { fmt.Fprintf(buf, "%v", x) }
func FormatSExprFloat64(buf *bytes.Buffer, x float64) { fmt.Fprintf(buf, "%v", x) }
func FormatSExprString(buf *bytes.Buffer, x string)   { fmt.Fprintf(buf, "%q", x) }

func (x BinOp) FormatSExpr(buf *bytes.Buffer) {
	buf.WriteString(x.String())
}

func (x ConstExpr) FormatSExpr(buf *bytes.Buffer) {
	buf.WriteString("(const-expr")

	buf.WriteString(" :datum ")
	FormatSExprInt64(buf, x.Datum())

	buf.WriteByte(')')
}

func (x ConstExpr) String() string { return asString(x) }

func (x BinExpr) FormatSExpr(buf *bytes.Buffer) {
	buf.WriteString("(bin-expr")

	buf.WriteString(" :left ")
	x.Left().FormatSExpr(buf)

	buf.WriteString(" :op ")
	x.Op().FormatSExpr(buf)

	buf.WriteString(" :right ")
	x.Right().FormatSExpr(buf)

	buf.WriteByte(')')
}

func (x BinExpr) String() string { return asString(x) }

func (x TriExpr) FormatSExpr(buf *bytes.Buffer) {
	buf.WriteString("(tri-expr")

	buf.WriteString(" :one ")
	x.One().FormatSExpr(buf)

	buf.WriteString(" :two ")
	x.Two().FormatSExpr(buf)

	buf.WriteString(" :three ")
	x.Three().FormatSExpr(buf)

	buf.WriteByte(')')
}

func (x TriExpr) String() string { return asString(x) }

func (x All) FormatSExpr(buf *bytes.Buffer) {
	buf.WriteString("(all")

	buf.WriteString(" :e ")
	x.E().FormatSExpr(buf)

	buf.WriteString(" :c-e ")
	x.CE().FormatSExpr(buf)

	buf.WriteString(" :b-e ")
	x.BE().FormatSExpr(buf)

	buf.WriteString(" :b-o ")
	x.BO().FormatSExpr(buf)

	buf.WriteString(" :a ")
	x.A().FormatSExpr(buf)

	buf.WriteByte(')')
}

func (x All) String() string { return asString(x) }

func (x Expr) FormatSExpr(buf *bytes.Buffer) {
	switch x.Tag() {
	case ExprConstExpr:
		x.MustBeConstExpr().FormatSExpr(buf)
	case ExprBinExpr:
		x.MustBeBinExpr().FormatSExpr(buf)
	}
}

func (x Expr) String() string { return asString(x) }

func (x AllOrExpr) FormatSExpr(buf *bytes.Buffer) {
	switch x.Tag() {
	case AllOrExprAll:
		x.MustBeAll().FormatSExpr(buf)
	case AllOrExprBinExpr:
		x.MustBeBinExpr().FormatSExpr(buf)
	}
}

func (x AllOrExpr) String() string { return asString(x) }

type Parser struct {
	// The string being parsed.
	s string
	// Allocator to use for new nodes.
	alloc *Allocator
	// Offset within the string.
	pos int
	// Current line number (0-indexed).
	lineno int
	// Current column number (0-indexed).
	col int
}

func MakeParser(s string, a *Allocator) Parser {
	return Parser{s: s, alloc: a}
}

var fmtErrDuplicateField = "%s: duplicate field definition for %s"
var fmtErrNoSuchField = "%s: no member named %s"
var fmtErrEOFWhileParsing = "%s: unexpected EOF"
var fmtErrNoSuchVariantName = "%s has no variant named %s"
var fmtErrNoSuchVariantTag = "%s has no variant with tag %d"
var fmtErrUnexpectedVariant = "expected %s variant, got %s"
var fmtErrUnexpectedSym = "expected %s, got %s"
var fmtErrValueMissing = "%s: value missing for:%s"

func (p *Parser) Errorf(format string, args ...interface{}) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "%d:%d: syntax error: ", p.lineno+1, p.col+1)
	fmt.Fprintf(&buf, format, args...)

	// Find the end of the line containing the last token.
	i := strings.Index(p.s[p.pos:], "\n")
	if i == -1 {
		i = len(p.s)
	} else {
		i += p.pos
	}
	// Find the beginning of the line containing the last token. Note that
	// LastIndex returns -1 if "\n" could not be found.
	j := strings.LastIndex(p.s[:p.pos], "\n") + 1
	// Output everything up to and including the line containing the last token.
	fmt.Fprintf(&buf, "\n%s\n", p.s[:i])
	// Output a caret indicating where the last token starts.
	fmt.Fprintf(&buf, "%*s^\n", p.pos-j, "")

	return errors.New(buf.String())
}

func (p *Parser) Eof() bool {
	return p.pos >= len(p.s)
}

func (p *Parser) skipWhite() bool {
	for true {
		if p.Eof() {
			return true
		}
		switch c := p.s[p.pos]; c {
		case '\n':
			p.pos++
			p.lineno++
			p.col = 0
		case ' ', '\t':
			p.col++
			p.pos++
		case '\r', '\v', '\f':
			p.pos++
		default:
			return false
		}
	}
	return false // not reached
}

func (p *Parser) ParseBinOp() (res BinOp, err error) {
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	switch sym {
	case "bin-op":
		if err := p.expChar('('); err != nil {
			return res, err
		}
		v, err := p.expInteger(64)
		if err != nil {
			return res, err
		}
		if err := p.expChar(')'); err != nil {
			return res, err
		}
		switch v {
		case 1:
			return BinOpAdd, nil
		case 2:
			return BinOpMul, nil
		default:
			return res, p.Errorf(fmtErrNoSuchVariantTag, "bin-op", v)
		}

	case "add":
		return BinOpAdd, nil
	case "mul":
		return BinOpMul, nil
	default:
		return res, p.Errorf(fmtErrNoSuchVariantName, "bin-op", sym)
	}
}

func (p *Parser) ParseExpr() (res Expr, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	res, err = p.openExpr(sym)
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openExpr(sym string) (Expr, error) {
	switch sym {
	case "const-expr":
		it, err := p.openConstExpr()
		if err != nil {
			return Expr{}, err
		}
		return it.Expr(), nil
	case "bin-expr":
		it, err := p.openBinExpr()
		if err != nil {
			return Expr{}, err
		}
		return it.Expr(), nil
	default:
		return Expr{}, p.Errorf(fmtErrUnexpectedVariant, "expr", sym)
	}
}

func (p *Parser) ParseAllOrExpr() (res AllOrExpr, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	res, err = p.openAllOrExpr(sym)
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openAllOrExpr(sym string) (AllOrExpr, error) {
	switch sym {
	case "all":
		it, err := p.openAll()
		if err != nil {
			return AllOrExpr{}, err
		}
		return it.AllOrExpr(), nil
	case "bin-expr":
		it, err := p.openBinExpr()
		if err != nil {
			return AllOrExpr{}, err
		}
		return it.AllOrExpr(), nil
	default:
		return AllOrExpr{}, p.Errorf(fmtErrUnexpectedVariant, "all-or-expr", sym)
	}
}

func (p *Parser) ParseConstExpr() (res ConstExpr, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	if sym != "const-expr" {
		return res, p.Errorf(fmtErrUnexpectedSym, "const-expr", sym)
	}
	res, err = p.openConstExpr()
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openConstExpr() (res ConstExpr, err error) {
	if p.skipWhite() {
		return res, p.Errorf(fmtErrEOFWhileParsing, "const-expr")
	}
	var s ConstExprValue
	for {
		lbl, err := p.expMaybeLabel()
		if err != nil {
			return res, err
		}
		if lbl == "" {
			break
		}
		switch lbl {
		case "datum":
			v, err := p.ParseInt64()
			if err != nil {
				return res, err
			}
			s = s.WithDatum(v)

		default:
			return res, p.Errorf(fmtErrNoSuchField, "const-expr", lbl)
		}
	}
	return s.R(p.alloc), nil
}

func (p *Parser) ParseBinExpr() (res BinExpr, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	if sym != "bin-expr" {
		return res, p.Errorf(fmtErrUnexpectedSym, "bin-expr", sym)
	}
	res, err = p.openBinExpr()
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openBinExpr() (res BinExpr, err error) {
	if p.skipWhite() {
		return res, p.Errorf(fmtErrEOFWhileParsing, "bin-expr")
	}
	var s BinExprValue
	var seen uint64
	for {
		lbl, err := p.expMaybeLabel()
		if err != nil {
			return res, err
		}
		if lbl == "" {
			break
		}
		switch lbl {
		case "left":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithLeft(v)
			if 0 != (seen & (uint64(1) << 0)) {
				return res, p.Errorf(fmtErrDuplicateField, "bin-expr", "left")
			}
			seen |= uint64(1) << 0
		case "op":
			v, err := p.ParseBinOp()
			if err != nil {
				return res, err
			}
			s = s.WithOp(v)
			if 0 != (seen & (uint64(1) << 1)) {
				return res, p.Errorf(fmtErrDuplicateField, "bin-expr", "op")
			}
			seen |= uint64(1) << 1
		case "right":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithRight(v)
			if 0 != (seen & (uint64(1) << 2)) {
				return res, p.Errorf(fmtErrDuplicateField, "bin-expr", "right")
			}
			seen |= uint64(1) << 2

		default:
			return res, p.Errorf(fmtErrNoSuchField, "bin-expr", lbl)
		}
	}
	if seen != 7 {
		var buf bytes.Buffer
		if 0 == (seen & (uint64(1) << 0)) {
			fmt.Fprintf(&buf, " :left (expr))")
		}
		if 0 == (seen & (uint64(1) << 1)) {
			fmt.Fprintf(&buf, " :op bin-op")
		}
		if 0 == (seen & (uint64(1) << 2)) {
			fmt.Fprintf(&buf, " :right (expr))")
		}
		return res, p.Errorf(fmtErrValueMissing, "bin-expr", buf.String())
	}
	return s.R(p.alloc), nil
}

func (p *Parser) ParseTriExpr() (res TriExpr, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	if sym != "tri-expr" {
		return res, p.Errorf(fmtErrUnexpectedSym, "tri-expr", sym)
	}
	res, err = p.openTriExpr()
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openTriExpr() (res TriExpr, err error) {
	if p.skipWhite() {
		return res, p.Errorf(fmtErrEOFWhileParsing, "tri-expr")
	}
	var s TriExprValue
	var seen uint64
	for {
		lbl, err := p.expMaybeLabel()
		if err != nil {
			return res, err
		}
		if lbl == "" {
			break
		}
		switch lbl {
		case "one":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithOne(v)
			if 0 != (seen & (uint64(1) << 0)) {
				return res, p.Errorf(fmtErrDuplicateField, "tri-expr", "one")
			}
			seen |= uint64(1) << 0
		case "two":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithTwo(v)
			if 0 != (seen & (uint64(1) << 1)) {
				return res, p.Errorf(fmtErrDuplicateField, "tri-expr", "two")
			}
			seen |= uint64(1) << 1
		case "three":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithThree(v)
			if 0 != (seen & (uint64(1) << 2)) {
				return res, p.Errorf(fmtErrDuplicateField, "tri-expr", "three")
			}
			seen |= uint64(1) << 2

		default:
			return res, p.Errorf(fmtErrNoSuchField, "tri-expr", lbl)
		}
	}
	if seen != 7 {
		var buf bytes.Buffer
		if 0 == (seen & (uint64(1) << 0)) {
			fmt.Fprintf(&buf, " :one (expr))")
		}
		if 0 == (seen & (uint64(1) << 1)) {
			fmt.Fprintf(&buf, " :two (expr))")
		}
		if 0 == (seen & (uint64(1) << 2)) {
			fmt.Fprintf(&buf, " :three (expr))")
		}
		return res, p.Errorf(fmtErrValueMissing, "tri-expr", buf.String())
	}
	return s.R(p.alloc), nil
}

func (p *Parser) ParseAll() (res All, err error) {
	if err = p.expChar('('); err != nil {
		return res, err
	}
	sym, err := p.expAtom()
	if err != nil {
		return res, err
	}
	if sym != "all" {
		return res, p.Errorf(fmtErrUnexpectedSym, "all", sym)
	}
	res, err = p.openAll()
	if err != nil {
		return res, err
	}
	if err = p.expChar(')'); err != nil {
		return res, err
	}
	return res, nil
}

func (p *Parser) openAll() (res All, err error) {
	if p.skipWhite() {
		return res, p.Errorf(fmtErrEOFWhileParsing, "all")
	}
	var s AllValue
	var seen uint64
	for {
		lbl, err := p.expMaybeLabel()
		if err != nil {
			return res, err
		}
		if lbl == "" {
			break
		}
		switch lbl {
		case "e":
			v, err := p.ParseExpr()
			if err != nil {
				return res, err
			}
			s = s.WithE(v)
			if 0 != (seen & (uint64(1) << 0)) {
				return res, p.Errorf(fmtErrDuplicateField, "all", "e")
			}
			seen |= uint64(1) << 0
		case "c-e":
			v, err := p.ParseConstExpr()
			if err != nil {
				return res, err
			}
			s = s.WithCE(v)
			if 0 != (seen & (uint64(1) << 1)) {
				return res, p.Errorf(fmtErrDuplicateField, "all", "c-e")
			}
			seen |= uint64(1) << 1
		case "b-e":
			v, err := p.ParseBinExpr()
			if err != nil {
				return res, err
			}
			s = s.WithBE(v)
			if 0 != (seen & (uint64(1) << 2)) {
				return res, p.Errorf(fmtErrDuplicateField, "all", "b-e")
			}
			seen |= uint64(1) << 2
		case "b-o":
			v, err := p.ParseBinOp()
			if err != nil {
				return res, err
			}
			s = s.WithBO(v)
			if 0 != (seen & (uint64(1) << 3)) {
				return res, p.Errorf(fmtErrDuplicateField, "all", "b-o")
			}
			seen |= uint64(1) << 3
		case "a":
			v, err := p.ParseAllOrExpr()
			if err != nil {
				return res, err
			}
			s = s.WithA(v)
			if 0 != (seen & (uint64(1) << 4)) {
				return res, p.Errorf(fmtErrDuplicateField, "all", "a")
			}
			seen |= uint64(1) << 4

		default:
			return res, p.Errorf(fmtErrNoSuchField, "all", lbl)
		}
	}
	if seen != 31 {
		var buf bytes.Buffer
		if 0 == (seen & (uint64(1) << 0)) {
			fmt.Fprintf(&buf, " :e (expr))")
		}
		if 0 == (seen & (uint64(1) << 1)) {
			fmt.Fprintf(&buf, " :c-e (const-expr))")
		}
		if 0 == (seen & (uint64(1) << 2)) {
			fmt.Fprintf(&buf, " :b-e (bin-expr))")
		}
		if 0 == (seen & (uint64(1) << 3)) {
			fmt.Fprintf(&buf, " :b-o bin-op")
		}
		if 0 == (seen & (uint64(1) << 4)) {
			fmt.Fprintf(&buf, " :a (all-or-expr))")
		}
		return res, p.Errorf(fmtErrValueMissing, "all", buf.String())
	}
	return s.R(p.alloc), nil
}

func (p *Parser) expChar(c byte) error {
	if p.skipWhite() {
		return p.Errorf("expected '%c', got EOF", c)
	}
	if p.s[p.pos] != c {
		return p.Errorf("expected '%c', got '%c'", c, p.s[p.pos])
	}
	p.pos++
	return nil
}

func (p *Parser) expMaybeLabel() (string, error) {
	if p.skipWhite() {
		return "", p.Errorf("expected ':' or ')', got EOF")
	}
	if p.s[p.pos] == ':' {
		p.pos++
		return p.expAtom()
	}
	return "", nil
}

func (p *Parser) scanInteger() (string, error) {
	start := p.pos
	for ; p.pos < len(p.s); p.pos++ {
		c := p.s[p.pos]
		if (c < '0' || c > '9') && c != '-' && c != '+' {
			break
		}
	}
	if p.pos == start {
		return "", p.Errorf("expected number, got '%c'", p.s[p.pos])
	}
	return p.s[start:p.pos], nil
}

func (p *Parser) scanRune() (rune, error) {
	s, err := p.scanString('\'')
	if err != nil {
		return 0, err
	}
	v, _, _, err := strconv.UnquoteChar(s, '\'')
	return v, err
}

func (p *Parser) expInteger(width int) (int64, error) {
	if p.skipWhite() {
		return 0, p.Errorf("expected number, got EOF")
	}
	if p.s[p.pos] == '\'' {
		v, err := p.scanRune()
		return int64(v), err
	}
	sv, err := p.scanInteger()
	if err != nil {
		return 0, err
	}
	return strconv.ParseInt(sv, 0, width)
}

func (p *Parser) expUnsigned(width int) (uint64, error) {
	if p.skipWhite() {
		return 0, p.Errorf("expected number, got EOF")
	}
	if p.s[p.pos] == '\'' {
		v, err := p.scanRune()
		return uint64(v), err
	}
	sv, err := p.scanInteger()
	if err != nil {
		return 0, err
	}
	return strconv.ParseUint(sv, 0, width)
}

func (p *Parser) expAtom() (string, error) {
	if p.skipWhite() {
		return "", p.Errorf(fmtErrEOFWhileParsing, "atom")
	}

	i := p.pos
	for w, r := 0, rune(0); i < len(p.s); i += w {
		r, w = utf8.DecodeRuneInString(p.s[i:])
		if r == '(' || r == ')' || unicode.IsSpace(r) {
			break
		}
	}
	res := p.s[p.pos:i]
	p.pos = i
	return res, nil
}

func (p *Parser) scanString(quote byte) (string, error) {
	start := p.pos
	if err := p.expChar(quote); err != nil {
		return "", err
	}
	for ; !p.Eof() && p.s[p.pos] != quote; p.pos++ {
		if p.s[p.pos] == '\\' {
			p.pos++
		}
	}
	if err := p.expChar(quote); err != nil {
		return "", err
	}
	return p.s[start:p.pos], nil
}

func (p *Parser) ParseString() (string, error) {
	if p.skipWhite() {
		return "", p.Errorf(fmtErrEOFWhileParsing, "string")
	}
	s, err := p.scanString('"')
	if err != nil {
		return s, err
	}
	return strconv.Unquote(s)
}

func (p *Parser) ParseFloat64() (float64, error) {
	sym, err := p.expAtom()
	if err != nil {
		return 0, err
	}
	return strconv.ParseFloat(sym, 64)
}

func (p *Parser) ParseFloat32() (float32, error) {
	sym, err := p.expAtom()
	if err != nil {
		return 0, err
	}
	v, err := strconv.ParseFloat(sym, 32)
	return float32(v), err
}

func (p *Parser) ParseBool() (bool, error) {
	sym, err := p.expAtom()
	if err != nil {
		return false, err
	}
	return strconv.ParseBool(sym)
}

func (p *Parser) ParseInt64() (int64, error)   { return p.expInteger(64) }
func (p *Parser) ParseUint64() (uint64, error) { return p.expUnsigned(64) }
func (p *Parser) ParseInt32() (int32, error)   { v, err := p.expInteger(32); return int32(v), err }
func (p *Parser) ParseUint32() (uint32, error) { v, err := p.expUnsigned(32); return uint32(v), err }
func (p *Parser) ParseInt16() (int16, error)   { v, err := p.expInteger(16); return int16(v), err }
func (p *Parser) ParseUint16() (uint16, error) { v, err := p.expUnsigned(16); return uint16(v), err }
func (p *Parser) ParseInt8() (int8, error)     { v, err := p.expInteger(8); return int8(v), err }
func (p *Parser) ParseUint8() (uint8, error)   { v, err := p.expUnsigned(8); return uint8(v), err }

// Codegen parameters:
// {NumNumericSlots:20 NumericSlotSize:64 NumRefSlots:20 NumStrSlots:20 Pack:true}
//
