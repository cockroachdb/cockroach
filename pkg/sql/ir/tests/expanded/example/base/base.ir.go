// Code generated by irgen/irgen base/base.tmpl.go tests/example.def. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package base

import (
	"fmt"
)

// node is a generic ADT node type, with slots for references to other nodes and
// enumeration values. Values that don't fit and values of other types go in the
// extra field.
type node struct {
	refs [10]*node
	nums [10]numvalslot
	strs [10]string
	extra
}

// enum is the type to define the tag part for working copies of IR
// node with sum and enum types.
type enum uint32

// ivalslot is the type used to store integer values in persistent IR nodes.
// must be larger than or as large as enum.
type numvalslot uint64

type extra interface {
	extraRefs() []*node
}

// Allocator allocates nodes in batches. Construct Allocators with NewAllocator
// and pass them by value.
type Allocator struct {
	nodes []node
}

// MakeAllocator constructs a new Allocator.
func MakeAllocator() Allocator {
	nodes := make([]node, 16)
	return Allocator{nodes}
}

// NewAllocator allocates a new Allocator.
func NewAllocator() *Allocator {
	a := MakeAllocator()
	return &a
}

// new allocates a new node. Users of this package should use the appropriate
// R() method, which is type safe.
func (a *Allocator) new() *node {
	nodes := a.nodes
	if len(nodes) == 0 {
		nodes = make([]node, 256)
	}
	x := &nodes[0]
	a.nodes = nodes[1:]
	return x
}

// ---- BinOp ---- //

// BinOp is an enumeration type.
type BinOp enum

// BinOp constants.
const (
	BinOpAdd BinOp = 1
	BinOpMul BinOp = 2
)

func (x BinOp) String() string {
	switch x {
	case BinOpAdd:
		return "Add"
	case BinOpMul:
		return "Mul"
	default:
		return fmt.Sprintf("<unknown BinOp %d>", x)
	}
}

// ---- ConstExpr ---- //

// ConstExpr is the type of a reference to an immutable record.
type ConstExpr struct{ ref *node }

const ConstExpr_Slot_Datum_Type = 1
const ConstExpr_Slot_Datum_Num = 0
const ConstExpr_Slot_Datum_BitSize = 64
const ConstExpr_Slot_Datum_BitOffset = 0
const ConstExpr_Slot_Datum_ByteSize = 8
const ConstExpr_Slot_Datum_ByteOffset = 0
const ConstExpr_Slot_Datum_ValueMask = 0xffffffffffffffff

// ConstExprValue is the logical type of a record. Immutable records are stored in
// nodes.
type ConstExprValue struct {
	Datum int64 // 1
}

// R constructs a reference to an immutable record.
func (x ConstExprValue) R(a *Allocator) ConstExpr {
	ref := a.new()

	ref.nums[0] = numvalslot(x.Datum)
	return ConstExpr{ref}
}

// Datum returns the Datum field.
func (x ConstExpr) Datum() int64 { return int64(x.ref.nums[0]) }

// V unpacks a reference into a value.
func (x ConstExpr) V() ConstExprValue {
	return ConstExprValue{
		Datum: int64(x.ref.nums[0]),
	}
}

// WithDatum constructs a new value where the value of Datum has been replaced by
// the argument.
func (x ConstExprValue) WithDatum(y int64) ConstExprValue {
	x.Datum = y
	return x
}

// ---- BinExpr ---- //

// BinExpr is the type of a reference to an immutable record.
type BinExpr struct{ ref *node }

const BinExpr_Slot_Left_Type = 0
const BinExpr_Slot_Left_Num = 0
const BinExpr_Slot_Left_BitSize = -1
const BinExpr_Slot_Left_BitOffset = -1
const BinExpr_Slot_Left_ByteSize = -1
const BinExpr_Slot_Left_ByteOffset = -1
const BinExpr_Slot_Left_ValueMask = -1

const BinExpr_Slot_Left__Tag_Type = 1
const BinExpr_Slot_Left__Tag_Num = 0
const BinExpr_Slot_Left__Tag_BitSize = 64
const BinExpr_Slot_Left__Tag_BitOffset = 0
const BinExpr_Slot_Left__Tag_ByteSize = 8
const BinExpr_Slot_Left__Tag_ByteOffset = 0
const BinExpr_Slot_Left__Tag_ValueMask = 0xffffffffffffffff

const BinExpr_Slot_Op_Type = 1
const BinExpr_Slot_Op_Num = 1
const BinExpr_Slot_Op_BitSize = 64
const BinExpr_Slot_Op_BitOffset = 0
const BinExpr_Slot_Op_ByteSize = 8
const BinExpr_Slot_Op_ByteOffset = 0
const BinExpr_Slot_Op_ValueMask = 0xffffffffffffffff

const BinExpr_Slot_Right_Type = 0
const BinExpr_Slot_Right_Num = 1
const BinExpr_Slot_Right_BitSize = -1
const BinExpr_Slot_Right_BitOffset = -1
const BinExpr_Slot_Right_ByteSize = -1
const BinExpr_Slot_Right_ByteOffset = -1
const BinExpr_Slot_Right_ValueMask = -1

const BinExpr_Slot_Right__Tag_Type = 1
const BinExpr_Slot_Right__Tag_Num = 2
const BinExpr_Slot_Right__Tag_BitSize = 64
const BinExpr_Slot_Right__Tag_BitOffset = 0
const BinExpr_Slot_Right__Tag_ByteSize = 8
const BinExpr_Slot_Right__Tag_ByteOffset = 0
const BinExpr_Slot_Right__Tag_ValueMask = 0xffffffffffffffff

// BinExprValue is the logical type of a record. Immutable records are stored in
// nodes.
type BinExprValue struct {
	Left  Expr  // 1
	Op    BinOp // 2
	Right Expr  // 3
}

// R constructs a reference to an immutable record.
func (x BinExprValue) R(a *Allocator) BinExpr {
	ref := a.new()

	ref.nums[0] = numvalslot(x.Left.tag)
	ref.refs[0] = x.Left.ref
	ref.nums[1] = numvalslot(x.Op)
	ref.nums[2] = numvalslot(x.Right.tag)
	ref.refs[1] = x.Right.ref
	return BinExpr{ref}
}

// Left returns the Left field.
func (x BinExpr) Left() Expr { return Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]} }

// Op returns the Op field.
func (x BinExpr) Op() BinOp { return BinOp(x.ref.nums[1]) }

// Right returns the Right field.
func (x BinExpr) Right() Expr { return Expr{ExprTag(x.ref.nums[2]), x.ref.refs[1]} }

// V unpacks a reference into a value.
func (x BinExpr) V() BinExprValue {
	return BinExprValue{
		Left:  Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]},
		Op:    BinOp(x.ref.nums[1]),
		Right: Expr{ExprTag(x.ref.nums[2]), x.ref.refs[1]},
	}
}

// WithLeft constructs a new value where the value of Left has been replaced by
// the argument.
func (x BinExprValue) WithLeft(y Expr) BinExprValue {
	x.Left = y
	return x
}

// WithOp constructs a new value where the value of Op has been replaced by
// the argument.
func (x BinExprValue) WithOp(y BinOp) BinExprValue {
	x.Op = y
	return x
}

// WithRight constructs a new value where the value of Right has been replaced by
// the argument.
func (x BinExprValue) WithRight(y Expr) BinExprValue {
	x.Right = y
	return x
}

// ---- TriExpr ---- //

// TriExpr is the type of a reference to an immutable record.
type TriExpr struct{ ref *node }

const TriExpr_Slot_One_Type = 0
const TriExpr_Slot_One_Num = 0
const TriExpr_Slot_One_BitSize = -1
const TriExpr_Slot_One_BitOffset = -1
const TriExpr_Slot_One_ByteSize = -1
const TriExpr_Slot_One_ByteOffset = -1
const TriExpr_Slot_One_ValueMask = -1

const TriExpr_Slot_One__Tag_Type = 1
const TriExpr_Slot_One__Tag_Num = 0
const TriExpr_Slot_One__Tag_BitSize = 64
const TriExpr_Slot_One__Tag_BitOffset = 0
const TriExpr_Slot_One__Tag_ByteSize = 8
const TriExpr_Slot_One__Tag_ByteOffset = 0
const TriExpr_Slot_One__Tag_ValueMask = 0xffffffffffffffff

const TriExpr_Slot_Three_Type = 0
const TriExpr_Slot_Three_Num = 2
const TriExpr_Slot_Three_BitSize = -1
const TriExpr_Slot_Three_BitOffset = -1
const TriExpr_Slot_Three_ByteSize = -1
const TriExpr_Slot_Three_ByteOffset = -1
const TriExpr_Slot_Three_ValueMask = -1

const TriExpr_Slot_Three__Tag_Type = 1
const TriExpr_Slot_Three__Tag_Num = 2
const TriExpr_Slot_Three__Tag_BitSize = 64
const TriExpr_Slot_Three__Tag_BitOffset = 0
const TriExpr_Slot_Three__Tag_ByteSize = 8
const TriExpr_Slot_Three__Tag_ByteOffset = 0
const TriExpr_Slot_Three__Tag_ValueMask = 0xffffffffffffffff

const TriExpr_Slot_Two_Type = 0
const TriExpr_Slot_Two_Num = 1
const TriExpr_Slot_Two_BitSize = -1
const TriExpr_Slot_Two_BitOffset = -1
const TriExpr_Slot_Two_ByteSize = -1
const TriExpr_Slot_Two_ByteOffset = -1
const TriExpr_Slot_Two_ValueMask = -1

const TriExpr_Slot_Two__Tag_Type = 1
const TriExpr_Slot_Two__Tag_Num = 1
const TriExpr_Slot_Two__Tag_BitSize = 64
const TriExpr_Slot_Two__Tag_BitOffset = 0
const TriExpr_Slot_Two__Tag_ByteSize = 8
const TriExpr_Slot_Two__Tag_ByteOffset = 0
const TriExpr_Slot_Two__Tag_ValueMask = 0xffffffffffffffff

// TriExprValue is the logical type of a record. Immutable records are stored in
// nodes.
type TriExprValue struct {
	One   Expr // 1
	Two   Expr // 2
	Three Expr // 4
}

// R constructs a reference to an immutable record.
func (x TriExprValue) R(a *Allocator) TriExpr {
	ref := a.new()

	ref.nums[0] = numvalslot(x.One.tag)
	ref.refs[0] = x.One.ref
	ref.nums[1] = numvalslot(x.Two.tag)
	ref.refs[1] = x.Two.ref
	ref.nums[2] = numvalslot(x.Three.tag)
	ref.refs[2] = x.Three.ref
	return TriExpr{ref}
}

// One returns the One field.
func (x TriExpr) One() Expr { return Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]} }

// Two returns the Two field.
func (x TriExpr) Two() Expr { return Expr{ExprTag(x.ref.nums[1]), x.ref.refs[1]} }

// Three returns the Three field.
func (x TriExpr) Three() Expr { return Expr{ExprTag(x.ref.nums[2]), x.ref.refs[2]} }

// V unpacks a reference into a value.
func (x TriExpr) V() TriExprValue {
	return TriExprValue{
		One:   Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]},
		Two:   Expr{ExprTag(x.ref.nums[1]), x.ref.refs[1]},
		Three: Expr{ExprTag(x.ref.nums[2]), x.ref.refs[2]},
	}
}

// WithOne constructs a new value where the value of One has been replaced by
// the argument.
func (x TriExprValue) WithOne(y Expr) TriExprValue {
	x.One = y
	return x
}

// WithTwo constructs a new value where the value of Two has been replaced by
// the argument.
func (x TriExprValue) WithTwo(y Expr) TriExprValue {
	x.Two = y
	return x
}

// WithThree constructs a new value where the value of Three has been replaced by
// the argument.
func (x TriExprValue) WithThree(y Expr) TriExprValue {
	x.Three = y
	return x
}

// ---- All ---- //

// All is the type of a reference to an immutable record.
type All struct{ ref *node }

const All_Slot_A_Type = 0
const All_Slot_A_Num = 3
const All_Slot_A_BitSize = -1
const All_Slot_A_BitOffset = -1
const All_Slot_A_ByteSize = -1
const All_Slot_A_ByteOffset = -1
const All_Slot_A_ValueMask = -1

const All_Slot_A__Tag_Type = 1
const All_Slot_A__Tag_Num = 2
const All_Slot_A__Tag_BitSize = 64
const All_Slot_A__Tag_BitOffset = 0
const All_Slot_A__Tag_ByteSize = 8
const All_Slot_A__Tag_ByteOffset = 0
const All_Slot_A__Tag_ValueMask = 0xffffffffffffffff

const All_Slot_BE_Type = 0
const All_Slot_BE_Num = 2
const All_Slot_BE_BitSize = -1
const All_Slot_BE_BitOffset = -1
const All_Slot_BE_ByteSize = -1
const All_Slot_BE_ByteOffset = -1
const All_Slot_BE_ValueMask = -1

const All_Slot_BO_Type = 1
const All_Slot_BO_Num = 1
const All_Slot_BO_BitSize = 64
const All_Slot_BO_BitOffset = 0
const All_Slot_BO_ByteSize = 8
const All_Slot_BO_ByteOffset = 0
const All_Slot_BO_ValueMask = 0xffffffffffffffff

const All_Slot_CE_Type = 0
const All_Slot_CE_Num = 1
const All_Slot_CE_BitSize = -1
const All_Slot_CE_BitOffset = -1
const All_Slot_CE_ByteSize = -1
const All_Slot_CE_ByteOffset = -1
const All_Slot_CE_ValueMask = -1

const All_Slot_E_Type = 0
const All_Slot_E_Num = 0
const All_Slot_E_BitSize = -1
const All_Slot_E_BitOffset = -1
const All_Slot_E_ByteSize = -1
const All_Slot_E_ByteOffset = -1
const All_Slot_E_ValueMask = -1

const All_Slot_E__Tag_Type = 1
const All_Slot_E__Tag_Num = 0
const All_Slot_E__Tag_BitSize = 64
const All_Slot_E__Tag_BitOffset = 0
const All_Slot_E__Tag_ByteSize = 8
const All_Slot_E__Tag_ByteOffset = 0
const All_Slot_E__Tag_ValueMask = 0xffffffffffffffff

// AllValue is the logical type of a record. Immutable records are stored in
// nodes.
type AllValue struct {
	E  Expr      // 1
	CE ConstExpr // 2
	BE BinExpr   // 3
	BO BinOp     // 4
	A  AllOrExpr // 5
}

// R constructs a reference to an immutable record.
func (x AllValue) R(a *Allocator) All {
	ref := a.new()

	ref.nums[0] = numvalslot(x.E.tag)
	ref.refs[0] = x.E.ref
	ref.refs[1] = x.CE.ref
	ref.refs[2] = x.BE.ref
	ref.nums[1] = numvalslot(x.BO)
	ref.nums[2] = numvalslot(x.A.tag)
	ref.refs[3] = x.A.ref
	return All{ref}
}

// E returns the E field.
func (x All) E() Expr { return Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]} }

// CE returns the CE field.
func (x All) CE() ConstExpr { return ConstExpr{x.ref.refs[1]} }

// BE returns the BE field.
func (x All) BE() BinExpr { return BinExpr{x.ref.refs[2]} }

// BO returns the BO field.
func (x All) BO() BinOp { return BinOp(x.ref.nums[1]) }

// A returns the A field.
func (x All) A() AllOrExpr { return AllOrExpr{AllOrExprTag(x.ref.nums[2]), x.ref.refs[3]} }

// V unpacks a reference into a value.
func (x All) V() AllValue {
	return AllValue{
		E:  Expr{ExprTag(x.ref.nums[0]), x.ref.refs[0]},
		CE: ConstExpr{x.ref.refs[1]},
		BE: BinExpr{x.ref.refs[2]},
		BO: BinOp(x.ref.nums[1]),
		A:  AllOrExpr{AllOrExprTag(x.ref.nums[2]), x.ref.refs[3]},
	}
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x AllValue) WithE(y Expr) AllValue {
	x.E = y
	return x
}

// WithCE constructs a new value where the value of CE has been replaced by
// the argument.
func (x AllValue) WithCE(y ConstExpr) AllValue {
	x.CE = y
	return x
}

// WithBE constructs a new value where the value of BE has been replaced by
// the argument.
func (x AllValue) WithBE(y BinExpr) AllValue {
	x.BE = y
	return x
}

// WithBO constructs a new value where the value of BO has been replaced by
// the argument.
func (x AllValue) WithBO(y BinOp) AllValue {
	x.BO = y
	return x
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x AllValue) WithA(y AllOrExpr) AllValue {
	x.A = y
	return x
}

// ---- Expr ---- //

// Expr is the type of a tagged union of records.
type Expr struct {
	tag ExprTag
	ref *node
}

// ExprTag is the tag type.
type ExprTag enum

// ExprTag constants.
const (
	ExprConstExpr ExprTag = 1
	ExprBinExpr   ExprTag = 2
)

func (x ExprTag) String() string {
	switch x {
	case ExprConstExpr:
		return "ConstExpr"
	case ExprBinExpr:
		return "BinExpr"
	default:
		return fmt.Sprintf("<unknown ExprTag %d>", x)
	}
}

// Tag returns the tag.
func (x Expr) Tag() ExprTag { return x.tag }

// Expr performs an upcast.
func (x ConstExpr) Expr() Expr { return Expr{ExprConstExpr, x.ref} }

// ConstExpr performs a downcast. If the downcast fails, return false.
func (x Expr) ConstExpr() (ConstExpr, bool) {
	if x.tag != ExprConstExpr {
		return ConstExpr{}, false
	}
	return ConstExpr{x.ref}, true
}

// MustBeConstExpr performs a downcast. If the downcast fails, panic.
func (x Expr) MustBeConstExpr() ConstExpr {
	if x.tag != ExprConstExpr {
		panic(fmt.Sprintf("type assertion failed: expected ConstExpr but got %s", x.tag))
	}
	return ConstExpr{x.ref}
}

// Expr performs an upcast.
func (x BinExpr) Expr() Expr { return Expr{ExprBinExpr, x.ref} }

// BinExpr performs a downcast. If the downcast fails, return false.
func (x Expr) BinExpr() (BinExpr, bool) {
	if x.tag != ExprBinExpr {
		return BinExpr{}, false
	}
	return BinExpr{x.ref}, true
}

// MustBeBinExpr performs a downcast. If the downcast fails, panic.
func (x Expr) MustBeBinExpr() BinExpr {
	if x.tag != ExprBinExpr {
		panic(fmt.Sprintf("type assertion failed: expected BinExpr but got %s", x.tag))
	}
	return BinExpr{x.ref}
}

// ---- AllOrExpr ---- //

// AllOrExpr is the type of a tagged union of records.
type AllOrExpr struct {
	tag AllOrExprTag
	ref *node
}

// AllOrExprTag is the tag type.
type AllOrExprTag enum

// AllOrExprTag constants.
const (
	AllOrExprAll     AllOrExprTag = 1
	AllOrExprBinExpr AllOrExprTag = 2
)

func (x AllOrExprTag) String() string {
	switch x {
	case AllOrExprAll:
		return "All"
	case AllOrExprBinExpr:
		return "BinExpr"
	default:
		return fmt.Sprintf("<unknown AllOrExprTag %d>", x)
	}
}

// Tag returns the tag.
func (x AllOrExpr) Tag() AllOrExprTag { return x.tag }

// AllOrExpr performs an upcast.
func (x All) AllOrExpr() AllOrExpr { return AllOrExpr{AllOrExprAll, x.ref} }

// All performs a downcast. If the downcast fails, return false.
func (x AllOrExpr) All() (All, bool) {
	if x.tag != AllOrExprAll {
		return All{}, false
	}
	return All{x.ref}, true
}

// MustBeAll performs a downcast. If the downcast fails, panic.
func (x AllOrExpr) MustBeAll() All {
	if x.tag != AllOrExprAll {
		panic(fmt.Sprintf("type assertion failed: expected All but got %s", x.tag))
	}
	return All{x.ref}
}

// AllOrExpr performs an upcast.
func (x BinExpr) AllOrExpr() AllOrExpr { return AllOrExpr{AllOrExprBinExpr, x.ref} }

// BinExpr performs a downcast. If the downcast fails, return false.
func (x AllOrExpr) BinExpr() (BinExpr, bool) {
	if x.tag != AllOrExprBinExpr {
		return BinExpr{}, false
	}
	return BinExpr{x.ref}, true
}

// MustBeBinExpr performs a downcast. If the downcast fails, panic.
func (x AllOrExpr) MustBeBinExpr() BinExpr {
	if x.tag != AllOrExprBinExpr {
		panic(fmt.Sprintf("type assertion failed: expected BinExpr but got %s", x.tag))
	}
	return BinExpr{x.ref}
}

// Codegen parameters:
// {NumNumericSlots:10 NumericSlotSize:64 NumRefSlots:10 NumStrSlots:10 Pack:false AllowUnsafe:false}
//
