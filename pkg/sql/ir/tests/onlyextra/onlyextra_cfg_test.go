// Code generated by make. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package onlyextra

import (
	"bytes"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"testing"

	d "github.com/cockroachdb/cockroach/pkg/sql/ir/tests/onlyextra/example/base"
	p "github.com/cockroachdb/cockroach/pkg/sql/ir/tests/onlyextra/prims/base"
)

func makeSampleExpr(a *d.Allocator) d.Expr {
	c1 := d.ConstExprValue{Datum: 1}.R(a).Expr()
	c2 := d.ConstExprValue{Datum: 2}.R(a).Expr()
	c3 := d.ConstExprValue{Datum: 3}.R(a).Expr()
	b4 := d.BinExprValue{Left: c1, Op: d.BinOpAdd, Right: c2}.R(a).Expr()
	b5 := d.BinExprValue{Left: c3, Op: d.BinOpMul, Right: b4}.R(a).Expr()
	return b5
}

func assertEq(t *testing.T, n int, val interface{}, exp interface{}) {
	if !reflect.DeepEqual(val, exp) {
		t.Errorf("equal failed %d: expected %v, got %v", n, exp, val)
	}
}

func TestExprValues(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)
	b5 := e.MustBeBinExpr()
	assertEq(t, 1, b5.Op(), d.BinOpMul)
	assertEq(t, 2, b5.Left().MustBeConstExpr().Datum(), int64(3))
	b4 := b5.Right().MustBeBinExpr()
	assertEq(t, 3, b4.Op(), d.BinOpAdd)
	assertEq(t, 4, b4.Left().MustBeConstExpr().Datum(), int64(1))
	assertEq(t, 5, b4.Right().MustBeConstExpr().Datum(), int64(2))
}

func format(ref d.Expr) string {
	switch ref.Tag() {
	case d.ExprConstExpr:
		c := ref.MustBeConstExpr()
		return strconv.FormatInt(c.Datum(), 10)
	case d.ExprBinExpr:
		b := ref.MustBeBinExpr()
		var op string
		switch b.Op() {
		case d.BinOpAdd:
			op = "+"
		case d.BinOpMul:
			op = "*"
		default:
			panic("unknown BinOp")
		}
		return fmt.Sprintf("(%s %s %s)", format(b.Left()), op, format(b.Right()))
	default:
		panic("unknown Expr tag")
	}
}

func TestExprFormatSExpr(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)

	var buf bytes.Buffer
	e.FormatSExpr(&buf)
	if buf.String() != "(BinExpr Left: (ConstExpr Datum: 3) Op: Mul Right: (BinExpr Left: (ConstExpr Datum: 1) Op: Add Right: (ConstExpr Datum: 2)))" {
		t.Fatalf("unexpected: %q", buf.String())
	}
}

func TestFormat(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)
	const expected = "(3 * (1 + 2))"
	if got := format(e); got != expected {
		t.Fatalf("expected %q but got %q", expected, got)
	}
}

func reverse(ref d.Expr, a *d.Allocator) d.Expr {
	if ref.Tag() != d.ExprBinExpr {
		return ref
	}
	b := ref.MustBeBinExpr()
	revLeft := reverse(b.Left(), a)
	revRight := reverse(b.Right(), a)
	return b.V().WithLeft(revRight).WithRight(revLeft).R(a).Expr()
}

func TestReverse(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)
	const expected = "((2 + 1) * 3)"
	if got := format(reverse(e, a)); got != expected {
		t.Fatalf("expected %q but got %q", expected, got)
	}
}

func TestDoubleReverse(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)
	if got0, got2 := format(e), format(reverse(reverse(e, a), a)); got0 != got2 {
		t.Fatalf("reverse is not an involution: %q != %q", got0, got2)
	}
}

func deepEqual(ref1 d.Expr, ref2 d.Expr) bool {
	if ref1.Tag() != ref2.Tag() {
		return false
	}
	switch ref1.Tag() {
	case d.ExprConstExpr:
		return ref1.MustBeConstExpr().Datum() == ref2.MustBeConstExpr().Datum()
	case d.ExprBinExpr:
		b1 := ref1.MustBeBinExpr()
		b2 := ref2.MustBeBinExpr()
		return b1.Op() == b2.Op() &&
			deepEqual(b1.Left(), b2.Left()) && deepEqual(b1.Right(), b2.Right())
	default:
		panic("unknown Expr tag")
	}
}

func TestDeepEqual(t *testing.T) {
	a := d.NewAllocator()
	e := makeSampleExpr(a)
	if deepEqual(e, reverse(e, a)) {
		t.Fatalf("expected expression not to be deepEqual to its reverse")
	}
	if !deepEqual(e, reverse(reverse(e, a), a)) {
		t.Fatalf("expected expression to be deepEqual to the reverse of its reverse")
	}
}

func TestPrimValues(t *testing.T) {
	a := p.NewAllocator()
	all := p.AllValue{
		B:   true,
		I8:  'b',
		U8:  'c',
		I16: 0x1234,
		U16: 0x4321,
		I32: 0x12345678,
		U32: 0x87654321,
		I64: 0x123456789abcdef0,
		U64: 0x0fedcba987654321,
		S:   "k",
		F32: 1.234,
		F64: 5.678,
	}.R(a)
	assertEq(t, 1, all.B(), true)
	assertEq(t, 2, all.I8(), int8('b'))
	assertEq(t, 3, all.U8(), uint8('c'))
	assertEq(t, 4, all.I16(), int16(0x1234))
	assertEq(t, 5, all.U16(), uint16(0x4321))
	assertEq(t, 6, all.I32(), int32(0x12345678))
	assertEq(t, 7, all.U32(), uint32(0x87654321))
	assertEq(t, 8, all.I64(), int64(0x123456789abcdef0))
	assertEq(t, 9, all.U64(), uint64(0x0fedcba987654321))
	assertEq(t, 10, all.S(), "k")
	assertEq(t, 11, all.F32(), float32(1.234))
	assertEq(t, 12, all.F64(), float64(5.678))

	var buf bytes.Buffer
	all.FormatSExpr(&buf)
	assertEq(t, 100, buf.String(), strings.TrimSpace(`
(All B: true I8: 98 U8: 99 I16: 4660 U16: 17185 I32: 305419896 U32: 2271560481 I64: 1311768467463790320 U64: 1147797409030816545 S: "k" F32: 1.234 F64: 5.678)
`))
}

func TestPrimValues2(t *testing.T) {
	a := p.NewAllocator()
	v := p.SmallBeforeValue{
		A: true,
		B: false,
		C: 'c',
		D: 'd',
		E: 'e',
		F: 0x1234,
		G: 0x4321,
		H: 0x12345678,
		I: 0x123456789abcdef0,
	}.R(a)
	assertEq(t, 1, v.A(), true)
	assertEq(t, 2, v.B(), false)
	assertEq(t, 3, v.C(), uint8('c'))
	assertEq(t, 4, v.D(), uint8('d'))
	assertEq(t, 5, v.E(), uint8('e'))
	assertEq(t, 6, v.F(), uint16(0x1234))
	assertEq(t, 7, v.G(), uint16(0x4321))
	assertEq(t, 8, v.H(), uint32(0x12345678))
	assertEq(t, 9, v.I(), uint64(0x123456789abcdef0))

	var buf bytes.Buffer
	v.FormatSExpr(&buf)
	assertEq(t, 100, buf.String(), strings.TrimSpace(`
(SmallBefore A: true B: false C: 99 D: 100 E: 101 F: 4660 G: 17185 H: 305419896 I: 1311768467463790320)
`))
}

func TestPrimValues3(t *testing.T) {
	a := p.NewAllocator()
	v := p.BigBeforeValue{
		A: 0x123456789abcdef0,
		B: 0x12345678,
		C: 0x1234,
		D: 0x4321,
		E: 'e',
		F: 'f',
		G: 'g',
		H: false,
		I: true,
	}.R(a)
	assertEq(t, 1, v.A(), uint64(0x123456789abcdef0))
	assertEq(t, 2, v.B(), uint32(0x12345678))
	assertEq(t, 3, v.C(), uint16(0x1234))
	assertEq(t, 4, v.D(), uint16(0x4321))
	assertEq(t, 5, v.E(), uint8('e'))
	assertEq(t, 6, v.F(), uint8('f'))
	assertEq(t, 7, v.G(), uint8('g'))
	assertEq(t, 8, v.H(), false)
	assertEq(t, 9, v.I(), true)

	var buf bytes.Buffer
	v.FormatSExpr(&buf)
	assertEq(t, 100, buf.String(), strings.TrimSpace(`
(BigBefore A: 1311768467463790320 B: 305419896 C: 4660 D: 17185 E: 101 F: 102 G: 103 H: false I: true)
`))
}
