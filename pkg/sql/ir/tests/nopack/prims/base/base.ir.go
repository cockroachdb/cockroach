// Code generated by irgen/irgen base/base.tmpl.go tests/prims.def. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package base

// node is a generic ADT node type, with slots for references to other nodes and
// enumeration values. Values that don't fit and values of other types go in the
// extra field.
type node struct {
	refs [2]*node
	nums [2]numvalslot
	strs [1]string
	extra
}

// enum is the type to define the tag part for working copies of IR
// node with sum and enum types.
type enum uint32

// numvalslot is the type used to store integer values in persistent IR nodes.
// must be larger than or as large as enum.
type numvalslot uint64

type extra interface {
	extraRefs() []*node
}

// Allocator allocates nodes in batches. Construct Allocators with NewAllocator
// and pass them by value.
type Allocator struct {
	nodes []node
}

// MakeAllocator constructs a new Allocator.
func MakeAllocator() Allocator {
	nodes := make([]node, 16)
	return Allocator{nodes}
}

// NewAllocator allocates a new Allocator.
func NewAllocator() *Allocator {
	a := MakeAllocator()
	return &a
}

// new allocates a new node. Users of this package should use the appropriate
// R() method, which is type safe.
func (a *Allocator) new() *node {
	nodes := a.nodes
	if len(nodes) == 0 {
		nodes = make([]node, 256)
	}
	x := &nodes[0]
	a.nodes = nodes[1:]
	return x
}

// ---- All ---- //

// All is the type of a reference to an immutable record.
type All struct{ ref *node }

const All_Slot_B_Type = 1
const All_Slot_B_Num = 0
const All_Slot_B_BitSize = 64
const All_Slot_B_BitOffset = 0
const All_Slot_B_ByteSize = 8
const All_Slot_B_ByteOffset = 0
const All_Slot_B_ValueMask = 0xffffffffffffffff

const All_Slot_F32_Type = 3
const All_Slot_F32_Num = -1
const All_Slot_F32_BitSize = -1
const All_Slot_F32_BitOffset = -1
const All_Slot_F32_ByteSize = -1
const All_Slot_F32_ByteOffset = -1
const All_Slot_F32_ValueMask = -1

const All_Slot_F64_Type = 3
const All_Slot_F64_Num = -1
const All_Slot_F64_BitSize = -1
const All_Slot_F64_BitOffset = -1
const All_Slot_F64_ByteSize = -1
const All_Slot_F64_ByteOffset = -1
const All_Slot_F64_ValueMask = -1

const All_Slot_I16_Type = 3
const All_Slot_I16_Num = -1
const All_Slot_I16_BitSize = -1
const All_Slot_I16_BitOffset = -1
const All_Slot_I16_ByteSize = -1
const All_Slot_I16_ByteOffset = -1
const All_Slot_I16_ValueMask = -1

const All_Slot_I32_Type = 3
const All_Slot_I32_Num = -1
const All_Slot_I32_BitSize = -1
const All_Slot_I32_BitOffset = -1
const All_Slot_I32_ByteSize = -1
const All_Slot_I32_ByteOffset = -1
const All_Slot_I32_ValueMask = -1

const All_Slot_I64_Type = 3
const All_Slot_I64_Num = -1
const All_Slot_I64_BitSize = -1
const All_Slot_I64_BitOffset = -1
const All_Slot_I64_ByteSize = -1
const All_Slot_I64_ByteOffset = -1
const All_Slot_I64_ValueMask = -1

const All_Slot_I8_Type = 1
const All_Slot_I8_Num = 1
const All_Slot_I8_BitSize = 64
const All_Slot_I8_BitOffset = 0
const All_Slot_I8_ByteSize = 8
const All_Slot_I8_ByteOffset = 0
const All_Slot_I8_ValueMask = 0xffffffffffffffff

const All_Slot_S_Type = 2
const All_Slot_S_Num = 0
const All_Slot_S_BitSize = -1
const All_Slot_S_BitOffset = -1
const All_Slot_S_ByteSize = -1
const All_Slot_S_ByteOffset = -1
const All_Slot_S_ValueMask = -1

const All_Slot_U16_Type = 3
const All_Slot_U16_Num = -1
const All_Slot_U16_BitSize = -1
const All_Slot_U16_BitOffset = -1
const All_Slot_U16_ByteSize = -1
const All_Slot_U16_ByteOffset = -1
const All_Slot_U16_ValueMask = -1

const All_Slot_U32_Type = 3
const All_Slot_U32_Num = -1
const All_Slot_U32_BitSize = -1
const All_Slot_U32_BitOffset = -1
const All_Slot_U32_ByteSize = -1
const All_Slot_U32_ByteOffset = -1
const All_Slot_U32_ValueMask = -1

const All_Slot_U64_Type = 3
const All_Slot_U64_Num = -1
const All_Slot_U64_BitSize = -1
const All_Slot_U64_BitOffset = -1
const All_Slot_U64_ByteSize = -1
const All_Slot_U64_ByteOffset = -1
const All_Slot_U64_ValueMask = -1

const All_Slot_U8_Type = 3
const All_Slot_U8_Num = -1
const All_Slot_U8_BitSize = -1
const All_Slot_U8_BitOffset = -1
const All_Slot_U8_ByteSize = -1
const All_Slot_U8_ByteOffset = -1
const All_Slot_U8_ValueMask = -1

// AllValue is the logical type of a record. Immutable records are stored in
// nodes.
type AllValue struct {
	B   bool    // 1
	I8  int8    // 2
	U8  uint8   // 3
	I16 int16   // 4
	U16 uint16  // 5
	I32 int32   // 6
	U32 uint32  // 7
	I64 int64   // 8
	U64 uint64  // 9
	S   string  // 10
	F32 float32 // 11
	F64 float64 // 12
}

type extraAll struct {
	U8  uint8
	I16 int16
	U16 uint16
	I32 int32
	U32 uint32
	I64 int64
	U64 uint64
	F32 float32
	F64 float64
}

func (x extraAll) extraRefs() []*node { return nil }

// R constructs a reference to an immutable record.
func (x AllValue) R(a *Allocator) All {
	ref := a.new()
	extra := &extraAll{}
	ref.extra = extra

	if x.B {
		ref.nums[0] = 1
	} else {
		ref.nums[0] = 0
	}
	ref.nums[1] = numvalslot(x.I8)
	extra.U8 = x.U8
	extra.I16 = x.I16
	extra.U16 = x.U16
	extra.I32 = x.I32
	extra.U32 = x.U32
	extra.I64 = x.I64
	extra.U64 = x.U64
	ref.strs[0] = x.S
	extra.F32 = x.F32
	extra.F64 = x.F64
	return All{ref}
}

// B returns the B field.
func (x All) B() bool { return !(0 == x.ref.nums[0]) }

// I8 returns the I8 field.
func (x All) I8() int8 { return int8(x.ref.nums[1]) }

// U8 returns the U8 field.
func (x All) U8() uint8 { return x.ref.extra.(*extraAll).U8 }

// I16 returns the I16 field.
func (x All) I16() int16 { return x.ref.extra.(*extraAll).I16 }

// U16 returns the U16 field.
func (x All) U16() uint16 { return x.ref.extra.(*extraAll).U16 }

// I32 returns the I32 field.
func (x All) I32() int32 { return x.ref.extra.(*extraAll).I32 }

// U32 returns the U32 field.
func (x All) U32() uint32 { return x.ref.extra.(*extraAll).U32 }

// I64 returns the I64 field.
func (x All) I64() int64 { return x.ref.extra.(*extraAll).I64 }

// U64 returns the U64 field.
func (x All) U64() uint64 { return x.ref.extra.(*extraAll).U64 }

// S returns the S field.
func (x All) S() string { return x.ref.strs[0] }

// F32 returns the F32 field.
func (x All) F32() float32 { return x.ref.extra.(*extraAll).F32 }

// F64 returns the F64 field.
func (x All) F64() float64 { return x.ref.extra.(*extraAll).F64 }

// V unpacks a reference into a value.
func (x All) V() AllValue {
	return AllValue{
		B:   !(0 == x.ref.nums[0]),
		I8:  int8(x.ref.nums[1]),
		U8:  x.ref.extra.(*extraAll).U8,
		I16: x.ref.extra.(*extraAll).I16,
		U16: x.ref.extra.(*extraAll).U16,
		I32: x.ref.extra.(*extraAll).I32,
		U32: x.ref.extra.(*extraAll).U32,
		I64: x.ref.extra.(*extraAll).I64,
		U64: x.ref.extra.(*extraAll).U64,
		S:   x.ref.strs[0],
		F32: x.ref.extra.(*extraAll).F32,
		F64: x.ref.extra.(*extraAll).F64,
	}
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x AllValue) WithB(y bool) AllValue {
	x.B = y
	return x
}

// WithI8 constructs a new value where the value of I8 has been replaced by
// the argument.
func (x AllValue) WithI8(y int8) AllValue {
	x.I8 = y
	return x
}

// WithU8 constructs a new value where the value of U8 has been replaced by
// the argument.
func (x AllValue) WithU8(y uint8) AllValue {
	x.U8 = y
	return x
}

// WithI16 constructs a new value where the value of I16 has been replaced by
// the argument.
func (x AllValue) WithI16(y int16) AllValue {
	x.I16 = y
	return x
}

// WithU16 constructs a new value where the value of U16 has been replaced by
// the argument.
func (x AllValue) WithU16(y uint16) AllValue {
	x.U16 = y
	return x
}

// WithI32 constructs a new value where the value of I32 has been replaced by
// the argument.
func (x AllValue) WithI32(y int32) AllValue {
	x.I32 = y
	return x
}

// WithU32 constructs a new value where the value of U32 has been replaced by
// the argument.
func (x AllValue) WithU32(y uint32) AllValue {
	x.U32 = y
	return x
}

// WithI64 constructs a new value where the value of I64 has been replaced by
// the argument.
func (x AllValue) WithI64(y int64) AllValue {
	x.I64 = y
	return x
}

// WithU64 constructs a new value where the value of U64 has been replaced by
// the argument.
func (x AllValue) WithU64(y uint64) AllValue {
	x.U64 = y
	return x
}

// WithS constructs a new value where the value of S has been replaced by
// the argument.
func (x AllValue) WithS(y string) AllValue {
	x.S = y
	return x
}

// WithF32 constructs a new value where the value of F32 has been replaced by
// the argument.
func (x AllValue) WithF32(y float32) AllValue {
	x.F32 = y
	return x
}

// WithF64 constructs a new value where the value of F64 has been replaced by
// the argument.
func (x AllValue) WithF64(y float64) AllValue {
	x.F64 = y
	return x
}

// ---- SmallBefore ---- //

// SmallBefore is the type of a reference to an immutable record.
type SmallBefore struct{ ref *node }

const SmallBefore_Slot_A_Type = 1
const SmallBefore_Slot_A_Num = 0
const SmallBefore_Slot_A_BitSize = 64
const SmallBefore_Slot_A_BitOffset = 0
const SmallBefore_Slot_A_ByteSize = 8
const SmallBefore_Slot_A_ByteOffset = 0
const SmallBefore_Slot_A_ValueMask = 0xffffffffffffffff

const SmallBefore_Slot_B_Type = 1
const SmallBefore_Slot_B_Num = 1
const SmallBefore_Slot_B_BitSize = 64
const SmallBefore_Slot_B_BitOffset = 0
const SmallBefore_Slot_B_ByteSize = 8
const SmallBefore_Slot_B_ByteOffset = 0
const SmallBefore_Slot_B_ValueMask = 0xffffffffffffffff

const SmallBefore_Slot_C_Type = 3
const SmallBefore_Slot_C_Num = -1
const SmallBefore_Slot_C_BitSize = -1
const SmallBefore_Slot_C_BitOffset = -1
const SmallBefore_Slot_C_ByteSize = -1
const SmallBefore_Slot_C_ByteOffset = -1
const SmallBefore_Slot_C_ValueMask = -1

const SmallBefore_Slot_D_Type = 3
const SmallBefore_Slot_D_Num = -1
const SmallBefore_Slot_D_BitSize = -1
const SmallBefore_Slot_D_BitOffset = -1
const SmallBefore_Slot_D_ByteSize = -1
const SmallBefore_Slot_D_ByteOffset = -1
const SmallBefore_Slot_D_ValueMask = -1

const SmallBefore_Slot_E_Type = 3
const SmallBefore_Slot_E_Num = -1
const SmallBefore_Slot_E_BitSize = -1
const SmallBefore_Slot_E_BitOffset = -1
const SmallBefore_Slot_E_ByteSize = -1
const SmallBefore_Slot_E_ByteOffset = -1
const SmallBefore_Slot_E_ValueMask = -1

const SmallBefore_Slot_F_Type = 3
const SmallBefore_Slot_F_Num = -1
const SmallBefore_Slot_F_BitSize = -1
const SmallBefore_Slot_F_BitOffset = -1
const SmallBefore_Slot_F_ByteSize = -1
const SmallBefore_Slot_F_ByteOffset = -1
const SmallBefore_Slot_F_ValueMask = -1

const SmallBefore_Slot_G_Type = 3
const SmallBefore_Slot_G_Num = -1
const SmallBefore_Slot_G_BitSize = -1
const SmallBefore_Slot_G_BitOffset = -1
const SmallBefore_Slot_G_ByteSize = -1
const SmallBefore_Slot_G_ByteOffset = -1
const SmallBefore_Slot_G_ValueMask = -1

const SmallBefore_Slot_H_Type = 3
const SmallBefore_Slot_H_Num = -1
const SmallBefore_Slot_H_BitSize = -1
const SmallBefore_Slot_H_BitOffset = -1
const SmallBefore_Slot_H_ByteSize = -1
const SmallBefore_Slot_H_ByteOffset = -1
const SmallBefore_Slot_H_ValueMask = -1

const SmallBefore_Slot_I_Type = 3
const SmallBefore_Slot_I_Num = -1
const SmallBefore_Slot_I_BitSize = -1
const SmallBefore_Slot_I_BitOffset = -1
const SmallBefore_Slot_I_ByteSize = -1
const SmallBefore_Slot_I_ByteOffset = -1
const SmallBefore_Slot_I_ValueMask = -1

// SmallBeforeValue is the logical type of a record. Immutable records are stored in
// nodes.
type SmallBeforeValue struct {
	A bool   // 1
	B bool   // 2
	C uint8  // 3
	D uint8  // 4
	E uint8  // 5
	F uint16 // 6
	G uint16 // 7
	H uint32 // 8
	I uint64 // 9
}

type extraSmallBefore struct {
	C uint8
	D uint8
	E uint8
	F uint16
	G uint16
	H uint32
	I uint64
}

func (x extraSmallBefore) extraRefs() []*node { return nil }

// R constructs a reference to an immutable record.
func (x SmallBeforeValue) R(a *Allocator) SmallBefore {
	ref := a.new()
	extra := &extraSmallBefore{}
	ref.extra = extra

	if x.A {
		ref.nums[0] = 1
	} else {
		ref.nums[0] = 0
	}
	if x.B {
		ref.nums[1] = 1
	} else {
		ref.nums[1] = 0
	}
	extra.C = x.C
	extra.D = x.D
	extra.E = x.E
	extra.F = x.F
	extra.G = x.G
	extra.H = x.H
	extra.I = x.I
	return SmallBefore{ref}
}

// A returns the A field.
func (x SmallBefore) A() bool { return !(0 == x.ref.nums[0]) }

// B returns the B field.
func (x SmallBefore) B() bool { return !(0 == x.ref.nums[1]) }

// C returns the C field.
func (x SmallBefore) C() uint8 { return x.ref.extra.(*extraSmallBefore).C }

// D returns the D field.
func (x SmallBefore) D() uint8 { return x.ref.extra.(*extraSmallBefore).D }

// E returns the E field.
func (x SmallBefore) E() uint8 { return x.ref.extra.(*extraSmallBefore).E }

// F returns the F field.
func (x SmallBefore) F() uint16 { return x.ref.extra.(*extraSmallBefore).F }

// G returns the G field.
func (x SmallBefore) G() uint16 { return x.ref.extra.(*extraSmallBefore).G }

// H returns the H field.
func (x SmallBefore) H() uint32 { return x.ref.extra.(*extraSmallBefore).H }

// I returns the I field.
func (x SmallBefore) I() uint64 { return x.ref.extra.(*extraSmallBefore).I }

// V unpacks a reference into a value.
func (x SmallBefore) V() SmallBeforeValue {
	return SmallBeforeValue{
		A: !(0 == x.ref.nums[0]),
		B: !(0 == x.ref.nums[1]),
		C: x.ref.extra.(*extraSmallBefore).C,
		D: x.ref.extra.(*extraSmallBefore).D,
		E: x.ref.extra.(*extraSmallBefore).E,
		F: x.ref.extra.(*extraSmallBefore).F,
		G: x.ref.extra.(*extraSmallBefore).G,
		H: x.ref.extra.(*extraSmallBefore).H,
		I: x.ref.extra.(*extraSmallBefore).I,
	}
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x SmallBeforeValue) WithA(y bool) SmallBeforeValue {
	x.A = y
	return x
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x SmallBeforeValue) WithB(y bool) SmallBeforeValue {
	x.B = y
	return x
}

// WithC constructs a new value where the value of C has been replaced by
// the argument.
func (x SmallBeforeValue) WithC(y uint8) SmallBeforeValue {
	x.C = y
	return x
}

// WithD constructs a new value where the value of D has been replaced by
// the argument.
func (x SmallBeforeValue) WithD(y uint8) SmallBeforeValue {
	x.D = y
	return x
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x SmallBeforeValue) WithE(y uint8) SmallBeforeValue {
	x.E = y
	return x
}

// WithF constructs a new value where the value of F has been replaced by
// the argument.
func (x SmallBeforeValue) WithF(y uint16) SmallBeforeValue {
	x.F = y
	return x
}

// WithG constructs a new value where the value of G has been replaced by
// the argument.
func (x SmallBeforeValue) WithG(y uint16) SmallBeforeValue {
	x.G = y
	return x
}

// WithH constructs a new value where the value of H has been replaced by
// the argument.
func (x SmallBeforeValue) WithH(y uint32) SmallBeforeValue {
	x.H = y
	return x
}

// WithI constructs a new value where the value of I has been replaced by
// the argument.
func (x SmallBeforeValue) WithI(y uint64) SmallBeforeValue {
	x.I = y
	return x
}

// ---- BigBefore ---- //

// BigBefore is the type of a reference to an immutable record.
type BigBefore struct{ ref *node }

const BigBefore_Slot_A_Type = 1
const BigBefore_Slot_A_Num = 0
const BigBefore_Slot_A_BitSize = 64
const BigBefore_Slot_A_BitOffset = 0
const BigBefore_Slot_A_ByteSize = 8
const BigBefore_Slot_A_ByteOffset = 0
const BigBefore_Slot_A_ValueMask = 0xffffffffffffffff

const BigBefore_Slot_B_Type = 1
const BigBefore_Slot_B_Num = 1
const BigBefore_Slot_B_BitSize = 64
const BigBefore_Slot_B_BitOffset = 0
const BigBefore_Slot_B_ByteSize = 8
const BigBefore_Slot_B_ByteOffset = 0
const BigBefore_Slot_B_ValueMask = 0xffffffffffffffff

const BigBefore_Slot_C_Type = 3
const BigBefore_Slot_C_Num = -1
const BigBefore_Slot_C_BitSize = -1
const BigBefore_Slot_C_BitOffset = -1
const BigBefore_Slot_C_ByteSize = -1
const BigBefore_Slot_C_ByteOffset = -1
const BigBefore_Slot_C_ValueMask = -1

const BigBefore_Slot_D_Type = 3
const BigBefore_Slot_D_Num = -1
const BigBefore_Slot_D_BitSize = -1
const BigBefore_Slot_D_BitOffset = -1
const BigBefore_Slot_D_ByteSize = -1
const BigBefore_Slot_D_ByteOffset = -1
const BigBefore_Slot_D_ValueMask = -1

const BigBefore_Slot_E_Type = 3
const BigBefore_Slot_E_Num = -1
const BigBefore_Slot_E_BitSize = -1
const BigBefore_Slot_E_BitOffset = -1
const BigBefore_Slot_E_ByteSize = -1
const BigBefore_Slot_E_ByteOffset = -1
const BigBefore_Slot_E_ValueMask = -1

const BigBefore_Slot_F_Type = 3
const BigBefore_Slot_F_Num = -1
const BigBefore_Slot_F_BitSize = -1
const BigBefore_Slot_F_BitOffset = -1
const BigBefore_Slot_F_ByteSize = -1
const BigBefore_Slot_F_ByteOffset = -1
const BigBefore_Slot_F_ValueMask = -1

const BigBefore_Slot_G_Type = 3
const BigBefore_Slot_G_Num = -1
const BigBefore_Slot_G_BitSize = -1
const BigBefore_Slot_G_BitOffset = -1
const BigBefore_Slot_G_ByteSize = -1
const BigBefore_Slot_G_ByteOffset = -1
const BigBefore_Slot_G_ValueMask = -1

const BigBefore_Slot_H_Type = 3
const BigBefore_Slot_H_Num = -1
const BigBefore_Slot_H_BitSize = -1
const BigBefore_Slot_H_BitOffset = -1
const BigBefore_Slot_H_ByteSize = -1
const BigBefore_Slot_H_ByteOffset = -1
const BigBefore_Slot_H_ValueMask = -1

const BigBefore_Slot_I_Type = 3
const BigBefore_Slot_I_Num = -1
const BigBefore_Slot_I_BitSize = -1
const BigBefore_Slot_I_BitOffset = -1
const BigBefore_Slot_I_ByteSize = -1
const BigBefore_Slot_I_ByteOffset = -1
const BigBefore_Slot_I_ValueMask = -1

// BigBeforeValue is the logical type of a record. Immutable records are stored in
// nodes.
type BigBeforeValue struct {
	A uint64 // 1
	B uint32 // 2
	C uint16 // 3
	D uint16 // 4
	E uint8  // 5
	F uint8  // 6
	G uint8  // 7
	H bool   // 8
	I bool   // 9
}

type extraBigBefore struct {
	C uint16
	D uint16
	E uint8
	F uint8
	G uint8
	H bool
	I bool
}

func (x extraBigBefore) extraRefs() []*node { return nil }

// R constructs a reference to an immutable record.
func (x BigBeforeValue) R(a *Allocator) BigBefore {
	ref := a.new()
	extra := &extraBigBefore{}
	ref.extra = extra

	ref.nums[0] = numvalslot(x.A)
	ref.nums[1] = numvalslot(x.B)
	extra.C = x.C
	extra.D = x.D
	extra.E = x.E
	extra.F = x.F
	extra.G = x.G
	extra.H = x.H
	extra.I = x.I
	return BigBefore{ref}
}

// A returns the A field.
func (x BigBefore) A() uint64 { return uint64(x.ref.nums[0]) }

// B returns the B field.
func (x BigBefore) B() uint32 { return uint32(x.ref.nums[1]) }

// C returns the C field.
func (x BigBefore) C() uint16 { return x.ref.extra.(*extraBigBefore).C }

// D returns the D field.
func (x BigBefore) D() uint16 { return x.ref.extra.(*extraBigBefore).D }

// E returns the E field.
func (x BigBefore) E() uint8 { return x.ref.extra.(*extraBigBefore).E }

// F returns the F field.
func (x BigBefore) F() uint8 { return x.ref.extra.(*extraBigBefore).F }

// G returns the G field.
func (x BigBefore) G() uint8 { return x.ref.extra.(*extraBigBefore).G }

// H returns the H field.
func (x BigBefore) H() bool { return x.ref.extra.(*extraBigBefore).H }

// I returns the I field.
func (x BigBefore) I() bool { return x.ref.extra.(*extraBigBefore).I }

// V unpacks a reference into a value.
func (x BigBefore) V() BigBeforeValue {
	return BigBeforeValue{
		A: uint64(x.ref.nums[0]),
		B: uint32(x.ref.nums[1]),
		C: x.ref.extra.(*extraBigBefore).C,
		D: x.ref.extra.(*extraBigBefore).D,
		E: x.ref.extra.(*extraBigBefore).E,
		F: x.ref.extra.(*extraBigBefore).F,
		G: x.ref.extra.(*extraBigBefore).G,
		H: x.ref.extra.(*extraBigBefore).H,
		I: x.ref.extra.(*extraBigBefore).I,
	}
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x BigBeforeValue) WithA(y uint64) BigBeforeValue {
	x.A = y
	return x
}

// WithB constructs a new value where the value of B has been replaced by
// the argument.
func (x BigBeforeValue) WithB(y uint32) BigBeforeValue {
	x.B = y
	return x
}

// WithC constructs a new value where the value of C has been replaced by
// the argument.
func (x BigBeforeValue) WithC(y uint16) BigBeforeValue {
	x.C = y
	return x
}

// WithD constructs a new value where the value of D has been replaced by
// the argument.
func (x BigBeforeValue) WithD(y uint16) BigBeforeValue {
	x.D = y
	return x
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x BigBeforeValue) WithE(y uint8) BigBeforeValue {
	x.E = y
	return x
}

// WithF constructs a new value where the value of F has been replaced by
// the argument.
func (x BigBeforeValue) WithF(y uint8) BigBeforeValue {
	x.F = y
	return x
}

// WithG constructs a new value where the value of G has been replaced by
// the argument.
func (x BigBeforeValue) WithG(y uint8) BigBeforeValue {
	x.G = y
	return x
}

// WithH constructs a new value where the value of H has been replaced by
// the argument.
func (x BigBeforeValue) WithH(y bool) BigBeforeValue {
	x.H = y
	return x
}

// WithI constructs a new value where the value of I has been replaced by
// the argument.
func (x BigBeforeValue) WithI(y bool) BigBeforeValue {
	x.I = y
	return x
}

// Codegen parameters:
// {NumNumericSlots:2 NumericSlotSize:64 NumRefSlots:2 NumStrSlots:1 Pack:false}
//
