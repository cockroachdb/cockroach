// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/pkg/errors"

	"github.com/cockroachdb/cockroach/pkg/sql/ir/irgen/analyzer"
	"github.com/cockroachdb/cockroach/pkg/sql/ir/irgen/codegen"
	"github.com/cockroachdb/cockroach/pkg/sql/ir/irgen/parser"
	"github.com/cockroachdb/cockroach/pkg/sql/ir/irgen/template"
)

// irgen loads one or more language definitions and uses the specified
// template file to generate the corresponding code. The languages
// are instantiated together in the output file.
func irgen() error {
	cfg, args := getParams()
	if len(args) < 2 {
		return errors.Errorf("usage: %s template definitions...", args[0])
	}

	// Get the template.
	tmpl, err := openTemplate(args[1])
	if err != nil {
		return err
	}

	// Get the languages.
	languages, err := loadLanguages(args[2:])
	if err != nil {
		return err
	}

	// Generate the code.

	// First comment for github/Go; second for reviewable.
	// https://github.com/golang/go/issues/13560#issuecomment-277804473
	// https://github.com/Reviewable/Reviewable/wiki/FAQ#how-do-i-tell-reviewable-that-a-file-is-generated-and-should-not-be-reviewed
	fmt.Printf("// Code generated by %s. DO NOT EDIT.\n// GENERATED FILE DO NOT EDIT\n",
		strings.Join(args, " "))
	err = cfg.Generate(os.Stdout, tmpl, languages...)
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Codegen parameters:\n%+v\n", cfg)
	fmt.Print(strings.Replace(buf.String(), "\n", "\n// ", -1))
	return err
}

// loadLanguages analyzes the input language definition files, controls the definitions
// and returns the language definitions for each of them.
func loadLanguages(files []string) ([]codegen.LanguageDef, error) {
	var languages []codegen.LanguageDef
	for _, name := range files {
		// Parse the language definition input file into a language
		// definition AST.
		defs, err := func() ([]parser.Def, error) {
			f, err := os.Open(name)
			if err != nil {
				return nil, err
			}
			defer f.Close()
			return parser.Parse(name, f)
		}()
		if err != nil {
			return nil, err
		}

		// Every language starts with all primitive types.
		defs = append(codegen.Pervasives, defs...)

		// Analyze the semantics.
		namedTypes, err := analyzer.Analyze(defs)
		if err != nil {
			return nil, err
		}
		languages = append(languages, codegen.LanguageDef(namedTypes))
	}
	return languages, nil
}

// getParams analyzes the command line and retrieves the codegen parameters and
// files to analyze.
func getParams() (cfg codegen.Config, files []string) {
	cfg = codegen.DefaultConfig
	flag.BoolVar(&cfg.Pack, "pack", cfg.Pack, "pack multiple numeric values per numeric slot (less memory usage)")
	flag.BoolVar(&cfg.AllowUnsafe, "allow-unsafe", cfg.AllowUnsafe, "allow storing float values in numeric slots (uses unsafe casts, likely incompatible with Big Endian systems)")
	flag.IntVar(&cfg.NumericSlotSize, "num-slot-size", cfg.NumericSlotSize, "number of bits per numeric slot (must be power of two)")
	flag.IntVar(&cfg.NumNumericSlots, "nums", cfg.NumNumericSlots, "number of embedded numeric slots (set to 0 to disable)")
	flag.IntVar(&cfg.NumRefSlots, "refs", cfg.NumRefSlots, "number of embedded reference slots (set to 0 to disable)")
	flag.IntVar(&cfg.NumStrSlots, "strs", cfg.NumStrSlots, "number of embedded string slots (set to 0 to disable)")

	flag.Parse()
	args := flag.Args()

	// The flag package forgets about argv[0], but we like it for error
	// messages. Keep it.
	args = append([]string{os.Args[0]}, args...)

	return cfg, args
}

// openTemplate instantiates a template.Template object from the given
// file name.
func openTemplate(tmplName string) (*template.Template, error) {
	f, err := os.Open(tmplName)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return template.Parse(f)
}

func main() {
	if err := irgen(); err != nil {
		fmt.Fprintf(os.Stderr, "%s: %s\n", os.Args[0], err)
		os.Exit(1)
	}
}
