// Code generated by irgen/irgen base/base.tmpl.go example.def. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
// Copyright 2017 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package base

import "fmt"

// node is a generic ADT node type, with slots for references to other nodes and
// enumeration values. Values that don't fit and values of other types go in the
// extra field.
type node struct {
	refs  [1]*node
	enums [2]enum
	extra
}

type enum int32

type extra interface {
	extraRefs() []*node
}

// Allocator allocates nodes in batches. Construct Allocators with NewAllocator
// and pass them by value.
type Allocator struct {
	nodes *[]node
}

// NewAllocator constructs a new Allocator.
func NewAllocator() Allocator {
	nodes := make([]node, 16)
	return Allocator{&nodes}
}

// new allocates a new node. Users of this package should use the appropriate
// R() method, which is type safe.
func (a Allocator) new() *node {
	nodes := *a.nodes
	if len(nodes) == 0 {
		nodes = make([]node, 256)
	}
	x := &nodes[0]
	*a.nodes = nodes[1:]
	return x
}

// ---- BinOp ---- //

// BinOp is an enumeration type.
type BinOp enum

// BinOp constants.
const (
	BinOpAdd BinOp = 1
	BinOpMul BinOp = 2
)

func (x BinOp) String() string {
	switch x {
	case BinOpAdd:
		return "Add"
	case BinOpMul:
		return "Mul"
	default:
		return fmt.Sprintf("<unknown BinOp %d>", x)
	}
}

// ---- ConstExpr ---- //

// ConstExpr is the type of a reference to an immutable record.
type ConstExpr struct{ ref *node }

// ConstExprValue is the logical type of a record. Immutable records are stored in
// nodes.
type ConstExprValue struct {
	Datum int64 // 1
}

type extraConstExpr struct {
	Datum int64
}

func (x extraConstExpr) extraRefs() []*node { return nil }

// R constructs a reference to an immutable record.
func (x ConstExprValue) R(a Allocator) ConstExpr {
	ref := a.new()
	extra := &extraConstExpr{}
	ref.extra = extra

	extra.Datum = x.Datum
	return ConstExpr{ref}
}

// Datum returns the Datum field.
func (x ConstExpr) Datum() int64 { return x.ref.extra.(*extraConstExpr).Datum }

// V unpacks a reference into a value.
func (x ConstExpr) V() ConstExprValue {
	return ConstExprValue{
		x.ref.extra.(*extraConstExpr).Datum,
	}
}

// WithDatum constructs a new value where the value of Datum has been replaced by
// the argument.
func (x ConstExprValue) WithDatum(y int64) ConstExprValue {
	x.Datum = y
	return x
}

// ---- BinExpr ---- //

// BinExpr is the type of a reference to an immutable record.
type BinExpr struct{ ref *node }

// BinExprValue is the logical type of a record. Immutable records are stored in
// nodes.
type BinExprValue struct {
	Left  Expr  // 1
	Op    BinOp // 2
	Right Expr  // 3
}

type extraBinExpr struct {
	Right ExprTag
	refs  [1]*node
}

func (x extraBinExpr) extraRefs() []*node { return x.refs[:] }

// R constructs a reference to an immutable record.
func (x BinExprValue) R(a Allocator) BinExpr {
	ref := a.new()
	extra := &extraBinExpr{}
	ref.extra = extra

	ref.enums[1] = enum(x.Left.tag)
	ref.refs[0] = x.Left.ref
	ref.enums[0] = enum(x.Op)
	extra.Right = x.Right.tag
	extra.refs[0] = x.Right.ref
	return BinExpr{ref}
}

// Left returns the Left field.
func (x BinExpr) Left() Expr { return Expr{ExprTag(x.ref.enums[1]), x.ref.refs[0]} }

// Op returns the Op field.
func (x BinExpr) Op() BinOp { return BinOp(x.ref.enums[0]) }

// Right returns the Right field.
func (x BinExpr) Right() Expr {
	return Expr{x.ref.extra.(*extraBinExpr).Right, x.ref.extra.(*extraBinExpr).refs[0]}
}

// V unpacks a reference into a value.
func (x BinExpr) V() BinExprValue {
	return BinExprValue{
		Expr{ExprTag(x.ref.enums[1]), x.ref.refs[0]},
		BinOp(x.ref.enums[0]),
		Expr{x.ref.extra.(*extraBinExpr).Right, x.ref.extra.(*extraBinExpr).refs[0]},
	}
}

// WithLeft constructs a new value where the value of Left has been replaced by
// the argument.
func (x BinExprValue) WithLeft(y Expr) BinExprValue {
	x.Left = y
	return x
}

// WithOp constructs a new value where the value of Op has been replaced by
// the argument.
func (x BinExprValue) WithOp(y BinOp) BinExprValue {
	x.Op = y
	return x
}

// WithRight constructs a new value where the value of Right has been replaced by
// the argument.
func (x BinExprValue) WithRight(y Expr) BinExprValue {
	x.Right = y
	return x
}

// ---- All ---- //

// All is the type of a reference to an immutable record.
type All struct{ ref *node }

// AllValue is the logical type of a record. Immutable records are stored in
// nodes.
type AllValue struct {
	E  Expr      // 1
	CE ConstExpr // 2
	BE BinExpr   // 3
	BO BinOp     // 4
	A  AllOrExpr // 5
}

type extraAll struct {
	A    AllOrExprTag
	refs [3]*node
}

func (x extraAll) extraRefs() []*node { return x.refs[:] }

// R constructs a reference to an immutable record.
func (x AllValue) R(a Allocator) All {
	ref := a.new()
	extra := &extraAll{}
	ref.extra = extra

	ref.enums[1] = enum(x.E.tag)
	ref.refs[0] = x.E.ref
	extra.refs[0] = x.CE.ref
	extra.refs[1] = x.BE.ref
	ref.enums[0] = enum(x.BO)
	extra.A = x.A.tag
	extra.refs[2] = x.A.ref
	return All{ref}
}

// E returns the E field.
func (x All) E() Expr { return Expr{ExprTag(x.ref.enums[1]), x.ref.refs[0]} }

// CE returns the CE field.
func (x All) CE() ConstExpr { return ConstExpr{x.ref.extra.(*extraAll).refs[0]} }

// BE returns the BE field.
func (x All) BE() BinExpr { return BinExpr{x.ref.extra.(*extraAll).refs[1]} }

// BO returns the BO field.
func (x All) BO() BinOp { return BinOp(x.ref.enums[0]) }

// A returns the A field.
func (x All) A() AllOrExpr {
	return AllOrExpr{x.ref.extra.(*extraAll).A, x.ref.extra.(*extraAll).refs[2]}
}

// V unpacks a reference into a value.
func (x All) V() AllValue {
	return AllValue{
		Expr{ExprTag(x.ref.enums[1]), x.ref.refs[0]},
		ConstExpr{x.ref.extra.(*extraAll).refs[0]},
		BinExpr{x.ref.extra.(*extraAll).refs[1]},
		BinOp(x.ref.enums[0]),
		AllOrExpr{x.ref.extra.(*extraAll).A, x.ref.extra.(*extraAll).refs[2]},
	}
}

// WithE constructs a new value where the value of E has been replaced by
// the argument.
func (x AllValue) WithE(y Expr) AllValue {
	x.E = y
	return x
}

// WithCE constructs a new value where the value of CE has been replaced by
// the argument.
func (x AllValue) WithCE(y ConstExpr) AllValue {
	x.CE = y
	return x
}

// WithBE constructs a new value where the value of BE has been replaced by
// the argument.
func (x AllValue) WithBE(y BinExpr) AllValue {
	x.BE = y
	return x
}

// WithBO constructs a new value where the value of BO has been replaced by
// the argument.
func (x AllValue) WithBO(y BinOp) AllValue {
	x.BO = y
	return x
}

// WithA constructs a new value where the value of A has been replaced by
// the argument.
func (x AllValue) WithA(y AllOrExpr) AllValue {
	x.A = y
	return x
}

// ---- Expr ---- //

// Expr is the type of a tagged union of records.
type Expr struct {
	tag ExprTag
	ref *node
}

// ExprTag is the tag type.
type ExprTag enum

// ExprTag constants.
const (
	ExprConstExpr ExprTag = 1
	ExprBinExpr   ExprTag = 2
)

func (x ExprTag) String() string {
	switch x {
	case ExprConstExpr:
		return "ConstExpr"
	case ExprBinExpr:
		return "BinExpr"
	default:
		return fmt.Sprintf("<unknown ExprTag %d>", x)
	}
}

// Tag returns the tag.
func (x Expr) Tag() ExprTag { return x.tag }

// Expr performs an upcast.
func (x ConstExpr) Expr() Expr { return Expr{ExprConstExpr, x.ref} }

// ConstExpr performs a downcast. If the downcast fails, return false.
func (x Expr) ConstExpr() (ConstExpr, bool) {
	if x.tag != ExprConstExpr {
		return ConstExpr{}, false
	}
	return ConstExpr{x.ref}, true
}

// MustBeConstExpr performs a downcast. If the downcast fails, panic.
func (x Expr) MustBeConstExpr() ConstExpr {
	if x.tag != ExprConstExpr {
		panic(fmt.Sprintf("type assertion failed: expected ConstExpr but got %s", x.tag))
	}
	return ConstExpr{x.ref}
}

// Expr performs an upcast.
func (x BinExpr) Expr() Expr { return Expr{ExprBinExpr, x.ref} }

// BinExpr performs a downcast. If the downcast fails, return false.
func (x Expr) BinExpr() (BinExpr, bool) {
	if x.tag != ExprBinExpr {
		return BinExpr{}, false
	}
	return BinExpr{x.ref}, true
}

// MustBeBinExpr performs a downcast. If the downcast fails, panic.
func (x Expr) MustBeBinExpr() BinExpr {
	if x.tag != ExprBinExpr {
		panic(fmt.Sprintf("type assertion failed: expected BinExpr but got %s", x.tag))
	}
	return BinExpr{x.ref}
}

// ---- AllOrExpr ---- //

// AllOrExpr is the type of a tagged union of records.
type AllOrExpr struct {
	tag AllOrExprTag
	ref *node
}

// AllOrExprTag is the tag type.
type AllOrExprTag enum

// AllOrExprTag constants.
const (
	AllOrExprAll     AllOrExprTag = 1
	AllOrExprBinExpr AllOrExprTag = 2
)

func (x AllOrExprTag) String() string {
	switch x {
	case AllOrExprAll:
		return "All"
	case AllOrExprBinExpr:
		return "BinExpr"
	default:
		return fmt.Sprintf("<unknown AllOrExprTag %d>", x)
	}
}

// Tag returns the tag.
func (x AllOrExpr) Tag() AllOrExprTag { return x.tag }

// AllOrExpr performs an upcast.
func (x All) AllOrExpr() AllOrExpr { return AllOrExpr{AllOrExprAll, x.ref} }

// All performs a downcast. If the downcast fails, return false.
func (x AllOrExpr) All() (All, bool) {
	if x.tag != AllOrExprAll {
		return All{}, false
	}
	return All{x.ref}, true
}

// MustBeAll performs a downcast. If the downcast fails, panic.
func (x AllOrExpr) MustBeAll() All {
	if x.tag != AllOrExprAll {
		panic(fmt.Sprintf("type assertion failed: expected All but got %s", x.tag))
	}
	return All{x.ref}
}

// AllOrExpr performs an upcast.
func (x BinExpr) AllOrExpr() AllOrExpr { return AllOrExpr{AllOrExprBinExpr, x.ref} }

// BinExpr performs a downcast. If the downcast fails, return false.
func (x AllOrExpr) BinExpr() (BinExpr, bool) {
	if x.tag != AllOrExprBinExpr {
		return BinExpr{}, false
	}
	return BinExpr{x.ref}, true
}

// MustBeBinExpr performs a downcast. If the downcast fails, panic.
func (x AllOrExpr) MustBeBinExpr() BinExpr {
	if x.tag != AllOrExprBinExpr {
		panic(fmt.Sprintf("type assertion failed: expected BinExpr but got %s", x.tag))
	}
	return BinExpr{x.ref}
}
