// Copyright 2015 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// Author: Marc Berhault (marc@cockroachlabs.com)

package sqlbase

import (
	"github.com/cockroachdb/cockroach/pkg/config"
	"github.com/cockroachdb/cockroach/pkg/keys"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
	"github.com/cockroachdb/cockroach/pkg/security"
	"github.com/cockroachdb/cockroach/pkg/sql/privilege"
	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/pkg/errors"
	"golang.org/x/net/context"
)

// sql CREATE commands and full schema for each system table.
// These strings are *not* used at runtime, but are checked by the
// `TestSystemTableLiterals` test that compares the table generated by
// evaluating the `CREATE TABLE` statement to the descriptor literal that is
// actually used at runtime.
const (
	// NamespaceTableSchema is checked in TestSystemTables.
	NamespaceTableSchema = `
CREATE TABLE system.namespace (
  parentID INT,
  name     STRING,
  id       INT,
  PRIMARY KEY (parentID, name)
);`

	// DescriptorTableSchema is checked in TestSystemTables.
	DescriptorTableSchema = `
CREATE TABLE system.descriptor (
  id         INT PRIMARY KEY,
  descriptor BYTES
);`

	// UsersTableSchema is checked in TestSystemTables.
	UsersTableSchema = `
CREATE TABLE system.users (
  username       STRING PRIMARY KEY,
  hashedPassword BYTES
);`

	// ZonesTableSchema is checked in TestSystemTables.
	// Zone settings per DB/Table.
	ZonesTableSchema = `
CREATE TABLE system.zones (
  id     INT PRIMARY KEY,
  config BYTES
);`
)

// These system tables are not part of the system config.
const (
	// LeaseTableSchema is checked in TestSystemTables.
	LeaseTableSchema = `
CREATE TABLE system.lease (
  descID     INT,
  version    INT,
  nodeID     INT,
  expiration TIMESTAMP,
  PRIMARY KEY (descID, version, expiration, nodeID)
);`

	// EventLogTableSchema describes the schema of the event log table.
	EventLogTableSchema = `
CREATE TABLE system.eventlog (
  timestamp    TIMESTAMP  NOT NULL,
  eventType    STRING     NOT NULL,
  targetID     INT        NOT NULL,
  reportingID  INT        NOT NULL,
  info         STRING,
  uniqueID     BYTES      DEFAULT experimental_unique_bytes(),
  PRIMARY KEY (timestamp, uniqueID)
);`

	// RangeEventTableSchema defines the schema of the event log table. It is
	// currently envisioned as a wide table; many different event types can be
	// recorded to the table.
	RangeEventTableSchema = `
CREATE TABLE system.rangelog (
  timestamp     TIMESTAMP  NOT NULL,
  rangeID       INT        NOT NULL,
  storeID       INT        NOT NULL,
  eventType     STRING     NOT NULL,
  otherRangeID  INT,
  info          STRING,
  uniqueID      INT        DEFAULT unique_rowid(),
  PRIMARY KEY (timestamp, uniqueID)
);`

	// UITableSchema is checked in TestSystemTables.
	// blobs based on unique keys.
	UITableSchema = `
CREATE TABLE system.ui (
	key         STRING PRIMARY KEY,
	value       BYTES,
	lastUpdated TIMESTAMP NOT NULL
);`

	// JobsTableSchema defines the schema of the table that tracks long-running
	// jobs being worked on in the cluster. These jobs can be of different types;
	// for example, they could be SQL schema changes or backup/restore processes.
	// TODO(a-robinson): Consider adding an index on jobType/status.
	JobsTableSchema = `
CREATE TABLE system.jobs (
	jobID                SERIAL PRIMARY KEY,
	jobType              STRING NOT NULL,
	name				         STRING NOT NULL,
	payload			         BYTES,
	status               STRING NOT NULL,
	completionPercentage FLOAT,
	startTime            TIMESTAMP NOT NULL,
	lastUpdated          TIMESTAMP NOT NULL
);`
)

func pk(name string) IndexDescriptor {
	return IndexDescriptor{
		Name:             "primary",
		ID:               1,
		Unique:           true,
		ColumnNames:      []string{name},
		ColumnDirections: singleASC,
		ColumnIDs:        singleID1,
	}
}

// Helpers used to make some of the TableDescriptor literals below more concise.
var (
	colTypeInt       = ColumnType{Kind: ColumnType_INT}
	colTypeFloat     = ColumnType{Kind: ColumnType_FLOAT}
	colTypeString    = ColumnType{Kind: ColumnType_STRING}
	colTypeBytes     = ColumnType{Kind: ColumnType_BYTES}
	colTypeTimestamp = ColumnType{Kind: ColumnType_TIMESTAMP}
	singleASC        = []IndexDescriptor_Direction{IndexDescriptor_ASC}
	singleID1        = []ColumnID{1}
)

// These system config TableDescriptor literals should match the descriptor
// that would be produced by evaluating one of the above `CREATE TABLE`
// statements. See the `TestSystemTableLiterals` which checks that they do
// indeed match, and has suggestions on writing and maintaining them.
var (
	// SystemDB is the descriptor for the system database.
	SystemDB = DatabaseDescriptor{
		Name: "system",
		ID:   keys.SystemDatabaseID,
		// Assign max privileges to root user.
		Privileges: NewPrivilegeDescriptor(security.RootUser,
			SystemConfigAllowedPrivileges[keys.SystemDatabaseID]),
	}

	// NamespaceTable is the descriptor for the namespace table.
	NamespaceTable = TableDescriptor{
		Name:     "namespace",
		ID:       keys.NamespaceTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "parentID", ID: 1, Type: colTypeInt},
			{Name: "name", ID: 2, Type: colTypeString},
			{Name: "id", ID: 3, Type: colTypeInt, Nullable: true},
		},
		NextColumnID: 4,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"parentID", "name"}, ColumnIDs: []ColumnID{1, 2}},
			{Name: "fam_3_id", ID: 3, ColumnNames: []string{"id"}, ColumnIDs: []ColumnID{3}, DefaultColumnID: 3},
		},
		NextFamilyID: 4,
		PrimaryIndex: IndexDescriptor{
			Name:             "primary",
			ID:               1,
			Unique:           true,
			ColumnNames:      []string{"parentID", "name"},
			ColumnDirections: []IndexDescriptor_Direction{IndexDescriptor_ASC, IndexDescriptor_ASC},
			ColumnIDs:        []ColumnID{1, 2},
		},
		NextIndexID:    2,
		Privileges:     NewPrivilegeDescriptor(security.RootUser, SystemConfigAllowedPrivileges[2]),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// DescriptorTable is the descriptor for the descriptor table.
	DescriptorTable = TableDescriptor{
		Name:       "descriptor",
		ID:         keys.DescriptorTableID,
		Privileges: NewPrivilegeDescriptor(security.RootUser, SystemConfigAllowedPrivileges[3]),
		ParentID:   1,
		Version:    1,
		Columns: []ColumnDescriptor{
			{Name: "id", ID: 1, Type: colTypeInt},
			{Name: "descriptor", ID: 2, Type: colTypeBytes, Nullable: true},
		},
		NextColumnID: 3,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"id"}, ColumnIDs: singleID1},
			{Name: "fam_2_descriptor", ID: 2, ColumnNames: []string{"descriptor"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
		},
		PrimaryIndex:   pk("id"),
		NextFamilyID:   3,
		NextIndexID:    2,
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// UsersTable is the descriptor for the users table.
	UsersTable = TableDescriptor{
		Name:     "users",
		ID:       keys.UsersTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "username", ID: 1, Type: colTypeString},
			{Name: "hashedPassword", ID: 2, Type: colTypeBytes, Nullable: true},
		},
		NextColumnID: 3,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"username"}, ColumnIDs: singleID1},
			{Name: "fam_2_hashedPassword", ID: 2, ColumnNames: []string{"hashedPassword"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
		},
		PrimaryIndex:   pk("username"),
		NextFamilyID:   3,
		NextIndexID:    2,
		Privileges:     NewPrivilegeDescriptor(security.RootUser, SystemConfigAllowedPrivileges[4]),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// ZonesTable is the descriptor for the zones table.
	ZonesTable = TableDescriptor{
		Name:     "zones",
		ID:       keys.ZonesTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "id", ID: 1, Type: colTypeInt},
			{Name: "config", ID: 2, Type: colTypeBytes, Nullable: true},
		},
		NextColumnID: 3,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"id"}, ColumnIDs: singleID1},
			{Name: "fam_2_config", ID: 2, ColumnNames: []string{"config"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
		},
		PrimaryIndex:   pk("id"),
		NextFamilyID:   3,
		NextIndexID:    2,
		Privileges:     NewPrivilegeDescriptor(security.RootUser, SystemConfigAllowedPrivileges[5]),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// SystemConfigAllowedPrivileges describes the privileges allowed for each
	// system config object. No user may have more than those privileges, and
	// the root user must have exactly those privileges. CREATE|DROP|ALL
	// should always be denied.
	SystemConfigAllowedPrivileges = map[ID]privilege.List{
		keys.SystemDatabaseID:  privilege.ReadData,
		keys.NamespaceTableID:  privilege.ReadData,
		keys.DescriptorTableID: privilege.ReadData,
		keys.UsersTableID:      privilege.ReadWriteData,
		keys.ZonesTableID:      privilege.ReadWriteData,
	}
)

// These system TableDescriptor literals should match the descriptor that
// would be produced by evaluating one of the above `CREATE TABLE` statements
// for system tables that are not system config tables. See the
// `TestSystemTableLiterals` which checks that they do indeed match, and has
// suggestions on writing and maintaining them.
var (
	// LeaseTable is the descriptor for the leases table.
	LeaseTable = TableDescriptor{
		Name:     "lease",
		ID:       keys.LeaseTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "descID", ID: 1, Type: colTypeInt},
			{Name: "version", ID: 2, Type: colTypeInt},
			{Name: "nodeID", ID: 3, Type: colTypeInt},
			{Name: "expiration", ID: 4, Type: colTypeTimestamp},
		},
		NextColumnID: 5,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"descID", "version", "nodeID", "expiration"}, ColumnIDs: []ColumnID{1, 2, 3, 4}},
		},
		PrimaryIndex: IndexDescriptor{
			Name:             "primary",
			ID:               1,
			Unique:           true,
			ColumnNames:      []string{"descID", "version", "expiration", "nodeID"},
			ColumnDirections: []IndexDescriptor_Direction{IndexDescriptor_ASC, IndexDescriptor_ASC, IndexDescriptor_ASC, IndexDescriptor_ASC},
			ColumnIDs:        []ColumnID{1, 2, 4, 3},
		},
		NextFamilyID:   1,
		NextIndexID:    2,
		Privileges:     NewDefaultPrivilegeDescriptor(),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	experimentalUniqueBytesString = "experimental_unique_bytes()"

	// EventLogTable is the descriptor for the event log table.
	EventLogTable = TableDescriptor{
		Name:     "eventlog",
		ID:       keys.EventLogTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "timestamp", ID: 1, Type: colTypeTimestamp},
			{Name: "eventType", ID: 2, Type: colTypeString},
			{Name: "targetID", ID: 3, Type: colTypeInt},
			{Name: "reportingID", ID: 4, Type: colTypeInt},
			{Name: "info", ID: 5, Type: colTypeString, Nullable: true},
			{Name: "uniqueID", ID: 6, Type: colTypeBytes, DefaultExpr: &experimentalUniqueBytesString},
		},
		NextColumnID: 7,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"timestamp", "uniqueID"}, ColumnIDs: []ColumnID{1, 6}},
			{Name: "fam_2_eventType", ID: 2, ColumnNames: []string{"eventType"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
			{Name: "fam_3_targetID", ID: 3, ColumnNames: []string{"targetID"}, ColumnIDs: []ColumnID{3}, DefaultColumnID: 3},
			{Name: "fam_4_reportingID", ID: 4, ColumnNames: []string{"reportingID"}, ColumnIDs: []ColumnID{4}, DefaultColumnID: 4},
			{Name: "fam_5_info", ID: 5, ColumnNames: []string{"info"}, ColumnIDs: []ColumnID{5}, DefaultColumnID: 5},
		},
		PrimaryIndex: IndexDescriptor{
			Name:             "primary",
			ID:               1,
			Unique:           true,
			ColumnNames:      []string{"timestamp", "uniqueID"},
			ColumnDirections: []IndexDescriptor_Direction{IndexDescriptor_ASC, IndexDescriptor_ASC},
			ColumnIDs:        []ColumnID{1, 6},
		},
		NextFamilyID:   6,
		NextIndexID:    2,
		Privileges:     NewDefaultPrivilegeDescriptor(),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	uniqueRowIDString = "unique_rowid()"

	// RangeEventTable is the descriptor for the range log table.
	RangeEventTable = TableDescriptor{
		Name:     "rangelog",
		ID:       keys.RangeEventTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "timestamp", ID: 1, Type: colTypeTimestamp},
			{Name: "rangeID", ID: 2, Type: colTypeInt},
			{Name: "storeID", ID: 3, Type: colTypeInt},
			{Name: "eventType", ID: 4, Type: colTypeString},
			{Name: "otherRangeID", ID: 5, Type: colTypeInt, Nullable: true},
			{Name: "info", ID: 6, Type: colTypeString, Nullable: true},
			{Name: "uniqueID", ID: 7, Type: colTypeInt, DefaultExpr: &uniqueRowIDString},
		},
		NextColumnID: 8,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"timestamp", "uniqueID"}, ColumnIDs: []ColumnID{1, 7}},
			{Name: "fam_2_rangeID", ID: 2, ColumnNames: []string{"rangeID"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
			{Name: "fam_3_storeID", ID: 3, ColumnNames: []string{"storeID"}, ColumnIDs: []ColumnID{3}, DefaultColumnID: 3},
			{Name: "fam_4_eventType", ID: 4, ColumnNames: []string{"eventType"}, ColumnIDs: []ColumnID{4}, DefaultColumnID: 4},
			{Name: "fam_5_otherRangeID", ID: 5, ColumnNames: []string{"otherRangeID"}, ColumnIDs: []ColumnID{5}, DefaultColumnID: 5},
			{Name: "fam_6_info", ID: 6, ColumnNames: []string{"info"}, ColumnIDs: []ColumnID{6}, DefaultColumnID: 6},
		},
		PrimaryIndex: IndexDescriptor{
			Name:             "primary",
			ID:               1,
			Unique:           true,
			ColumnNames:      []string{"timestamp", "uniqueID"},
			ColumnDirections: []IndexDescriptor_Direction{IndexDescriptor_ASC, IndexDescriptor_ASC},
			ColumnIDs:        []ColumnID{1, 7},
		},
		NextFamilyID:   7,
		NextIndexID:    2,
		Privileges:     NewDefaultPrivilegeDescriptor(),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// UITable is the descriptor for the ui table.
	UITable = TableDescriptor{
		Name:     "ui",
		ID:       keys.UITableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "key", ID: 1, Type: colTypeString},
			{Name: "value", ID: 2, Type: colTypeBytes, Nullable: true},
			{Name: "lastUpdated", ID: 3, Type: ColumnType{Kind: ColumnType_TIMESTAMP}},
		},
		NextColumnID: 4,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"key"}, ColumnIDs: singleID1},
			{Name: "fam_2_value", ID: 2, ColumnNames: []string{"value"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
			{Name: "fam_3_lastUpdated", ID: 3, ColumnNames: []string{"lastUpdated"}, ColumnIDs: []ColumnID{3}, DefaultColumnID: 3},
		},
		NextFamilyID:   4,
		PrimaryIndex:   pk("key"),
		NextIndexID:    2,
		Privileges:     NewDefaultPrivilegeDescriptor(),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}

	// JobsTable is the descriptor for the jobs table.
	JobsTable = TableDescriptor{
		Name:     "jobs",
		ID:       keys.JobsTableID,
		ParentID: 1,
		Version:  1,
		Columns: []ColumnDescriptor{
			{Name: "jobID", ID: 1, Type: colTypeInt, DefaultExpr: &uniqueRowIDString},
			{Name: "jobType", ID: 2, Type: colTypeString},
			{Name: "name", ID: 3, Type: colTypeString},
			{Name: "payload", ID: 4, Type: colTypeBytes, Nullable: true},
			{Name: "status", ID: 5, Type: colTypeString},
			{Name: "completionPercentage", ID: 6, Type: colTypeFloat, Nullable: true},
			{Name: "startTime", ID: 7, Type: colTypeTimestamp},
			{Name: "lastUpdated", ID: 8, Type: colTypeTimestamp},
		},
		NextColumnID: 9,
		Families: []ColumnFamilyDescriptor{
			{Name: "primary", ID: 0, ColumnNames: []string{"jobID"}, ColumnIDs: singleID1},
			{Name: "fam_2_jobType", ID: 2, ColumnNames: []string{"jobType"}, ColumnIDs: []ColumnID{2}, DefaultColumnID: 2},
			{Name: "fam_3_name", ID: 3, ColumnNames: []string{"name"}, ColumnIDs: []ColumnID{3}, DefaultColumnID: 3},
			{Name: "fam_4_payload", ID: 4, ColumnNames: []string{"payload"}, ColumnIDs: []ColumnID{4}, DefaultColumnID: 4},
			{Name: "fam_5_status", ID: 5, ColumnNames: []string{"status"}, ColumnIDs: []ColumnID{5}, DefaultColumnID: 5},
			{Name: "fam_6_completionPercentage", ID: 6, ColumnNames: []string{"completionPercentage"}, ColumnIDs: []ColumnID{6}, DefaultColumnID: 6},
			{Name: "fam_7_startTime", ID: 7, ColumnNames: []string{"startTime"}, ColumnIDs: []ColumnID{7}, DefaultColumnID: 7},
			{Name: "fam_8_lastUpdated", ID: 8, ColumnNames: []string{"lastUpdated"}, ColumnIDs: []ColumnID{8}, DefaultColumnID: 8},
		},
		NextFamilyID:   9,
		PrimaryIndex:   pk("jobID"),
		NextIndexID:    2,
		Privileges:     NewDefaultPrivilegeDescriptor(),
		FormatVersion:  InterleavedFormatVersion,
		NextMutationID: 1,
	}
)

// Create the key/value pairs for the default zone config entry.
func createDefaultZoneConfig() []roachpb.KeyValue {
	var ret []roachpb.KeyValue
	value := roachpb.Value{}
	desc := config.DefaultZoneConfig()
	if err := value.SetProto(&desc); err != nil {
		log.Fatalf(context.TODO(), "could not marshal %v", desc)
	}
	ret = append(ret, roachpb.KeyValue{
		Key:   MakeZoneKey(keys.RootNamespaceID),
		Value: value,
	})
	return ret
}

// addSystemDatabaseToSchema populates the supplied MetadataSchema with the
// System database and its tables. The descriptors for these objects exist
// statically in this file, but a MetadataSchema can be used to persist these
// descriptors to the cockroach store.
func addSystemDatabaseToSchema(target *MetadataSchema) {
	// Add system database.
	target.AddConfigDescriptor(keys.RootNamespaceID, &SystemDB)

	// Add system config tables.
	target.AddConfigDescriptor(keys.SystemDatabaseID, &NamespaceTable)
	target.AddConfigDescriptor(keys.SystemDatabaseID, &DescriptorTable)
	target.AddConfigDescriptor(keys.SystemDatabaseID, &UsersTable)
	target.AddConfigDescriptor(keys.SystemDatabaseID, &ZonesTable)

	// Add all the other system tables.
	target.AddDescriptor(keys.SystemDatabaseID, &LeaseTable)
	target.AddDescriptor(keys.SystemDatabaseID, &EventLogTable)
	target.AddDescriptor(keys.SystemDatabaseID, &RangeEventTable)
	target.AddDescriptor(keys.SystemDatabaseID, &UITable)
	target.AddDescriptor(keys.SystemDatabaseID, &JobsTable)

	target.otherKV = append(target.otherKV, createDefaultZoneConfig()...)
}

// IsSystemConfigID returns true if this ID is for a system config object.
func IsSystemConfigID(id ID) bool {
	return id > 0 && id <= keys.MaxSystemConfigDescID
}

// SystemTableID returns the ID for a named system table.
func SystemTableID(name string) (ID, error) {
	switch name {
	case "namespace":
		return keys.NamespaceTableID, nil
	case "descriptor":
		return keys.DescriptorTableID, nil
	case "users":
		return keys.UsersTableID, nil
	case "zones":
		return keys.ZonesTableID, nil
	case "lease":
		return keys.LeaseTableID, nil
	case "eventlog":
		return keys.EventLogTableID, nil
	case "rangelog":
		return keys.RangeEventTableID, nil
	case "ui":
		return keys.UITableID, nil
	case "jobs":
		return keys.JobsTableID, nil
	}

	return 0, errors.Errorf("system table %q not found", name)
}
