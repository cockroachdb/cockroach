// Code generated by MockGen. DO NOT EDIT.
// Source: ./dependencies.go

// Package scexec_test is a generated GoMock package.
package scexec_test

import (
	context "context"
	reflect "reflect"

	jobs "github.com/cockroachdb/cockroach/pkg/jobs"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	security "github.com/cockroachdb/cockroach/pkg/security"
	catalog "github.com/cockroachdb/cockroach/pkg/sql/catalog"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	tabledesc "github.com/cockroachdb/cockroach/pkg/sql/catalog/tabledesc"
	scexec "github.com/cockroachdb/cockroach/pkg/sql/schemachanger/scexec"
	scpb "github.com/cockroachdb/cockroach/pkg/sql/schemachanger/scpb"
	tree "github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	sessiondata "github.com/cockroachdb/cockroach/pkg/sql/sessiondata"
	eventpb "github.com/cockroachdb/cockroach/pkg/util/log/eventpb"
	gomock "github.com/golang/mock/gomock"
)

// MockDependencies is a mock of Dependencies interface.
type MockDependencies struct {
	ctrl     *gomock.Controller
	recorder *MockDependenciesMockRecorder
}

// MockDependenciesMockRecorder is the mock recorder for MockDependencies.
type MockDependenciesMockRecorder struct {
	mock *MockDependencies
}

// NewMockDependencies creates a new mock instance.
func NewMockDependencies(ctrl *gomock.Controller) *MockDependencies {
	mock := &MockDependencies{ctrl: ctrl}
	mock.recorder = &MockDependenciesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDependencies) EXPECT() *MockDependenciesMockRecorder {
	return m.recorder
}

// BackfillProgressTracker mocks base method.
func (m *MockDependencies) BackfillProgressTracker() scexec.BackfillTracker {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BackfillProgressTracker")
	ret0, _ := ret[0].(scexec.BackfillTracker)
	return ret0
}

// BackfillProgressTracker indicates an expected call of BackfillProgressTracker.
func (mr *MockDependenciesMockRecorder) BackfillProgressTracker() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BackfillProgressTracker", reflect.TypeOf((*MockDependencies)(nil).BackfillProgressTracker))
}

// Catalog mocks base method.
func (m *MockDependencies) Catalog() scexec.Catalog {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Catalog")
	ret0, _ := ret[0].(scexec.Catalog)
	return ret0
}

// Catalog indicates an expected call of Catalog.
func (mr *MockDependenciesMockRecorder) Catalog() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Catalog", reflect.TypeOf((*MockDependencies)(nil).Catalog))
}

// EventLogger mocks base method.
func (m *MockDependencies) EventLogger() scexec.EventLogger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EventLogger")
	ret0, _ := ret[0].(scexec.EventLogger)
	return ret0
}

// EventLogger indicates an expected call of EventLogger.
func (mr *MockDependenciesMockRecorder) EventLogger() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EventLogger", reflect.TypeOf((*MockDependencies)(nil).EventLogger))
}

// IndexBackfiller mocks base method.
func (m *MockDependencies) IndexBackfiller() scexec.Backfiller {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexBackfiller")
	ret0, _ := ret[0].(scexec.Backfiller)
	return ret0
}

// IndexBackfiller indicates an expected call of IndexBackfiller.
func (mr *MockDependenciesMockRecorder) IndexBackfiller() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexBackfiller", reflect.TypeOf((*MockDependencies)(nil).IndexBackfiller))
}

// IndexSpanSplitter mocks base method.
func (m *MockDependencies) IndexSpanSplitter() scexec.IndexSpanSplitter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexSpanSplitter")
	ret0, _ := ret[0].(scexec.IndexSpanSplitter)
	return ret0
}

// IndexSpanSplitter indicates an expected call of IndexSpanSplitter.
func (mr *MockDependenciesMockRecorder) IndexSpanSplitter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSpanSplitter", reflect.TypeOf((*MockDependencies)(nil).IndexSpanSplitter))
}

// IndexValidator mocks base method.
func (m *MockDependencies) IndexValidator() scexec.IndexValidator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexValidator")
	ret0, _ := ret[0].(scexec.IndexValidator)
	return ret0
}

// IndexValidator indicates an expected call of IndexValidator.
func (mr *MockDependenciesMockRecorder) IndexValidator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexValidator", reflect.TypeOf((*MockDependencies)(nil).IndexValidator))
}

// PeriodicProgressFlusher mocks base method.
func (m *MockDependencies) PeriodicProgressWriter() scexec.PeriodicProgressFlusher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeriodicProgressFlusher")
	ret0, _ := ret[0].(scexec.PeriodicProgressFlusher)
	return ret0
}

// PeriodicProgressFlusher indicates an expected call of PeriodicProgressFlusher.
func (mr *MockDependenciesMockRecorder) PeriodicProgressWriter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeriodicProgressFlusher", reflect.TypeOf((*MockDependencies)(nil).PeriodicProgressWriter))
}

// Statements mocks base method.
func (m *MockDependencies) Statements() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Statements")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Statements indicates an expected call of Statements.
func (mr *MockDependenciesMockRecorder) Statements() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Statements", reflect.TypeOf((*MockDependencies)(nil).Statements))
}

// TransactionalJobCreator mocks base method.
func (m *MockDependencies) TransactionalJobCreator() scexec.TransactionalJobCreator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionalJobCreator")
	ret0, _ := ret[0].(scexec.TransactionalJobCreator)
	return ret0
}

// TransactionalJobCreator indicates an expected call of TransactionalJobCreator.
func (mr *MockDependenciesMockRecorder) TransactionalJobCreator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionalJobCreator", reflect.TypeOf((*MockDependencies)(nil).TransactionalJobCreator))
}

// User mocks base method.
func (m *MockDependencies) User() security.SQLUsername {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "User")
	ret0, _ := ret[0].(security.SQLUsername)
	return ret0
}

// User indicates an expected call of User.
func (mr *MockDependenciesMockRecorder) User() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "User", reflect.TypeOf((*MockDependencies)(nil).User))
}

// MockCatalog is a mock of Catalog interface.
type MockCatalog struct {
	ctrl     *gomock.Controller
	recorder *MockCatalogMockRecorder
}

// MockCatalogMockRecorder is the mock recorder for MockCatalog.
type MockCatalogMockRecorder struct {
	mock *MockCatalog
}

// NewMockCatalog creates a new mock instance.
func NewMockCatalog(ctrl *gomock.Controller) *MockCatalog {
	mock := &MockCatalog{ctrl: ctrl}
	mock.recorder = &MockCatalogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCatalog) EXPECT() *MockCatalogMockRecorder {
	return m.recorder
}

// AddPartitioning mocks base method.
func (m *MockCatalog) AddPartitioning(
	tableDesc *tabledesc.Mutable,
	indexDesc *descpb.IndexDescriptor,
	partitionFields []string,
	listPartition []*scpb.ListPartition,
	rangePartition []*scpb.RangePartitions,
	allowedNewColumnNames []tree.Name,
	allowImplicitPartitioning bool,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPartitioning", tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddPartitioning indicates an expected call of AddPartitioning.
func (mr *MockCatalogMockRecorder) AddPartitioning(
	tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPartitioning", reflect.TypeOf((*MockCatalog)(nil).AddPartitioning), tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning)
}

// AddSyntheticDescriptor mocks base method.
func (m *MockCatalog) AddSyntheticDescriptor(desc catalog.Descriptor) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSyntheticDescriptor", desc)
}

// AddSyntheticDescriptor indicates an expected call of AddSyntheticDescriptor.
func (mr *MockCatalogMockRecorder) AddSyntheticDescriptor(desc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSyntheticDescriptor", reflect.TypeOf((*MockCatalog)(nil).AddSyntheticDescriptor), desc)
}

// GetFullyQualifiedName mocks base method.
func (m *MockCatalog) GetFullyQualifiedName(ctx context.Context, id descpb.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFullyQualifiedName", ctx, id)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFullyQualifiedName indicates an expected call of GetFullyQualifiedName.
func (mr *MockCatalogMockRecorder) GetFullyQualifiedName(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFullyQualifiedName", reflect.TypeOf((*MockCatalog)(nil).GetFullyQualifiedName), ctx, id)
}

// MustReadImmutableDescriptor mocks base method.
func (m *MockCatalog) MustReadImmutableDescriptor(
	ctx context.Context, id descpb.ID,
) (catalog.Descriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MustReadImmutableDescriptor", ctx, id)
	ret0, _ := ret[0].(catalog.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MustReadImmutableDescriptor indicates an expected call of MustReadImmutableDescriptor.
func (mr *MockCatalogMockRecorder) MustReadImmutableDescriptor(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustReadImmutableDescriptor", reflect.TypeOf((*MockCatalog)(nil).MustReadImmutableDescriptor), ctx, id)
}

// MustReadMutableDescriptor mocks base method.
func (m *MockCatalog) MustReadMutableDescriptor(
	ctx context.Context, id descpb.ID,
) (catalog.MutableDescriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MustReadMutableDescriptor", ctx, id)
	ret0, _ := ret[0].(catalog.MutableDescriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MustReadMutableDescriptor indicates an expected call of MustReadMutableDescriptor.
func (mr *MockCatalogMockRecorder) MustReadMutableDescriptor(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustReadMutableDescriptor", reflect.TypeOf((*MockCatalog)(nil).MustReadMutableDescriptor), ctx, id)
}

// NewCatalogChangeBatcher mocks base method.
func (m *MockCatalog) NewCatalogChangeBatcher() scexec.CatalogChangeBatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewCatalogChangeBatcher")
	ret0, _ := ret[0].(scexec.CatalogChangeBatcher)
	return ret0
}

// NewCatalogChangeBatcher indicates an expected call of NewCatalogChangeBatcher.
func (mr *MockCatalogMockRecorder) NewCatalogChangeBatcher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewCatalogChangeBatcher", reflect.TypeOf((*MockCatalog)(nil).NewCatalogChangeBatcher))
}

// RemoveSyntheticDescriptor mocks base method.
func (m *MockCatalog) RemoveSyntheticDescriptor(id descpb.ID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveSyntheticDescriptor", id)
}

// RemoveSyntheticDescriptor indicates an expected call of RemoveSyntheticDescriptor.
func (mr *MockCatalogMockRecorder) RemoveSyntheticDescriptor(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveSyntheticDescriptor", reflect.TypeOf((*MockCatalog)(nil).RemoveSyntheticDescriptor), id)
}

// MockEventLogger is a mock of EventLogger interface.
type MockEventLogger struct {
	ctrl     *gomock.Controller
	recorder *MockEventLoggerMockRecorder
}

// MockEventLoggerMockRecorder is the mock recorder for MockEventLogger.
type MockEventLoggerMockRecorder struct {
	mock *MockEventLogger
}

// NewMockEventLogger creates a new mock instance.
func NewMockEventLogger(ctrl *gomock.Controller) *MockEventLogger {
	mock := &MockEventLogger{ctrl: ctrl}
	mock.recorder = &MockEventLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventLogger) EXPECT() *MockEventLoggerMockRecorder {
	return m.recorder
}

// EnqueueEvent mocks base method.
func (m *MockEventLogger) EnqueueEvent(
	ctx context.Context, descID descpb.ID, metadata *scpb.ElementMetadata, event eventpb.EventPayload,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnqueueEvent", ctx, descID, metadata, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnqueueEvent indicates an expected call of EnqueueEvent.
func (mr *MockEventLoggerMockRecorder) EnqueueEvent(
	ctx, descID, metadata, event interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnqueueEvent", reflect.TypeOf((*MockEventLogger)(nil).EnqueueEvent), ctx, descID, metadata, event)
}

// ProcessAndSubmitEvents mocks base method.
func (m *MockEventLogger) ProcessAndSubmitEvents(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessAndSubmitEvents", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProcessAndSubmitEvents indicates an expected call of ProcessAndSubmitEvents.
func (mr *MockEventLoggerMockRecorder) ProcessAndSubmitEvents(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessAndSubmitEvents", reflect.TypeOf((*MockEventLogger)(nil).ProcessAndSubmitEvents), ctx)
}

// MockCatalogChangeBatcher is a mock of CatalogChangeBatcher interface.
type MockCatalogChangeBatcher struct {
	ctrl     *gomock.Controller
	recorder *MockCatalogChangeBatcherMockRecorder
}

// MockCatalogChangeBatcherMockRecorder is the mock recorder for MockCatalogChangeBatcher.
type MockCatalogChangeBatcherMockRecorder struct {
	mock *MockCatalogChangeBatcher
}

// NewMockCatalogChangeBatcher creates a new mock instance.
func NewMockCatalogChangeBatcher(ctrl *gomock.Controller) *MockCatalogChangeBatcher {
	mock := &MockCatalogChangeBatcher{ctrl: ctrl}
	mock.recorder = &MockCatalogChangeBatcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCatalogChangeBatcher) EXPECT() *MockCatalogChangeBatcherMockRecorder {
	return m.recorder
}

// CreateOrUpdateDescriptor mocks base method.
func (m *MockCatalogChangeBatcher) CreateOrUpdateDescriptor(
	ctx context.Context, desc catalog.MutableDescriptor,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrUpdateDescriptor", ctx, desc)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateOrUpdateDescriptor indicates an expected call of CreateOrUpdateDescriptor.
func (mr *MockCatalogChangeBatcherMockRecorder) CreateOrUpdateDescriptor(
	ctx, desc interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateDescriptor", reflect.TypeOf((*MockCatalogChangeBatcher)(nil).CreateOrUpdateDescriptor), ctx, desc)
}

// DeleteDescriptor mocks base method.
func (m *MockCatalogChangeBatcher) DeleteDescriptor(ctx context.Context, id descpb.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteDescriptor", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteDescriptor indicates an expected call of DeleteDescriptor.
func (mr *MockCatalogChangeBatcherMockRecorder) DeleteDescriptor(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDescriptor", reflect.TypeOf((*MockCatalogChangeBatcher)(nil).DeleteDescriptor), ctx, id)
}

// DeleteName mocks base method.
func (m *MockCatalogChangeBatcher) DeleteName(
	ctx context.Context, nameInfo descpb.NameInfo, id descpb.ID,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteName", ctx, nameInfo, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteName indicates an expected call of DeleteName.
func (mr *MockCatalogChangeBatcherMockRecorder) DeleteName(
	ctx, nameInfo, id interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteName", reflect.TypeOf((*MockCatalogChangeBatcher)(nil).DeleteName), ctx, nameInfo, id)
}

// ValidateAndRun mocks base method.
func (m *MockCatalogChangeBatcher) ValidateAndRun(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateAndRun", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateAndRun indicates an expected call of ValidateAndRun.
func (mr *MockCatalogChangeBatcherMockRecorder) ValidateAndRun(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAndRun", reflect.TypeOf((*MockCatalogChangeBatcher)(nil).ValidateAndRun), ctx)
}

// MockTransactionalJobCreator is a mock of TransactionalJobCreator interface.
type MockTransactionalJobCreator struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionalJobCreatorMockRecorder
}

// MockTransactionalJobCreatorMockRecorder is the mock recorder for MockTransactionalJobCreator.
type MockTransactionalJobCreatorMockRecorder struct {
	mock *MockTransactionalJobCreator
}

// NewMockTransactionalJobCreator creates a new mock instance.
func NewMockTransactionalJobCreator(ctrl *gomock.Controller) *MockTransactionalJobCreator {
	mock := &MockTransactionalJobCreator{ctrl: ctrl}
	mock.recorder = &MockTransactionalJobCreatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionalJobCreator) EXPECT() *MockTransactionalJobCreatorMockRecorder {
	return m.recorder
}

// CreateJob mocks base method.
func (m *MockTransactionalJobCreator) CreateJob(ctx context.Context, record jobs.Record) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJob", ctx, record)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateJob indicates an expected call of CreateJob.
func (mr *MockTransactionalJobCreatorMockRecorder) CreateJob(ctx, record interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJob", reflect.TypeOf((*MockTransactionalJobCreator)(nil).CreateJob), ctx, record)
}

// MakeJobID mocks base method.
func (m *MockTransactionalJobCreator) MakeJobID() jobspb.JobID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MakeJobID")
	ret0, _ := ret[0].(jobspb.JobID)
	return ret0
}

// MakeJobID indicates an expected call of MakeJobID.
func (mr *MockTransactionalJobCreatorMockRecorder) MakeJobID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeJobID", reflect.TypeOf((*MockTransactionalJobCreator)(nil).MakeJobID))
}

// UpdateSchemaChangeJob mocks base method.
func (m *MockTransactionalJobCreator) UpdateSchemaChangeJob(
	ctx context.Context, id jobspb.JobID, fn scexec.JobProgressUpdateFunc,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSchemaChangeJob", ctx, id, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSchemaChangeJob indicates an expected call of UpdateSchemaChangeJob.
func (mr *MockTransactionalJobCreatorMockRecorder) UpdateSchemaChangeJob(
	ctx, id, fn interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSchemaChangeJob", reflect.TypeOf((*MockTransactionalJobCreator)(nil).UpdateSchemaChangeJob), ctx, id, fn)
}

// MockBackfiller is a mock of Backfiller interface.
type MockBackfiller struct {
	ctrl     *gomock.Controller
	recorder *MockBackfillerMockRecorder
}

// MockBackfillerMockRecorder is the mock recorder for MockBackfiller.
type MockBackfillerMockRecorder struct {
	mock *MockBackfiller
}

// NewMockBackfiller creates a new mock instance.
func NewMockBackfiller(ctrl *gomock.Controller) *MockBackfiller {
	mock := &MockBackfiller{ctrl: ctrl}
	mock.recorder = &MockBackfillerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackfiller) EXPECT() *MockBackfillerMockRecorder {
	return m.recorder
}

// BackfillIndex mocks base method.
func (m *MockBackfiller) BackfillIndex(
	arg0 context.Context,
	arg1 scexec.BackfillProgress,
	arg2 scexec.BackfillProgressWriter,
	arg3 catalog.TableDescriptor,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BackfillIndex", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// BackfillIndex indicates an expected call of BackfillIndex.
func (mr *MockBackfillerMockRecorder) BackfillIndex(
	arg0, arg1, arg2, arg3 interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BackfillIndex", reflect.TypeOf((*MockBackfiller)(nil).BackfillIndex), arg0, arg1, arg2, arg3)
}

// MaybePrepareDestIndexesForBackfill mocks base method.
func (m *MockBackfiller) MaybePrepareDestIndexesForBackfill(
	arg0 context.Context, arg1 scexec.BackfillProgress, arg2 catalog.TableDescriptor,
) (scexec.BackfillProgress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaybePrepareDestIndexesForBackfill", arg0, arg1, arg2)
	ret0, _ := ret[0].(scexec.BackfillProgress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MaybePrepareDestIndexesForBackfill indicates an expected call of MaybePrepareDestIndexesForBackfill.
func (mr *MockBackfillerMockRecorder) MaybePrepareDestIndexesForBackfill(
	arg0, arg1, arg2 interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaybePrepareDestIndexesForBackfill", reflect.TypeOf((*MockBackfiller)(nil).MaybePrepareDestIndexesForBackfill), arg0, arg1, arg2)
}

// MockPartitioner is a mock of Partitioner interface.
type MockPartitioner struct {
	ctrl     *gomock.Controller
	recorder *MockPartitionerMockRecorder
}

// MockPartitionerMockRecorder is the mock recorder for MockPartitioner.
type MockPartitionerMockRecorder struct {
	mock *MockPartitioner
}

// NewMockPartitioner creates a new mock instance.
func NewMockPartitioner(ctrl *gomock.Controller) *MockPartitioner {
	mock := &MockPartitioner{ctrl: ctrl}
	mock.recorder = &MockPartitionerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPartitioner) EXPECT() *MockPartitionerMockRecorder {
	return m.recorder
}

// AddPartitioning mocks base method.
func (m *MockPartitioner) AddPartitioning(
	ctx context.Context,
	tableDesc *tabledesc.Mutable,
	indexDesc *descpb.IndexDescriptor,
	partitionFields []string,
	listPartition []*scpb.ListPartition,
	rangePartition []*scpb.RangePartitions,
	allowedNewColumnNames []tree.Name,
	allowImplicitPartitioning bool,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPartitioning", ctx, tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddPartitioning indicates an expected call of AddPartitioning.
func (mr *MockPartitionerMockRecorder) AddPartitioning(
	ctx, tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPartitioning", reflect.TypeOf((*MockPartitioner)(nil).AddPartitioning), ctx, tableDesc, indexDesc, partitionFields, listPartition, rangePartition, allowedNewColumnNames, allowImplicitPartitioning)
}

// MockIndexValidator is a mock of IndexValidator interface.
type MockIndexValidator struct {
	ctrl     *gomock.Controller
	recorder *MockIndexValidatorMockRecorder
}

// MockIndexValidatorMockRecorder is the mock recorder for MockIndexValidator.
type MockIndexValidatorMockRecorder struct {
	mock *MockIndexValidator
}

// NewMockIndexValidator creates a new mock instance.
func NewMockIndexValidator(ctrl *gomock.Controller) *MockIndexValidator {
	mock := &MockIndexValidator{ctrl: ctrl}
	mock.recorder = &MockIndexValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexValidator) EXPECT() *MockIndexValidatorMockRecorder {
	return m.recorder
}

// ValidateForwardIndexes mocks base method.
func (m *MockIndexValidator) ValidateForwardIndexes(
	ctx context.Context,
	tableDesc catalog.TableDescriptor,
	indexes []catalog.Index,
	withFirstMutationPublic, gatherAllInvalid bool,
	override sessiondata.InternalExecutorOverride,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateForwardIndexes", ctx, tableDesc, indexes, withFirstMutationPublic, gatherAllInvalid, override)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateForwardIndexes indicates an expected call of ValidateForwardIndexes.
func (mr *MockIndexValidatorMockRecorder) ValidateForwardIndexes(
	ctx, tableDesc, indexes, withFirstMutationPublic, gatherAllInvalid, override interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateForwardIndexes", reflect.TypeOf((*MockIndexValidator)(nil).ValidateForwardIndexes), ctx, tableDesc, indexes, withFirstMutationPublic, gatherAllInvalid, override)
}

// ValidateInvertedIndexes mocks base method.
func (m *MockIndexValidator) ValidateInvertedIndexes(
	ctx context.Context,
	tableDesc catalog.TableDescriptor,
	indexes []catalog.Index,
	gatherAllInvalid bool,
	override sessiondata.InternalExecutorOverride,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateInvertedIndexes", ctx, tableDesc, indexes, gatherAllInvalid, override)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateInvertedIndexes indicates an expected call of ValidateInvertedIndexes.
func (mr *MockIndexValidatorMockRecorder) ValidateInvertedIndexes(
	ctx, tableDesc, indexes, gatherAllInvalid, override interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateInvertedIndexes", reflect.TypeOf((*MockIndexValidator)(nil).ValidateInvertedIndexes), ctx, tableDesc, indexes, gatherAllInvalid, override)
}

// MockIndexSpanSplitter is a mock of IndexSpanSplitter interface.
type MockIndexSpanSplitter struct {
	ctrl     *gomock.Controller
	recorder *MockIndexSpanSplitterMockRecorder
}

// MockIndexSpanSplitterMockRecorder is the mock recorder for MockIndexSpanSplitter.
type MockIndexSpanSplitterMockRecorder struct {
	mock *MockIndexSpanSplitter
}

// NewMockIndexSpanSplitter creates a new mock instance.
func NewMockIndexSpanSplitter(ctrl *gomock.Controller) *MockIndexSpanSplitter {
	mock := &MockIndexSpanSplitter{ctrl: ctrl}
	mock.recorder = &MockIndexSpanSplitterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexSpanSplitter) EXPECT() *MockIndexSpanSplitterMockRecorder {
	return m.recorder
}

// MaybeSplitIndexSpans mocks base method.
func (m *MockIndexSpanSplitter) MaybeSplitIndexSpans(
	ctx context.Context, table catalog.TableDescriptor, indexToBackfill catalog.Index,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaybeSplitIndexSpans", ctx, table, indexToBackfill)
	ret0, _ := ret[0].(error)
	return ret0
}

// MaybeSplitIndexSpans indicates an expected call of MaybeSplitIndexSpans.
func (mr *MockIndexSpanSplitterMockRecorder) MaybeSplitIndexSpans(
	ctx, table, indexToBackfill interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaybeSplitIndexSpans", reflect.TypeOf((*MockIndexSpanSplitter)(nil).MaybeSplitIndexSpans), ctx, table, indexToBackfill)
}

// MockBackfillTracker is a mock of BackfillTracker interface.
type MockBackfillTracker struct {
	ctrl     *gomock.Controller
	recorder *MockBackfillTrackerMockRecorder
}

// MockBackfillTrackerMockRecorder is the mock recorder for MockBackfillTracker.
type MockBackfillTrackerMockRecorder struct {
	mock *MockBackfillTracker
}

// NewMockBackfillTracker creates a new mock instance.
func NewMockBackfillTracker(ctrl *gomock.Controller) *MockBackfillTracker {
	mock := &MockBackfillTracker{ctrl: ctrl}
	mock.recorder = &MockBackfillTrackerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackfillTracker) EXPECT() *MockBackfillTrackerMockRecorder {
	return m.recorder
}

// FlushCheckpoint mocks base method.
func (m *MockBackfillTracker) FlushCheckpoint(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushCheckpoint", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// FlushCheckpoint indicates an expected call of FlushCheckpoint.
func (mr *MockBackfillTrackerMockRecorder) FlushCheckpoint(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushCheckpoint", reflect.TypeOf((*MockBackfillTracker)(nil).FlushCheckpoint), ctx)
}

// FlushFractionCompleted mocks base method.
func (m *MockBackfillTracker) FlushFractionCompleted(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushFractionCompleted", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// FlushFractionCompleted indicates an expected call of FlushFractionCompleted.
func (mr *MockBackfillTrackerMockRecorder) FlushFractionCompleted(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushFractionCompleted", reflect.TypeOf((*MockBackfillTracker)(nil).FlushFractionCompleted), ctx)
}

// GetBackfillProgress mocks base method.
func (m *MockBackfillTracker) GetBackfillProgress(
	ctx context.Context, b scexec.Backfill,
) (scexec.BackfillProgress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBackfillProgress", ctx, b)
	ret0, _ := ret[0].(scexec.BackfillProgress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBackfillProgress indicates an expected call of GetBackfillProgress.
func (mr *MockBackfillTrackerMockRecorder) GetBackfillProgress(ctx, b interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBackfillProgress", reflect.TypeOf((*MockBackfillTracker)(nil).GetBackfillProgress), ctx, b)
}

// SetBackfillProgress mocks base method.
func (m *MockBackfillTracker) SetBackfillProgress(
	ctx context.Context, progress scexec.BackfillProgress,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBackfillProgress", ctx, progress)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetBackfillProgress indicates an expected call of SetBackfillProgress.
func (mr *MockBackfillTrackerMockRecorder) SetBackfillProgress(
	ctx, progress interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBackfillProgress", reflect.TypeOf((*MockBackfillTracker)(nil).SetBackfillProgress), ctx, progress)
}

// MockPeriodicBackfillProgressFlusher is a mock of PeriodicProgressFlusher interface.
type MockPeriodicBackfillProgressFlusher struct {
	ctrl     *gomock.Controller
	recorder *MockPeriodicBackfillProgressFlusherMockRecorder
}

// MockPeriodicBackfillProgressFlusherMockRecorder is the mock recorder for MockPeriodicBackfillProgressFlusher.
type MockPeriodicBackfillProgressFlusherMockRecorder struct {
	mock *MockPeriodicBackfillProgressFlusher
}

// NewMockPeriodicBackfillProgressFlusher creates a new mock instance.
func NewMockPeriodicBackfillProgressFlusher(
	ctrl *gomock.Controller,
) *MockPeriodicBackfillProgressFlusher {
	mock := &MockPeriodicBackfillProgressFlusher{ctrl: ctrl}
	mock.recorder = &MockPeriodicBackfillProgressFlusherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPeriodicBackfillProgressFlusher) EXPECT() *MockPeriodicBackfillProgressFlusherMockRecorder {
	return m.recorder
}

// StartPeriodicUpdates mocks base method.
func (m *MockPeriodicBackfillProgressFlusher) StartPeriodicUpdates(
	ctx context.Context, tracker scexec.BackfillProgressFlusher,
) func() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartPeriodicUpdates", ctx, tracker)
	ret0, _ := ret[0].(func() error)
	return ret0
}

// StartPeriodicUpdates indicates an expected call of StartPeriodicUpdates.
func (mr *MockPeriodicBackfillProgressFlusherMockRecorder) StartPeriodicUpdates(
	ctx, tracker interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartPeriodicUpdates", reflect.TypeOf((*MockPeriodicBackfillProgressFlusher)(nil).StartPeriodicUpdates), ctx, tracker)
}

// MockBackfillProgressReader is a mock of BackfillProgressReader interface.
type MockBackfillProgressReader struct {
	ctrl     *gomock.Controller
	recorder *MockBackfillProgressReaderMockRecorder
}

// MockBackfillProgressReaderMockRecorder is the mock recorder for MockBackfillProgressReader.
type MockBackfillProgressReaderMockRecorder struct {
	mock *MockBackfillProgressReader
}

// NewMockBackfillProgressReader creates a new mock instance.
func NewMockBackfillProgressReader(ctrl *gomock.Controller) *MockBackfillProgressReader {
	mock := &MockBackfillProgressReader{ctrl: ctrl}
	mock.recorder = &MockBackfillProgressReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackfillProgressReader) EXPECT() *MockBackfillProgressReaderMockRecorder {
	return m.recorder
}

// GetBackfillProgress mocks base method.
func (m *MockBackfillProgressReader) GetBackfillProgress(
	ctx context.Context, b scexec.Backfill,
) (scexec.BackfillProgress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBackfillProgress", ctx, b)
	ret0, _ := ret[0].(scexec.BackfillProgress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBackfillProgress indicates an expected call of GetBackfillProgress.
func (mr *MockBackfillProgressReaderMockRecorder) GetBackfillProgress(
	ctx, b interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBackfillProgress", reflect.TypeOf((*MockBackfillProgressReader)(nil).GetBackfillProgress), ctx, b)
}

// MockBackfillProgressWriter is a mock of BackfillProgressWriter interface.
type MockBackfillProgressWriter struct {
	ctrl     *gomock.Controller
	recorder *MockBackfillProgressWriterMockRecorder
}

// MockBackfillProgressWriterMockRecorder is the mock recorder for MockBackfillProgressWriter.
type MockBackfillProgressWriterMockRecorder struct {
	mock *MockBackfillProgressWriter
}

// NewMockBackfillProgressWriter creates a new mock instance.
func NewMockBackfillProgressWriter(ctrl *gomock.Controller) *MockBackfillProgressWriter {
	mock := &MockBackfillProgressWriter{ctrl: ctrl}
	mock.recorder = &MockBackfillProgressWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackfillProgressWriter) EXPECT() *MockBackfillProgressWriterMockRecorder {
	return m.recorder
}

// SetBackfillProgress mocks base method.
func (m *MockBackfillProgressWriter) SetBackfillProgress(
	ctx context.Context, progress scexec.BackfillProgress,
) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBackfillProgress", ctx, progress)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetBackfillProgress indicates an expected call of SetBackfillProgress.
func (mr *MockBackfillProgressWriterMockRecorder) SetBackfillProgress(
	ctx, progress interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBackfillProgress", reflect.TypeOf((*MockBackfillProgressWriter)(nil).SetBackfillProgress), ctx, progress)
}

// MockBackfillProgressFlusher is a mock of BackfillProgressFlusher interface.
type MockBackfillProgressFlusher struct {
	ctrl     *gomock.Controller
	recorder *MockBackfillProgressFlusherMockRecorder
}

// MockBackfillProgressFlusherMockRecorder is the mock recorder for MockBackfillProgressFlusher.
type MockBackfillProgressFlusherMockRecorder struct {
	mock *MockBackfillProgressFlusher
}

// NewMockBackfillProgressFlusher creates a new mock instance.
func NewMockBackfillProgressFlusher(ctrl *gomock.Controller) *MockBackfillProgressFlusher {
	mock := &MockBackfillProgressFlusher{ctrl: ctrl}
	mock.recorder = &MockBackfillProgressFlusherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackfillProgressFlusher) EXPECT() *MockBackfillProgressFlusherMockRecorder {
	return m.recorder
}

// FlushCheckpoint mocks base method.
func (m *MockBackfillProgressFlusher) FlushCheckpoint(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushCheckpoint", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// FlushCheckpoint indicates an expected call of FlushCheckpoint.
func (mr *MockBackfillProgressFlusherMockRecorder) FlushCheckpoint(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushCheckpoint", reflect.TypeOf((*MockBackfillProgressFlusher)(nil).FlushCheckpoint), ctx)
}

// FlushFractionCompleted mocks base method.
func (m *MockBackfillProgressFlusher) FlushFractionCompleted(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushFractionCompleted", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// FlushFractionCompleted indicates an expected call of FlushFractionCompleted.
func (mr *MockBackfillProgressFlusherMockRecorder) FlushFractionCompleted(
	ctx interface{},
) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushFractionCompleted", reflect.TypeOf((*MockBackfillProgressFlusher)(nil).FlushFractionCompleted), ctx)
}
