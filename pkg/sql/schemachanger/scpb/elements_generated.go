// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Code generated by element_generator.go. DO NOT EDIT.

package scpb

import "fmt"


func (e AliasType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_AliasType) Element() Element {
	return e.AliasType
}

// ForEachAliasType iterates over elements of type AliasType.
// Deprecated
func ForEachAliasType(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *AliasType),
) {
  c.FilterAliasType().ForEach(fn)
}

// FindAliasType finds the first element of type AliasType.
// Deprecated
func FindAliasType(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *AliasType) {
	if tc := c.FilterAliasType(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*AliasType)
	}
	return current, target, element
}

// AliasTypeElements filters elements of type AliasType.
func (c *ElementCollection[E]) FilterAliasType() *ElementCollection[*AliasType] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*AliasType)
		return ok
	})
	return (*ElementCollection[*AliasType])(ret)
}

func (e CheckConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CheckConstraint) Element() Element {
	return e.CheckConstraint
}

// ForEachCheckConstraint iterates over elements of type CheckConstraint.
// Deprecated
func ForEachCheckConstraint(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *CheckConstraint),
) {
  c.FilterCheckConstraint().ForEach(fn)
}

// FindCheckConstraint finds the first element of type CheckConstraint.
// Deprecated
func FindCheckConstraint(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *CheckConstraint) {
	if tc := c.FilterCheckConstraint(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*CheckConstraint)
	}
	return current, target, element
}

// CheckConstraintElements filters elements of type CheckConstraint.
func (c *ElementCollection[E]) FilterCheckConstraint() *ElementCollection[*CheckConstraint] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*CheckConstraint)
		return ok
	})
	return (*ElementCollection[*CheckConstraint])(ret)
}

func (e CheckConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CheckConstraintUnvalidated) Element() Element {
	return e.CheckConstraintUnvalidated
}

// ForEachCheckConstraintUnvalidated iterates over elements of type CheckConstraintUnvalidated.
// Deprecated
func ForEachCheckConstraintUnvalidated(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *CheckConstraintUnvalidated),
) {
  c.FilterCheckConstraintUnvalidated().ForEach(fn)
}

// FindCheckConstraintUnvalidated finds the first element of type CheckConstraintUnvalidated.
// Deprecated
func FindCheckConstraintUnvalidated(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *CheckConstraintUnvalidated) {
	if tc := c.FilterCheckConstraintUnvalidated(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*CheckConstraintUnvalidated)
	}
	return current, target, element
}

// CheckConstraintUnvalidatedElements filters elements of type CheckConstraintUnvalidated.
func (c *ElementCollection[E]) FilterCheckConstraintUnvalidated() *ElementCollection[*CheckConstraintUnvalidated] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*CheckConstraintUnvalidated)
		return ok
	})
	return (*ElementCollection[*CheckConstraintUnvalidated])(ret)
}

func (e Column) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Column) Element() Element {
	return e.Column
}

// ForEachColumn iterates over elements of type Column.
// Deprecated
func ForEachColumn(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Column),
) {
  c.FilterColumn().ForEach(fn)
}

// FindColumn finds the first element of type Column.
// Deprecated
func FindColumn(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Column) {
	if tc := c.FilterColumn(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Column)
	}
	return current, target, element
}

// ColumnElements filters elements of type Column.
func (c *ElementCollection[E]) FilterColumn() *ElementCollection[*Column] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Column)
		return ok
	})
	return (*ElementCollection[*Column])(ret)
}

func (e ColumnComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnComment) Element() Element {
	return e.ColumnComment
}

// ForEachColumnComment iterates over elements of type ColumnComment.
// Deprecated
func ForEachColumnComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnComment),
) {
  c.FilterColumnComment().ForEach(fn)
}

// FindColumnComment finds the first element of type ColumnComment.
// Deprecated
func FindColumnComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnComment) {
	if tc := c.FilterColumnComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnComment)
	}
	return current, target, element
}

// ColumnCommentElements filters elements of type ColumnComment.
func (c *ElementCollection[E]) FilterColumnComment() *ElementCollection[*ColumnComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnComment)
		return ok
	})
	return (*ElementCollection[*ColumnComment])(ret)
}

func (e ColumnDefaultExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnDefaultExpression) Element() Element {
	return e.ColumnDefaultExpression
}

// ForEachColumnDefaultExpression iterates over elements of type ColumnDefaultExpression.
// Deprecated
func ForEachColumnDefaultExpression(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnDefaultExpression),
) {
  c.FilterColumnDefaultExpression().ForEach(fn)
}

// FindColumnDefaultExpression finds the first element of type ColumnDefaultExpression.
// Deprecated
func FindColumnDefaultExpression(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnDefaultExpression) {
	if tc := c.FilterColumnDefaultExpression(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnDefaultExpression)
	}
	return current, target, element
}

// ColumnDefaultExpressionElements filters elements of type ColumnDefaultExpression.
func (c *ElementCollection[E]) FilterColumnDefaultExpression() *ElementCollection[*ColumnDefaultExpression] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnDefaultExpression)
		return ok
	})
	return (*ElementCollection[*ColumnDefaultExpression])(ret)
}

func (e ColumnFamily) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnFamily) Element() Element {
	return e.ColumnFamily
}

// ForEachColumnFamily iterates over elements of type ColumnFamily.
// Deprecated
func ForEachColumnFamily(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnFamily),
) {
  c.FilterColumnFamily().ForEach(fn)
}

// FindColumnFamily finds the first element of type ColumnFamily.
// Deprecated
func FindColumnFamily(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnFamily) {
	if tc := c.FilterColumnFamily(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnFamily)
	}
	return current, target, element
}

// ColumnFamilyElements filters elements of type ColumnFamily.
func (c *ElementCollection[E]) FilterColumnFamily() *ElementCollection[*ColumnFamily] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnFamily)
		return ok
	})
	return (*ElementCollection[*ColumnFamily])(ret)
}

func (e ColumnName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnName) Element() Element {
	return e.ColumnName
}

// ForEachColumnName iterates over elements of type ColumnName.
// Deprecated
func ForEachColumnName(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnName),
) {
  c.FilterColumnName().ForEach(fn)
}

// FindColumnName finds the first element of type ColumnName.
// Deprecated
func FindColumnName(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnName) {
	if tc := c.FilterColumnName(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnName)
	}
	return current, target, element
}

// ColumnNameElements filters elements of type ColumnName.
func (c *ElementCollection[E]) FilterColumnName() *ElementCollection[*ColumnName] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnName)
		return ok
	})
	return (*ElementCollection[*ColumnName])(ret)
}

func (e ColumnNotNull) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnNotNull) Element() Element {
	return e.ColumnNotNull
}

// ForEachColumnNotNull iterates over elements of type ColumnNotNull.
// Deprecated
func ForEachColumnNotNull(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnNotNull),
) {
  c.FilterColumnNotNull().ForEach(fn)
}

// FindColumnNotNull finds the first element of type ColumnNotNull.
// Deprecated
func FindColumnNotNull(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnNotNull) {
	if tc := c.FilterColumnNotNull(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnNotNull)
	}
	return current, target, element
}

// ColumnNotNullElements filters elements of type ColumnNotNull.
func (c *ElementCollection[E]) FilterColumnNotNull() *ElementCollection[*ColumnNotNull] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnNotNull)
		return ok
	})
	return (*ElementCollection[*ColumnNotNull])(ret)
}

func (e ColumnOnUpdateExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnOnUpdateExpression) Element() Element {
	return e.ColumnOnUpdateExpression
}

// ForEachColumnOnUpdateExpression iterates over elements of type ColumnOnUpdateExpression.
// Deprecated
func ForEachColumnOnUpdateExpression(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnOnUpdateExpression),
) {
  c.FilterColumnOnUpdateExpression().ForEach(fn)
}

// FindColumnOnUpdateExpression finds the first element of type ColumnOnUpdateExpression.
// Deprecated
func FindColumnOnUpdateExpression(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnOnUpdateExpression) {
	if tc := c.FilterColumnOnUpdateExpression(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnOnUpdateExpression)
	}
	return current, target, element
}

// ColumnOnUpdateExpressionElements filters elements of type ColumnOnUpdateExpression.
func (c *ElementCollection[E]) FilterColumnOnUpdateExpression() *ElementCollection[*ColumnOnUpdateExpression] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnOnUpdateExpression)
		return ok
	})
	return (*ElementCollection[*ColumnOnUpdateExpression])(ret)
}

func (e ColumnType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnType) Element() Element {
	return e.ColumnType
}

// ForEachColumnType iterates over elements of type ColumnType.
// Deprecated
func ForEachColumnType(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ColumnType),
) {
  c.FilterColumnType().ForEach(fn)
}

// FindColumnType finds the first element of type ColumnType.
// Deprecated
func FindColumnType(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ColumnType) {
	if tc := c.FilterColumnType(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ColumnType)
	}
	return current, target, element
}

// ColumnTypeElements filters elements of type ColumnType.
func (c *ElementCollection[E]) FilterColumnType() *ElementCollection[*ColumnType] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ColumnType)
		return ok
	})
	return (*ElementCollection[*ColumnType])(ret)
}

func (e CompositeType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeType) Element() Element {
	return e.CompositeType
}

// ForEachCompositeType iterates over elements of type CompositeType.
// Deprecated
func ForEachCompositeType(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *CompositeType),
) {
  c.FilterCompositeType().ForEach(fn)
}

// FindCompositeType finds the first element of type CompositeType.
// Deprecated
func FindCompositeType(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *CompositeType) {
	if tc := c.FilterCompositeType(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*CompositeType)
	}
	return current, target, element
}

// CompositeTypeElements filters elements of type CompositeType.
func (c *ElementCollection[E]) FilterCompositeType() *ElementCollection[*CompositeType] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*CompositeType)
		return ok
	})
	return (*ElementCollection[*CompositeType])(ret)
}

func (e CompositeTypeAttrName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeTypeAttrName) Element() Element {
	return e.CompositeTypeAttrName
}

// ForEachCompositeTypeAttrName iterates over elements of type CompositeTypeAttrName.
// Deprecated
func ForEachCompositeTypeAttrName(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *CompositeTypeAttrName),
) {
  c.FilterCompositeTypeAttrName().ForEach(fn)
}

// FindCompositeTypeAttrName finds the first element of type CompositeTypeAttrName.
// Deprecated
func FindCompositeTypeAttrName(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *CompositeTypeAttrName) {
	if tc := c.FilterCompositeTypeAttrName(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*CompositeTypeAttrName)
	}
	return current, target, element
}

// CompositeTypeAttrNameElements filters elements of type CompositeTypeAttrName.
func (c *ElementCollection[E]) FilterCompositeTypeAttrName() *ElementCollection[*CompositeTypeAttrName] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*CompositeTypeAttrName)
		return ok
	})
	return (*ElementCollection[*CompositeTypeAttrName])(ret)
}

func (e CompositeTypeAttrType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeTypeAttrType) Element() Element {
	return e.CompositeTypeAttrType
}

// ForEachCompositeTypeAttrType iterates over elements of type CompositeTypeAttrType.
// Deprecated
func ForEachCompositeTypeAttrType(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *CompositeTypeAttrType),
) {
  c.FilterCompositeTypeAttrType().ForEach(fn)
}

// FindCompositeTypeAttrType finds the first element of type CompositeTypeAttrType.
// Deprecated
func FindCompositeTypeAttrType(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *CompositeTypeAttrType) {
	if tc := c.FilterCompositeTypeAttrType(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*CompositeTypeAttrType)
	}
	return current, target, element
}

// CompositeTypeAttrTypeElements filters elements of type CompositeTypeAttrType.
func (c *ElementCollection[E]) FilterCompositeTypeAttrType() *ElementCollection[*CompositeTypeAttrType] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*CompositeTypeAttrType)
		return ok
	})
	return (*ElementCollection[*CompositeTypeAttrType])(ret)
}

func (e ConstraintComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ConstraintComment) Element() Element {
	return e.ConstraintComment
}

// ForEachConstraintComment iterates over elements of type ConstraintComment.
// Deprecated
func ForEachConstraintComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ConstraintComment),
) {
  c.FilterConstraintComment().ForEach(fn)
}

// FindConstraintComment finds the first element of type ConstraintComment.
// Deprecated
func FindConstraintComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ConstraintComment) {
	if tc := c.FilterConstraintComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ConstraintComment)
	}
	return current, target, element
}

// ConstraintCommentElements filters elements of type ConstraintComment.
func (c *ElementCollection[E]) FilterConstraintComment() *ElementCollection[*ConstraintComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ConstraintComment)
		return ok
	})
	return (*ElementCollection[*ConstraintComment])(ret)
}

func (e ConstraintWithoutIndexName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ConstraintWithoutIndexName) Element() Element {
	return e.ConstraintWithoutIndexName
}

// ForEachConstraintWithoutIndexName iterates over elements of type ConstraintWithoutIndexName.
// Deprecated
func ForEachConstraintWithoutIndexName(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ConstraintWithoutIndexName),
) {
  c.FilterConstraintWithoutIndexName().ForEach(fn)
}

// FindConstraintWithoutIndexName finds the first element of type ConstraintWithoutIndexName.
// Deprecated
func FindConstraintWithoutIndexName(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ConstraintWithoutIndexName) {
	if tc := c.FilterConstraintWithoutIndexName(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ConstraintWithoutIndexName)
	}
	return current, target, element
}

// ConstraintWithoutIndexNameElements filters elements of type ConstraintWithoutIndexName.
func (c *ElementCollection[E]) FilterConstraintWithoutIndexName() *ElementCollection[*ConstraintWithoutIndexName] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ConstraintWithoutIndexName)
		return ok
	})
	return (*ElementCollection[*ConstraintWithoutIndexName])(ret)
}

func (e Database) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Database) Element() Element {
	return e.Database
}

// ForEachDatabase iterates over elements of type Database.
// Deprecated
func ForEachDatabase(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Database),
) {
  c.FilterDatabase().ForEach(fn)
}

// FindDatabase finds the first element of type Database.
// Deprecated
func FindDatabase(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Database) {
	if tc := c.FilterDatabase(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Database)
	}
	return current, target, element
}

// DatabaseElements filters elements of type Database.
func (c *ElementCollection[E]) FilterDatabase() *ElementCollection[*Database] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Database)
		return ok
	})
	return (*ElementCollection[*Database])(ret)
}

func (e DatabaseComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseComment) Element() Element {
	return e.DatabaseComment
}

// ForEachDatabaseComment iterates over elements of type DatabaseComment.
// Deprecated
func ForEachDatabaseComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *DatabaseComment),
) {
  c.FilterDatabaseComment().ForEach(fn)
}

// FindDatabaseComment finds the first element of type DatabaseComment.
// Deprecated
func FindDatabaseComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *DatabaseComment) {
	if tc := c.FilterDatabaseComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*DatabaseComment)
	}
	return current, target, element
}

// DatabaseCommentElements filters elements of type DatabaseComment.
func (c *ElementCollection[E]) FilterDatabaseComment() *ElementCollection[*DatabaseComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*DatabaseComment)
		return ok
	})
	return (*ElementCollection[*DatabaseComment])(ret)
}

func (e DatabaseData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseData) Element() Element {
	return e.DatabaseData
}

// ForEachDatabaseData iterates over elements of type DatabaseData.
// Deprecated
func ForEachDatabaseData(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *DatabaseData),
) {
  c.FilterDatabaseData().ForEach(fn)
}

// FindDatabaseData finds the first element of type DatabaseData.
// Deprecated
func FindDatabaseData(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *DatabaseData) {
	if tc := c.FilterDatabaseData(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*DatabaseData)
	}
	return current, target, element
}

// DatabaseDataElements filters elements of type DatabaseData.
func (c *ElementCollection[E]) FilterDatabaseData() *ElementCollection[*DatabaseData] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*DatabaseData)
		return ok
	})
	return (*ElementCollection[*DatabaseData])(ret)
}

func (e DatabaseRegionConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseRegionConfig) Element() Element {
	return e.DatabaseRegionConfig
}

// ForEachDatabaseRegionConfig iterates over elements of type DatabaseRegionConfig.
// Deprecated
func ForEachDatabaseRegionConfig(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *DatabaseRegionConfig),
) {
  c.FilterDatabaseRegionConfig().ForEach(fn)
}

// FindDatabaseRegionConfig finds the first element of type DatabaseRegionConfig.
// Deprecated
func FindDatabaseRegionConfig(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *DatabaseRegionConfig) {
	if tc := c.FilterDatabaseRegionConfig(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*DatabaseRegionConfig)
	}
	return current, target, element
}

// DatabaseRegionConfigElements filters elements of type DatabaseRegionConfig.
func (c *ElementCollection[E]) FilterDatabaseRegionConfig() *ElementCollection[*DatabaseRegionConfig] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*DatabaseRegionConfig)
		return ok
	})
	return (*ElementCollection[*DatabaseRegionConfig])(ret)
}

func (e DatabaseRoleSetting) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseRoleSetting) Element() Element {
	return e.DatabaseRoleSetting
}

// ForEachDatabaseRoleSetting iterates over elements of type DatabaseRoleSetting.
// Deprecated
func ForEachDatabaseRoleSetting(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *DatabaseRoleSetting),
) {
  c.FilterDatabaseRoleSetting().ForEach(fn)
}

// FindDatabaseRoleSetting finds the first element of type DatabaseRoleSetting.
// Deprecated
func FindDatabaseRoleSetting(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *DatabaseRoleSetting) {
	if tc := c.FilterDatabaseRoleSetting(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*DatabaseRoleSetting)
	}
	return current, target, element
}

// DatabaseRoleSettingElements filters elements of type DatabaseRoleSetting.
func (c *ElementCollection[E]) FilterDatabaseRoleSetting() *ElementCollection[*DatabaseRoleSetting] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*DatabaseRoleSetting)
		return ok
	})
	return (*ElementCollection[*DatabaseRoleSetting])(ret)
}

func (e EnumType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_EnumType) Element() Element {
	return e.EnumType
}

// ForEachEnumType iterates over elements of type EnumType.
// Deprecated
func ForEachEnumType(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *EnumType),
) {
  c.FilterEnumType().ForEach(fn)
}

// FindEnumType finds the first element of type EnumType.
// Deprecated
func FindEnumType(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *EnumType) {
	if tc := c.FilterEnumType(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*EnumType)
	}
	return current, target, element
}

// EnumTypeElements filters elements of type EnumType.
func (c *ElementCollection[E]) FilterEnumType() *ElementCollection[*EnumType] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*EnumType)
		return ok
	})
	return (*ElementCollection[*EnumType])(ret)
}

func (e EnumTypeValue) element() {}

// Element implements ElementGetter.
func (e * ElementProto_EnumTypeValue) Element() Element {
	return e.EnumTypeValue
}

// ForEachEnumTypeValue iterates over elements of type EnumTypeValue.
// Deprecated
func ForEachEnumTypeValue(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *EnumTypeValue),
) {
  c.FilterEnumTypeValue().ForEach(fn)
}

// FindEnumTypeValue finds the first element of type EnumTypeValue.
// Deprecated
func FindEnumTypeValue(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *EnumTypeValue) {
	if tc := c.FilterEnumTypeValue(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*EnumTypeValue)
	}
	return current, target, element
}

// EnumTypeValueElements filters elements of type EnumTypeValue.
func (c *ElementCollection[E]) FilterEnumTypeValue() *ElementCollection[*EnumTypeValue] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*EnumTypeValue)
		return ok
	})
	return (*ElementCollection[*EnumTypeValue])(ret)
}

func (e ForeignKeyConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ForeignKeyConstraint) Element() Element {
	return e.ForeignKeyConstraint
}

// ForEachForeignKeyConstraint iterates over elements of type ForeignKeyConstraint.
// Deprecated
func ForEachForeignKeyConstraint(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ForeignKeyConstraint),
) {
  c.FilterForeignKeyConstraint().ForEach(fn)
}

// FindForeignKeyConstraint finds the first element of type ForeignKeyConstraint.
// Deprecated
func FindForeignKeyConstraint(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ForeignKeyConstraint) {
	if tc := c.FilterForeignKeyConstraint(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ForeignKeyConstraint)
	}
	return current, target, element
}

// ForeignKeyConstraintElements filters elements of type ForeignKeyConstraint.
func (c *ElementCollection[E]) FilterForeignKeyConstraint() *ElementCollection[*ForeignKeyConstraint] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ForeignKeyConstraint)
		return ok
	})
	return (*ElementCollection[*ForeignKeyConstraint])(ret)
}

func (e ForeignKeyConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ForeignKeyConstraintUnvalidated) Element() Element {
	return e.ForeignKeyConstraintUnvalidated
}

// ForEachForeignKeyConstraintUnvalidated iterates over elements of type ForeignKeyConstraintUnvalidated.
// Deprecated
func ForEachForeignKeyConstraintUnvalidated(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *ForeignKeyConstraintUnvalidated),
) {
  c.FilterForeignKeyConstraintUnvalidated().ForEach(fn)
}

// FindForeignKeyConstraintUnvalidated finds the first element of type ForeignKeyConstraintUnvalidated.
// Deprecated
func FindForeignKeyConstraintUnvalidated(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *ForeignKeyConstraintUnvalidated) {
	if tc := c.FilterForeignKeyConstraintUnvalidated(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*ForeignKeyConstraintUnvalidated)
	}
	return current, target, element
}

// ForeignKeyConstraintUnvalidatedElements filters elements of type ForeignKeyConstraintUnvalidated.
func (c *ElementCollection[E]) FilterForeignKeyConstraintUnvalidated() *ElementCollection[*ForeignKeyConstraintUnvalidated] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*ForeignKeyConstraintUnvalidated)
		return ok
	})
	return (*ElementCollection[*ForeignKeyConstraintUnvalidated])(ret)
}

func (e Function) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Function) Element() Element {
	return e.Function
}

// ForEachFunction iterates over elements of type Function.
// Deprecated
func ForEachFunction(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Function),
) {
  c.FilterFunction().ForEach(fn)
}

// FindFunction finds the first element of type Function.
// Deprecated
func FindFunction(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Function) {
	if tc := c.FilterFunction(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Function)
	}
	return current, target, element
}

// FunctionElements filters elements of type Function.
func (c *ElementCollection[E]) FilterFunction() *ElementCollection[*Function] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Function)
		return ok
	})
	return (*ElementCollection[*Function])(ret)
}

func (e FunctionBody) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionBody) Element() Element {
	return e.FunctionBody
}

// ForEachFunctionBody iterates over elements of type FunctionBody.
// Deprecated
func ForEachFunctionBody(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionBody),
) {
  c.FilterFunctionBody().ForEach(fn)
}

// FindFunctionBody finds the first element of type FunctionBody.
// Deprecated
func FindFunctionBody(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionBody) {
	if tc := c.FilterFunctionBody(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionBody)
	}
	return current, target, element
}

// FunctionBodyElements filters elements of type FunctionBody.
func (c *ElementCollection[E]) FilterFunctionBody() *ElementCollection[*FunctionBody] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionBody)
		return ok
	})
	return (*ElementCollection[*FunctionBody])(ret)
}

func (e FunctionLeakProof) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionLeakProof) Element() Element {
	return e.FunctionLeakProof
}

// ForEachFunctionLeakProof iterates over elements of type FunctionLeakProof.
// Deprecated
func ForEachFunctionLeakProof(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionLeakProof),
) {
  c.FilterFunctionLeakProof().ForEach(fn)
}

// FindFunctionLeakProof finds the first element of type FunctionLeakProof.
// Deprecated
func FindFunctionLeakProof(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionLeakProof) {
	if tc := c.FilterFunctionLeakProof(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionLeakProof)
	}
	return current, target, element
}

// FunctionLeakProofElements filters elements of type FunctionLeakProof.
func (c *ElementCollection[E]) FilterFunctionLeakProof() *ElementCollection[*FunctionLeakProof] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionLeakProof)
		return ok
	})
	return (*ElementCollection[*FunctionLeakProof])(ret)
}

func (e FunctionName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionName) Element() Element {
	return e.FunctionName
}

// ForEachFunctionName iterates over elements of type FunctionName.
// Deprecated
func ForEachFunctionName(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionName),
) {
  c.FilterFunctionName().ForEach(fn)
}

// FindFunctionName finds the first element of type FunctionName.
// Deprecated
func FindFunctionName(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionName) {
	if tc := c.FilterFunctionName(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionName)
	}
	return current, target, element
}

// FunctionNameElements filters elements of type FunctionName.
func (c *ElementCollection[E]) FilterFunctionName() *ElementCollection[*FunctionName] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionName)
		return ok
	})
	return (*ElementCollection[*FunctionName])(ret)
}

func (e FunctionNullInputBehavior) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionNullInputBehavior) Element() Element {
	return e.FunctionNullInputBehavior
}

// ForEachFunctionNullInputBehavior iterates over elements of type FunctionNullInputBehavior.
// Deprecated
func ForEachFunctionNullInputBehavior(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionNullInputBehavior),
) {
  c.FilterFunctionNullInputBehavior().ForEach(fn)
}

// FindFunctionNullInputBehavior finds the first element of type FunctionNullInputBehavior.
// Deprecated
func FindFunctionNullInputBehavior(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionNullInputBehavior) {
	if tc := c.FilterFunctionNullInputBehavior(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionNullInputBehavior)
	}
	return current, target, element
}

// FunctionNullInputBehaviorElements filters elements of type FunctionNullInputBehavior.
func (c *ElementCollection[E]) FilterFunctionNullInputBehavior() *ElementCollection[*FunctionNullInputBehavior] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionNullInputBehavior)
		return ok
	})
	return (*ElementCollection[*FunctionNullInputBehavior])(ret)
}

func (e FunctionParamDefaultExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionParamDefaultExpression) Element() Element {
	return e.FunctionParamDefaultExpression
}

// ForEachFunctionParamDefaultExpression iterates over elements of type FunctionParamDefaultExpression.
// Deprecated
func ForEachFunctionParamDefaultExpression(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionParamDefaultExpression),
) {
  c.FilterFunctionParamDefaultExpression().ForEach(fn)
}

// FindFunctionParamDefaultExpression finds the first element of type FunctionParamDefaultExpression.
// Deprecated
func FindFunctionParamDefaultExpression(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionParamDefaultExpression) {
	if tc := c.FilterFunctionParamDefaultExpression(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionParamDefaultExpression)
	}
	return current, target, element
}

// FunctionParamDefaultExpressionElements filters elements of type FunctionParamDefaultExpression.
func (c *ElementCollection[E]) FilterFunctionParamDefaultExpression() *ElementCollection[*FunctionParamDefaultExpression] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionParamDefaultExpression)
		return ok
	})
	return (*ElementCollection[*FunctionParamDefaultExpression])(ret)
}

func (e FunctionVolatility) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionVolatility) Element() Element {
	return e.FunctionVolatility
}

// ForEachFunctionVolatility iterates over elements of type FunctionVolatility.
// Deprecated
func ForEachFunctionVolatility(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *FunctionVolatility),
) {
  c.FilterFunctionVolatility().ForEach(fn)
}

// FindFunctionVolatility finds the first element of type FunctionVolatility.
// Deprecated
func FindFunctionVolatility(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *FunctionVolatility) {
	if tc := c.FilterFunctionVolatility(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*FunctionVolatility)
	}
	return current, target, element
}

// FunctionVolatilityElements filters elements of type FunctionVolatility.
func (c *ElementCollection[E]) FilterFunctionVolatility() *ElementCollection[*FunctionVolatility] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*FunctionVolatility)
		return ok
	})
	return (*ElementCollection[*FunctionVolatility])(ret)
}

func (e IndexColumn) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexColumn) Element() Element {
	return e.IndexColumn
}

// ForEachIndexColumn iterates over elements of type IndexColumn.
// Deprecated
func ForEachIndexColumn(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexColumn),
) {
  c.FilterIndexColumn().ForEach(fn)
}

// FindIndexColumn finds the first element of type IndexColumn.
// Deprecated
func FindIndexColumn(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexColumn) {
	if tc := c.FilterIndexColumn(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexColumn)
	}
	return current, target, element
}

// IndexColumnElements filters elements of type IndexColumn.
func (c *ElementCollection[E]) FilterIndexColumn() *ElementCollection[*IndexColumn] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexColumn)
		return ok
	})
	return (*ElementCollection[*IndexColumn])(ret)
}

func (e IndexComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexComment) Element() Element {
	return e.IndexComment
}

// ForEachIndexComment iterates over elements of type IndexComment.
// Deprecated
func ForEachIndexComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexComment),
) {
  c.FilterIndexComment().ForEach(fn)
}

// FindIndexComment finds the first element of type IndexComment.
// Deprecated
func FindIndexComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexComment) {
	if tc := c.FilterIndexComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexComment)
	}
	return current, target, element
}

// IndexCommentElements filters elements of type IndexComment.
func (c *ElementCollection[E]) FilterIndexComment() *ElementCollection[*IndexComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexComment)
		return ok
	})
	return (*ElementCollection[*IndexComment])(ret)
}

func (e IndexData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexData) Element() Element {
	return e.IndexData
}

// ForEachIndexData iterates over elements of type IndexData.
// Deprecated
func ForEachIndexData(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexData),
) {
  c.FilterIndexData().ForEach(fn)
}

// FindIndexData finds the first element of type IndexData.
// Deprecated
func FindIndexData(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexData) {
	if tc := c.FilterIndexData(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexData)
	}
	return current, target, element
}

// IndexDataElements filters elements of type IndexData.
func (c *ElementCollection[E]) FilterIndexData() *ElementCollection[*IndexData] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexData)
		return ok
	})
	return (*ElementCollection[*IndexData])(ret)
}

func (e IndexName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexName) Element() Element {
	return e.IndexName
}

// ForEachIndexName iterates over elements of type IndexName.
// Deprecated
func ForEachIndexName(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexName),
) {
  c.FilterIndexName().ForEach(fn)
}

// FindIndexName finds the first element of type IndexName.
// Deprecated
func FindIndexName(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexName) {
	if tc := c.FilterIndexName(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexName)
	}
	return current, target, element
}

// IndexNameElements filters elements of type IndexName.
func (c *ElementCollection[E]) FilterIndexName() *ElementCollection[*IndexName] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexName)
		return ok
	})
	return (*ElementCollection[*IndexName])(ret)
}

func (e IndexPartitioning) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexPartitioning) Element() Element {
	return e.IndexPartitioning
}

// ForEachIndexPartitioning iterates over elements of type IndexPartitioning.
// Deprecated
func ForEachIndexPartitioning(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexPartitioning),
) {
  c.FilterIndexPartitioning().ForEach(fn)
}

// FindIndexPartitioning finds the first element of type IndexPartitioning.
// Deprecated
func FindIndexPartitioning(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexPartitioning) {
	if tc := c.FilterIndexPartitioning(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexPartitioning)
	}
	return current, target, element
}

// IndexPartitioningElements filters elements of type IndexPartitioning.
func (c *ElementCollection[E]) FilterIndexPartitioning() *ElementCollection[*IndexPartitioning] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexPartitioning)
		return ok
	})
	return (*ElementCollection[*IndexPartitioning])(ret)
}

func (e IndexZoneConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexZoneConfig) Element() Element {
	return e.IndexZoneConfig
}

// ForEachIndexZoneConfig iterates over elements of type IndexZoneConfig.
// Deprecated
func ForEachIndexZoneConfig(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *IndexZoneConfig),
) {
  c.FilterIndexZoneConfig().ForEach(fn)
}

// FindIndexZoneConfig finds the first element of type IndexZoneConfig.
// Deprecated
func FindIndexZoneConfig(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *IndexZoneConfig) {
	if tc := c.FilterIndexZoneConfig(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*IndexZoneConfig)
	}
	return current, target, element
}

// IndexZoneConfigElements filters elements of type IndexZoneConfig.
func (c *ElementCollection[E]) FilterIndexZoneConfig() *ElementCollection[*IndexZoneConfig] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*IndexZoneConfig)
		return ok
	})
	return (*ElementCollection[*IndexZoneConfig])(ret)
}

func (e Namespace) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Namespace) Element() Element {
	return e.Namespace
}

// ForEachNamespace iterates over elements of type Namespace.
// Deprecated
func ForEachNamespace(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Namespace),
) {
  c.FilterNamespace().ForEach(fn)
}

// FindNamespace finds the first element of type Namespace.
// Deprecated
func FindNamespace(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Namespace) {
	if tc := c.FilterNamespace(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Namespace)
	}
	return current, target, element
}

// NamespaceElements filters elements of type Namespace.
func (c *ElementCollection[E]) FilterNamespace() *ElementCollection[*Namespace] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Namespace)
		return ok
	})
	return (*ElementCollection[*Namespace])(ret)
}

func (e Owner) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Owner) Element() Element {
	return e.Owner
}

// ForEachOwner iterates over elements of type Owner.
// Deprecated
func ForEachOwner(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Owner),
) {
  c.FilterOwner().ForEach(fn)
}

// FindOwner finds the first element of type Owner.
// Deprecated
func FindOwner(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Owner) {
	if tc := c.FilterOwner(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Owner)
	}
	return current, target, element
}

// OwnerElements filters elements of type Owner.
func (c *ElementCollection[E]) FilterOwner() *ElementCollection[*Owner] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Owner)
		return ok
	})
	return (*ElementCollection[*Owner])(ret)
}

func (e PrimaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_PrimaryIndex) Element() Element {
	return e.PrimaryIndex
}

// ForEachPrimaryIndex iterates over elements of type PrimaryIndex.
// Deprecated
func ForEachPrimaryIndex(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *PrimaryIndex),
) {
  c.FilterPrimaryIndex().ForEach(fn)
}

// FindPrimaryIndex finds the first element of type PrimaryIndex.
// Deprecated
func FindPrimaryIndex(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *PrimaryIndex) {
	if tc := c.FilterPrimaryIndex(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*PrimaryIndex)
	}
	return current, target, element
}

// PrimaryIndexElements filters elements of type PrimaryIndex.
func (c *ElementCollection[E]) FilterPrimaryIndex() *ElementCollection[*PrimaryIndex] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*PrimaryIndex)
		return ok
	})
	return (*ElementCollection[*PrimaryIndex])(ret)
}

func (e RowLevelTTL) element() {}

// Element implements ElementGetter.
func (e * ElementProto_RowLevelTTL) Element() Element {
	return e.RowLevelTTL
}

// ForEachRowLevelTTL iterates over elements of type RowLevelTTL.
// Deprecated
func ForEachRowLevelTTL(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *RowLevelTTL),
) {
  c.FilterRowLevelTTL().ForEach(fn)
}

// FindRowLevelTTL finds the first element of type RowLevelTTL.
// Deprecated
func FindRowLevelTTL(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *RowLevelTTL) {
	if tc := c.FilterRowLevelTTL(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*RowLevelTTL)
	}
	return current, target, element
}

// RowLevelTTLElements filters elements of type RowLevelTTL.
func (c *ElementCollection[E]) FilterRowLevelTTL() *ElementCollection[*RowLevelTTL] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*RowLevelTTL)
		return ok
	})
	return (*ElementCollection[*RowLevelTTL])(ret)
}

func (e Schema) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Schema) Element() Element {
	return e.Schema
}

// ForEachSchema iterates over elements of type Schema.
// Deprecated
func ForEachSchema(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Schema),
) {
  c.FilterSchema().ForEach(fn)
}

// FindSchema finds the first element of type Schema.
// Deprecated
func FindSchema(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Schema) {
	if tc := c.FilterSchema(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Schema)
	}
	return current, target, element
}

// SchemaElements filters elements of type Schema.
func (c *ElementCollection[E]) FilterSchema() *ElementCollection[*Schema] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Schema)
		return ok
	})
	return (*ElementCollection[*Schema])(ret)
}

func (e SchemaChild) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaChild) Element() Element {
	return e.SchemaChild
}

// ForEachSchemaChild iterates over elements of type SchemaChild.
// Deprecated
func ForEachSchemaChild(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SchemaChild),
) {
  c.FilterSchemaChild().ForEach(fn)
}

// FindSchemaChild finds the first element of type SchemaChild.
// Deprecated
func FindSchemaChild(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SchemaChild) {
	if tc := c.FilterSchemaChild(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SchemaChild)
	}
	return current, target, element
}

// SchemaChildElements filters elements of type SchemaChild.
func (c *ElementCollection[E]) FilterSchemaChild() *ElementCollection[*SchemaChild] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SchemaChild)
		return ok
	})
	return (*ElementCollection[*SchemaChild])(ret)
}

func (e SchemaComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaComment) Element() Element {
	return e.SchemaComment
}

// ForEachSchemaComment iterates over elements of type SchemaComment.
// Deprecated
func ForEachSchemaComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SchemaComment),
) {
  c.FilterSchemaComment().ForEach(fn)
}

// FindSchemaComment finds the first element of type SchemaComment.
// Deprecated
func FindSchemaComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SchemaComment) {
	if tc := c.FilterSchemaComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SchemaComment)
	}
	return current, target, element
}

// SchemaCommentElements filters elements of type SchemaComment.
func (c *ElementCollection[E]) FilterSchemaComment() *ElementCollection[*SchemaComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SchemaComment)
		return ok
	})
	return (*ElementCollection[*SchemaComment])(ret)
}

func (e SchemaParent) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaParent) Element() Element {
	return e.SchemaParent
}

// ForEachSchemaParent iterates over elements of type SchemaParent.
// Deprecated
func ForEachSchemaParent(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SchemaParent),
) {
  c.FilterSchemaParent().ForEach(fn)
}

// FindSchemaParent finds the first element of type SchemaParent.
// Deprecated
func FindSchemaParent(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SchemaParent) {
	if tc := c.FilterSchemaParent(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SchemaParent)
	}
	return current, target, element
}

// SchemaParentElements filters elements of type SchemaParent.
func (c *ElementCollection[E]) FilterSchemaParent() *ElementCollection[*SchemaParent] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SchemaParent)
		return ok
	})
	return (*ElementCollection[*SchemaParent])(ret)
}

func (e SecondaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SecondaryIndex) Element() Element {
	return e.SecondaryIndex
}

// ForEachSecondaryIndex iterates over elements of type SecondaryIndex.
// Deprecated
func ForEachSecondaryIndex(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SecondaryIndex),
) {
  c.FilterSecondaryIndex().ForEach(fn)
}

// FindSecondaryIndex finds the first element of type SecondaryIndex.
// Deprecated
func FindSecondaryIndex(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SecondaryIndex) {
	if tc := c.FilterSecondaryIndex(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SecondaryIndex)
	}
	return current, target, element
}

// SecondaryIndexElements filters elements of type SecondaryIndex.
func (c *ElementCollection[E]) FilterSecondaryIndex() *ElementCollection[*SecondaryIndex] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SecondaryIndex)
		return ok
	})
	return (*ElementCollection[*SecondaryIndex])(ret)
}

func (e SecondaryIndexPartial) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SecondaryIndexPartial) Element() Element {
	return e.SecondaryIndexPartial
}

// ForEachSecondaryIndexPartial iterates over elements of type SecondaryIndexPartial.
// Deprecated
func ForEachSecondaryIndexPartial(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SecondaryIndexPartial),
) {
  c.FilterSecondaryIndexPartial().ForEach(fn)
}

// FindSecondaryIndexPartial finds the first element of type SecondaryIndexPartial.
// Deprecated
func FindSecondaryIndexPartial(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SecondaryIndexPartial) {
	if tc := c.FilterSecondaryIndexPartial(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SecondaryIndexPartial)
	}
	return current, target, element
}

// SecondaryIndexPartialElements filters elements of type SecondaryIndexPartial.
func (c *ElementCollection[E]) FilterSecondaryIndexPartial() *ElementCollection[*SecondaryIndexPartial] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SecondaryIndexPartial)
		return ok
	})
	return (*ElementCollection[*SecondaryIndexPartial])(ret)
}

func (e Sequence) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Sequence) Element() Element {
	return e.Sequence
}

// ForEachSequence iterates over elements of type Sequence.
// Deprecated
func ForEachSequence(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Sequence),
) {
  c.FilterSequence().ForEach(fn)
}

// FindSequence finds the first element of type Sequence.
// Deprecated
func FindSequence(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Sequence) {
	if tc := c.FilterSequence(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Sequence)
	}
	return current, target, element
}

// SequenceElements filters elements of type Sequence.
func (c *ElementCollection[E]) FilterSequence() *ElementCollection[*Sequence] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Sequence)
		return ok
	})
	return (*ElementCollection[*Sequence])(ret)
}

func (e SequenceOption) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SequenceOption) Element() Element {
	return e.SequenceOption
}

// ForEachSequenceOption iterates over elements of type SequenceOption.
// Deprecated
func ForEachSequenceOption(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SequenceOption),
) {
  c.FilterSequenceOption().ForEach(fn)
}

// FindSequenceOption finds the first element of type SequenceOption.
// Deprecated
func FindSequenceOption(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SequenceOption) {
	if tc := c.FilterSequenceOption(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SequenceOption)
	}
	return current, target, element
}

// SequenceOptionElements filters elements of type SequenceOption.
func (c *ElementCollection[E]) FilterSequenceOption() *ElementCollection[*SequenceOption] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SequenceOption)
		return ok
	})
	return (*ElementCollection[*SequenceOption])(ret)
}

func (e SequenceOwner) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SequenceOwner) Element() Element {
	return e.SequenceOwner
}

// ForEachSequenceOwner iterates over elements of type SequenceOwner.
// Deprecated
func ForEachSequenceOwner(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *SequenceOwner),
) {
  c.FilterSequenceOwner().ForEach(fn)
}

// FindSequenceOwner finds the first element of type SequenceOwner.
// Deprecated
func FindSequenceOwner(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *SequenceOwner) {
	if tc := c.FilterSequenceOwner(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*SequenceOwner)
	}
	return current, target, element
}

// SequenceOwnerElements filters elements of type SequenceOwner.
func (c *ElementCollection[E]) FilterSequenceOwner() *ElementCollection[*SequenceOwner] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*SequenceOwner)
		return ok
	})
	return (*ElementCollection[*SequenceOwner])(ret)
}

func (e Table) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Table) Element() Element {
	return e.Table
}

// ForEachTable iterates over elements of type Table.
// Deprecated
func ForEachTable(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *Table),
) {
  c.FilterTable().ForEach(fn)
}

// FindTable finds the first element of type Table.
// Deprecated
func FindTable(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *Table) {
	if tc := c.FilterTable(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*Table)
	}
	return current, target, element
}

// TableElements filters elements of type Table.
func (c *ElementCollection[E]) FilterTable() *ElementCollection[*Table] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*Table)
		return ok
	})
	return (*ElementCollection[*Table])(ret)
}

func (e TableComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableComment) Element() Element {
	return e.TableComment
}

// ForEachTableComment iterates over elements of type TableComment.
// Deprecated
func ForEachTableComment(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableComment),
) {
  c.FilterTableComment().ForEach(fn)
}

// FindTableComment finds the first element of type TableComment.
// Deprecated
func FindTableComment(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableComment) {
	if tc := c.FilterTableComment(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableComment)
	}
	return current, target, element
}

// TableCommentElements filters elements of type TableComment.
func (c *ElementCollection[E]) FilterTableComment() *ElementCollection[*TableComment] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableComment)
		return ok
	})
	return (*ElementCollection[*TableComment])(ret)
}

func (e TableData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableData) Element() Element {
	return e.TableData
}

// ForEachTableData iterates over elements of type TableData.
// Deprecated
func ForEachTableData(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableData),
) {
  c.FilterTableData().ForEach(fn)
}

// FindTableData finds the first element of type TableData.
// Deprecated
func FindTableData(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableData) {
	if tc := c.FilterTableData(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableData)
	}
	return current, target, element
}

// TableDataElements filters elements of type TableData.
func (c *ElementCollection[E]) FilterTableData() *ElementCollection[*TableData] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableData)
		return ok
	})
	return (*ElementCollection[*TableData])(ret)
}

func (e TableLocalityGlobal) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityGlobal) Element() Element {
	return e.TableLocalityGlobal
}

// ForEachTableLocalityGlobal iterates over elements of type TableLocalityGlobal.
// Deprecated
func ForEachTableLocalityGlobal(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableLocalityGlobal),
) {
  c.FilterTableLocalityGlobal().ForEach(fn)
}

// FindTableLocalityGlobal finds the first element of type TableLocalityGlobal.
// Deprecated
func FindTableLocalityGlobal(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableLocalityGlobal) {
	if tc := c.FilterTableLocalityGlobal(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableLocalityGlobal)
	}
	return current, target, element
}

// TableLocalityGlobalElements filters elements of type TableLocalityGlobal.
func (c *ElementCollection[E]) FilterTableLocalityGlobal() *ElementCollection[*TableLocalityGlobal] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableLocalityGlobal)
		return ok
	})
	return (*ElementCollection[*TableLocalityGlobal])(ret)
}

func (e TableLocalityPrimaryRegion) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityPrimaryRegion) Element() Element {
	return e.TableLocalityPrimaryRegion
}

// ForEachTableLocalityPrimaryRegion iterates over elements of type TableLocalityPrimaryRegion.
// Deprecated
func ForEachTableLocalityPrimaryRegion(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableLocalityPrimaryRegion),
) {
  c.FilterTableLocalityPrimaryRegion().ForEach(fn)
}

// FindTableLocalityPrimaryRegion finds the first element of type TableLocalityPrimaryRegion.
// Deprecated
func FindTableLocalityPrimaryRegion(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableLocalityPrimaryRegion) {
	if tc := c.FilterTableLocalityPrimaryRegion(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableLocalityPrimaryRegion)
	}
	return current, target, element
}

// TableLocalityPrimaryRegionElements filters elements of type TableLocalityPrimaryRegion.
func (c *ElementCollection[E]) FilterTableLocalityPrimaryRegion() *ElementCollection[*TableLocalityPrimaryRegion] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableLocalityPrimaryRegion)
		return ok
	})
	return (*ElementCollection[*TableLocalityPrimaryRegion])(ret)
}

func (e TableLocalityRegionalByRow) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityRegionalByRow) Element() Element {
	return e.TableLocalityRegionalByRow
}

// ForEachTableLocalityRegionalByRow iterates over elements of type TableLocalityRegionalByRow.
// Deprecated
func ForEachTableLocalityRegionalByRow(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableLocalityRegionalByRow),
) {
  c.FilterTableLocalityRegionalByRow().ForEach(fn)
}

// FindTableLocalityRegionalByRow finds the first element of type TableLocalityRegionalByRow.
// Deprecated
func FindTableLocalityRegionalByRow(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableLocalityRegionalByRow) {
	if tc := c.FilterTableLocalityRegionalByRow(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableLocalityRegionalByRow)
	}
	return current, target, element
}

// TableLocalityRegionalByRowElements filters elements of type TableLocalityRegionalByRow.
func (c *ElementCollection[E]) FilterTableLocalityRegionalByRow() *ElementCollection[*TableLocalityRegionalByRow] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableLocalityRegionalByRow)
		return ok
	})
	return (*ElementCollection[*TableLocalityRegionalByRow])(ret)
}

func (e TableLocalitySecondaryRegion) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalitySecondaryRegion) Element() Element {
	return e.TableLocalitySecondaryRegion
}

// ForEachTableLocalitySecondaryRegion iterates over elements of type TableLocalitySecondaryRegion.
// Deprecated
func ForEachTableLocalitySecondaryRegion(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableLocalitySecondaryRegion),
) {
  c.FilterTableLocalitySecondaryRegion().ForEach(fn)
}

// FindTableLocalitySecondaryRegion finds the first element of type TableLocalitySecondaryRegion.
// Deprecated
func FindTableLocalitySecondaryRegion(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableLocalitySecondaryRegion) {
	if tc := c.FilterTableLocalitySecondaryRegion(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableLocalitySecondaryRegion)
	}
	return current, target, element
}

// TableLocalitySecondaryRegionElements filters elements of type TableLocalitySecondaryRegion.
func (c *ElementCollection[E]) FilterTableLocalitySecondaryRegion() *ElementCollection[*TableLocalitySecondaryRegion] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableLocalitySecondaryRegion)
		return ok
	})
	return (*ElementCollection[*TableLocalitySecondaryRegion])(ret)
}

func (e TablePartitioning) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TablePartitioning) Element() Element {
	return e.TablePartitioning
}

// ForEachTablePartitioning iterates over elements of type TablePartitioning.
// Deprecated
func ForEachTablePartitioning(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TablePartitioning),
) {
  c.FilterTablePartitioning().ForEach(fn)
}

// FindTablePartitioning finds the first element of type TablePartitioning.
// Deprecated
func FindTablePartitioning(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TablePartitioning) {
	if tc := c.FilterTablePartitioning(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TablePartitioning)
	}
	return current, target, element
}

// TablePartitioningElements filters elements of type TablePartitioning.
func (c *ElementCollection[E]) FilterTablePartitioning() *ElementCollection[*TablePartitioning] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TablePartitioning)
		return ok
	})
	return (*ElementCollection[*TablePartitioning])(ret)
}

func (e TableSchemaLocked) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableSchemaLocked) Element() Element {
	return e.TableSchemaLocked
}

// ForEachTableSchemaLocked iterates over elements of type TableSchemaLocked.
// Deprecated
func ForEachTableSchemaLocked(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableSchemaLocked),
) {
  c.FilterTableSchemaLocked().ForEach(fn)
}

// FindTableSchemaLocked finds the first element of type TableSchemaLocked.
// Deprecated
func FindTableSchemaLocked(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableSchemaLocked) {
	if tc := c.FilterTableSchemaLocked(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableSchemaLocked)
	}
	return current, target, element
}

// TableSchemaLockedElements filters elements of type TableSchemaLocked.
func (c *ElementCollection[E]) FilterTableSchemaLocked() *ElementCollection[*TableSchemaLocked] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableSchemaLocked)
		return ok
	})
	return (*ElementCollection[*TableSchemaLocked])(ret)
}

func (e TableZoneConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableZoneConfig) Element() Element {
	return e.TableZoneConfig
}

// ForEachTableZoneConfig iterates over elements of type TableZoneConfig.
// Deprecated
func ForEachTableZoneConfig(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TableZoneConfig),
) {
  c.FilterTableZoneConfig().ForEach(fn)
}

// FindTableZoneConfig finds the first element of type TableZoneConfig.
// Deprecated
func FindTableZoneConfig(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TableZoneConfig) {
	if tc := c.FilterTableZoneConfig(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TableZoneConfig)
	}
	return current, target, element
}

// TableZoneConfigElements filters elements of type TableZoneConfig.
func (c *ElementCollection[E]) FilterTableZoneConfig() *ElementCollection[*TableZoneConfig] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TableZoneConfig)
		return ok
	})
	return (*ElementCollection[*TableZoneConfig])(ret)
}

func (e TemporaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TemporaryIndex) Element() Element {
	return e.TemporaryIndex
}

// ForEachTemporaryIndex iterates over elements of type TemporaryIndex.
// Deprecated
func ForEachTemporaryIndex(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *TemporaryIndex),
) {
  c.FilterTemporaryIndex().ForEach(fn)
}

// FindTemporaryIndex finds the first element of type TemporaryIndex.
// Deprecated
func FindTemporaryIndex(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *TemporaryIndex) {
	if tc := c.FilterTemporaryIndex(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*TemporaryIndex)
	}
	return current, target, element
}

// TemporaryIndexElements filters elements of type TemporaryIndex.
func (c *ElementCollection[E]) FilterTemporaryIndex() *ElementCollection[*TemporaryIndex] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*TemporaryIndex)
		return ok
	})
	return (*ElementCollection[*TemporaryIndex])(ret)
}

func (e UniqueWithoutIndexConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UniqueWithoutIndexConstraint) Element() Element {
	return e.UniqueWithoutIndexConstraint
}

// ForEachUniqueWithoutIndexConstraint iterates over elements of type UniqueWithoutIndexConstraint.
// Deprecated
func ForEachUniqueWithoutIndexConstraint(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraint),
) {
  c.FilterUniqueWithoutIndexConstraint().ForEach(fn)
}

// FindUniqueWithoutIndexConstraint finds the first element of type UniqueWithoutIndexConstraint.
// Deprecated
func FindUniqueWithoutIndexConstraint(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraint) {
	if tc := c.FilterUniqueWithoutIndexConstraint(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*UniqueWithoutIndexConstraint)
	}
	return current, target, element
}

// UniqueWithoutIndexConstraintElements filters elements of type UniqueWithoutIndexConstraint.
func (c *ElementCollection[E]) FilterUniqueWithoutIndexConstraint() *ElementCollection[*UniqueWithoutIndexConstraint] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*UniqueWithoutIndexConstraint)
		return ok
	})
	return (*ElementCollection[*UniqueWithoutIndexConstraint])(ret)
}

func (e UniqueWithoutIndexConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UniqueWithoutIndexConstraintUnvalidated) Element() Element {
	return e.UniqueWithoutIndexConstraintUnvalidated
}

// ForEachUniqueWithoutIndexConstraintUnvalidated iterates over elements of type UniqueWithoutIndexConstraintUnvalidated.
// Deprecated
func ForEachUniqueWithoutIndexConstraintUnvalidated(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraintUnvalidated),
) {
  c.FilterUniqueWithoutIndexConstraintUnvalidated().ForEach(fn)
}

// FindUniqueWithoutIndexConstraintUnvalidated finds the first element of type UniqueWithoutIndexConstraintUnvalidated.
// Deprecated
func FindUniqueWithoutIndexConstraintUnvalidated(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraintUnvalidated) {
	if tc := c.FilterUniqueWithoutIndexConstraintUnvalidated(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*UniqueWithoutIndexConstraintUnvalidated)
	}
	return current, target, element
}

// UniqueWithoutIndexConstraintUnvalidatedElements filters elements of type UniqueWithoutIndexConstraintUnvalidated.
func (c *ElementCollection[E]) FilterUniqueWithoutIndexConstraintUnvalidated() *ElementCollection[*UniqueWithoutIndexConstraintUnvalidated] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*UniqueWithoutIndexConstraintUnvalidated)
		return ok
	})
	return (*ElementCollection[*UniqueWithoutIndexConstraintUnvalidated])(ret)
}

func (e UserPrivileges) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UserPrivileges) Element() Element {
	return e.UserPrivileges
}

// ForEachUserPrivileges iterates over elements of type UserPrivileges.
// Deprecated
func ForEachUserPrivileges(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *UserPrivileges),
) {
  c.FilterUserPrivileges().ForEach(fn)
}

// FindUserPrivileges finds the first element of type UserPrivileges.
// Deprecated
func FindUserPrivileges(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *UserPrivileges) {
	if tc := c.FilterUserPrivileges(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*UserPrivileges)
	}
	return current, target, element
}

// UserPrivilegesElements filters elements of type UserPrivileges.
func (c *ElementCollection[E]) FilterUserPrivileges() *ElementCollection[*UserPrivileges] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*UserPrivileges)
		return ok
	})
	return (*ElementCollection[*UserPrivileges])(ret)
}

func (e View) element() {}

// Element implements ElementGetter.
func (e * ElementProto_View) Element() Element {
	return e.View
}

// ForEachView iterates over elements of type View.
// Deprecated
func ForEachView(
	c *ElementCollection[Element], fn func(current Status, target TargetStatus, e *View),
) {
  c.FilterView().ForEach(fn)
}

// FindView finds the first element of type View.
// Deprecated
func FindView(
	c *ElementCollection[Element],
) (current Status, target TargetStatus, element *View) {
	if tc := c.FilterView(); !tc.IsEmpty() {
		var e Element
		current, target, e = tc.Get(0)
		element = e.(*View)
	}
	return current, target, element
}

// ViewElements filters elements of type View.
func (c *ElementCollection[E]) FilterView() *ElementCollection[*View] {
	ret := c.genericFilter(func(_ Status, _ TargetStatus, e Element) bool {
		_, ok := e.(*View)
		return ok
	})
	return (*ElementCollection[*View])(ret)
}//
// SetElements sets the element inside the protobuf.
func (e* ElementProto) SetElement(element Element) {
	switch t := element.(type) {
		default:
			panic(fmt.Sprintf("unknown type %T", t))

		case *AliasType:
			e.ElementOneOf = &ElementProto_AliasType{ AliasType: t}
		case *CheckConstraint:
			e.ElementOneOf = &ElementProto_CheckConstraint{ CheckConstraint: t}
		case *CheckConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_CheckConstraintUnvalidated{ CheckConstraintUnvalidated: t}
		case *Column:
			e.ElementOneOf = &ElementProto_Column{ Column: t}
		case *ColumnComment:
			e.ElementOneOf = &ElementProto_ColumnComment{ ColumnComment: t}
		case *ColumnDefaultExpression:
			e.ElementOneOf = &ElementProto_ColumnDefaultExpression{ ColumnDefaultExpression: t}
		case *ColumnFamily:
			e.ElementOneOf = &ElementProto_ColumnFamily{ ColumnFamily: t}
		case *ColumnName:
			e.ElementOneOf = &ElementProto_ColumnName{ ColumnName: t}
		case *ColumnNotNull:
			e.ElementOneOf = &ElementProto_ColumnNotNull{ ColumnNotNull: t}
		case *ColumnOnUpdateExpression:
			e.ElementOneOf = &ElementProto_ColumnOnUpdateExpression{ ColumnOnUpdateExpression: t}
		case *ColumnType:
			e.ElementOneOf = &ElementProto_ColumnType{ ColumnType: t}
		case *CompositeType:
			e.ElementOneOf = &ElementProto_CompositeType{ CompositeType: t}
		case *CompositeTypeAttrName:
			e.ElementOneOf = &ElementProto_CompositeTypeAttrName{ CompositeTypeAttrName: t}
		case *CompositeTypeAttrType:
			e.ElementOneOf = &ElementProto_CompositeTypeAttrType{ CompositeTypeAttrType: t}
		case *ConstraintComment:
			e.ElementOneOf = &ElementProto_ConstraintComment{ ConstraintComment: t}
		case *ConstraintWithoutIndexName:
			e.ElementOneOf = &ElementProto_ConstraintWithoutIndexName{ ConstraintWithoutIndexName: t}
		case *Database:
			e.ElementOneOf = &ElementProto_Database{ Database: t}
		case *DatabaseComment:
			e.ElementOneOf = &ElementProto_DatabaseComment{ DatabaseComment: t}
		case *DatabaseData:
			e.ElementOneOf = &ElementProto_DatabaseData{ DatabaseData: t}
		case *DatabaseRegionConfig:
			e.ElementOneOf = &ElementProto_DatabaseRegionConfig{ DatabaseRegionConfig: t}
		case *DatabaseRoleSetting:
			e.ElementOneOf = &ElementProto_DatabaseRoleSetting{ DatabaseRoleSetting: t}
		case *EnumType:
			e.ElementOneOf = &ElementProto_EnumType{ EnumType: t}
		case *EnumTypeValue:
			e.ElementOneOf = &ElementProto_EnumTypeValue{ EnumTypeValue: t}
		case *ForeignKeyConstraint:
			e.ElementOneOf = &ElementProto_ForeignKeyConstraint{ ForeignKeyConstraint: t}
		case *ForeignKeyConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_ForeignKeyConstraintUnvalidated{ ForeignKeyConstraintUnvalidated: t}
		case *Function:
			e.ElementOneOf = &ElementProto_Function{ Function: t}
		case *FunctionBody:
			e.ElementOneOf = &ElementProto_FunctionBody{ FunctionBody: t}
		case *FunctionLeakProof:
			e.ElementOneOf = &ElementProto_FunctionLeakProof{ FunctionLeakProof: t}
		case *FunctionName:
			e.ElementOneOf = &ElementProto_FunctionName{ FunctionName: t}
		case *FunctionNullInputBehavior:
			e.ElementOneOf = &ElementProto_FunctionNullInputBehavior{ FunctionNullInputBehavior: t}
		case *FunctionParamDefaultExpression:
			e.ElementOneOf = &ElementProto_FunctionParamDefaultExpression{ FunctionParamDefaultExpression: t}
		case *FunctionVolatility:
			e.ElementOneOf = &ElementProto_FunctionVolatility{ FunctionVolatility: t}
		case *IndexColumn:
			e.ElementOneOf = &ElementProto_IndexColumn{ IndexColumn: t}
		case *IndexComment:
			e.ElementOneOf = &ElementProto_IndexComment{ IndexComment: t}
		case *IndexData:
			e.ElementOneOf = &ElementProto_IndexData{ IndexData: t}
		case *IndexName:
			e.ElementOneOf = &ElementProto_IndexName{ IndexName: t}
		case *IndexPartitioning:
			e.ElementOneOf = &ElementProto_IndexPartitioning{ IndexPartitioning: t}
		case *IndexZoneConfig:
			e.ElementOneOf = &ElementProto_IndexZoneConfig{ IndexZoneConfig: t}
		case *Namespace:
			e.ElementOneOf = &ElementProto_Namespace{ Namespace: t}
		case *Owner:
			e.ElementOneOf = &ElementProto_Owner{ Owner: t}
		case *PrimaryIndex:
			e.ElementOneOf = &ElementProto_PrimaryIndex{ PrimaryIndex: t}
		case *RowLevelTTL:
			e.ElementOneOf = &ElementProto_RowLevelTTL{ RowLevelTTL: t}
		case *Schema:
			e.ElementOneOf = &ElementProto_Schema{ Schema: t}
		case *SchemaChild:
			e.ElementOneOf = &ElementProto_SchemaChild{ SchemaChild: t}
		case *SchemaComment:
			e.ElementOneOf = &ElementProto_SchemaComment{ SchemaComment: t}
		case *SchemaParent:
			e.ElementOneOf = &ElementProto_SchemaParent{ SchemaParent: t}
		case *SecondaryIndex:
			e.ElementOneOf = &ElementProto_SecondaryIndex{ SecondaryIndex: t}
		case *SecondaryIndexPartial:
			e.ElementOneOf = &ElementProto_SecondaryIndexPartial{ SecondaryIndexPartial: t}
		case *Sequence:
			e.ElementOneOf = &ElementProto_Sequence{ Sequence: t}
		case *SequenceOption:
			e.ElementOneOf = &ElementProto_SequenceOption{ SequenceOption: t}
		case *SequenceOwner:
			e.ElementOneOf = &ElementProto_SequenceOwner{ SequenceOwner: t}
		case *Table:
			e.ElementOneOf = &ElementProto_Table{ Table: t}
		case *TableComment:
			e.ElementOneOf = &ElementProto_TableComment{ TableComment: t}
		case *TableData:
			e.ElementOneOf = &ElementProto_TableData{ TableData: t}
		case *TableLocalityGlobal:
			e.ElementOneOf = &ElementProto_TableLocalityGlobal{ TableLocalityGlobal: t}
		case *TableLocalityPrimaryRegion:
			e.ElementOneOf = &ElementProto_TableLocalityPrimaryRegion{ TableLocalityPrimaryRegion: t}
		case *TableLocalityRegionalByRow:
			e.ElementOneOf = &ElementProto_TableLocalityRegionalByRow{ TableLocalityRegionalByRow: t}
		case *TableLocalitySecondaryRegion:
			e.ElementOneOf = &ElementProto_TableLocalitySecondaryRegion{ TableLocalitySecondaryRegion: t}
		case *TablePartitioning:
			e.ElementOneOf = &ElementProto_TablePartitioning{ TablePartitioning: t}
		case *TableSchemaLocked:
			e.ElementOneOf = &ElementProto_TableSchemaLocked{ TableSchemaLocked: t}
		case *TableZoneConfig:
			e.ElementOneOf = &ElementProto_TableZoneConfig{ TableZoneConfig: t}
		case *TemporaryIndex:
			e.ElementOneOf = &ElementProto_TemporaryIndex{ TemporaryIndex: t}
		case *UniqueWithoutIndexConstraint:
			e.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraint{ UniqueWithoutIndexConstraint: t}
		case *UniqueWithoutIndexConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraintUnvalidated{ UniqueWithoutIndexConstraintUnvalidated: t}
		case *UserPrivileges:
			e.ElementOneOf = &ElementProto_UserPrivileges{ UserPrivileges: t}
		case *View:
			e.ElementOneOf = &ElementProto_View{ View: t}}
}
//
// GetElementOneOfProtos returns all one of protos.
func GetElementOneOfProtos() []interface{} {
	return []interface{} {

	((*ElementProto_AliasType)(nil)),
	((*ElementProto_CheckConstraint)(nil)),
	((*ElementProto_CheckConstraintUnvalidated)(nil)),
	((*ElementProto_Column)(nil)),
	((*ElementProto_ColumnComment)(nil)),
	((*ElementProto_ColumnDefaultExpression)(nil)),
	((*ElementProto_ColumnFamily)(nil)),
	((*ElementProto_ColumnName)(nil)),
	((*ElementProto_ColumnNotNull)(nil)),
	((*ElementProto_ColumnOnUpdateExpression)(nil)),
	((*ElementProto_ColumnType)(nil)),
	((*ElementProto_CompositeType)(nil)),
	((*ElementProto_CompositeTypeAttrName)(nil)),
	((*ElementProto_CompositeTypeAttrType)(nil)),
	((*ElementProto_ConstraintComment)(nil)),
	((*ElementProto_ConstraintWithoutIndexName)(nil)),
	((*ElementProto_Database)(nil)),
	((*ElementProto_DatabaseComment)(nil)),
	((*ElementProto_DatabaseData)(nil)),
	((*ElementProto_DatabaseRegionConfig)(nil)),
	((*ElementProto_DatabaseRoleSetting)(nil)),
	((*ElementProto_EnumType)(nil)),
	((*ElementProto_EnumTypeValue)(nil)),
	((*ElementProto_ForeignKeyConstraint)(nil)),
	((*ElementProto_ForeignKeyConstraintUnvalidated)(nil)),
	((*ElementProto_Function)(nil)),
	((*ElementProto_FunctionBody)(nil)),
	((*ElementProto_FunctionLeakProof)(nil)),
	((*ElementProto_FunctionName)(nil)),
	((*ElementProto_FunctionNullInputBehavior)(nil)),
	((*ElementProto_FunctionParamDefaultExpression)(nil)),
	((*ElementProto_FunctionVolatility)(nil)),
	((*ElementProto_IndexColumn)(nil)),
	((*ElementProto_IndexComment)(nil)),
	((*ElementProto_IndexData)(nil)),
	((*ElementProto_IndexName)(nil)),
	((*ElementProto_IndexPartitioning)(nil)),
	((*ElementProto_IndexZoneConfig)(nil)),
	((*ElementProto_Namespace)(nil)),
	((*ElementProto_Owner)(nil)),
	((*ElementProto_PrimaryIndex)(nil)),
	((*ElementProto_RowLevelTTL)(nil)),
	((*ElementProto_Schema)(nil)),
	((*ElementProto_SchemaChild)(nil)),
	((*ElementProto_SchemaComment)(nil)),
	((*ElementProto_SchemaParent)(nil)),
	((*ElementProto_SecondaryIndex)(nil)),
	((*ElementProto_SecondaryIndexPartial)(nil)),
	((*ElementProto_Sequence)(nil)),
	((*ElementProto_SequenceOption)(nil)),
	((*ElementProto_SequenceOwner)(nil)),
	((*ElementProto_Table)(nil)),
	((*ElementProto_TableComment)(nil)),
	((*ElementProto_TableData)(nil)),
	((*ElementProto_TableLocalityGlobal)(nil)),
	((*ElementProto_TableLocalityPrimaryRegion)(nil)),
	((*ElementProto_TableLocalityRegionalByRow)(nil)),
	((*ElementProto_TableLocalitySecondaryRegion)(nil)),
	((*ElementProto_TablePartitioning)(nil)),
	((*ElementProto_TableSchemaLocked)(nil)),
	((*ElementProto_TableZoneConfig)(nil)),
	((*ElementProto_TemporaryIndex)(nil)),
	((*ElementProto_UniqueWithoutIndexConstraint)(nil)),
	((*ElementProto_UniqueWithoutIndexConstraintUnvalidated)(nil)),
	((*ElementProto_UserPrivileges)(nil)),
	((*ElementProto_View)(nil)),}
}
//
// GetElementTypes returns all element types. 
func GetElementTypes() []interface{} {

	return []interface{} {

	((*AliasType)(nil)),
	((*CheckConstraint)(nil)),
	((*CheckConstraintUnvalidated)(nil)),
	((*Column)(nil)),
	((*ColumnComment)(nil)),
	((*ColumnDefaultExpression)(nil)),
	((*ColumnFamily)(nil)),
	((*ColumnName)(nil)),
	((*ColumnNotNull)(nil)),
	((*ColumnOnUpdateExpression)(nil)),
	((*ColumnType)(nil)),
	((*CompositeType)(nil)),
	((*CompositeTypeAttrName)(nil)),
	((*CompositeTypeAttrType)(nil)),
	((*ConstraintComment)(nil)),
	((*ConstraintWithoutIndexName)(nil)),
	((*Database)(nil)),
	((*DatabaseComment)(nil)),
	((*DatabaseData)(nil)),
	((*DatabaseRegionConfig)(nil)),
	((*DatabaseRoleSetting)(nil)),
	((*EnumType)(nil)),
	((*EnumTypeValue)(nil)),
	((*ForeignKeyConstraint)(nil)),
	((*ForeignKeyConstraintUnvalidated)(nil)),
	((*Function)(nil)),
	((*FunctionBody)(nil)),
	((*FunctionLeakProof)(nil)),
	((*FunctionName)(nil)),
	((*FunctionNullInputBehavior)(nil)),
	((*FunctionParamDefaultExpression)(nil)),
	((*FunctionVolatility)(nil)),
	((*IndexColumn)(nil)),
	((*IndexComment)(nil)),
	((*IndexData)(nil)),
	((*IndexName)(nil)),
	((*IndexPartitioning)(nil)),
	((*IndexZoneConfig)(nil)),
	((*Namespace)(nil)),
	((*Owner)(nil)),
	((*PrimaryIndex)(nil)),
	((*RowLevelTTL)(nil)),
	((*Schema)(nil)),
	((*SchemaChild)(nil)),
	((*SchemaComment)(nil)),
	((*SchemaParent)(nil)),
	((*SecondaryIndex)(nil)),
	((*SecondaryIndexPartial)(nil)),
	((*Sequence)(nil)),
	((*SequenceOption)(nil)),
	((*SequenceOwner)(nil)),
	((*Table)(nil)),
	((*TableComment)(nil)),
	((*TableData)(nil)),
	((*TableLocalityGlobal)(nil)),
	((*TableLocalityPrimaryRegion)(nil)),
	((*TableLocalityRegionalByRow)(nil)),
	((*TableLocalitySecondaryRegion)(nil)),
	((*TablePartitioning)(nil)),
	((*TableSchemaLocked)(nil)),
	((*TableZoneConfig)(nil)),
	((*TemporaryIndex)(nil)),
	((*UniqueWithoutIndexConstraint)(nil)),
	((*UniqueWithoutIndexConstraintUnvalidated)(nil)),
	((*UserPrivileges)(nil)),
	((*View)(nil)),}
}
//
// ForEachElementType loops over each element type
func ForEachElementType(fn func(e Element) error) error {
	for _, e := range GetElementTypes() {
		if err := fn(e.(Element)); err != nil {
			return err
		}
	}
	return nil
}
