// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Code generated by element_generator.go. DO NOT EDIT.

package scpb

type ElementStatusIterator interface {
	ForEachElementStatus(fn func(current Status, target TargetStatus, e Element))
}


func (e AliasType) element() {}

// ForEachAliasType iterates over elements of type AliasType.
func ForEachAliasType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *AliasType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*AliasType); ok {
			fn(current, target, elt)
		}
	})
}

// FindAliasType finds the first element of type AliasType.
func FindAliasType(b ElementStatusIterator) (current Status, target TargetStatus, element *AliasType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*AliasType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CheckConstraint) element() {}

// ForEachCheckConstraint iterates over elements of type CheckConstraint.
func ForEachCheckConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CheckConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindCheckConstraint finds the first element of type CheckConstraint.
func FindCheckConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *CheckConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CheckConstraintUnvalidated) element() {}

// ForEachCheckConstraintUnvalidated iterates over elements of type CheckConstraintUnvalidated.
func ForEachCheckConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CheckConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindCheckConstraintUnvalidated finds the first element of type CheckConstraintUnvalidated.
func FindCheckConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *CheckConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Column) element() {}

// ForEachColumn iterates over elements of type Column.
func ForEachColumn(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Column),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Column); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumn finds the first element of type Column.
func FindColumn(b ElementStatusIterator) (current Status, target TargetStatus, element *Column) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Column); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnComment) element() {}

// ForEachColumnComment iterates over elements of type ColumnComment.
func ForEachColumnComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnComment finds the first element of type ColumnComment.
func FindColumnComment(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnDefaultExpression) element() {}

// ForEachColumnDefaultExpression iterates over elements of type ColumnDefaultExpression.
func ForEachColumnDefaultExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnDefaultExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnDefaultExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnDefaultExpression finds the first element of type ColumnDefaultExpression.
func FindColumnDefaultExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnDefaultExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnDefaultExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnFamily) element() {}

// ForEachColumnFamily iterates over elements of type ColumnFamily.
func ForEachColumnFamily(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnFamily),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnFamily); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnFamily finds the first element of type ColumnFamily.
func FindColumnFamily(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnFamily) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnFamily); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnName) element() {}

// ForEachColumnName iterates over elements of type ColumnName.
func ForEachColumnName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnName); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnName finds the first element of type ColumnName.
func FindColumnName(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnNotNull) element() {}

// ForEachColumnNotNull iterates over elements of type ColumnNotNull.
func ForEachColumnNotNull(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnNotNull),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnNotNull); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnNotNull finds the first element of type ColumnNotNull.
func FindColumnNotNull(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnNotNull) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnNotNull); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnOnUpdateExpression) element() {}

// ForEachColumnOnUpdateExpression iterates over elements of type ColumnOnUpdateExpression.
func ForEachColumnOnUpdateExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnOnUpdateExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnOnUpdateExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnOnUpdateExpression finds the first element of type ColumnOnUpdateExpression.
func FindColumnOnUpdateExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnOnUpdateExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnOnUpdateExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnType) element() {}

// ForEachColumnType iterates over elements of type ColumnType.
func ForEachColumnType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnType); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnType finds the first element of type ColumnType.
func FindColumnType(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeType) element() {}

// ForEachCompositeType iterates over elements of type CompositeType.
func ForEachCompositeType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeType); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeType finds the first element of type CompositeType.
func FindCompositeType(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeTypeAttrName) element() {}

// ForEachCompositeTypeAttrName iterates over elements of type CompositeTypeAttrName.
func ForEachCompositeTypeAttrName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeTypeAttrName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrName); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeTypeAttrName finds the first element of type CompositeTypeAttrName.
func FindCompositeTypeAttrName(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeTypeAttrName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeTypeAttrType) element() {}

// ForEachCompositeTypeAttrType iterates over elements of type CompositeTypeAttrType.
func ForEachCompositeTypeAttrType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeTypeAttrType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrType); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeTypeAttrType finds the first element of type CompositeTypeAttrType.
func FindCompositeTypeAttrType(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeTypeAttrType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ConstraintComment) element() {}

// ForEachConstraintComment iterates over elements of type ConstraintComment.
func ForEachConstraintComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ConstraintComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindConstraintComment finds the first element of type ConstraintComment.
func FindConstraintComment(b ElementStatusIterator) (current Status, target TargetStatus, element *ConstraintComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ConstraintWithoutIndexName) element() {}

// ForEachConstraintWithoutIndexName iterates over elements of type ConstraintWithoutIndexName.
func ForEachConstraintWithoutIndexName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ConstraintWithoutIndexName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintWithoutIndexName); ok {
			fn(current, target, elt)
		}
	})
}

// FindConstraintWithoutIndexName finds the first element of type ConstraintWithoutIndexName.
func FindConstraintWithoutIndexName(b ElementStatusIterator) (current Status, target TargetStatus, element *ConstraintWithoutIndexName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintWithoutIndexName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Database) element() {}

// ForEachDatabase iterates over elements of type Database.
func ForEachDatabase(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Database),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Database); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabase finds the first element of type Database.
func FindDatabase(b ElementStatusIterator) (current Status, target TargetStatus, element *Database) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Database); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseComment) element() {}

// ForEachDatabaseComment iterates over elements of type DatabaseComment.
func ForEachDatabaseComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseComment finds the first element of type DatabaseComment.
func FindDatabaseComment(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseData) element() {}

// ForEachDatabaseData iterates over elements of type DatabaseData.
func ForEachDatabaseData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseData); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseData finds the first element of type DatabaseData.
func FindDatabaseData(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseRegionConfig) element() {}

// ForEachDatabaseRegionConfig iterates over elements of type DatabaseRegionConfig.
func ForEachDatabaseRegionConfig(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseRegionConfig),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRegionConfig); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseRegionConfig finds the first element of type DatabaseRegionConfig.
func FindDatabaseRegionConfig(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseRegionConfig) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRegionConfig); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseRoleSetting) element() {}

// ForEachDatabaseRoleSetting iterates over elements of type DatabaseRoleSetting.
func ForEachDatabaseRoleSetting(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseRoleSetting),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRoleSetting); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseRoleSetting finds the first element of type DatabaseRoleSetting.
func FindDatabaseRoleSetting(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseRoleSetting) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRoleSetting); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e EnumType) element() {}

// ForEachEnumType iterates over elements of type EnumType.
func ForEachEnumType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *EnumType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*EnumType); ok {
			fn(current, target, elt)
		}
	})
}

// FindEnumType finds the first element of type EnumType.
func FindEnumType(b ElementStatusIterator) (current Status, target TargetStatus, element *EnumType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*EnumType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e EnumTypeValue) element() {}

// ForEachEnumTypeValue iterates over elements of type EnumTypeValue.
func ForEachEnumTypeValue(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *EnumTypeValue),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*EnumTypeValue); ok {
			fn(current, target, elt)
		}
	})
}

// FindEnumTypeValue finds the first element of type EnumTypeValue.
func FindEnumTypeValue(b ElementStatusIterator) (current Status, target TargetStatus, element *EnumTypeValue) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*EnumTypeValue); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ForeignKeyConstraint) element() {}

// ForEachForeignKeyConstraint iterates over elements of type ForeignKeyConstraint.
func ForEachForeignKeyConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ForeignKeyConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindForeignKeyConstraint finds the first element of type ForeignKeyConstraint.
func FindForeignKeyConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *ForeignKeyConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ForeignKeyConstraintUnvalidated) element() {}

// ForEachForeignKeyConstraintUnvalidated iterates over elements of type ForeignKeyConstraintUnvalidated.
func ForEachForeignKeyConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ForeignKeyConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindForeignKeyConstraintUnvalidated finds the first element of type ForeignKeyConstraintUnvalidated.
func FindForeignKeyConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *ForeignKeyConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Function) element() {}

// ForEachFunction iterates over elements of type Function.
func ForEachFunction(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Function),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Function); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunction finds the first element of type Function.
func FindFunction(b ElementStatusIterator) (current Status, target TargetStatus, element *Function) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Function); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionBody) element() {}

// ForEachFunctionBody iterates over elements of type FunctionBody.
func ForEachFunctionBody(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionBody),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionBody); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionBody finds the first element of type FunctionBody.
func FindFunctionBody(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionBody) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionBody); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionLeakProof) element() {}

// ForEachFunctionLeakProof iterates over elements of type FunctionLeakProof.
func ForEachFunctionLeakProof(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionLeakProof),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionLeakProof); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionLeakProof finds the first element of type FunctionLeakProof.
func FindFunctionLeakProof(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionLeakProof) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionLeakProof); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionName) element() {}

// ForEachFunctionName iterates over elements of type FunctionName.
func ForEachFunctionName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionName); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionName finds the first element of type FunctionName.
func FindFunctionName(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionNullInputBehavior) element() {}

// ForEachFunctionNullInputBehavior iterates over elements of type FunctionNullInputBehavior.
func ForEachFunctionNullInputBehavior(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionNullInputBehavior),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionNullInputBehavior); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionNullInputBehavior finds the first element of type FunctionNullInputBehavior.
func FindFunctionNullInputBehavior(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionNullInputBehavior) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionNullInputBehavior); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionParamDefaultExpression) element() {}

// ForEachFunctionParamDefaultExpression iterates over elements of type FunctionParamDefaultExpression.
func ForEachFunctionParamDefaultExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionParamDefaultExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionParamDefaultExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionParamDefaultExpression finds the first element of type FunctionParamDefaultExpression.
func FindFunctionParamDefaultExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionParamDefaultExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionParamDefaultExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionVolatility) element() {}

// ForEachFunctionVolatility iterates over elements of type FunctionVolatility.
func ForEachFunctionVolatility(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionVolatility),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionVolatility); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionVolatility finds the first element of type FunctionVolatility.
func FindFunctionVolatility(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionVolatility) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionVolatility); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexColumn) element() {}

// ForEachIndexColumn iterates over elements of type IndexColumn.
func ForEachIndexColumn(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexColumn),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexColumn); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexColumn finds the first element of type IndexColumn.
func FindIndexColumn(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexColumn) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexColumn); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexComment) element() {}

// ForEachIndexComment iterates over elements of type IndexComment.
func ForEachIndexComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexComment finds the first element of type IndexComment.
func FindIndexComment(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexData) element() {}

// ForEachIndexData iterates over elements of type IndexData.
func ForEachIndexData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexData); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexData finds the first element of type IndexData.
func FindIndexData(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexName) element() {}

// ForEachIndexName iterates over elements of type IndexName.
func ForEachIndexName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexName); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexName finds the first element of type IndexName.
func FindIndexName(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexPartitioning) element() {}

// ForEachIndexPartitioning iterates over elements of type IndexPartitioning.
func ForEachIndexPartitioning(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexPartitioning),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexPartitioning); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexPartitioning finds the first element of type IndexPartitioning.
func FindIndexPartitioning(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexPartitioning) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexPartitioning); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Namespace) element() {}

// ForEachNamespace iterates over elements of type Namespace.
func ForEachNamespace(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Namespace),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Namespace); ok {
			fn(current, target, elt)
		}
	})
}

// FindNamespace finds the first element of type Namespace.
func FindNamespace(b ElementStatusIterator) (current Status, target TargetStatus, element *Namespace) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Namespace); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ObjectParent) element() {}

// ForEachObjectParent iterates over elements of type ObjectParent.
func ForEachObjectParent(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ObjectParent),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ObjectParent); ok {
			fn(current, target, elt)
		}
	})
}

// FindObjectParent finds the first element of type ObjectParent.
func FindObjectParent(b ElementStatusIterator) (current Status, target TargetStatus, element *ObjectParent) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ObjectParent); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Owner) element() {}

// ForEachOwner iterates over elements of type Owner.
func ForEachOwner(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Owner),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Owner); ok {
			fn(current, target, elt)
		}
	})
}

// FindOwner finds the first element of type Owner.
func FindOwner(b ElementStatusIterator) (current Status, target TargetStatus, element *Owner) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Owner); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e PrimaryIndex) element() {}

// ForEachPrimaryIndex iterates over elements of type PrimaryIndex.
func ForEachPrimaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *PrimaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*PrimaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindPrimaryIndex finds the first element of type PrimaryIndex.
func FindPrimaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *PrimaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*PrimaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e RowLevelTTL) element() {}

// ForEachRowLevelTTL iterates over elements of type RowLevelTTL.
func ForEachRowLevelTTL(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *RowLevelTTL),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*RowLevelTTL); ok {
			fn(current, target, elt)
		}
	})
}

// FindRowLevelTTL finds the first element of type RowLevelTTL.
func FindRowLevelTTL(b ElementStatusIterator) (current Status, target TargetStatus, element *RowLevelTTL) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*RowLevelTTL); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Schema) element() {}

// ForEachSchema iterates over elements of type Schema.
func ForEachSchema(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Schema),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Schema); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchema finds the first element of type Schema.
func FindSchema(b ElementStatusIterator) (current Status, target TargetStatus, element *Schema) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Schema); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SchemaComment) element() {}

// ForEachSchemaComment iterates over elements of type SchemaComment.
func ForEachSchemaComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SchemaComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SchemaComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchemaComment finds the first element of type SchemaComment.
func FindSchemaComment(b ElementStatusIterator) (current Status, target TargetStatus, element *SchemaComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SchemaComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SchemaParent) element() {}

// ForEachSchemaParent iterates over elements of type SchemaParent.
func ForEachSchemaParent(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SchemaParent),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SchemaParent); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchemaParent finds the first element of type SchemaParent.
func FindSchemaParent(b ElementStatusIterator) (current Status, target TargetStatus, element *SchemaParent) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SchemaParent); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SecondaryIndex) element() {}

// ForEachSecondaryIndex iterates over elements of type SecondaryIndex.
func ForEachSecondaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SecondaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindSecondaryIndex finds the first element of type SecondaryIndex.
func FindSecondaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *SecondaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SecondaryIndexPartial) element() {}

// ForEachSecondaryIndexPartial iterates over elements of type SecondaryIndexPartial.
func ForEachSecondaryIndexPartial(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SecondaryIndexPartial),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndexPartial); ok {
			fn(current, target, elt)
		}
	})
}

// FindSecondaryIndexPartial finds the first element of type SecondaryIndexPartial.
func FindSecondaryIndexPartial(b ElementStatusIterator) (current Status, target TargetStatus, element *SecondaryIndexPartial) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndexPartial); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Sequence) element() {}

// ForEachSequence iterates over elements of type Sequence.
func ForEachSequence(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Sequence),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Sequence); ok {
			fn(current, target, elt)
		}
	})
}

// FindSequence finds the first element of type Sequence.
func FindSequence(b ElementStatusIterator) (current Status, target TargetStatus, element *Sequence) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Sequence); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SequenceOwner) element() {}

// ForEachSequenceOwner iterates over elements of type SequenceOwner.
func ForEachSequenceOwner(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SequenceOwner),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SequenceOwner); ok {
			fn(current, target, elt)
		}
	})
}

// FindSequenceOwner finds the first element of type SequenceOwner.
func FindSequenceOwner(b ElementStatusIterator) (current Status, target TargetStatus, element *SequenceOwner) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SequenceOwner); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Table) element() {}

// ForEachTable iterates over elements of type Table.
func ForEachTable(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Table),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Table); ok {
			fn(current, target, elt)
		}
	})
}

// FindTable finds the first element of type Table.
func FindTable(b ElementStatusIterator) (current Status, target TargetStatus, element *Table) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Table); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableComment) element() {}

// ForEachTableComment iterates over elements of type TableComment.
func ForEachTableComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableComment finds the first element of type TableComment.
func FindTableComment(b ElementStatusIterator) (current Status, target TargetStatus, element *TableComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableData) element() {}

// ForEachTableData iterates over elements of type TableData.
func ForEachTableData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableData); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableData finds the first element of type TableData.
func FindTableData(b ElementStatusIterator) (current Status, target TargetStatus, element *TableData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityGlobal) element() {}

// ForEachTableLocalityGlobal iterates over elements of type TableLocalityGlobal.
func ForEachTableLocalityGlobal(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityGlobal),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityGlobal); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityGlobal finds the first element of type TableLocalityGlobal.
func FindTableLocalityGlobal(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityGlobal) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityGlobal); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityPrimaryRegion) element() {}

// ForEachTableLocalityPrimaryRegion iterates over elements of type TableLocalityPrimaryRegion.
func ForEachTableLocalityPrimaryRegion(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityPrimaryRegion),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityPrimaryRegion); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityPrimaryRegion finds the first element of type TableLocalityPrimaryRegion.
func FindTableLocalityPrimaryRegion(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityPrimaryRegion) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityPrimaryRegion); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityRegionalByRow) element() {}

// ForEachTableLocalityRegionalByRow iterates over elements of type TableLocalityRegionalByRow.
func ForEachTableLocalityRegionalByRow(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityRegionalByRow),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityRegionalByRow); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityRegionalByRow finds the first element of type TableLocalityRegionalByRow.
func FindTableLocalityRegionalByRow(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityRegionalByRow) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityRegionalByRow); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalitySecondaryRegion) element() {}

// ForEachTableLocalitySecondaryRegion iterates over elements of type TableLocalitySecondaryRegion.
func ForEachTableLocalitySecondaryRegion(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalitySecondaryRegion),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalitySecondaryRegion); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalitySecondaryRegion finds the first element of type TableLocalitySecondaryRegion.
func FindTableLocalitySecondaryRegion(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalitySecondaryRegion) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalitySecondaryRegion); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TablePartitioning) element() {}

// ForEachTablePartitioning iterates over elements of type TablePartitioning.
func ForEachTablePartitioning(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TablePartitioning),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TablePartitioning); ok {
			fn(current, target, elt)
		}
	})
}

// FindTablePartitioning finds the first element of type TablePartitioning.
func FindTablePartitioning(b ElementStatusIterator) (current Status, target TargetStatus, element *TablePartitioning) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TablePartitioning); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableZoneConfig) element() {}

// ForEachTableZoneConfig iterates over elements of type TableZoneConfig.
func ForEachTableZoneConfig(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableZoneConfig),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableZoneConfig); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableZoneConfig finds the first element of type TableZoneConfig.
func FindTableZoneConfig(b ElementStatusIterator) (current Status, target TargetStatus, element *TableZoneConfig) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableZoneConfig); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TemporaryIndex) element() {}

// ForEachTemporaryIndex iterates over elements of type TemporaryIndex.
func ForEachTemporaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TemporaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TemporaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindTemporaryIndex finds the first element of type TemporaryIndex.
func FindTemporaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *TemporaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TemporaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UniqueWithoutIndexConstraint) element() {}

// ForEachUniqueWithoutIndexConstraint iterates over elements of type UniqueWithoutIndexConstraint.
func ForEachUniqueWithoutIndexConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindUniqueWithoutIndexConstraint finds the first element of type UniqueWithoutIndexConstraint.
func FindUniqueWithoutIndexConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UniqueWithoutIndexConstraintUnvalidated) element() {}

// ForEachUniqueWithoutIndexConstraintUnvalidated iterates over elements of type UniqueWithoutIndexConstraintUnvalidated.
func ForEachUniqueWithoutIndexConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindUniqueWithoutIndexConstraintUnvalidated finds the first element of type UniqueWithoutIndexConstraintUnvalidated.
func FindUniqueWithoutIndexConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UserPrivileges) element() {}

// ForEachUserPrivileges iterates over elements of type UserPrivileges.
func ForEachUserPrivileges(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UserPrivileges),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UserPrivileges); ok {
			fn(current, target, elt)
		}
	})
}

// FindUserPrivileges finds the first element of type UserPrivileges.
func FindUserPrivileges(b ElementStatusIterator) (current Status, target TargetStatus, element *UserPrivileges) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UserPrivileges); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e View) element() {}

// ForEachView iterates over elements of type View.
func ForEachView(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *View),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*View); ok {
			fn(current, target, elt)
		}
	})
}

// FindView finds the first element of type View.
func FindView(b ElementStatusIterator) (current Status, target TargetStatus, element *View) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*View); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}