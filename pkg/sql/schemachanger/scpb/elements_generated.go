// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Code generated by element_generator.go. DO NOT EDIT.

package scpb

import "fmt"

type ElementStatusIterator interface {
	ForEachElementStatus(fn func(current Status, target TargetStatus, e Element))
}


func (e AliasType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_AliasType) Element() Element {
	return e.AliasType
}

// ForEachAliasType iterates over elements of type AliasType.
func ForEachAliasType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *AliasType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*AliasType); ok {
			fn(current, target, elt)
		}
	})
}

// FindAliasType finds the first element of type AliasType.
func FindAliasType(b ElementStatusIterator) (current Status, target TargetStatus, element *AliasType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*AliasType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CheckConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CheckConstraint) Element() Element {
	return e.CheckConstraint
}

// ForEachCheckConstraint iterates over elements of type CheckConstraint.
func ForEachCheckConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CheckConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindCheckConstraint finds the first element of type CheckConstraint.
func FindCheckConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *CheckConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CheckConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CheckConstraintUnvalidated) Element() Element {
	return e.CheckConstraintUnvalidated
}

// ForEachCheckConstraintUnvalidated iterates over elements of type CheckConstraintUnvalidated.
func ForEachCheckConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CheckConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindCheckConstraintUnvalidated finds the first element of type CheckConstraintUnvalidated.
func FindCheckConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *CheckConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CheckConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Column) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Column) Element() Element {
	return e.Column
}

// ForEachColumn iterates over elements of type Column.
func ForEachColumn(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Column),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Column); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumn finds the first element of type Column.
func FindColumn(b ElementStatusIterator) (current Status, target TargetStatus, element *Column) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Column); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnComment) Element() Element {
	return e.ColumnComment
}

// ForEachColumnComment iterates over elements of type ColumnComment.
func ForEachColumnComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnComment finds the first element of type ColumnComment.
func FindColumnComment(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnDefaultExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnDefaultExpression) Element() Element {
	return e.ColumnDefaultExpression
}

// ForEachColumnDefaultExpression iterates over elements of type ColumnDefaultExpression.
func ForEachColumnDefaultExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnDefaultExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnDefaultExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnDefaultExpression finds the first element of type ColumnDefaultExpression.
func FindColumnDefaultExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnDefaultExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnDefaultExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnFamily) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnFamily) Element() Element {
	return e.ColumnFamily
}

// ForEachColumnFamily iterates over elements of type ColumnFamily.
func ForEachColumnFamily(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnFamily),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnFamily); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnFamily finds the first element of type ColumnFamily.
func FindColumnFamily(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnFamily) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnFamily); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnName) Element() Element {
	return e.ColumnName
}

// ForEachColumnName iterates over elements of type ColumnName.
func ForEachColumnName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnName); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnName finds the first element of type ColumnName.
func FindColumnName(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnNotNull) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnNotNull) Element() Element {
	return e.ColumnNotNull
}

// ForEachColumnNotNull iterates over elements of type ColumnNotNull.
func ForEachColumnNotNull(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnNotNull),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnNotNull); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnNotNull finds the first element of type ColumnNotNull.
func FindColumnNotNull(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnNotNull) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnNotNull); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnOnUpdateExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnOnUpdateExpression) Element() Element {
	return e.ColumnOnUpdateExpression
}

// ForEachColumnOnUpdateExpression iterates over elements of type ColumnOnUpdateExpression.
func ForEachColumnOnUpdateExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnOnUpdateExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnOnUpdateExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnOnUpdateExpression finds the first element of type ColumnOnUpdateExpression.
func FindColumnOnUpdateExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnOnUpdateExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnOnUpdateExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ColumnType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ColumnType) Element() Element {
	return e.ColumnType
}

// ForEachColumnType iterates over elements of type ColumnType.
func ForEachColumnType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ColumnType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ColumnType); ok {
			fn(current, target, elt)
		}
	})
}

// FindColumnType finds the first element of type ColumnType.
func FindColumnType(b ElementStatusIterator) (current Status, target TargetStatus, element *ColumnType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ColumnType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeType) Element() Element {
	return e.CompositeType
}

// ForEachCompositeType iterates over elements of type CompositeType.
func ForEachCompositeType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeType); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeType finds the first element of type CompositeType.
func FindCompositeType(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeTypeAttrName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeTypeAttrName) Element() Element {
	return e.CompositeTypeAttrName
}

// ForEachCompositeTypeAttrName iterates over elements of type CompositeTypeAttrName.
func ForEachCompositeTypeAttrName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeTypeAttrName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrName); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeTypeAttrName finds the first element of type CompositeTypeAttrName.
func FindCompositeTypeAttrName(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeTypeAttrName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e CompositeTypeAttrType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_CompositeTypeAttrType) Element() Element {
	return e.CompositeTypeAttrType
}

// ForEachCompositeTypeAttrType iterates over elements of type CompositeTypeAttrType.
func ForEachCompositeTypeAttrType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *CompositeTypeAttrType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrType); ok {
			fn(current, target, elt)
		}
	})
}

// FindCompositeTypeAttrType finds the first element of type CompositeTypeAttrType.
func FindCompositeTypeAttrType(b ElementStatusIterator) (current Status, target TargetStatus, element *CompositeTypeAttrType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*CompositeTypeAttrType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ConstraintComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ConstraintComment) Element() Element {
	return e.ConstraintComment
}

// ForEachConstraintComment iterates over elements of type ConstraintComment.
func ForEachConstraintComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ConstraintComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindConstraintComment finds the first element of type ConstraintComment.
func FindConstraintComment(b ElementStatusIterator) (current Status, target TargetStatus, element *ConstraintComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ConstraintWithoutIndexName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ConstraintWithoutIndexName) Element() Element {
	return e.ConstraintWithoutIndexName
}

// ForEachConstraintWithoutIndexName iterates over elements of type ConstraintWithoutIndexName.
func ForEachConstraintWithoutIndexName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ConstraintWithoutIndexName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintWithoutIndexName); ok {
			fn(current, target, elt)
		}
	})
}

// FindConstraintWithoutIndexName finds the first element of type ConstraintWithoutIndexName.
func FindConstraintWithoutIndexName(b ElementStatusIterator) (current Status, target TargetStatus, element *ConstraintWithoutIndexName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ConstraintWithoutIndexName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Database) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Database) Element() Element {
	return e.Database
}

// ForEachDatabase iterates over elements of type Database.
func ForEachDatabase(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Database),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Database); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabase finds the first element of type Database.
func FindDatabase(b ElementStatusIterator) (current Status, target TargetStatus, element *Database) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Database); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseComment) Element() Element {
	return e.DatabaseComment
}

// ForEachDatabaseComment iterates over elements of type DatabaseComment.
func ForEachDatabaseComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseComment finds the first element of type DatabaseComment.
func FindDatabaseComment(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseData) Element() Element {
	return e.DatabaseData
}

// ForEachDatabaseData iterates over elements of type DatabaseData.
func ForEachDatabaseData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseData); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseData finds the first element of type DatabaseData.
func FindDatabaseData(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseRegionConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseRegionConfig) Element() Element {
	return e.DatabaseRegionConfig
}

// ForEachDatabaseRegionConfig iterates over elements of type DatabaseRegionConfig.
func ForEachDatabaseRegionConfig(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseRegionConfig),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRegionConfig); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseRegionConfig finds the first element of type DatabaseRegionConfig.
func FindDatabaseRegionConfig(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseRegionConfig) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRegionConfig); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e DatabaseRoleSetting) element() {}

// Element implements ElementGetter.
func (e * ElementProto_DatabaseRoleSetting) Element() Element {
	return e.DatabaseRoleSetting
}

// ForEachDatabaseRoleSetting iterates over elements of type DatabaseRoleSetting.
func ForEachDatabaseRoleSetting(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *DatabaseRoleSetting),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRoleSetting); ok {
			fn(current, target, elt)
		}
	})
}

// FindDatabaseRoleSetting finds the first element of type DatabaseRoleSetting.
func FindDatabaseRoleSetting(b ElementStatusIterator) (current Status, target TargetStatus, element *DatabaseRoleSetting) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*DatabaseRoleSetting); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e EnumType) element() {}

// Element implements ElementGetter.
func (e * ElementProto_EnumType) Element() Element {
	return e.EnumType
}

// ForEachEnumType iterates over elements of type EnumType.
func ForEachEnumType(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *EnumType),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*EnumType); ok {
			fn(current, target, elt)
		}
	})
}

// FindEnumType finds the first element of type EnumType.
func FindEnumType(b ElementStatusIterator) (current Status, target TargetStatus, element *EnumType) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*EnumType); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e EnumTypeValue) element() {}

// Element implements ElementGetter.
func (e * ElementProto_EnumTypeValue) Element() Element {
	return e.EnumTypeValue
}

// ForEachEnumTypeValue iterates over elements of type EnumTypeValue.
func ForEachEnumTypeValue(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *EnumTypeValue),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*EnumTypeValue); ok {
			fn(current, target, elt)
		}
	})
}

// FindEnumTypeValue finds the first element of type EnumTypeValue.
func FindEnumTypeValue(b ElementStatusIterator) (current Status, target TargetStatus, element *EnumTypeValue) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*EnumTypeValue); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ForeignKeyConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ForeignKeyConstraint) Element() Element {
	return e.ForeignKeyConstraint
}

// ForEachForeignKeyConstraint iterates over elements of type ForeignKeyConstraint.
func ForEachForeignKeyConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ForeignKeyConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindForeignKeyConstraint finds the first element of type ForeignKeyConstraint.
func FindForeignKeyConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *ForeignKeyConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e ForeignKeyConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_ForeignKeyConstraintUnvalidated) Element() Element {
	return e.ForeignKeyConstraintUnvalidated
}

// ForEachForeignKeyConstraintUnvalidated iterates over elements of type ForeignKeyConstraintUnvalidated.
func ForEachForeignKeyConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *ForeignKeyConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindForeignKeyConstraintUnvalidated finds the first element of type ForeignKeyConstraintUnvalidated.
func FindForeignKeyConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *ForeignKeyConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*ForeignKeyConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Function) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Function) Element() Element {
	return e.Function
}

// ForEachFunction iterates over elements of type Function.
func ForEachFunction(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Function),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Function); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunction finds the first element of type Function.
func FindFunction(b ElementStatusIterator) (current Status, target TargetStatus, element *Function) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Function); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionBody) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionBody) Element() Element {
	return e.FunctionBody
}

// ForEachFunctionBody iterates over elements of type FunctionBody.
func ForEachFunctionBody(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionBody),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionBody); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionBody finds the first element of type FunctionBody.
func FindFunctionBody(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionBody) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionBody); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionLeakProof) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionLeakProof) Element() Element {
	return e.FunctionLeakProof
}

// ForEachFunctionLeakProof iterates over elements of type FunctionLeakProof.
func ForEachFunctionLeakProof(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionLeakProof),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionLeakProof); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionLeakProof finds the first element of type FunctionLeakProof.
func FindFunctionLeakProof(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionLeakProof) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionLeakProof); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionName) Element() Element {
	return e.FunctionName
}

// ForEachFunctionName iterates over elements of type FunctionName.
func ForEachFunctionName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionName); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionName finds the first element of type FunctionName.
func FindFunctionName(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionNullInputBehavior) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionNullInputBehavior) Element() Element {
	return e.FunctionNullInputBehavior
}

// ForEachFunctionNullInputBehavior iterates over elements of type FunctionNullInputBehavior.
func ForEachFunctionNullInputBehavior(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionNullInputBehavior),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionNullInputBehavior); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionNullInputBehavior finds the first element of type FunctionNullInputBehavior.
func FindFunctionNullInputBehavior(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionNullInputBehavior) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionNullInputBehavior); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionParamDefaultExpression) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionParamDefaultExpression) Element() Element {
	return e.FunctionParamDefaultExpression
}

// ForEachFunctionParamDefaultExpression iterates over elements of type FunctionParamDefaultExpression.
func ForEachFunctionParamDefaultExpression(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionParamDefaultExpression),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionParamDefaultExpression); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionParamDefaultExpression finds the first element of type FunctionParamDefaultExpression.
func FindFunctionParamDefaultExpression(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionParamDefaultExpression) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionParamDefaultExpression); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e FunctionVolatility) element() {}

// Element implements ElementGetter.
func (e * ElementProto_FunctionVolatility) Element() Element {
	return e.FunctionVolatility
}

// ForEachFunctionVolatility iterates over elements of type FunctionVolatility.
func ForEachFunctionVolatility(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *FunctionVolatility),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*FunctionVolatility); ok {
			fn(current, target, elt)
		}
	})
}

// FindFunctionVolatility finds the first element of type FunctionVolatility.
func FindFunctionVolatility(b ElementStatusIterator) (current Status, target TargetStatus, element *FunctionVolatility) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*FunctionVolatility); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexColumn) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexColumn) Element() Element {
	return e.IndexColumn
}

// ForEachIndexColumn iterates over elements of type IndexColumn.
func ForEachIndexColumn(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexColumn),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexColumn); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexColumn finds the first element of type IndexColumn.
func FindIndexColumn(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexColumn) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexColumn); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexComment) Element() Element {
	return e.IndexComment
}

// ForEachIndexComment iterates over elements of type IndexComment.
func ForEachIndexComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexComment finds the first element of type IndexComment.
func FindIndexComment(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexData) Element() Element {
	return e.IndexData
}

// ForEachIndexData iterates over elements of type IndexData.
func ForEachIndexData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexData); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexData finds the first element of type IndexData.
func FindIndexData(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexName) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexName) Element() Element {
	return e.IndexName
}

// ForEachIndexName iterates over elements of type IndexName.
func ForEachIndexName(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexName),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexName); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexName finds the first element of type IndexName.
func FindIndexName(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexName) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexName); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexPartitioning) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexPartitioning) Element() Element {
	return e.IndexPartitioning
}

// ForEachIndexPartitioning iterates over elements of type IndexPartitioning.
func ForEachIndexPartitioning(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexPartitioning),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexPartitioning); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexPartitioning finds the first element of type IndexPartitioning.
func FindIndexPartitioning(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexPartitioning) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexPartitioning); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e IndexZoneConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_IndexZoneConfig) Element() Element {
	return e.IndexZoneConfig
}

// ForEachIndexZoneConfig iterates over elements of type IndexZoneConfig.
func ForEachIndexZoneConfig(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *IndexZoneConfig),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*IndexZoneConfig); ok {
			fn(current, target, elt)
		}
	})
}

// FindIndexZoneConfig finds the first element of type IndexZoneConfig.
func FindIndexZoneConfig(b ElementStatusIterator) (current Status, target TargetStatus, element *IndexZoneConfig) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*IndexZoneConfig); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Namespace) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Namespace) Element() Element {
	return e.Namespace
}

// ForEachNamespace iterates over elements of type Namespace.
func ForEachNamespace(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Namespace),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Namespace); ok {
			fn(current, target, elt)
		}
	})
}

// FindNamespace finds the first element of type Namespace.
func FindNamespace(b ElementStatusIterator) (current Status, target TargetStatus, element *Namespace) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Namespace); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Owner) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Owner) Element() Element {
	return e.Owner
}

// ForEachOwner iterates over elements of type Owner.
func ForEachOwner(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Owner),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Owner); ok {
			fn(current, target, elt)
		}
	})
}

// FindOwner finds the first element of type Owner.
func FindOwner(b ElementStatusIterator) (current Status, target TargetStatus, element *Owner) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Owner); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e PrimaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_PrimaryIndex) Element() Element {
	return e.PrimaryIndex
}

// ForEachPrimaryIndex iterates over elements of type PrimaryIndex.
func ForEachPrimaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *PrimaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*PrimaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindPrimaryIndex finds the first element of type PrimaryIndex.
func FindPrimaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *PrimaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*PrimaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e RowLevelTTL) element() {}

// Element implements ElementGetter.
func (e * ElementProto_RowLevelTTL) Element() Element {
	return e.RowLevelTTL
}

// ForEachRowLevelTTL iterates over elements of type RowLevelTTL.
func ForEachRowLevelTTL(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *RowLevelTTL),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*RowLevelTTL); ok {
			fn(current, target, elt)
		}
	})
}

// FindRowLevelTTL finds the first element of type RowLevelTTL.
func FindRowLevelTTL(b ElementStatusIterator) (current Status, target TargetStatus, element *RowLevelTTL) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*RowLevelTTL); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Schema) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Schema) Element() Element {
	return e.Schema
}

// ForEachSchema iterates over elements of type Schema.
func ForEachSchema(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Schema),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Schema); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchema finds the first element of type Schema.
func FindSchema(b ElementStatusIterator) (current Status, target TargetStatus, element *Schema) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Schema); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SchemaChild) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaChild) Element() Element {
	return e.SchemaChild
}

// ForEachSchemaChild iterates over elements of type SchemaChild.
func ForEachSchemaChild(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SchemaChild),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SchemaChild); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchemaChild finds the first element of type SchemaChild.
func FindSchemaChild(b ElementStatusIterator) (current Status, target TargetStatus, element *SchemaChild) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SchemaChild); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SchemaComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaComment) Element() Element {
	return e.SchemaComment
}

// ForEachSchemaComment iterates over elements of type SchemaComment.
func ForEachSchemaComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SchemaComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SchemaComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchemaComment finds the first element of type SchemaComment.
func FindSchemaComment(b ElementStatusIterator) (current Status, target TargetStatus, element *SchemaComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SchemaComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SchemaParent) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SchemaParent) Element() Element {
	return e.SchemaParent
}

// ForEachSchemaParent iterates over elements of type SchemaParent.
func ForEachSchemaParent(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SchemaParent),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SchemaParent); ok {
			fn(current, target, elt)
		}
	})
}

// FindSchemaParent finds the first element of type SchemaParent.
func FindSchemaParent(b ElementStatusIterator) (current Status, target TargetStatus, element *SchemaParent) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SchemaParent); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SecondaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SecondaryIndex) Element() Element {
	return e.SecondaryIndex
}

// ForEachSecondaryIndex iterates over elements of type SecondaryIndex.
func ForEachSecondaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SecondaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindSecondaryIndex finds the first element of type SecondaryIndex.
func FindSecondaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *SecondaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SecondaryIndexPartial) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SecondaryIndexPartial) Element() Element {
	return e.SecondaryIndexPartial
}

// ForEachSecondaryIndexPartial iterates over elements of type SecondaryIndexPartial.
func ForEachSecondaryIndexPartial(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SecondaryIndexPartial),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndexPartial); ok {
			fn(current, target, elt)
		}
	})
}

// FindSecondaryIndexPartial finds the first element of type SecondaryIndexPartial.
func FindSecondaryIndexPartial(b ElementStatusIterator) (current Status, target TargetStatus, element *SecondaryIndexPartial) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SecondaryIndexPartial); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Sequence) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Sequence) Element() Element {
	return e.Sequence
}

// ForEachSequence iterates over elements of type Sequence.
func ForEachSequence(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Sequence),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Sequence); ok {
			fn(current, target, elt)
		}
	})
}

// FindSequence finds the first element of type Sequence.
func FindSequence(b ElementStatusIterator) (current Status, target TargetStatus, element *Sequence) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Sequence); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e SequenceOwner) element() {}

// Element implements ElementGetter.
func (e * ElementProto_SequenceOwner) Element() Element {
	return e.SequenceOwner
}

// ForEachSequenceOwner iterates over elements of type SequenceOwner.
func ForEachSequenceOwner(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *SequenceOwner),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*SequenceOwner); ok {
			fn(current, target, elt)
		}
	})
}

// FindSequenceOwner finds the first element of type SequenceOwner.
func FindSequenceOwner(b ElementStatusIterator) (current Status, target TargetStatus, element *SequenceOwner) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*SequenceOwner); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e Table) element() {}

// Element implements ElementGetter.
func (e * ElementProto_Table) Element() Element {
	return e.Table
}

// ForEachTable iterates over elements of type Table.
func ForEachTable(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *Table),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*Table); ok {
			fn(current, target, elt)
		}
	})
}

// FindTable finds the first element of type Table.
func FindTable(b ElementStatusIterator) (current Status, target TargetStatus, element *Table) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*Table); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableComment) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableComment) Element() Element {
	return e.TableComment
}

// ForEachTableComment iterates over elements of type TableComment.
func ForEachTableComment(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableComment),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableComment); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableComment finds the first element of type TableComment.
func FindTableComment(b ElementStatusIterator) (current Status, target TargetStatus, element *TableComment) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableComment); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableData) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableData) Element() Element {
	return e.TableData
}

// ForEachTableData iterates over elements of type TableData.
func ForEachTableData(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableData),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableData); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableData finds the first element of type TableData.
func FindTableData(b ElementStatusIterator) (current Status, target TargetStatus, element *TableData) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableData); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityGlobal) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityGlobal) Element() Element {
	return e.TableLocalityGlobal
}

// ForEachTableLocalityGlobal iterates over elements of type TableLocalityGlobal.
func ForEachTableLocalityGlobal(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityGlobal),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityGlobal); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityGlobal finds the first element of type TableLocalityGlobal.
func FindTableLocalityGlobal(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityGlobal) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityGlobal); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityPrimaryRegion) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityPrimaryRegion) Element() Element {
	return e.TableLocalityPrimaryRegion
}

// ForEachTableLocalityPrimaryRegion iterates over elements of type TableLocalityPrimaryRegion.
func ForEachTableLocalityPrimaryRegion(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityPrimaryRegion),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityPrimaryRegion); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityPrimaryRegion finds the first element of type TableLocalityPrimaryRegion.
func FindTableLocalityPrimaryRegion(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityPrimaryRegion) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityPrimaryRegion); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalityRegionalByRow) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalityRegionalByRow) Element() Element {
	return e.TableLocalityRegionalByRow
}

// ForEachTableLocalityRegionalByRow iterates over elements of type TableLocalityRegionalByRow.
func ForEachTableLocalityRegionalByRow(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalityRegionalByRow),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityRegionalByRow); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalityRegionalByRow finds the first element of type TableLocalityRegionalByRow.
func FindTableLocalityRegionalByRow(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalityRegionalByRow) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalityRegionalByRow); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableLocalitySecondaryRegion) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableLocalitySecondaryRegion) Element() Element {
	return e.TableLocalitySecondaryRegion
}

// ForEachTableLocalitySecondaryRegion iterates over elements of type TableLocalitySecondaryRegion.
func ForEachTableLocalitySecondaryRegion(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableLocalitySecondaryRegion),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalitySecondaryRegion); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableLocalitySecondaryRegion finds the first element of type TableLocalitySecondaryRegion.
func FindTableLocalitySecondaryRegion(b ElementStatusIterator) (current Status, target TargetStatus, element *TableLocalitySecondaryRegion) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableLocalitySecondaryRegion); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TablePartitioning) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TablePartitioning) Element() Element {
	return e.TablePartitioning
}

// ForEachTablePartitioning iterates over elements of type TablePartitioning.
func ForEachTablePartitioning(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TablePartitioning),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TablePartitioning); ok {
			fn(current, target, elt)
		}
	})
}

// FindTablePartitioning finds the first element of type TablePartitioning.
func FindTablePartitioning(b ElementStatusIterator) (current Status, target TargetStatus, element *TablePartitioning) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TablePartitioning); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableSchemaLocked) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableSchemaLocked) Element() Element {
	return e.TableSchemaLocked
}

// ForEachTableSchemaLocked iterates over elements of type TableSchemaLocked.
func ForEachTableSchemaLocked(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableSchemaLocked),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableSchemaLocked); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableSchemaLocked finds the first element of type TableSchemaLocked.
func FindTableSchemaLocked(b ElementStatusIterator) (current Status, target TargetStatus, element *TableSchemaLocked) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableSchemaLocked); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TableZoneConfig) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TableZoneConfig) Element() Element {
	return e.TableZoneConfig
}

// ForEachTableZoneConfig iterates over elements of type TableZoneConfig.
func ForEachTableZoneConfig(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TableZoneConfig),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TableZoneConfig); ok {
			fn(current, target, elt)
		}
	})
}

// FindTableZoneConfig finds the first element of type TableZoneConfig.
func FindTableZoneConfig(b ElementStatusIterator) (current Status, target TargetStatus, element *TableZoneConfig) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TableZoneConfig); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e TemporaryIndex) element() {}

// Element implements ElementGetter.
func (e * ElementProto_TemporaryIndex) Element() Element {
	return e.TemporaryIndex
}

// ForEachTemporaryIndex iterates over elements of type TemporaryIndex.
func ForEachTemporaryIndex(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *TemporaryIndex),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*TemporaryIndex); ok {
			fn(current, target, elt)
		}
	})
}

// FindTemporaryIndex finds the first element of type TemporaryIndex.
func FindTemporaryIndex(b ElementStatusIterator) (current Status, target TargetStatus, element *TemporaryIndex) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*TemporaryIndex); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UniqueWithoutIndexConstraint) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UniqueWithoutIndexConstraint) Element() Element {
	return e.UniqueWithoutIndexConstraint
}

// ForEachUniqueWithoutIndexConstraint iterates over elements of type UniqueWithoutIndexConstraint.
func ForEachUniqueWithoutIndexConstraint(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraint),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraint); ok {
			fn(current, target, elt)
		}
	})
}

// FindUniqueWithoutIndexConstraint finds the first element of type UniqueWithoutIndexConstraint.
func FindUniqueWithoutIndexConstraint(b ElementStatusIterator) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraint) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraint); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UniqueWithoutIndexConstraintUnvalidated) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UniqueWithoutIndexConstraintUnvalidated) Element() Element {
	return e.UniqueWithoutIndexConstraintUnvalidated
}

// ForEachUniqueWithoutIndexConstraintUnvalidated iterates over elements of type UniqueWithoutIndexConstraintUnvalidated.
func ForEachUniqueWithoutIndexConstraintUnvalidated(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UniqueWithoutIndexConstraintUnvalidated),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraintUnvalidated); ok {
			fn(current, target, elt)
		}
	})
}

// FindUniqueWithoutIndexConstraintUnvalidated finds the first element of type UniqueWithoutIndexConstraintUnvalidated.
func FindUniqueWithoutIndexConstraintUnvalidated(b ElementStatusIterator) (current Status, target TargetStatus, element *UniqueWithoutIndexConstraintUnvalidated) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UniqueWithoutIndexConstraintUnvalidated); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e UserPrivileges) element() {}

// Element implements ElementGetter.
func (e * ElementProto_UserPrivileges) Element() Element {
	return e.UserPrivileges
}

// ForEachUserPrivileges iterates over elements of type UserPrivileges.
func ForEachUserPrivileges(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *UserPrivileges),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*UserPrivileges); ok {
			fn(current, target, elt)
		}
	})
}

// FindUserPrivileges finds the first element of type UserPrivileges.
func FindUserPrivileges(b ElementStatusIterator) (current Status, target TargetStatus, element *UserPrivileges) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*UserPrivileges); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}

func (e View) element() {}

// Element implements ElementGetter.
func (e * ElementProto_View) Element() Element {
	return e.View
}

// ForEachView iterates over elements of type View.
func ForEachView(
	b ElementStatusIterator, fn func(current Status, target TargetStatus, e *View),
) {
  if b == nil {
    return
  }
	b.ForEachElementStatus(func(current Status, target TargetStatus, e Element) {
		if elt, ok := e.(*View); ok {
			fn(current, target, elt)
		}
	})
}

// FindView finds the first element of type View.
func FindView(b ElementStatusIterator) (current Status, target TargetStatus, element *View) {
  if b == nil {
    return current, target, element
  }
	b.ForEachElementStatus(func(c Status, t TargetStatus, e Element) {
		if elt, ok := e.(*View); ok {
			element = elt
			current = c
			target = t
		}
	})
	return current, target, element
}//
// SetElements sets the element inside the protobuf.
func (e* ElementProto) SetElement(element Element) {
	switch t := element.(type) {
		default:
			panic(fmt.Sprintf("unknown type %T", t))

		case *AliasType:
			e.ElementOneOf = &ElementProto_AliasType{ AliasType: t}
		case *CheckConstraint:
			e.ElementOneOf = &ElementProto_CheckConstraint{ CheckConstraint: t}
		case *CheckConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_CheckConstraintUnvalidated{ CheckConstraintUnvalidated: t}
		case *Column:
			e.ElementOneOf = &ElementProto_Column{ Column: t}
		case *ColumnComment:
			e.ElementOneOf = &ElementProto_ColumnComment{ ColumnComment: t}
		case *ColumnDefaultExpression:
			e.ElementOneOf = &ElementProto_ColumnDefaultExpression{ ColumnDefaultExpression: t}
		case *ColumnFamily:
			e.ElementOneOf = &ElementProto_ColumnFamily{ ColumnFamily: t}
		case *ColumnName:
			e.ElementOneOf = &ElementProto_ColumnName{ ColumnName: t}
		case *ColumnNotNull:
			e.ElementOneOf = &ElementProto_ColumnNotNull{ ColumnNotNull: t}
		case *ColumnOnUpdateExpression:
			e.ElementOneOf = &ElementProto_ColumnOnUpdateExpression{ ColumnOnUpdateExpression: t}
		case *ColumnType:
			e.ElementOneOf = &ElementProto_ColumnType{ ColumnType: t}
		case *CompositeType:
			e.ElementOneOf = &ElementProto_CompositeType{ CompositeType: t}
		case *CompositeTypeAttrName:
			e.ElementOneOf = &ElementProto_CompositeTypeAttrName{ CompositeTypeAttrName: t}
		case *CompositeTypeAttrType:
			e.ElementOneOf = &ElementProto_CompositeTypeAttrType{ CompositeTypeAttrType: t}
		case *ConstraintComment:
			e.ElementOneOf = &ElementProto_ConstraintComment{ ConstraintComment: t}
		case *ConstraintWithoutIndexName:
			e.ElementOneOf = &ElementProto_ConstraintWithoutIndexName{ ConstraintWithoutIndexName: t}
		case *Database:
			e.ElementOneOf = &ElementProto_Database{ Database: t}
		case *DatabaseComment:
			e.ElementOneOf = &ElementProto_DatabaseComment{ DatabaseComment: t}
		case *DatabaseData:
			e.ElementOneOf = &ElementProto_DatabaseData{ DatabaseData: t}
		case *DatabaseRegionConfig:
			e.ElementOneOf = &ElementProto_DatabaseRegionConfig{ DatabaseRegionConfig: t}
		case *DatabaseRoleSetting:
			e.ElementOneOf = &ElementProto_DatabaseRoleSetting{ DatabaseRoleSetting: t}
		case *EnumType:
			e.ElementOneOf = &ElementProto_EnumType{ EnumType: t}
		case *EnumTypeValue:
			e.ElementOneOf = &ElementProto_EnumTypeValue{ EnumTypeValue: t}
		case *ForeignKeyConstraint:
			e.ElementOneOf = &ElementProto_ForeignKeyConstraint{ ForeignKeyConstraint: t}
		case *ForeignKeyConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_ForeignKeyConstraintUnvalidated{ ForeignKeyConstraintUnvalidated: t}
		case *Function:
			e.ElementOneOf = &ElementProto_Function{ Function: t}
		case *FunctionBody:
			e.ElementOneOf = &ElementProto_FunctionBody{ FunctionBody: t}
		case *FunctionLeakProof:
			e.ElementOneOf = &ElementProto_FunctionLeakProof{ FunctionLeakProof: t}
		case *FunctionName:
			e.ElementOneOf = &ElementProto_FunctionName{ FunctionName: t}
		case *FunctionNullInputBehavior:
			e.ElementOneOf = &ElementProto_FunctionNullInputBehavior{ FunctionNullInputBehavior: t}
		case *FunctionParamDefaultExpression:
			e.ElementOneOf = &ElementProto_FunctionParamDefaultExpression{ FunctionParamDefaultExpression: t}
		case *FunctionVolatility:
			e.ElementOneOf = &ElementProto_FunctionVolatility{ FunctionVolatility: t}
		case *IndexColumn:
			e.ElementOneOf = &ElementProto_IndexColumn{ IndexColumn: t}
		case *IndexComment:
			e.ElementOneOf = &ElementProto_IndexComment{ IndexComment: t}
		case *IndexData:
			e.ElementOneOf = &ElementProto_IndexData{ IndexData: t}
		case *IndexName:
			e.ElementOneOf = &ElementProto_IndexName{ IndexName: t}
		case *IndexPartitioning:
			e.ElementOneOf = &ElementProto_IndexPartitioning{ IndexPartitioning: t}
		case *IndexZoneConfig:
			e.ElementOneOf = &ElementProto_IndexZoneConfig{ IndexZoneConfig: t}
		case *Namespace:
			e.ElementOneOf = &ElementProto_Namespace{ Namespace: t}
		case *Owner:
			e.ElementOneOf = &ElementProto_Owner{ Owner: t}
		case *PrimaryIndex:
			e.ElementOneOf = &ElementProto_PrimaryIndex{ PrimaryIndex: t}
		case *RowLevelTTL:
			e.ElementOneOf = &ElementProto_RowLevelTTL{ RowLevelTTL: t}
		case *Schema:
			e.ElementOneOf = &ElementProto_Schema{ Schema: t}
		case *SchemaChild:
			e.ElementOneOf = &ElementProto_SchemaChild{ SchemaChild: t}
		case *SchemaComment:
			e.ElementOneOf = &ElementProto_SchemaComment{ SchemaComment: t}
		case *SchemaParent:
			e.ElementOneOf = &ElementProto_SchemaParent{ SchemaParent: t}
		case *SecondaryIndex:
			e.ElementOneOf = &ElementProto_SecondaryIndex{ SecondaryIndex: t}
		case *SecondaryIndexPartial:
			e.ElementOneOf = &ElementProto_SecondaryIndexPartial{ SecondaryIndexPartial: t}
		case *Sequence:
			e.ElementOneOf = &ElementProto_Sequence{ Sequence: t}
		case *SequenceOwner:
			e.ElementOneOf = &ElementProto_SequenceOwner{ SequenceOwner: t}
		case *Table:
			e.ElementOneOf = &ElementProto_Table{ Table: t}
		case *TableComment:
			e.ElementOneOf = &ElementProto_TableComment{ TableComment: t}
		case *TableData:
			e.ElementOneOf = &ElementProto_TableData{ TableData: t}
		case *TableLocalityGlobal:
			e.ElementOneOf = &ElementProto_TableLocalityGlobal{ TableLocalityGlobal: t}
		case *TableLocalityPrimaryRegion:
			e.ElementOneOf = &ElementProto_TableLocalityPrimaryRegion{ TableLocalityPrimaryRegion: t}
		case *TableLocalityRegionalByRow:
			e.ElementOneOf = &ElementProto_TableLocalityRegionalByRow{ TableLocalityRegionalByRow: t}
		case *TableLocalitySecondaryRegion:
			e.ElementOneOf = &ElementProto_TableLocalitySecondaryRegion{ TableLocalitySecondaryRegion: t}
		case *TablePartitioning:
			e.ElementOneOf = &ElementProto_TablePartitioning{ TablePartitioning: t}
		case *TableSchemaLocked:
			e.ElementOneOf = &ElementProto_TableSchemaLocked{ TableSchemaLocked: t}
		case *TableZoneConfig:
			e.ElementOneOf = &ElementProto_TableZoneConfig{ TableZoneConfig: t}
		case *TemporaryIndex:
			e.ElementOneOf = &ElementProto_TemporaryIndex{ TemporaryIndex: t}
		case *UniqueWithoutIndexConstraint:
			e.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraint{ UniqueWithoutIndexConstraint: t}
		case *UniqueWithoutIndexConstraintUnvalidated:
			e.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraintUnvalidated{ UniqueWithoutIndexConstraintUnvalidated: t}
		case *UserPrivileges:
			e.ElementOneOf = &ElementProto_UserPrivileges{ UserPrivileges: t}
		case *View:
			e.ElementOneOf = &ElementProto_View{ View: t}}
}
//
// GetElementOneOfProtos returns all one of protos.
func GetElementOneOfProtos() []interface{} {
	return []interface{} {

	((*ElementProto_AliasType)(nil)),
	((*ElementProto_CheckConstraint)(nil)),
	((*ElementProto_CheckConstraintUnvalidated)(nil)),
	((*ElementProto_Column)(nil)),
	((*ElementProto_ColumnComment)(nil)),
	((*ElementProto_ColumnDefaultExpression)(nil)),
	((*ElementProto_ColumnFamily)(nil)),
	((*ElementProto_ColumnName)(nil)),
	((*ElementProto_ColumnNotNull)(nil)),
	((*ElementProto_ColumnOnUpdateExpression)(nil)),
	((*ElementProto_ColumnType)(nil)),
	((*ElementProto_CompositeType)(nil)),
	((*ElementProto_CompositeTypeAttrName)(nil)),
	((*ElementProto_CompositeTypeAttrType)(nil)),
	((*ElementProto_ConstraintComment)(nil)),
	((*ElementProto_ConstraintWithoutIndexName)(nil)),
	((*ElementProto_Database)(nil)),
	((*ElementProto_DatabaseComment)(nil)),
	((*ElementProto_DatabaseData)(nil)),
	((*ElementProto_DatabaseRegionConfig)(nil)),
	((*ElementProto_DatabaseRoleSetting)(nil)),
	((*ElementProto_EnumType)(nil)),
	((*ElementProto_EnumTypeValue)(nil)),
	((*ElementProto_ForeignKeyConstraint)(nil)),
	((*ElementProto_ForeignKeyConstraintUnvalidated)(nil)),
	((*ElementProto_Function)(nil)),
	((*ElementProto_FunctionBody)(nil)),
	((*ElementProto_FunctionLeakProof)(nil)),
	((*ElementProto_FunctionName)(nil)),
	((*ElementProto_FunctionNullInputBehavior)(nil)),
	((*ElementProto_FunctionParamDefaultExpression)(nil)),
	((*ElementProto_FunctionVolatility)(nil)),
	((*ElementProto_IndexColumn)(nil)),
	((*ElementProto_IndexComment)(nil)),
	((*ElementProto_IndexData)(nil)),
	((*ElementProto_IndexName)(nil)),
	((*ElementProto_IndexPartitioning)(nil)),
	((*ElementProto_IndexZoneConfig)(nil)),
	((*ElementProto_Namespace)(nil)),
	((*ElementProto_Owner)(nil)),
	((*ElementProto_PrimaryIndex)(nil)),
	((*ElementProto_RowLevelTTL)(nil)),
	((*ElementProto_Schema)(nil)),
	((*ElementProto_SchemaChild)(nil)),
	((*ElementProto_SchemaComment)(nil)),
	((*ElementProto_SchemaParent)(nil)),
	((*ElementProto_SecondaryIndex)(nil)),
	((*ElementProto_SecondaryIndexPartial)(nil)),
	((*ElementProto_Sequence)(nil)),
	((*ElementProto_SequenceOwner)(nil)),
	((*ElementProto_Table)(nil)),
	((*ElementProto_TableComment)(nil)),
	((*ElementProto_TableData)(nil)),
	((*ElementProto_TableLocalityGlobal)(nil)),
	((*ElementProto_TableLocalityPrimaryRegion)(nil)),
	((*ElementProto_TableLocalityRegionalByRow)(nil)),
	((*ElementProto_TableLocalitySecondaryRegion)(nil)),
	((*ElementProto_TablePartitioning)(nil)),
	((*ElementProto_TableSchemaLocked)(nil)),
	((*ElementProto_TableZoneConfig)(nil)),
	((*ElementProto_TemporaryIndex)(nil)),
	((*ElementProto_UniqueWithoutIndexConstraint)(nil)),
	((*ElementProto_UniqueWithoutIndexConstraintUnvalidated)(nil)),
	((*ElementProto_UserPrivileges)(nil)),
	((*ElementProto_View)(nil)),}
}
//
// GetElementTypes returns all element types. 
func GetElementTypes() []interface{} {

	return []interface{} {

	((*AliasType)(nil)),
	((*CheckConstraint)(nil)),
	((*CheckConstraintUnvalidated)(nil)),
	((*Column)(nil)),
	((*ColumnComment)(nil)),
	((*ColumnDefaultExpression)(nil)),
	((*ColumnFamily)(nil)),
	((*ColumnName)(nil)),
	((*ColumnNotNull)(nil)),
	((*ColumnOnUpdateExpression)(nil)),
	((*ColumnType)(nil)),
	((*CompositeType)(nil)),
	((*CompositeTypeAttrName)(nil)),
	((*CompositeTypeAttrType)(nil)),
	((*ConstraintComment)(nil)),
	((*ConstraintWithoutIndexName)(nil)),
	((*Database)(nil)),
	((*DatabaseComment)(nil)),
	((*DatabaseData)(nil)),
	((*DatabaseRegionConfig)(nil)),
	((*DatabaseRoleSetting)(nil)),
	((*EnumType)(nil)),
	((*EnumTypeValue)(nil)),
	((*ForeignKeyConstraint)(nil)),
	((*ForeignKeyConstraintUnvalidated)(nil)),
	((*Function)(nil)),
	((*FunctionBody)(nil)),
	((*FunctionLeakProof)(nil)),
	((*FunctionName)(nil)),
	((*FunctionNullInputBehavior)(nil)),
	((*FunctionParamDefaultExpression)(nil)),
	((*FunctionVolatility)(nil)),
	((*IndexColumn)(nil)),
	((*IndexComment)(nil)),
	((*IndexData)(nil)),
	((*IndexName)(nil)),
	((*IndexPartitioning)(nil)),
	((*IndexZoneConfig)(nil)),
	((*Namespace)(nil)),
	((*Owner)(nil)),
	((*PrimaryIndex)(nil)),
	((*RowLevelTTL)(nil)),
	((*Schema)(nil)),
	((*SchemaChild)(nil)),
	((*SchemaComment)(nil)),
	((*SchemaParent)(nil)),
	((*SecondaryIndex)(nil)),
	((*SecondaryIndexPartial)(nil)),
	((*Sequence)(nil)),
	((*SequenceOwner)(nil)),
	((*Table)(nil)),
	((*TableComment)(nil)),
	((*TableData)(nil)),
	((*TableLocalityGlobal)(nil)),
	((*TableLocalityPrimaryRegion)(nil)),
	((*TableLocalityRegionalByRow)(nil)),
	((*TableLocalitySecondaryRegion)(nil)),
	((*TablePartitioning)(nil)),
	((*TableSchemaLocked)(nil)),
	((*TableZoneConfig)(nil)),
	((*TemporaryIndex)(nil)),
	((*UniqueWithoutIndexConstraint)(nil)),
	((*UniqueWithoutIndexConstraintUnvalidated)(nil)),
	((*UserPrivileges)(nil)),
	((*View)(nil)),}
}
//
// ForEachElementType loops over each element type
func ForEachElementType(fn func(e Element) error) error {
	for _, e := range GetElementTypes() {
		if err := fn(e.(Element)); err != nil {
			return err
		}
	}
	return nil
}
