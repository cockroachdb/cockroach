// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sessiondatapb/local_only_session_data.proto

package sessiondatapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_security "github.com/cockroachdb/cockroach/pkg/security"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LocalOnlySessionData contains the serializable components of session
// parameters that only influence execution on the gateway nodes.
type LocalOnlySessionData struct {
	// SaveTablesPrefix indicates that a table should be created with the
	// given prefix for the output of each subexpression in a query. If
	// SaveTablesPrefix is empty, no tables are created.
	SaveTablesPrefix string `protobuf:"bytes,1,opt,name=save_tables_prefix,json=saveTablesPrefix,proto3" json:"save_tables_prefix,omitempty"`
	// OptimizerFKCascadesLimit is the maximum number of cascading operations that
	// are run for a single query.
	OptimizerFKCascadesLimit int64 `protobuf:"varint,2,opt,name=optimizer_fk_cascades_limit,json=optimizerFkCascadesLimit,proto3" json:"optimizer_fk_cascades_limit,omitempty"`
	// StmtTimeout is the duration a query is permitted to run before it is
	// canceled by the session. If set to 0, there is no timeout.
	StmtTimeout time.Duration `protobuf:"varint,3,opt,name=stmt_timeout,json=stmtTimeout,proto3,casttype=time.Duration" json:"stmt_timeout,omitempty"`
	// IdleInSessionTimeout is the duration a session is permitted to idle before
	// the session is canceled. If set to 0, there is no timeout.
	IdleInSessionTimeout time.Duration `protobuf:"varint,4,opt,name=idle_in_session_timeout,json=idleInSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_session_timeout,omitempty"`
	// IdleInTransactionSessionTimeout is the duration a session is permitted to
	// idle in a transaction before the session is canceled.
	// If set to 0, there is no timeout.
	IdleInTransactionSessionTimeout time.Duration `protobuf:"varint,5,opt,name=idle_in_transaction_session_timeout,json=idleInTransactionSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_transaction_session_timeout,omitempty"`
	// NoticeDisplaySeverity indicates the level of Severity to send notices for the given
	// session. This should ideally be of type pgnotice.DisplaySeverity, but cannot be done
	// due to a circular dependency.
	NoticeDisplaySeverity uint32 `protobuf:"varint,6,opt,name=notice_display_severity,json=noticeDisplaySeverity,proto3" json:"notice_display_severity,omitempty"`
	// ReorderJoinsLimit indicates the number of joins at which the optimizer should
	// stop attempting to reorder.
	ReorderJoinsLimit int64 `protobuf:"varint,7,opt,name=reorder_joins_limit,json=reorderJoinsLimit,proto3" json:"reorder_joins_limit,omitempty"`
	// DefaultTxnPriority indicates the default priority of newly created
	// transactions.
	// NOTE: we'd prefer to use tree.UserPriority here, but doing so would
	// introduce a package dependency cycle.
	DefaultTxnPriority int64 `protobuf:"varint,8,opt,name=default_txn_priority,json=defaultTxnPriority,proto3" json:"default_txn_priority,omitempty"`
	// DefaultTxnReadOnly indicates the default read-only status of newly
	// created transactions.
	DefaultTxnReadOnly bool `protobuf:"varint,9,opt,name=default_txn_read_only,json=defaultTxnReadOnly,proto3" json:"default_txn_read_only,omitempty"`
	// DefaultTxnUseFollowerReads indicates whether transactions should be
	// created by default using an AS OF SYSTEM TIME clause far enough in the
	// past to facilitate reads against followers. If true, transactions will
	// also default to being read-only.
	DefaultTxnUseFollowerReads bool `protobuf:"varint,10,opt,name=default_txn_use_follower_reads,json=defaultTxnUseFollowerReads,proto3" json:"default_txn_use_follower_reads,omitempty"`
	// PartiallyDistributedPlansDisabled indicates whether the partially
	// distributed plans produced by distSQLSpecExecFactory are disabled. It
	// should be set to 'true' only in tests that verify that the old and the
	// new factories return exactly the same physical plans.
	// TODO(yuzefovich): remove it when deleting old sql.execFactory.
	PartiallyDistributedPlansDisabled bool `protobuf:"varint,11,opt,name=partially_distributed_plans_disabled,json=partiallyDistributedPlansDisabled,proto3" json:"partially_distributed_plans_disabled,omitempty"`
	// OptimizerUseHistograms indicates whether we should use histograms for
	// cardinality estimation in the optimizer.
	OptimizerUseHistograms bool `protobuf:"varint,12,opt,name=optimizer_use_histograms,json=optimizerUseHistograms,proto3" json:"optimizer_use_histograms,omitempty"`
	// OptimizerUseMultiColStats indicates whether we should use multi-column
	// statistics for cardinality estimation in the optimizer.
	OptimizerUseMultiColStats bool `protobuf:"varint,13,opt,name=optimizer_use_multi_col_stats,json=optimizerUseMultiColStats,proto3" json:"optimizer_use_multi_col_stats,omitempty"`
	// LocalityOptimizedSearch indicates that the optimizer will try to plan scans
	// and lookup joins in which local nodes (i.e., nodes in the gateway region)
	// are searched for matching rows before remote nodes, in the hope that the
	// execution engine can avoid visiting remote nodes.
	LocalityOptimizedSearch bool `protobuf:"varint,14,opt,name=locality_optimized_search,json=localityOptimizedSearch,proto3" json:"locality_optimized_search,omitempty"`
	// SafeUpdates causes errors when the client
	// sends syntax that may have unwanted side effects.
	SafeUpdates bool `protobuf:"varint,15,opt,name=safe_updates,json=safeUpdates,proto3" json:"safe_updates,omitempty"`
	// PreferLookupJoinsForFKs causes foreign key operations to prefer lookup
	// joins.
	PreferLookupJoinsForFKs bool `protobuf:"varint,16,opt,name=prefer_lookup_joins_for_fks,json=preferLookupJoinsForFks,proto3" json:"prefer_lookup_joins_for_fks,omitempty"`
	// ZigzagJoinEnabled indicates whether the optimizer should try and plan a
	// zigzag join.
	ZigzagJoinEnabled bool `protobuf:"varint,17,opt,name=zigzag_join_enabled,json=zigzagJoinEnabled,proto3" json:"zigzag_join_enabled,omitempty"`
	// RequireExplicitPrimaryKeys indicates whether CREATE TABLE statements should
	// error out if no primary key is provided.
	RequireExplicitPrimaryKeys bool `protobuf:"varint,18,opt,name=require_explicit_primary_keys,json=requireExplicitPrimaryKeys,proto3" json:"require_explicit_primary_keys,omitempty"`
	// ForceSavepointRestart overrides the default SAVEPOINT behavior
	// for compatibility with certain ORMs. When this flag is set,
	// the savepoint name will no longer be compared against the magic
	// identifier `cockroach_restart` in order use a restartable
	// transaction.
	ForceSavepointRestart bool `protobuf:"varint,19,opt,name=force_savepoint_restart,json=forceSavepointRestart,proto3" json:"force_savepoint_restart,omitempty"`
	// AllowPrepareAsOptPlan must be set to allow use of
	//   PREPARE name AS OPT PLAN '...'
	AllowPrepareAsOptPlan bool `protobuf:"varint,20,opt,name=allow_prepare_as_opt_plan,json=allowPrepareAsOptPlan,proto3" json:"allow_prepare_as_opt_plan,omitempty"`
	// TempTablesEnabled indicates whether temporary tables can be created or not.
	TempTablesEnabled bool `protobuf:"varint,21,opt,name=temp_tables_enabled,json=tempTablesEnabled,proto3" json:"temp_tables_enabled,omitempty"`
	// ImplicitPartitioningEnabled indicates whether implicit column partitioning
	// can be created.
	ImplicitColumnPartitioningEnabled bool `protobuf:"varint,22,opt,name=implicit_column_partitioning_enabled,json=implicitColumnPartitioningEnabled,proto3" json:"implicit_column_partitioning_enabled,omitempty"`
	// OverrideMultiRegionZoneConfigEnabled indicates whether zone configurations can be
	// modified for multi-region databases and tables/indexes/partitions.
	OverrideMultiRegionZoneConfigEnabled bool `protobuf:"varint,24,opt,name=override_multi_region_zone_config_enabled,json=overrideMultiRegionZoneConfigEnabled,proto3" json:"override_multi_region_zone_config_enabled,omitempty"`
	// HashShardedIndexesEnabled indicates whether hash sharded indexes can be created.
	HashShardedIndexesEnabled bool `protobuf:"varint,25,opt,name=hash_sharded_indexes_enabled,json=hashShardedIndexesEnabled,proto3" json:"hash_sharded_indexes_enabled,omitempty"`
	// DisallowFullTableScans indicates whether queries that plan full table scans
	// should be rejected.
	DisallowFullTableScans bool `protobuf:"varint,26,opt,name=disallow_full_table_scans,json=disallowFullTableScans,proto3" json:"disallow_full_table_scans,omitempty"`
	// ImplicitSelectForUpdate is true if FOR UPDATE locking may be used during
	// the row-fetch phase of mutation statements.
	ImplicitSelectForUpdate bool `protobuf:"varint,27,opt,name=implicit_select_for_update,json=implicitSelectForUpdate,proto3" json:"implicit_select_for_update,omitempty"`
	// InsertFastPath is true if the fast path for insert (with VALUES input) may
	// be used.
	InsertFastPath bool `protobuf:"varint,28,opt,name=insert_fast_path,json=insertFastPath,proto3" json:"insert_fast_path,omitempty"`
	// AlterColumnTypeGeneralEnabled is true if ALTER TABLE ... ALTER COLUMN ...
	// TYPE x may be used for general conversions requiring online schema change/
	AlterColumnTypeGeneralEnabled bool `protobuf:"varint,29,opt,name=alter_column_type_general_enabled,json=alterColumnTypeGeneralEnabled,proto3" json:"alter_column_type_general_enabled,omitempty"`
	// SynchronousCommit is a dummy setting for the synchronous_commit var.
	SynchronousCommit bool `protobuf:"varint,30,opt,name=synchronous_commit,json=synchronousCommit,proto3" json:"synchronous_commit,omitempty"`
	// EnableSeqScan is a dummy setting for the enable_seqscan var.
	EnableSeqScan bool `protobuf:"varint,31,opt,name=enable_seq_scan,json=enableSeqScan,proto3" json:"enable_seq_scan,omitempty"`
	// EnableUniqueWithoutIndexConstraints indicates whether creating unique
	// constraints without an index is allowed.
	// TODO(rytaft): remove this once unique without index constraints are fully
	// supported.
	EnableUniqueWithoutIndexConstraints bool `protobuf:"varint,33,opt,name=enable_unique_without_index_constraints,json=enableUniqueWithoutIndexConstraints,proto3" json:"enable_unique_without_index_constraints,omitempty"`
	// StubCatalogTablesEnabled allows queries against virtual
	// tables that are not yet implemented.
	StubCatalogTablesEnabled bool `protobuf:"varint,34,opt,name=stub_catalog_tables_enabled,json=stubCatalogTablesEnabled,proto3" json:"stub_catalog_tables_enabled,omitempty"`
	// ExperimentalComputedColumnRewrites allows automatic rewriting of computed
	// column expressions in CREATE TABLE and ALTER TABLE statements. See the
	// experimentalComputedColumnRewrites cluster setting for a description of the
	// format.
	ExperimentalComputedColumnRewrites string `protobuf:"bytes,35,opt,name=experimental_computed_column_rewrites,json=experimentalComputedColumnRewrites,proto3" json:"experimental_computed_column_rewrites,omitempty"`
	// EnableStreamReplication indicates whether to allow setting up a replication
	// stream.
	EnableStreamReplication bool `protobuf:"varint,37,opt,name=enable_stream_replication,json=enableStreamReplication,proto3" json:"enable_stream_replication,omitempty"`
	// ResultsBufferSize specifies the size at which the pgwire results buffer
	// will self-flush.
	ResultsBufferSize int64 `protobuf:"varint,38,opt,name=results_buffer_size,json=resultsBufferSize,proto3" json:"results_buffer_size,omitempty"`
	// PropagateInputOrdering indicates that when planning a subquery or CTE, the
	// inner ordering should be propagated to the outer scope if the outer scope
	// is unordered. PropagateInputOrdering is currently experimental.
	PropagateInputOrdering bool `protobuf:"varint,39,opt,name=propagate_input_ordering,json=propagateInputOrdering,proto3" json:"propagate_input_ordering,omitempty"`
	// ExperimentalDistSQLPlanningMode indicates whether the experimental
	// DistSQL planning driven by the optimizer is enabled.
	ExperimentalDistSQLPlanningMode ExperimentalDistSQLPlanningMode `protobuf:"varint,40,opt,name=experimental_distsql_planning_mode,json=experimentalDistsqlPlanningMode,proto3,casttype=ExperimentalDistSQLPlanningMode" json:"experimental_distsql_planning_mode,omitempty"`
	// DistSQLMode indicates whether to run queries using the distributed
	// execution engine.
	DistSQLMode DistSQLExecMode `protobuf:"varint,41,opt,name=dist_sql_mode,json=distSqlMode,proto3,casttype=DistSQLExecMode" json:"dist_sql_mode,omitempty"`
	// SerialNormalizationMode indicates how to handle the SERIAL pseudo-type.
	SerialNormalizationMode SerialNormalizationMode `protobuf:"varint,42,opt,name=serial_normalization_mode,json=serialNormalizationMode,proto3,casttype=SerialNormalizationMode" json:"serial_normalization_mode,omitempty"`
	// NewSchemaChangerMode indicates whether to use the new schema changer.
	NewSchemaChangerMode NewSchemaChangerMode `protobuf:"varint,43,opt,name=new_schema_changer_mode,json=newSchemaChangerMode,proto3,casttype=NewSchemaChangerMode" json:"new_schema_changer_mode,omitempty"`
	// SequenceCache stores sequence values which have been cached using the
	// CACHE sequence option.
	SequenceCache SequenceCache `protobuf:"bytes,44,rep,name=sequence_cache,json=sequenceCache,proto3,casttype=SequenceCache" json:"sequence_cache,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PlacementEnabled indicates whether PLACEMENT can be used or not.
	PlacementEnabled bool `protobuf:"varint,45,opt,name=placement_enabled,json=placementEnabled,proto3" json:"placement_enabled,omitempty"`
	// SessionUserProto is the name of the user which has performed a SET ROLE
	// command. In other words, it is the name of the user which originally
	// established the connection before SET ROLE was first performed.
	// This is only populated when SET ROLE is used, otherwise the session_user
	// is the same as the UserProto in SessionData.
	SessionUserProto github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto `protobuf:"bytes,46,opt,name=session_user_proto,json=sessionUserProto,proto3,casttype=github.com/cockroachdb/cockroach/pkg/security.SQLUsernameProto" json:"session_user_proto,omitempty"`
	// TxnRowsWrittenLog is the threshold for the number of rows written by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsWrittenLog int64 `protobuf:"varint,47,opt,name=txn_rows_written_log,json=txnRowsWrittenLog,proto3" json:"txn_rows_written_log,omitempty"`
	// TxnRowsWrittenErr is the limit for the number of rows written by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsWrittenErr int64 `protobuf:"varint,48,opt,name=txn_rows_written_err,json=txnRowsWrittenErr,proto3" json:"txn_rows_written_err,omitempty"`
	// TxnRowsReadLog is the threshold for the number of rows read by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsReadLog int64 `protobuf:"varint,49,opt,name=txn_rows_read_log,json=txnRowsReadLog,proto3" json:"txn_rows_read_log,omitempty"`
	// TxnRowsReadErr is the limit for the number of rows read by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsReadErr int64 `protobuf:"varint,50,opt,name=txn_rows_read_err,json=txnRowsReadErr,proto3" json:"txn_rows_read_err,omitempty"`
	// AutoRehomingEnabled indicates whether or not REGIONAL BY ROW tables should
	// have a rehoming ON UPDATE clause added to them.
	AutoRehomingEnabled bool `protobuf:"varint,51,opt,name=auto_rehoming_enabled,json=autoRehomingEnabled,proto3" json:"auto_rehoming_enabled,omitempty"`
	// IsSuperuser returns whether the user is a "superuser", which is defined
	// to be a user with an admin role.
	IsSuperuser bool `protobuf:"varint,52,opt,name=is_superuser,json=isSuperuser,proto3" json:"is_superuser,omitempty"`
	// LargeFullScanRows is the estimated row count at which a full scan is
	// considered large, and worthy of logging and/or disabling depending on other
	// settings.
	LargeFullScanRows float64 `protobuf:"fixed64,53,opt,name=large_full_scan_rows,json=largeFullScanRows,proto3" json:"large_full_scan_rows,omitempty"`
	// InjectRetryErrorsEnabled causes statements inside an explicit
	// transaction to return a transaction retry error. It is intended for
	// developers to test their app's retry logic.
	InjectRetryErrorsEnabled bool `protobuf:"varint,54,opt,name=inject_retry_errors_enabled,json=injectRetryErrorsEnabled,proto3" json:"inject_retry_errors_enabled,omitempty"`
	// NullOrderedLast controls whether NULL is ordered last. We default to
	// NULLS FIRST for ascending order by default, whereas postgres defaults
	// to NULLS LAST.
	NullOrderedLast bool `protobuf:"varint,55,opt,name=null_ordered_last,json=nullOrderedLast,proto3" json:"null_ordered_last,omitempty"`
	// DisablePlanGists indicates whether we should disable automatic gists.
	DisablePlanGists bool `protobuf:"varint,56,opt,name=disable_plan_gists,json=disablePlanGists,proto3" json:"disable_plan_gists,omitempty"`
	// CustomOptions contains a map of all custom session settings.
	// These session variables have at least one period in their name.
	CustomOptions map[string]string `protobuf:"bytes,57,rep,name=custom_options,json=customOptions,proto3" json:"custom_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// IndexRecommendationsEnabled controls whether or not we display index
	// recommendations below the plan in EXPLAIN.
	IndexRecommendationsEnabled bool `protobuf:"varint,58,opt,name=index_recommendations_enabled,json=indexRecommendationsEnabled,proto3" json:"index_recommendations_enabled,omitempty"`
	// AvoidBuffering indicates that the returned data should not be
	// buffered by conn executor.  This is currently used by replication primitives
	// to ensure the data is flushed to the consumer immediately.
	AvoidBuffering bool `protobuf:"varint,59,opt,name=avoid_buffering,json=avoidBuffering,proto3" json:"avoid_buffering,omitempty"`
}

func (m *LocalOnlySessionData) Reset()         { *m = LocalOnlySessionData{} }
func (m *LocalOnlySessionData) String() string { return proto.CompactTextString(m) }
func (*LocalOnlySessionData) ProtoMessage()    {}
func (*LocalOnlySessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{0}
}
func (m *LocalOnlySessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalOnlySessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalOnlySessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalOnlySessionData.Merge(m, src)
}
func (m *LocalOnlySessionData) XXX_Size() int {
	return m.Size()
}
func (m *LocalOnlySessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalOnlySessionData.DiscardUnknown(m)
}

var xxx_messageInfo_LocalOnlySessionData proto.InternalMessageInfo

// SequenceCacheEntry is an entry in a SequenceCache.
type SequenceCacheEntry struct {
	// CachedVersion stores the descpb.DescriptorVersion that cached values are associated with.
	// The version is checked to determine if cache needs to be invalidated. The version is stored as
	// a uint32 to prevent an import cycle with the descpb package.
	CachedVersion uint32 `protobuf:"varint,1,opt,name=cached_version,json=cachedVersion,proto3" json:"cached_version,omitempty"`
	// CurrentValue stores the present value of the sequence to be given out.
	CurrentValue int64 `protobuf:"varint,2,opt,name=current_value,json=currentValue,proto3" json:"current_value,omitempty"`
	// Increment stores the amount to Increment the currentVal by each time the
	// currentVal is used. This value corresponds to descpb.TableDescriptor_SequenceOpts.Increment.
	Increment int64 `protobuf:"varint,3,opt,name=increment,proto3" json:"increment,omitempty"`
	// NumValues represents the number of values to cache. The cache is considered
	// to be empty when NumValues is 0.
	NumValues int64 `protobuf:"varint,4,opt,name=num_values,json=numValues,proto3" json:"num_values,omitempty"`
}

func (m *SequenceCacheEntry) Reset()         { *m = SequenceCacheEntry{} }
func (m *SequenceCacheEntry) String() string { return proto.CompactTextString(m) }
func (*SequenceCacheEntry) ProtoMessage()    {}
func (*SequenceCacheEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{1}
}
func (m *SequenceCacheEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceCacheEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceCacheEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceCacheEntry.Merge(m, src)
}
func (m *SequenceCacheEntry) XXX_Size() int {
	return m.Size()
}
func (m *SequenceCacheEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceCacheEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceCacheEntry proto.InternalMessageInfo

func init() {
	proto.RegisterType((*LocalOnlySessionData)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.CustomOptionsEntry")
	proto.RegisterMapType((SequenceCache)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.SequenceCacheEntry")
	proto.RegisterType((*SequenceCacheEntry)(nil), "cockroach.sql.sessiondatapb.SequenceCacheEntry")
}

func init() {
	proto.RegisterFile("sql/sessiondatapb/local_only_session_data.proto", fileDescriptor_21ead158cf36da28)
}

var fileDescriptor_21ead158cf36da28 = []byte{
	// 1990 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4b, 0x57, 0x1c, 0xc7,
	0x15, 0xd6, 0x58, 0xb2, 0x23, 0x0a, 0x81, 0xa0, 0x8d, 0x4c, 0x03, 0x82, 0x01, 0x3d, 0x6c, 0xe4,
	0x07, 0xd8, 0xb2, 0xe3, 0xc8, 0xf2, 0x49, 0x62, 0x33, 0x80, 0xf5, 0xc0, 0x06, 0xf5, 0x20, 0xeb,
	0xc4, 0x59, 0xd4, 0x29, 0xba, 0xef, 0xcc, 0x94, 0xe9, 0xae, 0xea, 0xa9, 0xaa, 0x06, 0x86, 0x45,
	0x7e, 0x41, 0x16, 0x39, 0x27, 0xeb, 0xfc, 0x1f, 0x2f, 0xbd, 0xf4, 0x8a, 0x93, 0xa0, 0x7f, 0xa1,
	0x55, 0xce, 0xbd, 0xd5, 0x3d, 0x33, 0x08, 0xec, 0x9c, 0x93, 0xdd, 0xcc, 0xfd, 0xbe, 0xfb, 0x55,
	0xd5, 0xad, 0xfb, 0xa8, 0x66, 0xab, 0xb6, 0x9b, 0xae, 0x5a, 0xb0, 0x56, 0x6a, 0x95, 0x08, 0x27,
	0xf2, 0xbd, 0xd5, 0x54, 0xc7, 0x22, 0xe5, 0x5a, 0xa5, 0x3d, 0x5e, 0x02, 0x1c, 0x91, 0x95, 0xdc,
	0x68, 0xa7, 0x83, 0xb9, 0x58, 0xc7, 0xfb, 0x46, 0x8b, 0xb8, 0xb3, 0x62, 0xbb, 0xe9, 0xca, 0x19,
	0xd7, 0xd9, 0xa9, 0xb6, 0x6e, 0x6b, 0xe2, 0xad, 0xe2, 0x2f, 0xef, 0x72, 0xeb, 0xef, 0x0b, 0x6c,
	0x6a, 0x0b, 0x45, 0xb7, 0x55, 0xda, 0x6b, 0x7a, 0x87, 0x75, 0xe1, 0x44, 0xf0, 0x21, 0x0b, 0xac,
	0x38, 0x00, 0xee, 0xc4, 0x5e, 0x0a, 0x96, 0xe7, 0x06, 0x5a, 0xf2, 0x28, 0xac, 0x2d, 0xd6, 0x96,
	0x47, 0xa2, 0x09, 0x44, 0x76, 0x09, 0xd8, 0x21, 0x7b, 0xf0, 0x57, 0x36, 0xa7, 0x73, 0x27, 0x33,
	0x79, 0x0c, 0x86, 0xb7, 0xf6, 0x79, 0x2c, 0x6c, 0x2c, 0x12, 0xb0, 0x3c, 0x95, 0x99, 0x74, 0xe1,
	0x1b, 0x8b, 0xb5, 0xe5, 0xcb, 0x6b, 0x37, 0x4f, 0x4f, 0xea, 0xe1, 0x76, 0x45, 0xdb, 0x7c, 0xda,
	0x28, 0x49, 0x5b, 0xc8, 0x89, 0xc2, 0xbe, 0xc0, 0xe6, 0xfe, 0x19, 0x24, 0xf8, 0x8c, 0x5d, 0xb3,
	0x2e, 0x73, 0xdc, 0xc9, 0x0c, 0x74, 0xe1, 0xc2, 0xcb, 0xa4, 0x36, 0xf9, 0xea, 0xa4, 0x3e, 0x86,
	0xa6, 0x95, 0xf5, 0xc2, 0x08, 0x27, 0xb5, 0x8a, 0x46, 0x91, 0xb6, 0xeb, 0x59, 0xc1, 0x23, 0x36,
	0x2d, 0x93, 0x14, 0xb8, 0x54, 0xfd, 0x50, 0x55, 0x02, 0x57, 0x7e, 0x4d, 0x60, 0x0a, 0x3d, 0x1e,
	0xab, 0x32, 0x0e, 0x95, 0x12, 0x67, 0xb7, 0x2b, 0x25, 0x67, 0x84, 0xb2, 0x22, 0x46, 0xf2, 0x39,
	0xd5, 0x37, 0x7f, 0x4d, 0xb5, 0xee, 0x55, 0x77, 0x07, 0xbe, 0xaf, 0x2d, 0xf0, 0x39, 0x9b, 0x56,
	0xda, 0xc9, 0x18, 0x78, 0x22, 0x6d, 0x9e, 0x0a, 0xbc, 0xdc, 0x03, 0x30, 0xd2, 0xf5, 0xc2, 0xb7,
	0x16, 0x6b, 0xcb, 0x63, 0xd1, 0x0d, 0x0f, 0xaf, 0x7b, 0xb4, 0x59, 0x82, 0xc1, 0x0a, 0x7b, 0xdb,
	0x80, 0x36, 0x09, 0x18, 0xfe, 0xa3, 0x96, 0xaa, 0x8a, 0xf6, 0xef, 0x70, 0x23, 0xd1, 0x64, 0x09,
	0x3d, 0x41, 0xc4, 0x07, 0xf2, 0x63, 0x36, 0x95, 0x40, 0x4b, 0x14, 0xa9, 0xe3, 0xee, 0x48, 0xf1,
	0xdc, 0x48, 0x4d, 0x8b, 0x5c, 0x25, 0x87, 0xa0, 0xc4, 0x76, 0x8f, 0xd4, 0x4e, 0x89, 0x04, 0x9f,
	0xb0, 0x1b, 0xc3, 0x1e, 0x06, 0x44, 0x42, 0xd9, 0x17, 0x8e, 0x2c, 0xd6, 0x96, 0xaf, 0x0e, 0xbb,
	0x44, 0x20, 0x12, 0xcc, 0xa1, 0x60, 0x8d, 0x2d, 0x0c, 0xbb, 0x14, 0x16, 0x78, 0x4b, 0xa7, 0xa9,
	0x3e, 0x04, 0x43, 0xfe, 0x36, 0x64, 0xe4, 0x3b, 0x3b, 0xf0, 0x7d, 0x6e, 0x61, 0xb3, 0xa4, 0xa0,
	0x8c, 0x0d, 0xb6, 0xd9, 0x9d, 0x5c, 0x18, 0x27, 0x45, 0x9a, 0xf6, 0x30, 0x26, 0xce, 0xc8, 0xbd,
	0xc2, 0x41, 0xc2, 0xf3, 0x54, 0x28, 0x8b, 0x16, 0x4c, 0xbe, 0x24, 0x1c, 0x25, 0xa5, 0xa5, 0x3e,
	0x77, 0x7d, 0x40, 0xdd, 0x41, 0xe6, 0x7a, 0x49, 0x0c, 0x1e, 0xb0, 0x41, 0x7a, 0xd1, 0x96, 0x3a,
	0xd2, 0x3a, 0xdd, 0x36, 0x22, 0xb3, 0xe1, 0x35, 0x12, 0x79, 0xa7, 0x8f, 0x3f, 0xb7, 0xf0, 0xa8,
	0x8f, 0x06, 0x5f, 0xb1, 0xf9, 0xb3, 0x9e, 0x59, 0x91, 0x3a, 0xc9, 0x63, 0x9d, 0x72, 0xeb, 0x84,
	0xb3, 0xe1, 0x18, 0xb9, 0xcf, 0x0c, 0xbb, 0x7f, 0x8b, 0x94, 0x86, 0x4e, 0x9b, 0x48, 0x08, 0x1e,
	0xb2, 0x19, 0x2a, 0x5b, 0xe9, 0x7a, 0xbc, 0x62, 0x25, 0xdc, 0x82, 0x30, 0x71, 0x27, 0x1c, 0x27,
	0xef, 0xe9, 0x8a, 0x50, 0x55, 0x47, 0xd2, 0x24, 0x38, 0x58, 0x62, 0xd7, 0xac, 0x68, 0x01, 0x2f,
	0xf2, 0x44, 0x38, 0xb0, 0xe1, 0x75, 0xa2, 0x8f, 0xa2, 0xed, 0xb9, 0x37, 0x05, 0x7f, 0x61, 0x73,
	0x58, 0x9c, 0x60, 0x78, 0xaa, 0xf5, 0x7e, 0x91, 0x97, 0xa9, 0xd0, 0xd2, 0x58, 0x88, 0x36, 0x9c,
	0x40, 0x8f, 0xb5, 0xb9, 0xd3, 0x93, 0xfa, 0xf4, 0x0e, 0xd1, 0xb6, 0x88, 0x45, 0x59, 0xb1, 0xa9,
	0xcd, 0xe6, 0x53, 0x1b, 0x4d, 0xe7, 0x17, 0x01, 0xfb, 0x16, 0xf3, 0xeb, 0x58, 0xb6, 0x8f, 0x45,
	0x9b, 0x34, 0x39, 0x28, 0x1f, 0xf5, 0x49, 0xda, 0xc4, 0xa4, 0x87, 0x90, 0xbf, 0xe1, 0x81, 0xe0,
	0x6b, 0x36, 0x6f, 0xa0, 0x5b, 0x48, 0x03, 0x1c, 0x8e, 0xf2, 0x54, 0xc6, 0xd2, 0x61, 0x92, 0x65,
	0xc2, 0xf4, 0xf8, 0x3e, 0xf4, 0x6c, 0x18, 0xf8, 0x9b, 0x2f, 0x49, 0x1b, 0x25, 0x67, 0xc7, 0x53,
	0x9e, 0x42, 0xcf, 0x62, 0x29, 0xb4, 0xb4, 0x89, 0x81, 0x63, 0x8b, 0xc9, 0xb5, 0x54, 0x8e, 0x1b,
	0xb0, 0x4e, 0x18, 0x17, 0xbe, 0x4d, 0xce, 0x37, 0x08, 0x6e, 0x56, 0x68, 0xe4, 0xc1, 0xe0, 0x01,
	0x9b, 0x11, 0x98, 0x41, 0xd8, 0xa8, 0x72, 0x61, 0x80, 0x0b, 0x8b, 0xc1, 0xa6, 0x84, 0x09, 0xa7,
	0xbc, 0x27, 0x11, 0x76, 0x3c, 0xfe, 0xb5, 0xdd, 0xce, 0x1d, 0xe6, 0x08, 0x1e, 0xd2, 0x41, 0x96,
	0x57, 0x8d, 0xae, 0x3a, 0xe4, 0x0d, 0x7f, 0x48, 0x84, 0x7c, 0xa7, 0xab, 0x0e, 0xb9, 0xcd, 0xee,
	0xc8, 0xac, 0x3c, 0x5c, 0xac, 0xd3, 0x22, 0x53, 0x9c, 0xf2, 0x0f, 0xeb, 0x5a, 0xaa, 0x76, 0x5f,
	0xe0, 0x1d, 0x9f, 0x9b, 0x15, 0xb7, 0x41, 0xd4, 0x9d, 0x21, 0x66, 0x25, 0xf8, 0x82, 0xdd, 0xd3,
	0x07, 0x60, 0x8c, 0x4c, 0xaa, 0xe4, 0x32, 0xd0, 0xc6, 0xc6, 0x72, 0xac, 0x15, 0xf0, 0x58, 0xab,
	0x96, 0x1c, 0xa8, 0x86, 0xa4, 0x7a, 0xa7, 0x72, 0xa0, 0x4c, 0x8b, 0x88, 0xfe, 0x83, 0x56, 0xd0,
	0x20, 0x72, 0x25, 0xfc, 0x67, 0x76, 0xb3, 0x23, 0x6c, 0x87, 0xdb, 0x8e, 0x30, 0x09, 0x24, 0x5c,
	0xaa, 0x04, 0x8e, 0x86, 0x8e, 0x38, 0xe3, 0x33, 0x17, 0x39, 0x4d, 0x4f, 0x79, 0xec, 0x19, 0x95,
	0xc0, 0x17, 0x6c, 0x06, 0x4b, 0x8d, 0xe2, 0xda, 0x2a, 0xd2, 0xd4, 0xc7, 0x88, 0xdb, 0x58, 0x28,
	0x1b, 0xce, 0xfa, 0xb2, 0xa9, 0x08, 0x9b, 0x45, 0x9a, 0x52, 0xa0, 0x9a, 0x88, 0x06, 0x5f, 0xb2,
	0xd9, 0x7e, 0x94, 0x2c, 0xa4, 0x10, 0x3b, 0xca, 0x48, 0x9f, 0xc7, 0xe1, 0x9c, 0xcf, 0xfa, 0x8a,
	0xd1, 0x24, 0xc2, 0xa6, 0x36, 0x3e, 0xa7, 0x83, 0x65, 0x36, 0x21, 0x95, 0x05, 0xe3, 0x78, 0x4b,
	0x58, 0xc7, 0x73, 0xe1, 0x3a, 0xe1, 0x4d, 0x72, 0x19, 0xf7, 0xf6, 0x4d, 0x61, 0xdd, 0x8e, 0x70,
	0x9d, 0xe0, 0x11, 0x5b, 0x12, 0xa9, 0x03, 0x53, 0xdd, 0x84, 0xeb, 0xe5, 0xc0, 0xdb, 0xa0, 0xc0,
	0x88, 0xb4, 0x7f, 0xce, 0x79, 0x72, 0x9d, 0x27, 0xa2, 0xbf, 0x86, 0xdd, 0x5e, 0x0e, 0xdf, 0x78,
	0x56, 0x75, 0xd6, 0x8f, 0x58, 0x60, 0x7b, 0x2a, 0xee, 0x18, 0xad, 0x74, 0x61, 0x79, 0xac, 0x33,
	0x6c, 0xa5, 0x0b, 0x3e, 0x0b, 0x86, 0x90, 0x06, 0x01, 0xc1, 0xbb, 0xec, 0xba, 0x97, 0xe7, 0x16,
	0xba, 0x14, 0x91, 0xb0, 0x4e, 0xdc, 0x31, 0x6f, 0x6e, 0x42, 0x17, 0x03, 0x11, 0xec, 0xb2, 0xf7,
	0x4a, 0x5e, 0xa1, 0x64, 0xb7, 0x00, 0x7e, 0x28, 0x5d, 0x47, 0x17, 0xce, 0x5f, 0x06, 0xde, 0xae,
	0x75, 0x46, 0x48, 0xe5, 0x6c, 0xb8, 0x44, 0xfe, 0xb7, 0x3d, 0xfd, 0x39, 0xb1, 0x5f, 0x78, 0x32,
	0x5d, 0x4b, 0x63, 0x40, 0x0d, 0xfe, 0xc8, 0xe6, 0xac, 0x2b, 0xf6, 0x78, 0x2c, 0x9c, 0x48, 0x75,
	0xfb, 0xf5, 0xdc, 0xbd, 0x45, 0x4a, 0x21, 0x52, 0x1a, 0x9e, 0x71, 0x36, 0x85, 0x9f, 0xb1, 0xbb,
	0x70, 0x94, 0x83, 0x91, 0x19, 0x28, 0x27, 0x52, 0x3c, 0x6c, 0x4e, 0xed, 0xb5, 0x8c, 0xa2, 0x81,
	0x43, 0x23, 0xb1, 0xdd, 0xdc, 0xa6, 0x71, 0x7f, 0x6b, 0x98, 0xdc, 0x28, 0xb9, 0x3e, 0x90, 0x51,
	0xc9, 0xc4, 0x26, 0x57, 0xc5, 0xc3, 0x19, 0x10, 0x19, 0x37, 0x80, 0x77, 0x4b, 0x03, 0x30, 0xbc,
	0xeb, 0xaf, 0xbb, 0x8c, 0x0c, 0xe1, 0xd1, 0x00, 0xf6, 0x63, 0xcc, 0x16, 0xa9, 0xb3, 0x7c, 0xaf,
	0x68, 0x61, 0x27, 0xb3, 0xf2, 0x18, 0xc2, 0x77, 0xab, 0x31, 0x46, 0xd0, 0x1a, 0x21, 0x4d, 0x79,
	0x0c, 0xd8, 0xcc, 0x73, 0xa3, 0x73, 0xd1, 0x16, 0x0e, 0x87, 0x72, 0x5e, 0x38, 0x4e, 0x93, 0x4e,
	0xaa, 0x76, 0xf8, 0x9e, 0xcf, 0xca, 0x3e, 0xfe, 0x18, 0xe1, 0xed, 0x12, 0x0d, 0xfe, 0x59, 0x63,
	0x67, 0x0e, 0x43, 0xb3, 0xc5, 0x76, 0x53, 0x6a, 0x13, 0x54, 0xbd, 0x99, 0x4e, 0x20, 0x5c, 0xa6,
	0x49, 0xbe, 0x79, 0x7a, 0x52, 0xaf, 0x6f, 0x0c, 0xb1, 0x71, 0xba, 0x34, 0x9f, 0x6d, 0xed, 0x94,
	0xdc, 0x6f, 0x75, 0x02, 0xaf, 0xfe, 0x37, 0x25, 0xaa, 0xc3, 0x6b, 0x04, 0xdb, 0x4d, 0x87, 0x09,
	0xc1, 0x26, 0x1b, 0xc3, 0x7d, 0x70, 0xdc, 0x08, 0xad, 0x7f, 0x8f, 0xd6, 0xbf, 0x75, 0x7a, 0x52,
	0x1f, 0x2d, 0x05, 0xcb, 0xb5, 0xae, 0x97, 0x7f, 0x37, 0x8e, 0x20, 0x26, 0xed, 0x51, 0x74, 0x6c,
	0x76, 0x53, 0xd2, 0x79, 0xc1, 0x66, 0x2c, 0x18, 0x29, 0x52, 0xae, 0xb4, 0xc9, 0x44, 0x2a, 0x8f,
	0x29, 0xbe, 0x5e, 0xf3, 0x7d, 0xd2, 0x9c, 0x7b, 0x75, 0x52, 0x9f, 0x6e, 0x12, 0xe9, 0xbb, 0x61,
	0x0e, 0x89, 0x4d, 0xdb, 0x8b, 0x81, 0x60, 0x9b, 0x4d, 0x2b, 0x38, 0xe4, 0x36, 0xee, 0x40, 0x26,
	0x78, 0xdc, 0x11, 0xaa, 0x0d, 0xc6, 0xcb, 0x7e, 0x40, 0xb2, 0xe1, 0xab, 0x93, 0xfa, 0xd4, 0x77,
	0x70, 0xd8, 0x24, 0x46, 0xc3, 0x13, 0x48, 0x73, 0x4a, 0x5d, 0x60, 0x0d, 0xfe, 0xc6, 0xc6, 0x2d,
	0x74, 0x0b, 0x50, 0x31, 0xf0, 0x58, 0xc4, 0x1d, 0x08, 0x3f, 0x5c, 0xbc, 0xbc, 0x3c, 0x7a, 0x7f,
	0x7d, 0xe5, 0x37, 0x5e, 0xb0, 0x2b, 0x17, 0xbd, 0x53, 0x57, 0x9a, 0xa5, 0x4e, 0x03, 0x65, 0x36,
	0x94, 0x33, 0x3d, 0xff, 0x04, 0x3b, 0x63, 0x8f, 0xc6, 0xec, 0xf0, 0xdf, 0xe0, 0x03, 0x36, 0x99,
	0xa7, 0x22, 0x06, 0xbc, 0x93, 0x7e, 0xd5, 0x7c, 0x44, 0xa9, 0x33, 0xd1, 0x07, 0xaa, 0x6a, 0xc9,
	0x59, 0x50, 0x3d, 0xf5, 0x0a, 0x0b, 0x86, 0xd3, 0xc3, 0x39, 0x5c, 0xc1, 0xd2, 0x58, 0x5b, 0x7b,
	0x75, 0x52, 0xff, 0x53, 0x5b, 0xba, 0x4e, 0xb1, 0xb7, 0x12, 0xeb, 0x6c, 0xb5, 0xbf, 0xfd, 0x64,
	0x6f, 0xf0, 0x7b, 0x35, 0xdf, 0x6f, 0xaf, 0x5a, 0x88, 0x0b, 0x7c, 0x52, 0xad, 0x34, 0x9f, 0x6d,
	0x3d, 0xb7, 0x60, 0x94, 0xc8, 0x60, 0x07, 0x95, 0xa2, 0x89, 0x52, 0x1d, 0xad, 0x64, 0x09, 0x56,
	0xd9, 0x14, 0xbd, 0xb6, 0xf4, 0xa1, 0xe5, 0x58, 0x5f, 0x0e, 0x14, 0x4f, 0x75, 0x3b, 0x5c, 0xf5,
	0x15, 0xe1, 0x8e, 0x54, 0xa4, 0x0f, 0xed, 0x0b, 0x8f, 0x6c, 0xe9, 0xf6, 0x85, 0x0e, 0x60, 0x4c,
	0xf8, 0xf1, 0x45, 0x0e, 0x1b, 0xc6, 0x04, 0xf7, 0xd8, 0x64, 0xdf, 0x81, 0x1e, 0x75, 0x28, 0xff,
	0x09, 0xb1, 0xc7, 0x4b, 0x36, 0xbe, 0xc4, 0x50, 0xfb, 0x1c, 0x15, 0x85, 0xef, 0x9f, 0xa3, 0xa2,
	0xea, 0x7d, 0x76, 0x43, 0x14, 0x4e, 0x73, 0x03, 0x1d, 0x9d, 0x0d, 0xcf, 0xc2, 0x4f, 0x29, 0xb4,
	0x6f, 0x23, 0x18, 0x95, 0x58, 0x15, 0xdd, 0x25, 0x76, 0x4d, 0x5a, 0x6e, 0x8b, 0x1c, 0x0c, 0x46,
	0x37, 0xfc, 0xcc, 0xbf, 0x70, 0xa4, 0x6d, 0x56, 0x26, 0x3c, 0x5d, 0x2a, 0x4c, 0x1b, 0xfc, 0x0c,
	0xc2, 0x5e, 0x4b, 0xbb, 0x09, 0x7f, 0xbf, 0x58, 0x5b, 0xae, 0x45, 0x93, 0x84, 0xe1, 0xf8, 0xc1,
	0x86, 0x8b, 0xdb, 0xc1, 0xf6, 0x28, 0xd5, 0x8f, 0x38, 0x73, 0x0c, 0x38, 0xd3, 0xc3, 0x1d, 0x6b,
	0x33, 0x68, 0x8f, 0x9f, 0xfb, 0xf6, 0xe8, 0x29, 0x11, 0x32, 0x36, 0x88, 0x50, 0x6d, 0xe9, 0x7d,
	0x36, 0xa9, 0x70, 0x25, 0x6a, 0x2a, 0x90, 0xf0, 0x54, 0x58, 0x17, 0xfe, 0x81, 0x9c, 0xae, 0x23,
	0xb0, 0xed, 0xed, 0x5b, 0xc2, 0x3a, 0xfc, 0x4c, 0x2a, 0x5f, 0xa3, 0xd4, 0x43, 0x78, 0x1b, 0xeb,
	0x3b, 0x7c, 0xe0, 0x53, 0xa9, 0x44, 0xb0, 0xd8, 0xbf, 0x41, 0x7b, 0xb0, 0xcf, 0xc6, 0xe3, 0xc2,
	0x3a, 0x9d, 0xd1, 0x43, 0x50, 0x2b, 0x1b, 0x7e, 0xf1, 0xff, 0xe6, 0x7d, 0x83, 0x74, 0xb6, 0xbd,
	0x0c, 0xe5, 0x7d, 0x34, 0x16, 0x0f, 0xdb, 0x82, 0x35, 0x36, 0xef, 0x87, 0x8c, 0x01, 0x9c, 0x66,
	0x80, 0x72, 0x08, 0xf4, 0xe3, 0xf0, 0x90, 0x76, 0x39, 0x47, 0xa4, 0xe8, 0x2c, 0xa7, 0x0a, 0xc5,
	0x7b, 0xec, 0xba, 0x38, 0xd0, 0x32, 0x29, 0x1b, 0x33, 0x76, 0xd8, 0x2f, 0xfd, 0x20, 0x26, 0xf3,
	0x5a, 0x65, 0x9d, 0xed, 0xb2, 0xe0, 0x7c, 0x25, 0x06, 0x13, 0xec, 0xf2, 0x3e, 0xf4, 0xe8, 0xab,
	0x71, 0x2c, 0xc2, 0x9f, 0xc1, 0x06, 0x7b, 0xf3, 0x40, 0xa4, 0x05, 0xd0, 0x27, 0xe1, 0xe8, 0xfd,
	0xd5, 0xdf, 0x3c, 0xf8, 0x79, 0xc5, 0xc8, 0x7b, 0x3f, 0x7c, 0xe3, 0x41, 0x6d, 0xf6, 0x2b, 0x16,
	0x9c, 0x0f, 0xc2, 0xf0, 0x92, 0x23, 0x7e, 0xc9, 0xa9, 0xe1, 0x25, 0x47, 0x86, 0x14, 0x9e, 0x5c,
	0xb9, 0x3a, 0x3d, 0x11, 0x3e, 0xb9, 0x72, 0x75, 0x71, 0x62, 0xe9, 0xc9, 0x95, 0xab, 0x77, 0x26,
	0xee, 0xde, 0xfa, 0x57, 0xed, 0xc2, 0x73, 0xdc, 0x65, 0xe3, 0xd4, 0xa6, 0x12, 0x7e, 0x00, 0x06,
	0x37, 0x58, 0x1e, 0x69, 0xcc, 0x5b, 0xbf, 0xf7, 0xc6, 0xe0, 0x36, 0x1b, 0x8b, 0x0b, 0x63, 0xb0,
	0xa9, 0x0c, 0x56, 0xbc, 0x1c, 0x5d, 0x2b, 0x8d, 0xdf, 0xa3, 0x2d, 0xb8, 0xc9, 0x46, 0xa4, 0x8a,
	0x0d, 0xb5, 0x18, 0xff, 0x29, 0x1b, 0x0d, 0x0c, 0xc1, 0x3c, 0x63, 0xaa, 0xc8, 0xbc, 0xbb, 0xf5,
	0x1f, 0xaa, 0xd1, 0x88, 0x2a, 0x32, 0xf2, 0xb5, 0x6b, 0xab, 0x3f, 0xfd, 0x67, 0xe1, 0xd2, 0x4f,
	0xa7, 0x0b, 0xb5, 0x9f, 0x4f, 0x17, 0x6a, 0xbf, 0x9c, 0x2e, 0xd4, 0xfe, 0x7d, 0xba, 0x50, 0xfb,
	0xc7, 0xcb, 0x85, 0x4b, 0x3f, 0xbf, 0x5c, 0xb8, 0xf4, 0xcb, 0xcb, 0x85, 0x4b, 0x3f, 0x8c, 0x9d,
	0x09, 0xe1, 0xde, 0x5b, 0xd4, 0xad, 0x3e, 0xfd, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x12, 0x35,
	0x0a, 0xd5, 0x4c, 0x10, 0x00, 0x00,
}

func (m *LocalOnlySessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalOnlySessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalOnlySessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AvoidBuffering {
		i--
		if m.AvoidBuffering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.IndexRecommendationsEnabled {
		i--
		if m.IndexRecommendationsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if len(m.CustomOptions) > 0 {
		keysForCustomOptions := make([]string, 0, len(m.CustomOptions))
		for k := range m.CustomOptions {
			keysForCustomOptions = append(keysForCustomOptions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForCustomOptions)
		for iNdEx := len(keysForCustomOptions) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomOptions[string(keysForCustomOptions[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForCustomOptions[iNdEx])
			copy(dAtA[i:], keysForCustomOptions[iNdEx])
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(keysForCustomOptions[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if m.DisablePlanGists {
		i--
		if m.DisablePlanGists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.NullOrderedLast {
		i--
		if m.NullOrderedLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.InjectRetryErrorsEnabled {
		i--
		if m.InjectRetryErrorsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.LargeFullScanRows != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LargeFullScanRows))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa9
	}
	if m.IsSuperuser {
		i--
		if m.IsSuperuser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.AutoRehomingEnabled {
		i--
		if m.AutoRehomingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.TxnRowsReadErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.TxnRowsReadLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadLog))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.TxnRowsWrittenErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.TxnRowsWrittenLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenLog))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if len(m.SessionUserProto) > 0 {
		i -= len(m.SessionUserProto)
		copy(dAtA[i:], m.SessionUserProto)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SessionUserProto)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.PlacementEnabled {
		i--
		if m.PlacementEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if len(m.SequenceCache) > 0 {
		keysForSequenceCache := make([]uint32, 0, len(m.SequenceCache))
		for k := range m.SequenceCache {
			keysForSequenceCache = append(keysForSequenceCache, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForSequenceCache)
		for iNdEx := len(keysForSequenceCache) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SequenceCache[uint32(keysForSequenceCache[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(keysForSequenceCache[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.NewSchemaChangerMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NewSchemaChangerMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.SerialNormalizationMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.SerialNormalizationMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.DistSQLMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistSQLMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ExperimentalDistSQLPlanningMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.PropagateInputOrdering {
		i--
		if m.PropagateInputOrdering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ResultsBufferSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ResultsBufferSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.EnableStreamReplication {
		i--
		if m.EnableStreamReplication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ExperimentalComputedColumnRewrites) > 0 {
		i -= len(m.ExperimentalComputedColumnRewrites)
		copy(dAtA[i:], m.ExperimentalComputedColumnRewrites)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.ExperimentalComputedColumnRewrites)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.StubCatalogTablesEnabled {
		i--
		if m.StubCatalogTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.EnableUniqueWithoutIndexConstraints {
		i--
		if m.EnableUniqueWithoutIndexConstraints {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.EnableSeqScan {
		i--
		if m.EnableSeqScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.SynchronousCommit {
		i--
		if m.SynchronousCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.AlterColumnTypeGeneralEnabled {
		i--
		if m.AlterColumnTypeGeneralEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.InsertFastPath {
		i--
		if m.InsertFastPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ImplicitSelectForUpdate {
		i--
		if m.ImplicitSelectForUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DisallowFullTableScans {
		i--
		if m.DisallowFullTableScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.HashShardedIndexesEnabled {
		i--
		if m.HashShardedIndexesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		i--
		if m.OverrideMultiRegionZoneConfigEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ImplicitColumnPartitioningEnabled {
		i--
		if m.ImplicitColumnPartitioningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TempTablesEnabled {
		i--
		if m.TempTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AllowPrepareAsOptPlan {
		i--
		if m.AllowPrepareAsOptPlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ForceSavepointRestart {
		i--
		if m.ForceSavepointRestart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RequireExplicitPrimaryKeys {
		i--
		if m.RequireExplicitPrimaryKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ZigzagJoinEnabled {
		i--
		if m.ZigzagJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PreferLookupJoinsForFKs {
		i--
		if m.PreferLookupJoinsForFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SafeUpdates {
		i--
		if m.SafeUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.LocalityOptimizedSearch {
		i--
		if m.LocalityOptimizedSearch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.OptimizerUseMultiColStats {
		i--
		if m.OptimizerUseMultiColStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptimizerUseHistograms {
		i--
		if m.OptimizerUseHistograms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.PartiallyDistributedPlansDisabled {
		i--
		if m.PartiallyDistributedPlansDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.DefaultTxnUseFollowerReads {
		i--
		if m.DefaultTxnUseFollowerReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DefaultTxnReadOnly {
		i--
		if m.DefaultTxnReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DefaultTxnPriority != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnPriority))
		i--
		dAtA[i] = 0x40
	}
	if m.ReorderJoinsLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ReorderJoinsLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.NoticeDisplaySeverity != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NoticeDisplaySeverity))
		i--
		dAtA[i] = 0x30
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInTransactionSessionTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.IdleInSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInSessionTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.StmtTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.StmtTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.OptimizerFKCascadesLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OptimizerFKCascadesLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SaveTablesPrefix) > 0 {
		i -= len(m.SaveTablesPrefix)
		copy(dAtA[i:], m.SaveTablesPrefix)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SaveTablesPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SequenceCacheEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceCacheEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceCacheEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumValues != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NumValues))
		i--
		dAtA[i] = 0x20
	}
	if m.Increment != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.Increment))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentValue != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CurrentValue))
		i--
		dAtA[i] = 0x10
	}
	if m.CachedVersion != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CachedVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLocalOnlySessionData(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocalOnlySessionData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocalOnlySessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SaveTablesPrefix)
	if l > 0 {
		n += 1 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.OptimizerFKCascadesLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.OptimizerFKCascadesLimit))
	}
	if m.StmtTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.StmtTimeout))
	}
	if m.IdleInSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInSessionTimeout))
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInTransactionSessionTimeout))
	}
	if m.NoticeDisplaySeverity != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NoticeDisplaySeverity))
	}
	if m.ReorderJoinsLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.ReorderJoinsLimit))
	}
	if m.DefaultTxnPriority != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.DefaultTxnPriority))
	}
	if m.DefaultTxnReadOnly {
		n += 2
	}
	if m.DefaultTxnUseFollowerReads {
		n += 2
	}
	if m.PartiallyDistributedPlansDisabled {
		n += 2
	}
	if m.OptimizerUseHistograms {
		n += 2
	}
	if m.OptimizerUseMultiColStats {
		n += 2
	}
	if m.LocalityOptimizedSearch {
		n += 2
	}
	if m.SafeUpdates {
		n += 2
	}
	if m.PreferLookupJoinsForFKs {
		n += 3
	}
	if m.ZigzagJoinEnabled {
		n += 3
	}
	if m.RequireExplicitPrimaryKeys {
		n += 3
	}
	if m.ForceSavepointRestart {
		n += 3
	}
	if m.AllowPrepareAsOptPlan {
		n += 3
	}
	if m.TempTablesEnabled {
		n += 3
	}
	if m.ImplicitColumnPartitioningEnabled {
		n += 3
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		n += 3
	}
	if m.HashShardedIndexesEnabled {
		n += 3
	}
	if m.DisallowFullTableScans {
		n += 3
	}
	if m.ImplicitSelectForUpdate {
		n += 3
	}
	if m.InsertFastPath {
		n += 3
	}
	if m.AlterColumnTypeGeneralEnabled {
		n += 3
	}
	if m.SynchronousCommit {
		n += 3
	}
	if m.EnableSeqScan {
		n += 3
	}
	if m.EnableUniqueWithoutIndexConstraints {
		n += 3
	}
	if m.StubCatalogTablesEnabled {
		n += 3
	}
	l = len(m.ExperimentalComputedColumnRewrites)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.EnableStreamReplication {
		n += 3
	}
	if m.ResultsBufferSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ResultsBufferSize))
	}
	if m.PropagateInputOrdering {
		n += 3
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ExperimentalDistSQLPlanningMode))
	}
	if m.DistSQLMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistSQLMode))
	}
	if m.SerialNormalizationMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.SerialNormalizationMode))
	}
	if m.NewSchemaChangerMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.NewSchemaChangerMode))
	}
	if len(m.SequenceCache) > 0 {
		for k, v := range m.SequenceCache {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLocalOnlySessionData(uint64(l))
			}
			mapEntrySize := 1 + sovLocalOnlySessionData(uint64(k)) + l
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.PlacementEnabled {
		n += 3
	}
	l = len(m.SessionUserProto)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.TxnRowsWrittenLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenLog))
	}
	if m.TxnRowsWrittenErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenErr))
	}
	if m.TxnRowsReadLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadLog))
	}
	if m.TxnRowsReadErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadErr))
	}
	if m.AutoRehomingEnabled {
		n += 3
	}
	if m.IsSuperuser {
		n += 3
	}
	if m.LargeFullScanRows != 0 {
		n += 10
	}
	if m.InjectRetryErrorsEnabled {
		n += 3
	}
	if m.NullOrderedLast {
		n += 3
	}
	if m.DisablePlanGists {
		n += 3
	}
	if len(m.CustomOptions) > 0 {
		for k, v := range m.CustomOptions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocalOnlySessionData(uint64(len(k))) + 1 + len(v) + sovLocalOnlySessionData(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.IndexRecommendationsEnabled {
		n += 3
	}
	if m.AvoidBuffering {
		n += 3
	}
	return n
}

func (m *SequenceCacheEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CachedVersion != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CachedVersion))
	}
	if m.CurrentValue != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CurrentValue))
	}
	if m.Increment != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.Increment))
	}
	if m.NumValues != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NumValues))
	}
	return n
}

func sovLocalOnlySessionData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLocalOnlySessionData(x uint64) (n int) {
	return sovLocalOnlySessionData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalOnlySessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalOnlySessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalOnlySessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveTablesPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaveTablesPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerFKCascadesLimit", wireType)
			}
			m.OptimizerFKCascadesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptimizerFKCascadesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtTimeout", wireType)
			}
			m.StmtTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInSessionTimeout", wireType)
			}
			m.IdleInSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInTransactionSessionTimeout", wireType)
			}
			m.IdleInTransactionSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInTransactionSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeDisplaySeverity", wireType)
			}
			m.NoticeDisplaySeverity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoticeDisplaySeverity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReorderJoinsLimit", wireType)
			}
			m.ReorderJoinsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReorderJoinsLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnPriority", wireType)
			}
			m.DefaultTxnPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnPriority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnReadOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnUseFollowerReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnUseFollowerReads = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiallyDistributedPlansDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartiallyDistributedPlansDisabled = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseHistograms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseHistograms = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseMultiColStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseMultiColStats = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityOptimizedSearch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalityOptimizedSearch = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SafeUpdates = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferLookupJoinsForFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferLookupJoinsForFKs = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZigzagJoinEnabled = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireExplicitPrimaryKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireExplicitPrimaryKeys = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceSavepointRestart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceSavepointRestart = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrepareAsOptPlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrepareAsOptPlan = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TempTablesEnabled = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitColumnPartitioningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitColumnPartitioningEnabled = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideMultiRegionZoneConfigEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideMultiRegionZoneConfigEnabled = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashShardedIndexesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashShardedIndexesEnabled = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowFullTableScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisallowFullTableScans = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitSelectForUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitSelectForUpdate = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertFastPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsertFastPath = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterColumnTypeGeneralEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlterColumnTypeGeneralEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousCommit = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSeqScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSeqScan = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableUniqueWithoutIndexConstraints", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableUniqueWithoutIndexConstraints = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StubCatalogTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StubCatalogTablesEnabled = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalComputedColumnRewrites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExperimentalComputedColumnRewrites = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStreamReplication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStreamReplication = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultsBufferSize", wireType)
			}
			m.ResultsBufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultsBufferSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateInputOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropagateInputOrdering = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalDistSQLPlanningMode", wireType)
			}
			m.ExperimentalDistSQLPlanningMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExperimentalDistSQLPlanningMode |= ExperimentalDistSQLPlanningMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLMode", wireType)
			}
			m.DistSQLMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistSQLMode |= DistSQLExecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNormalizationMode", wireType)
			}
			m.SerialNormalizationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialNormalizationMode |= SerialNormalizationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSchemaChangerMode", wireType)
			}
			m.NewSchemaChangerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSchemaChangerMode |= NewSchemaChangerMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceCache == nil {
				m.SequenceCache = make(SequenceCache)
			}
			var mapkey uint32
			var mapvalue *SequenceCacheEntry
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SequenceCacheEntry{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SequenceCache[mapkey] = mapvalue
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacementEnabled = bool(v != 0)
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionUserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionUserProto = github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenLog", wireType)
			}
			m.TxnRowsWrittenLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenErr", wireType)
			}
			m.TxnRowsWrittenErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadLog", wireType)
			}
			m.TxnRowsReadLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadErr", wireType)
			}
			m.TxnRowsReadErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRehomingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRehomingEnabled = bool(v != 0)
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuperuser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuperuser = bool(v != 0)
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeFullScanRows", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LargeFullScanRows = float64(math.Float64frombits(v))
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectRetryErrorsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InjectRetryErrorsEnabled = bool(v != 0)
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullOrderedLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullOrderedLast = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePlanGists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePlanGists = bool(v != 0)
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomOptions == nil {
				m.CustomOptions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRecommendationsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexRecommendationsEnabled = bool(v != 0)
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvoidBuffering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvoidBuffering = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceCacheEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceCacheEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceCacheEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedVersion", wireType)
			}
			m.CachedVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			m.CurrentValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValues", wireType)
			}
			m.NumValues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumValues |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocalOnlySessionData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocalOnlySessionData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocalOnlySessionData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocalOnlySessionData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocalOnlySessionData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocalOnlySessionData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocalOnlySessionData = fmt.Errorf("proto: unexpected end of group")
)
