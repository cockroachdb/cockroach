// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sessiondatapb/session_data.proto

package sessiondatapb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// BytesEncodeFormat is the configuration for bytes to string conversions.
type BytesEncodeFormat int32

const (
	// BytesEncodeHex uses the hex format: e'abc\n'::BYTES::STRING -> '\x61626312'.
	// This is the default, for compatibility with PostgreSQL.
	BytesEncodeHex BytesEncodeFormat = 0
	// BytesEncodeEscape uses the escaped format: e'abc\n'::BYTES::STRING -> 'abc\012'.
	BytesEncodeEscape BytesEncodeFormat = 1
	// BytesEncodeBase64 uses base64 encoding.
	BytesEncodeBase64 BytesEncodeFormat = 2
)

var BytesEncodeFormat_name = map[int32]string{
	0: "BytesEncodeHex",
	1: "BytesEncodeEscape",
	2: "BytesEncodeBase64",
}
var BytesEncodeFormat_value = map[string]int32{
	"BytesEncodeHex":    0,
	"BytesEncodeEscape": 1,
	"BytesEncodeBase64": 2,
}

func (x BytesEncodeFormat) Enum() *BytesEncodeFormat {
	p := new(BytesEncodeFormat)
	*p = x
	return p
}
func (x BytesEncodeFormat) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(BytesEncodeFormat_name, int32(x))
}
func (x *BytesEncodeFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BytesEncodeFormat_value, data, "BytesEncodeFormat")
	if err != nil {
		return err
	}
	*x = BytesEncodeFormat(value)
	return nil
}
func (BytesEncodeFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_session_data_38273df3056aef01, []int{0}
}

// VectorizeExecMode controls if an when the Executor executes queries using
// the columnar execution engine.
type VectorizeExecMode int32

const (
	// VectorizeOff means that columnar execution is disabled.
	VectorizeOff VectorizeExecMode = 0
	// Vectorize201Auto means that that any supported queries that use only
	// streaming operators (i.e. those that do not require any buffering) will
	// be run using the columnar execution. If any part of a query is not
	// supported by the vectorized execution engine, the whole query will fall
	// back to row execution.
	// This is the default setting in 20.1.
	Vectorize201Auto VectorizeExecMode = 1
	// VectorizeOn means that any supported queries will be run using the
	// columnar execution.
	VectorizeOn VectorizeExecMode = 2
	// VectorizeExperimentalAlways means that we attempt to vectorize all
	// queries; unsupported queries will fail. Mostly used for testing.
	VectorizeExperimentalAlways VectorizeExecMode = 3
)

var VectorizeExecMode_name = map[int32]string{
	0: "VectorizeOff",
	1: "Vectorize201Auto",
	2: "VectorizeOn",
	3: "VectorizeExperimentalAlways",
}
var VectorizeExecMode_value = map[string]int32{
	"VectorizeOff":                0,
	"Vectorize201Auto":            1,
	"VectorizeOn":                 2,
	"VectorizeExperimentalAlways": 3,
}

func (x VectorizeExecMode) Enum() *VectorizeExecMode {
	p := new(VectorizeExecMode)
	*p = x
	return p
}
func (x VectorizeExecMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(VectorizeExecMode_name, int32(x))
}
func (x *VectorizeExecMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VectorizeExecMode_value, data, "VectorizeExecMode")
	if err != nil {
		return err
	}
	*x = VectorizeExecMode(value)
	return nil
}
func (VectorizeExecMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_session_data_38273df3056aef01, []int{1}
}

// SessionData contains session parameters that are easily serializable and are
// required to be propagated to the remote nodes for the correct execution of
// DistSQL flows.
type SessionData struct {
	// Database indicates the "current" database for the purpose of resolving
	// names.
	Database string `protobuf:"bytes,1,opt,name=database" json:"database"`
	// ApplicationName is the name of the application running the current
	// session. This can be used for logging and per-application statistics.
	ApplicationName string `protobuf:"bytes,2,opt,name=application_name,json=applicationName" json:"application_name"`
	// User is the name of the user logged into the session.
	User string `protobuf:"bytes,3,opt,name=user" json:"user"`
	// DataConversion gives access to the data conversion configuration.
	DataConversionConfig DataConversionConfig `protobuf:"bytes,4,opt,name=data_conversion_config,json=dataConversionConfig" json:"data_conversion_config"`
	// VectorizeMode indicates which kinds of queries to use vectorized execution
	// engine for.
	VectorizeMode VectorizeExecMode `protobuf:"varint,5,opt,name=vectorize_mode,json=vectorizeMode,enum=cockroach.sql.sessiondatapb.VectorizeExecMode" json:"vectorize_mode"`
	// TestingVectorizeInjectPanics indicates whether random panics are injected
	// into the vectorized flow execution. The goal of such behavior is making
	// sure that errors that are propagated as panics in the vectorized engine
	// are caught in all scenarios.
	TestingVectorizeInjectPanics bool `protobuf:"varint,6,opt,name=testing_vectorize_inject_panics,json=testingVectorizeInjectPanics" json:"testing_vectorize_inject_panics"`
	// DefaultIntSize specifies the size in bits or bytes (preferred) of how a
	// "naked" INT type should be parsed.
	DefaultIntSize int32 `protobuf:"varint,7,opt,name=default_int_size,json=defaultIntSize" json:"default_int_size"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_session_data_38273df3056aef01, []int{0}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(dst, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

// DataConversionConfig contains the parameters that influence the conversion
// between SQL data types and strings/byte arrays.
type DataConversionConfig struct {
	// BytesEncodeFormat indicates how to encode byte arrays when converting to
	// string.
	BytesEncodeFormat BytesEncodeFormat `protobuf:"varint,1,opt,name=bytes_encode_format,json=bytesEncodeFormat,enum=cockroach.sql.sessiondatapb.BytesEncodeFormat" json:"bytes_encode_format"`
	// ExtraFloatDigits indicates the number of digits beyond the standard number
	// to use for float conversions.This must be set to a value between -15 and
	// 3, inclusive.
	ExtraFloatDigits int32 `protobuf:"varint,2,opt,name=extra_float_digits,json=extraFloatDigits" json:"extra_float_digits"`
}

func (m *DataConversionConfig) Reset()         { *m = DataConversionConfig{} }
func (m *DataConversionConfig) String() string { return proto.CompactTextString(m) }
func (*DataConversionConfig) ProtoMessage()    {}
func (*DataConversionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_session_data_38273df3056aef01, []int{1}
}
func (m *DataConversionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataConversionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DataConversionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataConversionConfig.Merge(dst, src)
}
func (m *DataConversionConfig) XXX_Size() int {
	return m.Size()
}
func (m *DataConversionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DataConversionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DataConversionConfig proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SessionData)(nil), "cockroach.sql.sessiondatapb.SessionData")
	proto.RegisterType((*DataConversionConfig)(nil), "cockroach.sql.sessiondatapb.DataConversionConfig")
	proto.RegisterEnum("cockroach.sql.sessiondatapb.BytesEncodeFormat", BytesEncodeFormat_name, BytesEncodeFormat_value)
	proto.RegisterEnum("cockroach.sql.sessiondatapb.VectorizeExecMode", VectorizeExecMode_name, VectorizeExecMode_value)
}
func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(len(m.Database)))
	i += copy(dAtA[i:], m.Database)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(len(m.ApplicationName)))
	i += copy(dAtA[i:], m.ApplicationName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(len(m.User)))
	i += copy(dAtA[i:], m.User)
	dAtA[i] = 0x22
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(m.DataConversionConfig.Size()))
	n1, err := m.DataConversionConfig.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x28
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(m.VectorizeMode))
	dAtA[i] = 0x30
	i++
	if m.TestingVectorizeInjectPanics {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(m.DefaultIntSize))
	return i, nil
}

func (m *DataConversionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataConversionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(m.BytesEncodeFormat))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSessionData(dAtA, i, uint64(m.ExtraFloatDigits))
	return i, nil
}

func encodeVarintSessionData(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	n += 1 + l + sovSessionData(uint64(l))
	l = len(m.ApplicationName)
	n += 1 + l + sovSessionData(uint64(l))
	l = len(m.User)
	n += 1 + l + sovSessionData(uint64(l))
	l = m.DataConversionConfig.Size()
	n += 1 + l + sovSessionData(uint64(l))
	n += 1 + sovSessionData(uint64(m.VectorizeMode))
	n += 2
	n += 1 + sovSessionData(uint64(m.DefaultIntSize))
	return n
}

func (m *DataConversionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSessionData(uint64(m.BytesEncodeFormat))
	n += 1 + sovSessionData(uint64(m.ExtraFloatDigits))
	return n
}

func sovSessionData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSessionData(x uint64) (n int) {
	return sovSessionData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataConversionConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataConversionConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorizeMode", wireType)
			}
			m.VectorizeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorizeMode |= (VectorizeExecMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingVectorizeInjectPanics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestingVectorizeInjectPanics = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultIntSize", wireType)
			}
			m.DefaultIntSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultIntSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataConversionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataConversionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataConversionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesEncodeFormat", wireType)
			}
			m.BytesEncodeFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesEncodeFormat |= (BytesEncodeFormat(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFloatDigits", wireType)
			}
			m.ExtraFloatDigits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraFloatDigits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSessionData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSessionData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSessionData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSessionData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSessionData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSessionData   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/sessiondatapb/session_data.proto", fileDescriptor_session_data_38273df3056aef01)
}

var fileDescriptor_session_data_38273df3056aef01 = []byte{
	// 548 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xcb, 0x6e, 0xd4, 0x3c,
	0x1c, 0xc5, 0xe3, 0x5e, 0xbe, 0xaf, 0xb8, 0x74, 0xea, 0x9a, 0x01, 0x45, 0x2d, 0x4a, 0xa3, 0x8a,
	0xc5, 0xa8, 0x8b, 0x0c, 0x1d, 0x21, 0xf6, 0x9d, 0x5e, 0x44, 0x85, 0xb8, 0x88, 0x4a, 0x2c, 0x60,
	0x61, 0x79, 0x9c, 0x7f, 0x06, 0x43, 0x62, 0xa7, 0xb1, 0x7b, 0x7d, 0x02, 0x96, 0xbc, 0x03, 0x2c,
	0x58, 0xf2, 0x0e, 0x6c, 0xba, 0xec, 0xb2, 0x2b, 0x04, 0xd3, 0x17, 0x41, 0x71, 0xd3, 0x74, 0xa6,
	0xad, 0xca, 0x2e, 0x3e, 0xe7, 0x77, 0xfe, 0xc7, 0x97, 0xe0, 0x47, 0x66, 0x27, 0x6d, 0x1b, 0x30,
	0x46, 0x6a, 0x15, 0x73, 0xcb, 0xf3, 0xde, 0xc5, 0x8a, 0x95, 0xcb, 0x28, 0x2f, 0xb4, 0xd5, 0x74,
	0x41, 0x68, 0xf1, 0xa9, 0xd0, 0x5c, 0x7c, 0x88, 0xcc, 0x4e, 0x1a, 0x8d, 0xf0, 0xf3, 0xcd, 0xbe,
	0xee, 0x6b, 0xc7, 0xb5, 0xcb, 0xaf, 0xf3, 0xc8, 0xd2, 0xcf, 0x71, 0x3c, 0xbd, 0x7d, 0xce, 0xad,
	0x73, 0xcb, 0x69, 0x88, 0xa7, 0x4a, 0xbe, 0xc7, 0x0d, 0xf8, 0x28, 0x44, 0xad, 0x3b, 0xdd, 0x89,
	0xe3, 0x5f, 0x8b, 0xde, 0x9b, 0x5a, 0xa5, 0x6d, 0x4c, 0x78, 0x9e, 0xa7, 0x52, 0x70, 0x5b, 0xd6,
	0x2b, 0x9e, 0x81, 0x3f, 0x36, 0x44, 0xce, 0x0e, 0xb9, 0x2f, 0x79, 0x06, 0xd4, 0xc7, 0x13, 0xbb,
	0x06, 0x0a, 0x7f, 0x7c, 0x08, 0x72, 0x0a, 0xcd, 0xf0, 0x83, 0x72, 0x2c, 0x13, 0x5a, 0xed, 0x41,
	0xe1, 0x4e, 0x23, 0xb4, 0x4a, 0x64, 0xdf, 0x9f, 0x08, 0x51, 0x6b, 0xba, 0xb3, 0x12, 0xdd, 0x72,
	0xa0, 0xa8, 0xdc, 0xef, 0x5a, 0x9d, 0x5c, 0x73, 0xc1, 0x6a, 0x7c, 0x33, 0xbe, 0xc1, 0xa3, 0xef,
	0x71, 0x63, 0x0f, 0x84, 0xd5, 0x85, 0x3c, 0x02, 0x96, 0xe9, 0x18, 0xfc, 0xc9, 0x10, 0xb5, 0x1a,
	0x9d, 0xe8, 0xd6, 0x9a, 0xb7, 0x17, 0x91, 0x8d, 0x03, 0x10, 0x2f, 0x74, 0x0c, 0x55, 0xc7, 0x4c,
	0x3d, 0xab, 0x14, 0xe9, 0x73, 0xbc, 0x68, 0xc1, 0x58, 0xa9, 0xfa, 0xec, 0xb2, 0x44, 0xaa, 0x8f,
	0x20, 0x2c, 0xcb, 0xb9, 0x92, 0xc2, 0xf8, 0xff, 0x85, 0xa8, 0x35, 0x55, 0xa5, 0x1f, 0x56, 0x70,
	0x3d, 0x7d, 0xcb, 0xa1, 0xaf, 0x1d, 0x49, 0x23, 0x4c, 0x62, 0x48, 0xf8, 0x6e, 0x6a, 0x99, 0x54,
	0x96, 0x19, 0x79, 0x04, 0xfe, 0xff, 0x21, 0x6a, 0x4d, 0x56, 0xe9, 0x46, 0xe5, 0x6e, 0x29, 0xbb,
	0x2d, 0x8f, 0x60, 0xe9, 0x07, 0xc2, 0xcd, 0x9b, 0xae, 0x83, 0xc6, 0xf8, 0x5e, 0xef, 0xd0, 0x82,
	0x61, 0xa0, 0x84, 0x8e, 0x81, 0x25, 0xba, 0xc8, 0xb8, 0x75, 0x2f, 0xfb, 0xaf, 0x73, 0x77, 0xcb,
	0xdc, 0x86, 0x8b, 0x6d, 0xba, 0x54, 0xd5, 0x3d, 0xd7, 0xbb, 0x6a, 0xd0, 0x0e, 0xa6, 0x70, 0x60,
	0x0b, 0xce, 0x92, 0x54, 0x73, 0xcb, 0x62, 0xd9, 0x97, 0xd6, 0xb8, 0x9f, 0xe2, 0x62, 0xc3, 0xc4,
	0xf9, 0x9b, 0xa5, 0xbd, 0xee, 0xdc, 0x65, 0x86, 0xe7, 0xae, 0x35, 0x50, 0x8a, 0x1b, 0x43, 0xe2,
	0x33, 0x38, 0x20, 0x1e, 0xbd, 0x3f, 0x02, 0x6e, 0x18, 0xc1, 0x73, 0x20, 0xe8, 0x8a, 0xdc, 0xe5,
	0x06, 0x9e, 0x3e, 0x21, 0x63, 0xf3, 0x53, 0x9f, 0xbf, 0x06, 0xde, 0xf7, 0x6f, 0x81, 0xb7, 0xbc,
	0x8f, 0xe7, 0xae, 0x3d, 0x1d, 0x25, 0xf8, 0x6e, 0x2d, 0xbe, 0x4a, 0x12, 0xe2, 0xd1, 0x26, 0x26,
	0xb5, 0xd2, 0x79, 0xbc, 0xb2, 0xba, 0x6b, 0x35, 0x41, 0x74, 0x16, 0x4f, 0x5f, 0x72, 0x8a, 0x8c,
	0xd1, 0x45, 0xbc, 0x30, 0x34, 0x2d, 0x87, 0x42, 0x66, 0xa0, 0x2c, 0x4f, 0x57, 0xd3, 0x7d, 0x7e,
	0x68, 0xc8, 0xf8, 0x65, 0x71, 0xb7, 0x7d, 0xfc, 0x27, 0xf0, 0x8e, 0x07, 0x01, 0x3a, 0x19, 0x04,
	0xe8, 0x74, 0x10, 0xa0, 0xdf, 0x83, 0x00, 0x7d, 0x39, 0x0b, 0xbc, 0x93, 0xb3, 0xc0, 0x3b, 0x3d,
	0x0b, 0xbc, 0x77, 0x33, 0x23, 0x37, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xf2, 0xdf, 0x93,
	0xdd, 0x03, 0x00, 0x00,
}
