// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Cannot be proto3 because we are moving definitions from descpb which
// relies on proto2 for its nullable primitives and for its different
// enum interactions with json marshaling.
syntax = "proto2";

package cockroach.sql.catalog.catpb;
option go_package = "catpb";

import "gogoproto/gogo.proto";

// ForeignKeyAction describes the action which should be taken when a foreign
// key constraint reference is acted upon.
enum ForeignKeyAction {
  option (gogoproto.goproto_enum_stringer) = false;
  NO_ACTION = 0;
  RESTRICT = 1;
  SET_NULL = 2;
  SET_DEFAULT = 3;
  CASCADE = 4;
}

// LocalityConfig is used to figure the locality of a table.
message LocalityConfig {
  option (gogoproto.equal) = true;
  // REGIONAL BY TABLE tables have an "implicit" bidirectional dependency with
  // the multi-region enum. The dependency is described "implicit" because
  // even though no column on the table uses the multi-region type descriptor
  // to store the homing region, a value from the type descriptor is stored in
  // the locality config below (when the table is homed in the non-primary
  // region).
  // This changes how type dependencies are constructed for table descriptors.
  // After the introduction of REGIONAL BY TABLE tables, a column on the table
  // descriptor using a type is no longer a necessary (note it is still a
  // sufficient) condition to establish a type dependency. As is the case with
  // adding and dropping columns, this type dependency must be negotiated. As
  // such, switching locality patterns or adding new locality configs must be
  // done so that back references to the multi-region type descriptor are
  // kept sane.
  message RegionalByTable {
    option (gogoproto.equal) = true;
    // Region is set if the table has an affinity with a non-primary region.
    optional string region = 1 [(gogoproto.casttype)="RegionName"];
  }
  message RegionalByRow {
    option (gogoproto.equal) = true;
    // As is set if the table has a REGIONAL BY ROW AS ... set to a specific column.
    optional string as = 1;
  }
  message Global {
    option (gogoproto.equal) = true;
  }
  oneof locality {
    Global global = 1;
    RegionalByTable regional_by_table = 2;
    RegionalByRow regional_by_row = 3;
  }
}

// SystemColumnKind is an enum representing the different kind of system
// columns that can be synthesized by the execution engine.
enum SystemColumnKind {
  // Default value, unused.
  NONE = 0;
  // A system column containing the value of the MVCC timestamp associated
  // with the kv's corresponding to the row.
  MVCCTIMESTAMP = 1;
  // A system column containing the OID of the table that the row came from.
  TABLEOID = 2;
}

// GeneratedAsIdentityType is an enum representing how the creation of
// a column is associated with the GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY
// syntax.
enum GeneratedAsIdentityType {
  // A column created without `GENERATED ... AS IDENTITY` syntax.
  NOT_IDENTITY_COLUMN = 0;
  // A column created with `GENERATED ALWAYS AS IDENTITY` syntax.
  // Such a column does not allow override without `OVERRIDING SYSTEM VALUE`
  // syntax.
  GENERATED_ALWAYS = 1;
  // A column created with `GENERATED BY DEFAULT AS IDENTITY` syntax.
  // Such a column can be overridden without `OVERRIDING SYSTEM VALUE` syntax.
  GENERATED_BY_DEFAULT = 2;
}

// ShardedDescriptor represents an index (either primary or secondary) that is hash
// sharded into a user-specified number of buckets.
//
// As as example, sample field values for the following table:
//
// CREATE TABLE abc (
//   a INT PRIMARY KEY USING HASH WITH (bucket_count=10),  // column id: 1
//   b BYTES
// );
//
// Sharded descriptor:
//   name:          "a_shard"
//   shard_buckets: 10
//   column_names:  ["a"]
message ShardedDescriptor {
  option (gogoproto.equal) = true;

  // IsSharded indicates whether the index in question is a sharded one.
  optional bool is_sharded = 1 [(gogoproto.nullable) = false];
  // Name is the name of the shard column.
  optional string name = 2 [(gogoproto.nullable) = false];

  // ShardBuckets indicates the number of shards this index is divided into.
  optional int32 shard_buckets = 3 [(gogoproto.nullable) = false,
    (gogoproto.customname) = "ShardBuckets"];

  // ColumnNames lists the names of the columns used to compute the shard column's
  // values.
  repeated string column_names = 4;
}

// ScheduledRowLevelTTLArgs represents the arguments for a row-level TTL
// scheduled job.
message ScheduledRowLevelTTLArgs {
  optional uint32 table_id = 1 [
    (gogoproto.customname) = "TableID",
    (gogoproto.casttype) = "github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID",
    (gogoproto.nullable) = false
  ];
}

// PartitioningDescriptor represents the partitioning of an index into spans
// of keys addressable by a zone config. The key encoding is unchanged. Each
// partition may optionally be itself divided into further partitions, called
// subpartitions.
message PartitioningDescriptor {
  option (gogoproto.equal) = true;
  // List represents a list partitioning, which maps individual tuples to
  // partitions.
  message List {
    option (gogoproto.equal) = true;
    // Name is the partition name.
    optional string name = 1 [(gogoproto.nullable) = false];
    // Values is an unordered set of the tuples included in this partition. Each
    // tuple is encoded with the EncDatum value encoding. DEFAULT is encoded as
    // NOT NULL followed by PartitionDefaultVal encoded as a non-sorting
    // uvarint.
    repeated bytes values = 2;
    // Subpartitioning represents a further partitioning of this list partition.
    optional PartitioningDescriptor subpartitioning = 3 [(gogoproto.nullable) = false];
  }

  // Range represents a range partitioning, which maps ranges of tuples to
  // partitions by specifying exclusive upper bounds. The range partitions in a
  // PartitioningDescriptor are required to be sorted by UpperBound.
  message Range {
    option (gogoproto.equal) = true;
    // Name is the partition name.
    optional string name = 1 [(gogoproto.nullable) = false];
    // FromInclusive is the inclusive lower bound of this range partition. It is
    // encoded with the EncDatum value encoding. MINVALUE and MAXVALUE are
    // encoded as NOT NULL followed by a PartitionSpecialValCode encoded as a
    // non-sorting uvarint.
    optional bytes from_inclusive = 3;
    // ToExclusive is the exclusive upper bound of this range partition. It is
    // encoded in the same way as From.
    optional bytes to_exclusive = 2;
  }

  // NumColumns is how large of a prefix of the columns in an index are used in
  // the function mapping column values to partitions. If this is a
  // subpartition, this is offset to start from the end of the parent
  // partition's columns. If NumColumns is 0, then there is no partitioning.
  optional uint32 num_columns = 1 [(gogoproto.nullable) = false];
  // NumImplicitColumns specifies the number of columns that implicitly prefix a given index.
  // This occurs if a user specifies a PARTITION BY which is not a prefix of the given index,
  // in which case the ColumnIDs are added in front of the index and this field denotes
  // the number of columns added as a prefix.
  // If NumImplicitColumns is 0, there are no implicit columns defined for the index."
  optional uint32 num_implicit_columns = 4 [(gogoproto.nullable)=false];

  // Exactly one of List or Range is required to be non-empty if NumColumns is
  // non-zero.
  repeated List list = 2 [(gogoproto.nullable) = false];
  repeated Range range = 3 [(gogoproto.nullable) = false];
}

// RowLevelTTL represents the TTL configured on a table.
message RowLevelTTL {
  option (gogoproto.equal) = true;

  // DurationExpr is the automatically assigned interval for when the TTL should apply to a row.
  optional string duration_expr = 1 [(gogoproto.nullable)=false, (gogoproto.casttype)="Expression"];
  // SelectBatchSize is the amount of rows that should be fetched at a time
  optional int64 select_batch_size = 2 [(gogoproto.nullable)=false];
  // DeleteBatchSize is the amount of rows that should be deleted at a time.
  optional int64 delete_batch_size = 3 [(gogoproto.nullable)=false];
  // DeletionCron signifies how often the TTL deletion job runs in a cron format.
  optional string deletion_cron = 4 [(gogoproto.nullable)=false];
  // ScheduleID is the ID of the row-level TTL job schedules.
  optional int64 schedule_id = 5 [(gogoproto.customname)="ScheduleID",(gogoproto.nullable)=false];
  // RangeConcurrency is the number of ranges to process at a time.
  optional int64 range_concurrency = 6 [(gogoproto.nullable)=false];
  // DeleteRateLimit is the maximum amount of rows to delete per second.
  optional int64 delete_rate_limit = 7 [(gogoproto.nullable)=false];
  // Pause is set if the TTL job should not run.
  optional bool pause = 8 [(gogoproto.nullable)=false];
  // RowStatsPollInterval is the interval to report row statistics (number of rows on table, number of expired
  // rows on table) during row level TTL. If zero, no statistics are reported.
  optional int64 row_stats_poll_interval = 9 [(gogoproto.nullable)=false, (gogoproto.casttype)="time.Duration"];
}
