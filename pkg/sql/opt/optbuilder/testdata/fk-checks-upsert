# The upsert tests need to exercise these dimensions:
#  - inbound vs outbound FKs
#  - single vs multiple FK columns
#  - all table columns specified vs subset of table (and FK) columns specified
#  - statement type:
#     - UPSERT
#     - INSERT ON CONFLICT DO UPDATE
#     - INSERT ON CONFLICT with a secondary index
#
# Note that ON CONFLICT DO NOTHING is not built as an Upsert so it is not
# tested here.

exec-ddl
CREATE TABLE xyzw (x INT, y INT, z INT, w INT)
----

exec-ddl
CREATE TABLE uv (u INT NOT NULL, v INT NOT NULL)
----

# ---------------------------------------
# Outbound FK tests with single FK column
# ---------------------------------------

exec-ddl
CREATE TABLE p (p INT PRIMARY KEY, other INT)
----

exec-ddl
CREATE TABLE c1 (c INT PRIMARY KEY, p INT NOT NULL DEFAULT 5 REFERENCES p(p), i INT)
----

build
UPSERT INTO c1 VALUES (100, 1), (200, 1)
----
upsert c1
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── column1:5 => c:1
 │    ├── column2:6 => c1.p:2
 │    └── i:7 => c1.i:3
 ├── input binding: &1
 ├── project
 │    ├── columns: i:7 column1:5!null column2:6!null
 │    ├── values
 │    │    ├── columns: column1:5!null column2:6!null
 │    │    ├── (100, 1)
 │    │    └── (200, 1)
 │    └── projections
 │         └── NULL::INT8 [as=i:7]
 └── f-k-checks
      └── f-k-checks-item: c1(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:8!null
                ├── with-scan &1
                │    ├── columns: p:8!null
                │    └── mapping:
                │         └──  column2:6 => p:8
                ├── scan p
                │    └── columns: p.p:9!null
                └── filters
                     └── p:8 = p.p:9

build
UPSERT INTO c1(c) VALUES (100), (200)
----
upsert c1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: c1.c:8
 ├── fetch columns: c1.c:8 c1.p:9 c1.i:10
 ├── insert-mapping:
 │    ├── column1:5 => c1.c:1
 │    ├── p:6 => c1.p:2
 │    └── i:7 => c1.i:3
 ├── input binding: &1
 ├── project
 │    ├── columns: c:12 p:13 i:14 column1:5!null p:6!null i:7 c1.c:8 c1.p:9 c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    ├── left-join (hash)
 │    │    ├── columns: column1:5!null p:6!null i:7 c1.c:8 c1.p:9 c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:5!null p:6!null i:7
 │    │    │    ├── grouping columns: column1:5!null
 │    │    │    ├── project
 │    │    │    │    ├── columns: p:6!null i:7 column1:5!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:5!null
 │    │    │    │    │    ├── (100,)
 │    │    │    │    │    └── (200,)
 │    │    │    │    └── projections
 │    │    │    │         ├── 5 [as=p:6]
 │    │    │    │         └── NULL::INT8 [as=i:7]
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=p:6]
 │    │    │         │    └── p:6
 │    │    │         └── first-agg [as=i:7]
 │    │    │              └── i:7
 │    │    ├── scan c1
 │    │    │    └── columns: c1.c:8!null c1.p:9!null c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    │    └── filters
 │    │         └── column1:5 = c1.c:8
 │    └── projections
 │         ├── CASE WHEN c1.c:8 IS NULL THEN column1:5 ELSE c1.c:8 END [as=c:12]
 │         ├── CASE WHEN c1.c:8 IS NULL THEN p:6 ELSE c1.p:9 END [as=p:13]
 │         └── CASE WHEN c1.c:8 IS NULL THEN i:7 ELSE c1.i:10 END [as=i:14]
 └── f-k-checks
      └── f-k-checks-item: c1(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:15
                ├── with-scan &1
                │    ├── columns: p:15
                │    └── mapping:
                │         └──  p:13 => p:15
                ├── scan p
                │    └── columns: p.p:16!null
                └── filters
                     └── p:15 = p.p:16

# Use a non-constant input.
build
UPSERT INTO c1 SELECT x, y FROM xyzw
----
upsert c1
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── x:5 => c:1
 │    ├── y:6 => c1.p:2
 │    └── i:11 => c1.i:3
 ├── input binding: &1
 ├── project
 │    ├── columns: i:11 x:5 y:6
 │    ├── project
 │    │    ├── columns: x:5 y:6
 │    │    └── scan xyzw
 │    │         └── columns: x:5 y:6 z:7 w:8 rowid:9!null xyzw.crdb_internal_mvcc_timestamp:10
 │    └── projections
 │         └── NULL::INT8 [as=i:11]
 └── f-k-checks
      └── f-k-checks-item: c1(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:12
                ├── with-scan &1
                │    ├── columns: p:12
                │    └── mapping:
                │         └──  y:6 => p:12
                ├── scan p
                │    └── columns: p.p:13!null
                └── filters
                     └── p:12 = p.p:13

build
INSERT INTO c1 VALUES (100, 1), (200, 1) ON CONFLICT (c) DO UPDATE SET p = excluded.p + 1
----
upsert c1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: c1.c:8
 ├── fetch columns: c1.c:8 c1.p:9 c1.i:10
 ├── insert-mapping:
 │    ├── column1:5 => c1.c:1
 │    ├── column2:6 => c1.p:2
 │    └── i:7 => c1.i:3
 ├── update-mapping:
 │    └── p:14 => c1.p:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:13 p:14!null i:15 column1:5!null column2:6!null i:7 c1.c:8 c1.p:9 c1.i:10 c1.crdb_internal_mvcc_timestamp:11 p:12!null
 │    ├── project
 │    │    ├── columns: p:12!null column1:5!null column2:6!null i:7 c1.c:8 c1.p:9 c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:5!null column2:6!null i:7 c1.c:8 c1.p:9 c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:5!null column2:6!null i:7
 │    │    │    │    ├── grouping columns: column1:5!null
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: i:7 column1:5!null column2:6!null
 │    │    │    │    │    ├── values
 │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
 │    │    │    │    │    │    ├── (100, 1)
 │    │    │    │    │    │    └── (200, 1)
 │    │    │    │    │    └── projections
 │    │    │    │    │         └── NULL::INT8 [as=i:7]
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=column2:6]
 │    │    │    │         │    └── column2:6
 │    │    │    │         └── first-agg [as=i:7]
 │    │    │    │              └── i:7
 │    │    │    ├── scan c1
 │    │    │    │    └── columns: c1.c:8!null c1.p:9!null c1.i:10 c1.crdb_internal_mvcc_timestamp:11
 │    │    │    └── filters
 │    │    │         └── column1:5 = c1.c:8
 │    │    └── projections
 │    │         └── column2:6 + 1 [as=p:12]
 │    └── projections
 │         ├── CASE WHEN c1.c:8 IS NULL THEN column1:5 ELSE c1.c:8 END [as=c:13]
 │         ├── CASE WHEN c1.c:8 IS NULL THEN column2:6 ELSE p:12 END [as=p:14]
 │         └── CASE WHEN c1.c:8 IS NULL THEN i:7 ELSE c1.i:10 END [as=i:15]
 └── f-k-checks
      └── f-k-checks-item: c1(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:16!null
                ├── with-scan &1
                │    ├── columns: p:16!null
                │    └── mapping:
                │         └──  p:14 => p:16
                ├── scan p
                │    └── columns: p.p:17!null
                └── filters
                     └── p:16 = p.p:17

build
INSERT INTO c1 SELECT u, v FROM uv ON CONFLICT (c) DO UPDATE SET i = c1.c + 1
----
upsert c1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: c1.c:10
 ├── fetch columns: c1.c:10 c1.p:11 c1.i:12
 ├── insert-mapping:
 │    ├── u:5 => c1.c:1
 │    ├── v:6 => c1.p:2
 │    └── i:9 => c1.i:3
 ├── update-mapping:
 │    └── i:17 => c1.i:3
 ├── input binding: &1
 ├── project
 │    ├── columns: c:15 p:16 i:17 u:5!null v:6!null i:9 c1.c:10 c1.p:11 c1.i:12 c1.crdb_internal_mvcc_timestamp:13 i:14
 │    ├── project
 │    │    ├── columns: i:14 u:5!null v:6!null i:9 c1.c:10 c1.p:11 c1.i:12 c1.crdb_internal_mvcc_timestamp:13
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: u:5!null v:6!null i:9 c1.c:10 c1.p:11 c1.i:12 c1.crdb_internal_mvcc_timestamp:13
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: u:5!null v:6!null i:9
 │    │    │    │    ├── grouping columns: u:5!null
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: i:9 u:5!null v:6!null
 │    │    │    │    │    ├── project
 │    │    │    │    │    │    ├── columns: u:5!null v:6!null
 │    │    │    │    │    │    └── scan uv
 │    │    │    │    │    │         └── columns: u:5!null v:6!null rowid:7!null uv.crdb_internal_mvcc_timestamp:8
 │    │    │    │    │    └── projections
 │    │    │    │    │         └── NULL::INT8 [as=i:9]
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=v:6]
 │    │    │    │         │    └── v:6
 │    │    │    │         └── first-agg [as=i:9]
 │    │    │    │              └── i:9
 │    │    │    ├── scan c1
 │    │    │    │    └── columns: c1.c:10!null c1.p:11!null c1.i:12 c1.crdb_internal_mvcc_timestamp:13
 │    │    │    └── filters
 │    │    │         └── u:5 = c1.c:10
 │    │    └── projections
 │    │         └── c1.c:10 + 1 [as=i:14]
 │    └── projections
 │         ├── CASE WHEN c1.c:10 IS NULL THEN u:5 ELSE c1.c:10 END [as=c:15]
 │         ├── CASE WHEN c1.c:10 IS NULL THEN v:6 ELSE c1.p:11 END [as=p:16]
 │         └── CASE WHEN c1.c:10 IS NULL THEN i:9 ELSE i:14 END [as=i:17]
 └── f-k-checks
      └── f-k-checks-item: c1(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:18
                ├── with-scan &1
                │    ├── columns: p:18
                │    └── mapping:
                │         └──  p:16 => p:18
                ├── scan p
                │    └── columns: p.p:19!null
                └── filters
                     └── p:18 = p.p:19

exec-ddl
CREATE TABLE c2 (c INT PRIMARY KEY, FOREIGN KEY (c) REFERENCES p(p))
----

build
INSERT INTO c2 VALUES (1), (2) ON CONFLICT (c) DO UPDATE SET c = 1
----
upsert c2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: c2.c:4
 ├── fetch columns: c2.c:4
 ├── insert-mapping:
 │    └── column1:3 => c2.c:1
 ├── update-mapping:
 │    └── c:7 => c2.c:1
 ├── input binding: &1
 ├── project
 │    ├── columns: c:7!null column1:3!null c2.c:4 c2.crdb_internal_mvcc_timestamp:5 c:6!null
 │    ├── project
 │    │    ├── columns: c:6!null column1:3!null c2.c:4 c2.crdb_internal_mvcc_timestamp:5
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:3!null c2.c:4 c2.crdb_internal_mvcc_timestamp:5
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:3!null
 │    │    │    │    ├── grouping columns: column1:3!null
 │    │    │    │    └── values
 │    │    │    │         ├── columns: column1:3!null
 │    │    │    │         ├── (1,)
 │    │    │    │         └── (2,)
 │    │    │    ├── scan c2
 │    │    │    │    └── columns: c2.c:4!null c2.crdb_internal_mvcc_timestamp:5
 │    │    │    └── filters
 │    │    │         └── column1:3 = c2.c:4
 │    │    └── projections
 │    │         └── 1 [as=c:6]
 │    └── projections
 │         └── CASE WHEN c2.c:4 IS NULL THEN column1:3 ELSE c:6 END [as=c:7]
 └── f-k-checks
      └── f-k-checks-item: c2(c) -> p(p)
           └── anti-join (hash)
                ├── columns: c:8!null
                ├── with-scan &1
                │    ├── columns: c:8!null
                │    └── mapping:
                │         └──  c:7 => c:8
                ├── scan p
                │    └── columns: p:9!null
                └── filters
                     └── c:8 = p:9

exec-ddl
CREATE TABLE c3 (c INT PRIMARY KEY, p INT REFERENCES p(p));
----

# Because the input column can be NULL (in which case it requires no FK match),
# we have to add an extra filter.
build
UPSERT INTO c3 VALUES (100, 1), (200, NULL)
----
upsert c3
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── column1:4 => c:1
 │    └── column2:5 => c3.p:2
 ├── input binding: &1
 ├── values
 │    ├── columns: column1:4!null column2:5
 │    ├── (100, 1)
 │    └── (200, NULL::INT8)
 └── f-k-checks
      └── f-k-checks-item: c3(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:6!null
                ├── select
                │    ├── columns: p:6!null
                │    ├── with-scan &1
                │    │    ├── columns: p:6
                │    │    └── mapping:
                │    │         └──  column2:5 => p:6
                │    └── filters
                │         └── p:6 IS NOT NULL
                ├── scan p
                │    └── columns: p.p:7!null
                └── filters
                     └── p:6 = p.p:7

build
UPSERT INTO c3(c) VALUES (100), (200)
----
upsert c3
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: c3.c:6
 ├── fetch columns: c3.c:6 c3.p:7
 ├── insert-mapping:
 │    ├── column1:4 => c3.c:1
 │    └── p:5 => c3.p:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:9 p:10 column1:4!null p:5 c3.c:6 c3.p:7 c3.crdb_internal_mvcc_timestamp:8
 │    ├── left-join (hash)
 │    │    ├── columns: column1:4!null p:5 c3.c:6 c3.p:7 c3.crdb_internal_mvcc_timestamp:8
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:4!null p:5
 │    │    │    ├── grouping columns: column1:4!null
 │    │    │    ├── project
 │    │    │    │    ├── columns: p:5 column1:4!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:4!null
 │    │    │    │    │    ├── (100,)
 │    │    │    │    │    └── (200,)
 │    │    │    │    └── projections
 │    │    │    │         └── NULL::INT8 [as=p:5]
 │    │    │    └── aggregations
 │    │    │         └── first-agg [as=p:5]
 │    │    │              └── p:5
 │    │    ├── scan c3
 │    │    │    └── columns: c3.c:6!null c3.p:7 c3.crdb_internal_mvcc_timestamp:8
 │    │    └── filters
 │    │         └── column1:4 = c3.c:6
 │    └── projections
 │         ├── CASE WHEN c3.c:6 IS NULL THEN column1:4 ELSE c3.c:6 END [as=c:9]
 │         └── CASE WHEN c3.c:6 IS NULL THEN p:5 ELSE c3.p:7 END [as=p:10]
 └── f-k-checks
      └── f-k-checks-item: c3(p) -> p(p)
           └── anti-join (hash)
                ├── columns: p:11!null
                ├── select
                │    ├── columns: p:11!null
                │    ├── with-scan &1
                │    │    ├── columns: p:11
                │    │    └── mapping:
                │    │         └──  p:10 => p:11
                │    └── filters
                │         └── p:11 IS NOT NULL
                ├── scan p
                │    └── columns: p.p:12!null
                └── filters
                     └── p:11 = p.p:12

exec-ddl
CREATE TABLE c4 (c INT PRIMARY KEY, a INT REFERENCES p(p), other INT, UNIQUE(a))
----

build
INSERT INTO c4 SELECT x, y, z FROM xyzw ON CONFLICT (a) DO UPDATE SET other = 1
----
upsert c4
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: c4.c:11
 ├── fetch columns: c4.c:11 c4.a:12 c4.other:13
 ├── insert-mapping:
 │    ├── x:5 => c4.c:1
 │    ├── y:6 => c4.a:2
 │    └── z:7 => c4.other:3
 ├── update-mapping:
 │    └── other:18 => c4.other:3
 ├── input binding: &1
 ├── project
 │    ├── columns: c:16 a:17 other:18 x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14 other:15!null
 │    ├── project
 │    │    ├── columns: other:15!null x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: x:5 y:6 z:7
 │    │    │    │    ├── grouping columns: y:6
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: x:5 y:6 z:7
 │    │    │    │    │    └── scan xyzw
 │    │    │    │    │         └── columns: x:5 y:6 z:7 w:8 rowid:9!null xyzw.crdb_internal_mvcc_timestamp:10
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=x:5]
 │    │    │    │         │    └── x:5
 │    │    │    │         └── first-agg [as=z:7]
 │    │    │    │              └── z:7
 │    │    │    ├── scan c4
 │    │    │    │    └── columns: c4.c:11!null c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    │    └── filters
 │    │    │         └── y:6 = c4.a:12
 │    │    └── projections
 │    │         └── 1 [as=other:15]
 │    └── projections
 │         ├── CASE WHEN c4.c:11 IS NULL THEN x:5 ELSE c4.c:11 END [as=c:16]
 │         ├── CASE WHEN c4.c:11 IS NULL THEN y:6 ELSE c4.a:12 END [as=a:17]
 │         └── CASE WHEN c4.c:11 IS NULL THEN z:7 ELSE other:15 END [as=other:18]
 └── f-k-checks
      └── f-k-checks-item: c4(a) -> p(p)
           └── anti-join (hash)
                ├── columns: a:19!null
                ├── select
                │    ├── columns: a:19!null
                │    ├── with-scan &1
                │    │    ├── columns: a:19
                │    │    └── mapping:
                │    │         └──  a:17 => a:19
                │    └── filters
                │         └── a:19 IS NOT NULL
                ├── scan p
                │    └── columns: p:20!null
                └── filters
                     └── a:19 = p:20

build
INSERT INTO c4 SELECT x, y, z FROM xyzw ON CONFLICT (a) DO UPDATE SET a = 5
----
upsert c4
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: c4.c:11
 ├── fetch columns: c4.c:11 c4.a:12 c4.other:13
 ├── insert-mapping:
 │    ├── x:5 => c4.c:1
 │    ├── y:6 => c4.a:2
 │    └── z:7 => c4.other:3
 ├── update-mapping:
 │    └── a:17 => c4.a:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:16 a:17 other:18 x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14 a:15!null
 │    ├── project
 │    │    ├── columns: a:15!null x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: x:5 y:6 z:7 c4.c:11 c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: x:5 y:6 z:7
 │    │    │    │    ├── grouping columns: y:6
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: x:5 y:6 z:7
 │    │    │    │    │    └── scan xyzw
 │    │    │    │    │         └── columns: x:5 y:6 z:7 w:8 rowid:9!null xyzw.crdb_internal_mvcc_timestamp:10
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=x:5]
 │    │    │    │         │    └── x:5
 │    │    │    │         └── first-agg [as=z:7]
 │    │    │    │              └── z:7
 │    │    │    ├── scan c4
 │    │    │    │    └── columns: c4.c:11!null c4.a:12 c4.other:13 c4.crdb_internal_mvcc_timestamp:14
 │    │    │    └── filters
 │    │    │         └── y:6 = c4.a:12
 │    │    └── projections
 │    │         └── 5 [as=a:15]
 │    └── projections
 │         ├── CASE WHEN c4.c:11 IS NULL THEN x:5 ELSE c4.c:11 END [as=c:16]
 │         ├── CASE WHEN c4.c:11 IS NULL THEN y:6 ELSE a:15 END [as=a:17]
 │         └── CASE WHEN c4.c:11 IS NULL THEN z:7 ELSE c4.other:13 END [as=other:18]
 └── f-k-checks
      └── f-k-checks-item: c4(a) -> p(p)
           └── anti-join (hash)
                ├── columns: a:19!null
                ├── select
                │    ├── columns: a:19!null
                │    ├── with-scan &1
                │    │    ├── columns: a:19
                │    │    └── mapping:
                │    │         └──  a:17 => a:19
                │    └── filters
                │         └── a:19 IS NOT NULL
                ├── scan p
                │    └── columns: p:20!null
                └── filters
                     └── a:19 = p:20


# ------------------------------------------
# Outbound FK tests with multiple FK columns
# ------------------------------------------

exec-ddl
CREATE TABLE pq (
  k INT PRIMARY KEY,
  p INT,
  q INT,
  other INT,
  UNIQUE(p,q),
  FAMILY (k), FAMILY (p), FAMILY (q), FAMILY (other)
)
----

exec-ddl
CREATE TABLE cpq (
  c INT PRIMARY KEY,
  p INT DEFAULT 4,
  q INT DEFAULT 8,
  other INT,
  FAMILY (c), FAMILY (p), FAMILY (q), FAMILY (other),
  CONSTRAINT fk FOREIGN KEY (p,q) REFERENCES pq(p,q) MATCH SIMPLE
)
----

build
UPSERT INTO cpq VALUES (1, 1, 1, 1)
----
upsert cpq
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── column1:6 => c:1
 │    ├── column2:7 => cpq.p:2
 │    ├── column3:8 => cpq.q:3
 │    └── column4:9 => cpq.other:4
 ├── input binding: &1
 ├── values
 │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    └── (1, 1, 1, 1)
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:10!null q:11!null
                ├── with-scan &1
                │    ├── columns: p:10!null q:11!null
                │    └── mapping:
                │         ├──  column2:7 => p:10
                │         └──  column3:8 => q:11
                ├── scan pq
                │    └── columns: pq.p:13 pq.q:14
                └── filters
                     ├── p:10 = pq.p:13
                     └── q:11 = pq.q:14

# In this case, the input columns can be null.
build
UPSERT INTO cpq SELECT x,y,z,w FROM xyzw
----
upsert cpq
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── x:6 => c:1
 │    ├── y:7 => cpq.p:2
 │    ├── z:8 => cpq.q:3
 │    └── w:9 => cpq.other:4
 ├── input binding: &1
 ├── project
 │    ├── columns: x:6 y:7 z:8 w:9
 │    └── scan xyzw
 │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:12!null q:13!null
                ├── select
                │    ├── columns: p:12!null q:13!null
                │    ├── with-scan &1
                │    │    ├── columns: p:12 q:13
                │    │    └── mapping:
                │    │         ├──  y:7 => p:12
                │    │         └──  z:8 => q:13
                │    └── filters
                │         ├── p:12 IS NOT NULL
                │         └── q:13 IS NOT NULL
                ├── scan pq
                │    └── columns: pq.p:15 pq.q:16
                └── filters
                     ├── p:12 = pq.p:15
                     └── q:13 = pq.q:16

build
UPSERT INTO cpq(c,p) SELECT x,y FROM xyzw
----
upsert cpq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: cpq.c:14
 ├── fetch columns: cpq.c:14 cpq.p:15 cpq.q:16 cpq.other:17
 ├── insert-mapping:
 │    ├── x:6 => cpq.c:1
 │    ├── y:7 => cpq.p:2
 │    ├── q:12 => cpq.q:3
 │    └── other:13 => cpq.other:4
 ├── update-mapping:
 │    └── y:7 => cpq.p:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:19 q:20 other:21 x:6 y:7 q:12!null other:13 cpq.c:14 cpq.p:15 cpq.q:16 cpq.other:17 cpq.crdb_internal_mvcc_timestamp:18
 │    ├── left-join (hash)
 │    │    ├── columns: x:6 y:7 q:12!null other:13 cpq.c:14 cpq.p:15 cpq.q:16 cpq.other:17 cpq.crdb_internal_mvcc_timestamp:18
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: x:6 y:7 q:12!null other:13
 │    │    │    ├── grouping columns: x:6
 │    │    │    ├── project
 │    │    │    │    ├── columns: q:12!null other:13 x:6 y:7
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: x:6 y:7
 │    │    │    │    │    └── scan xyzw
 │    │    │    │    │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 │    │    │    │    └── projections
 │    │    │    │         ├── 8 [as=q:12]
 │    │    │    │         └── NULL::INT8 [as=other:13]
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=y:7]
 │    │    │         │    └── y:7
 │    │    │         ├── first-agg [as=q:12]
 │    │    │         │    └── q:12
 │    │    │         └── first-agg [as=other:13]
 │    │    │              └── other:13
 │    │    ├── scan cpq
 │    │    │    └── columns: cpq.c:14!null cpq.p:15 cpq.q:16 cpq.other:17 cpq.crdb_internal_mvcc_timestamp:18
 │    │    └── filters
 │    │         └── x:6 = cpq.c:14
 │    └── projections
 │         ├── CASE WHEN cpq.c:14 IS NULL THEN x:6 ELSE cpq.c:14 END [as=c:19]
 │         ├── CASE WHEN cpq.c:14 IS NULL THEN q:12 ELSE cpq.q:16 END [as=q:20]
 │         └── CASE WHEN cpq.c:14 IS NULL THEN other:13 ELSE cpq.other:17 END [as=other:21]
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:22!null q:23!null
                ├── select
                │    ├── columns: p:22!null q:23!null
                │    ├── with-scan &1
                │    │    ├── columns: p:22 q:23
                │    │    └── mapping:
                │    │         ├──  y:7 => p:22
                │    │         └──  q:20 => q:23
                │    └── filters
                │         ├── p:22 IS NOT NULL
                │         └── q:23 IS NOT NULL
                ├── scan pq
                │    └── columns: pq.p:25 pq.q:26
                └── filters
                     ├── p:22 = pq.p:25
                     └── q:23 = pq.q:26

build
UPSERT INTO cpq(c) SELECT x FROM xyzw
----
upsert cpq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: cpq.c:15
 ├── fetch columns: cpq.c:15 cpq.p:16 cpq.q:17 cpq.other:18
 ├── insert-mapping:
 │    ├── x:6 => cpq.c:1
 │    ├── p:12 => cpq.p:2
 │    ├── q:13 => cpq.q:3
 │    └── other:14 => cpq.other:4
 ├── input binding: &1
 ├── project
 │    ├── columns: c:20 p:21 q:22 other:23 x:6 p:12!null q:13!null other:14 cpq.c:15 cpq.p:16 cpq.q:17 cpq.other:18 cpq.crdb_internal_mvcc_timestamp:19
 │    ├── left-join (hash)
 │    │    ├── columns: x:6 p:12!null q:13!null other:14 cpq.c:15 cpq.p:16 cpq.q:17 cpq.other:18 cpq.crdb_internal_mvcc_timestamp:19
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: x:6 p:12!null q:13!null other:14
 │    │    │    ├── grouping columns: x:6
 │    │    │    ├── project
 │    │    │    │    ├── columns: p:12!null q:13!null other:14 x:6
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: x:6
 │    │    │    │    │    └── scan xyzw
 │    │    │    │    │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 │    │    │    │    └── projections
 │    │    │    │         ├── 4 [as=p:12]
 │    │    │    │         ├── 8 [as=q:13]
 │    │    │    │         └── NULL::INT8 [as=other:14]
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=p:12]
 │    │    │         │    └── p:12
 │    │    │         ├── first-agg [as=q:13]
 │    │    │         │    └── q:13
 │    │    │         └── first-agg [as=other:14]
 │    │    │              └── other:14
 │    │    ├── scan cpq
 │    │    │    └── columns: cpq.c:15!null cpq.p:16 cpq.q:17 cpq.other:18 cpq.crdb_internal_mvcc_timestamp:19
 │    │    └── filters
 │    │         └── x:6 = cpq.c:15
 │    └── projections
 │         ├── CASE WHEN cpq.c:15 IS NULL THEN x:6 ELSE cpq.c:15 END [as=c:20]
 │         ├── CASE WHEN cpq.c:15 IS NULL THEN p:12 ELSE cpq.p:16 END [as=p:21]
 │         ├── CASE WHEN cpq.c:15 IS NULL THEN q:13 ELSE cpq.q:17 END [as=q:22]
 │         └── CASE WHEN cpq.c:15 IS NULL THEN other:14 ELSE cpq.other:18 END [as=other:23]
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:24!null q:25!null
                ├── select
                │    ├── columns: p:24!null q:25!null
                │    ├── with-scan &1
                │    │    ├── columns: p:24 q:25
                │    │    └── mapping:
                │    │         ├──  p:21 => p:24
                │    │         └──  q:22 => q:25
                │    └── filters
                │         ├── p:24 IS NOT NULL
                │         └── q:25 IS NOT NULL
                ├── scan pq
                │    └── columns: pq.p:27 pq.q:28
                └── filters
                     ├── p:24 = pq.p:27
                     └── q:25 = pq.q:28

# This has different semantics from the UPSERT INTO cpq(c) version - here we
# upsert default values for all unspecified columns.
build
UPSERT INTO cpq SELECT x FROM xyzw
----
upsert cpq
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── x:6 => c:1
 │    ├── p:12 => cpq.p:2
 │    ├── q:13 => cpq.q:3
 │    └── other:14 => cpq.other:4
 ├── input binding: &1
 ├── project
 │    ├── columns: p:12!null q:13!null other:14 x:6
 │    ├── project
 │    │    ├── columns: x:6
 │    │    └── scan xyzw
 │    │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 │    └── projections
 │         ├── 4 [as=p:12]
 │         ├── 8 [as=q:13]
 │         └── NULL::INT8 [as=other:14]
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:15!null q:16!null
                ├── with-scan &1
                │    ├── columns: p:15!null q:16!null
                │    └── mapping:
                │         ├──  p:12 => p:15
                │         └──  q:13 => q:16
                ├── scan pq
                │    └── columns: pq.p:18 pq.q:19
                └── filters
                     ├── p:15 = pq.p:18
                     └── q:16 = pq.q:19

build
INSERT INTO cpq VALUES (1), (2) ON CONFLICT (c) DO UPDATE SET p = 10
----
upsert cpq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: cpq.c:10
 ├── fetch columns: cpq.c:10 cpq.p:11 cpq.q:12 cpq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => cpq.c:1
 │    ├── p:7 => cpq.p:2
 │    ├── q:8 => cpq.q:3
 │    └── other:9 => cpq.other:4
 ├── update-mapping:
 │    └── p:17 => cpq.p:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:16 p:17!null q:18 other:19 column1:6!null p:7!null q:8!null other:9 cpq.c:10 cpq.p:11 cpq.q:12 cpq.other:13 cpq.crdb_internal_mvcc_timestamp:14 p:15!null
 │    ├── project
 │    │    ├── columns: p:15!null column1:6!null p:7!null q:8!null other:9 cpq.c:10 cpq.p:11 cpq.q:12 cpq.other:13 cpq.crdb_internal_mvcc_timestamp:14
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:6!null p:7!null q:8!null other:9 cpq.c:10 cpq.p:11 cpq.q:12 cpq.other:13 cpq.crdb_internal_mvcc_timestamp:14
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:6!null p:7!null q:8!null other:9
 │    │    │    │    ├── grouping columns: column1:6!null
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: p:7!null q:8!null other:9 column1:6!null
 │    │    │    │    │    ├── values
 │    │    │    │    │    │    ├── columns: column1:6!null
 │    │    │    │    │    │    ├── (1,)
 │    │    │    │    │    │    └── (2,)
 │    │    │    │    │    └── projections
 │    │    │    │    │         ├── 4 [as=p:7]
 │    │    │    │    │         ├── 8 [as=q:8]
 │    │    │    │    │         └── NULL::INT8 [as=other:9]
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=p:7]
 │    │    │    │         │    └── p:7
 │    │    │    │         ├── first-agg [as=q:8]
 │    │    │    │         │    └── q:8
 │    │    │    │         └── first-agg [as=other:9]
 │    │    │    │              └── other:9
 │    │    │    ├── scan cpq
 │    │    │    │    └── columns: cpq.c:10!null cpq.p:11 cpq.q:12 cpq.other:13 cpq.crdb_internal_mvcc_timestamp:14
 │    │    │    └── filters
 │    │    │         └── column1:6 = cpq.c:10
 │    │    └── projections
 │    │         └── 10 [as=p:15]
 │    └── projections
 │         ├── CASE WHEN cpq.c:10 IS NULL THEN column1:6 ELSE cpq.c:10 END [as=c:16]
 │         ├── CASE WHEN cpq.c:10 IS NULL THEN p:7 ELSE p:15 END [as=p:17]
 │         ├── CASE WHEN cpq.c:10 IS NULL THEN q:8 ELSE cpq.q:12 END [as=q:18]
 │         └── CASE WHEN cpq.c:10 IS NULL THEN other:9 ELSE cpq.other:13 END [as=other:19]
 └── f-k-checks
      └── f-k-checks-item: cpq(p,q) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: p:20!null q:21!null
                ├── select
                │    ├── columns: p:20!null q:21!null
                │    ├── with-scan &1
                │    │    ├── columns: p:20!null q:21
                │    │    └── mapping:
                │    │         ├──  p:17 => p:20
                │    │         └──  q:18 => q:21
                │    └── filters
                │         └── q:21 IS NOT NULL
                ├── scan pq
                │    └── columns: pq.p:23 pq.q:24
                └── filters
                     ├── p:20 = pq.p:23
                     └── q:21 = pq.q:24

# ------------------------------------------
# Multiple outbound FKs
# ------------------------------------------

exec-ddl
CREATE TABLE cmulti (
  a INT,
  b INT,
  c INT DEFAULT 4,
  d INT DEFAULT 8,
  PRIMARY KEY (a,b),
  FOREIGN KEY (a) REFERENCES p(p),
  FOREIGN KEY (b,c) REFERENCES pq(p,q) MATCH FULL
)
----

build
UPSERT INTO cmulti SELECT x,y,z,w FROM xyzw
----
upsert cmulti
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── x:6 => cmulti.a:1
 │    ├── y:7 => cmulti.b:2
 │    ├── z:8 => cmulti.c:3
 │    └── w:9 => d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: x:6 y:7 z:8 w:9
 │    └── scan xyzw
 │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 └── f-k-checks
      ├── f-k-checks-item: cmulti(a) -> p(p)
      │    └── anti-join (hash)
      │         ├── columns: a:12
      │         ├── with-scan &1
      │         │    ├── columns: a:12
      │         │    └── mapping:
      │         │         └──  x:6 => a:12
      │         ├── scan p
      │         │    └── columns: p.p:13!null
      │         └── filters
      │              └── a:12 = p.p:13
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: b:16 c:17
                ├── with-scan &1
                │    ├── columns: b:16 c:17
                │    └── mapping:
                │         ├──  y:7 => b:16
                │         └──  z:8 => c:17
                ├── scan pq
                │    └── columns: pq.p:19 q:20
                └── filters
                     ├── b:16 = pq.p:19
                     └── c:17 = q:20

build
UPSERT INTO cmulti(a,b,c) SELECT x,y,z FROM xyzw
----
upsert cmulti
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: cmulti.a:13
 ├── fetch columns: cmulti.a:13 cmulti.b:14 cmulti.c:15 cmulti.d:16
 ├── insert-mapping:
 │    ├── x:6 => cmulti.a:1
 │    ├── y:7 => cmulti.b:2
 │    ├── z:8 => cmulti.c:3
 │    └── d:12 => cmulti.d:4
 ├── update-mapping:
 │    └── z:8 => cmulti.c:3
 ├── input binding: &1
 ├── project
 │    ├── columns: a:18 b:19 d:20 x:6 y:7 z:8 d:12!null cmulti.a:13 cmulti.b:14 cmulti.c:15 cmulti.d:16 cmulti.crdb_internal_mvcc_timestamp:17
 │    ├── left-join (hash)
 │    │    ├── columns: x:6 y:7 z:8 d:12!null cmulti.a:13 cmulti.b:14 cmulti.c:15 cmulti.d:16 cmulti.crdb_internal_mvcc_timestamp:17
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: x:6 y:7 z:8 d:12!null
 │    │    │    ├── grouping columns: x:6 y:7
 │    │    │    ├── project
 │    │    │    │    ├── columns: d:12!null x:6 y:7 z:8
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: x:6 y:7 z:8
 │    │    │    │    │    └── scan xyzw
 │    │    │    │    │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 │    │    │    │    └── projections
 │    │    │    │         └── 8 [as=d:12]
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=z:8]
 │    │    │         │    └── z:8
 │    │    │         └── first-agg [as=d:12]
 │    │    │              └── d:12
 │    │    ├── scan cmulti
 │    │    │    └── columns: cmulti.a:13!null cmulti.b:14!null cmulti.c:15 cmulti.d:16 cmulti.crdb_internal_mvcc_timestamp:17
 │    │    └── filters
 │    │         ├── x:6 = cmulti.a:13
 │    │         └── y:7 = cmulti.b:14
 │    └── projections
 │         ├── CASE WHEN cmulti.a:13 IS NULL THEN x:6 ELSE cmulti.a:13 END [as=a:18]
 │         ├── CASE WHEN cmulti.a:13 IS NULL THEN y:7 ELSE cmulti.b:14 END [as=b:19]
 │         └── CASE WHEN cmulti.a:13 IS NULL THEN d:12 ELSE cmulti.d:16 END [as=d:20]
 └── f-k-checks
      ├── f-k-checks-item: cmulti(a) -> p(p)
      │    └── anti-join (hash)
      │         ├── columns: a:21
      │         ├── with-scan &1
      │         │    ├── columns: a:21
      │         │    └── mapping:
      │         │         └──  a:18 => a:21
      │         ├── scan p
      │         │    └── columns: p.p:22!null
      │         └── filters
      │              └── a:21 = p.p:22
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── anti-join (hash)
                ├── columns: b:25 c:26
                ├── with-scan &1
                │    ├── columns: b:25 c:26
                │    └── mapping:
                │         ├──  b:19 => b:25
                │         └──  z:8 => c:26
                ├── scan pq
                │    └── columns: pq.p:28 q:29
                └── filters
                     ├── b:25 = pq.p:28
                     └── c:26 = q:29

# ---------------------------------------
# Inbound FK tests with single FK column
# ---------------------------------------

# No need to check inbound FKs since PK values never get removed by an upsert.
build
UPSERT INTO p VALUES (1, 1), (2, 2)
----
upsert p
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├── column1:4 => p:1
 │    └── column2:5 => other:2
 └── values
      ├── columns: column1:4!null column2:5!null
      ├── (1, 1)
      └── (2, 2)

exec-ddl
CREATE TABLE p1 (p INT PRIMARY KEY, other INT, INDEX(other))
----

exec-ddl
CREATE TABLE p1c (c INT PRIMARY KEY, p INT NOT NULL DEFAULT 5 REFERENCES p1(p))
----

# No need to check inbound FKs since PK values never get removed by an upsert.
build
UPSERT INTO p1 VALUES (1, 1), (2, 2)
----
upsert p1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p1.p:6
 ├── fetch columns: p1.p:6 other:7
 ├── insert-mapping:
 │    ├── column1:4 => p1.p:1
 │    └── column2:5 => other:2
 ├── update-mapping:
 │    └── column2:5 => other:2
 └── project
      ├── columns: p:9 column1:4!null column2:5!null p1.p:6 other:7 crdb_internal_mvcc_timestamp:8
      ├── left-join (hash)
      │    ├── columns: column1:4!null column2:5!null p1.p:6 other:7 crdb_internal_mvcc_timestamp:8
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: column1:4!null column2:5!null
      │    │    ├── grouping columns: column1:4!null
      │    │    ├── values
      │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    ├── (1, 1)
      │    │    │    └── (2, 2)
      │    │    └── aggregations
      │    │         └── first-agg [as=column2:5]
      │    │              └── column2:5
      │    ├── scan p1
      │    │    └── columns: p1.p:6!null other:7 crdb_internal_mvcc_timestamp:8
      │    └── filters
      │         └── column1:4 = p1.p:6
      └── projections
           └── CASE WHEN p1.p:6 IS NULL THEN column1:4 ELSE p1.p:6 END [as=p:9]

# This statement can modify existing values of p so we need to perform the FK
# check.
build
INSERT INTO p1 VALUES (100, 1), (200, 1) ON CONFLICT (p) DO UPDATE SET p = excluded.p + 1
----
upsert p1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p1.p:6
 ├── fetch columns: p1.p:6 p1.other:7
 ├── insert-mapping:
 │    ├── column1:4 => p1.p:1
 │    └── column2:5 => p1.other:2
 ├── update-mapping:
 │    └── p:10 => p1.p:1
 ├── input binding: &1
 ├── project
 │    ├── columns: p:10!null other:11 column1:4!null column2:5!null p1.p:6 p1.other:7 p1.crdb_internal_mvcc_timestamp:8 p:9!null
 │    ├── project
 │    │    ├── columns: p:9!null column1:4!null column2:5!null p1.p:6 p1.other:7 p1.crdb_internal_mvcc_timestamp:8
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:4!null column2:5!null p1.p:6 p1.other:7 p1.crdb_internal_mvcc_timestamp:8
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    ├── grouping columns: column1:4!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    │    ├── (100, 1)
 │    │    │    │    │    └── (200, 1)
 │    │    │    │    └── aggregations
 │    │    │    │         └── first-agg [as=column2:5]
 │    │    │    │              └── column2:5
 │    │    │    ├── scan p1
 │    │    │    │    └── columns: p1.p:6!null p1.other:7 p1.crdb_internal_mvcc_timestamp:8
 │    │    │    └── filters
 │    │    │         └── column1:4 = p1.p:6
 │    │    └── projections
 │    │         └── column1:4 + 1 [as=p:9]
 │    └── projections
 │         ├── CASE WHEN p1.p:6 IS NULL THEN column1:4 ELSE p:9 END [as=p:10]
 │         └── CASE WHEN p1.p:6 IS NULL THEN column2:5 ELSE p1.other:7 END [as=other:11]
 └── f-k-checks
      └── f-k-checks-item: p1c(p) -> p1(p)
           └── semi-join (hash)
                ├── columns: p:12
                ├── except
                │    ├── columns: p:12
                │    ├── left columns: p:12
                │    ├── right columns: p:13
                │    ├── with-scan &1
                │    │    ├── columns: p:12
                │    │    └── mapping:
                │    │         └──  p1.p:6 => p:12
                │    └── with-scan &1
                │         ├── columns: p:13!null
                │         └── mapping:
                │              └──  p:10 => p:13
                ├── scan p1c
                │    └── columns: p1c.p:15!null
                └── filters
                     └── p:12 = p1c.p:15

# No need to check the inbound FK: we never modify existing values of p.
build
INSERT INTO p1 VALUES (100, 1), (200, 1) ON CONFLICT (p) DO UPDATE SET other = p1.other + 1
----
upsert p1
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p1.p:6
 ├── fetch columns: p1.p:6 p1.other:7
 ├── insert-mapping:
 │    ├── column1:4 => p1.p:1
 │    └── column2:5 => p1.other:2
 ├── update-mapping:
 │    └── other:11 => p1.other:2
 └── project
      ├── columns: p:10 other:11 column1:4!null column2:5!null p1.p:6 p1.other:7 crdb_internal_mvcc_timestamp:8 other:9
      ├── project
      │    ├── columns: other:9 column1:4!null column2:5!null p1.p:6 p1.other:7 crdb_internal_mvcc_timestamp:8
      │    ├── left-join (hash)
      │    │    ├── columns: column1:4!null column2:5!null p1.p:6 p1.other:7 crdb_internal_mvcc_timestamp:8
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    ├── grouping columns: column1:4!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    │    ├── (100, 1)
      │    │    │    │    └── (200, 1)
      │    │    │    └── aggregations
      │    │    │         └── first-agg [as=column2:5]
      │    │    │              └── column2:5
      │    │    ├── scan p1
      │    │    │    └── columns: p1.p:6!null p1.other:7 crdb_internal_mvcc_timestamp:8
      │    │    └── filters
      │    │         └── column1:4 = p1.p:6
      │    └── projections
      │         └── p1.other:7 + 1 [as=other:9]
      └── projections
           ├── CASE WHEN p1.p:6 IS NULL THEN column1:4 ELSE p1.p:6 END [as=p:10]
           └── CASE WHEN p1.p:6 IS NULL THEN column2:5 ELSE other:9 END [as=other:11]

# Similar tests when the FK column is not the PK.
exec-ddl
CREATE TABLE p2 (p INT PRIMARY KEY, fk INT UNIQUE)
----

exec-ddl
CREATE TABLE p2c (c INT PRIMARY KEY, fk INT REFERENCES p2(fk))
----

build
UPSERT INTO p2 VALUES (1, 1), (2, 2)
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── column2:5 => p2.fk:2
 ├── update-mapping:
 │    └── column2:5 => p2.fk:2
 ├── input binding: &1
 ├── project
 │    ├── columns: p:9 column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    ├── left-join (hash)
 │    │    ├── columns: column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    ├── grouping columns: column1:4!null
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    ├── (1, 1)
 │    │    │    │    └── (2, 2)
 │    │    │    └── aggregations
 │    │    │         └── first-agg [as=column2:5]
 │    │    │              └── column2:5
 │    │    ├── scan p2
 │    │    │    └── columns: p2.p:6!null p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    └── filters
 │    │         └── column1:4 = p2.p:6
 │    └── projections
 │         └── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p2.p:6 END [as=p:9]
 └── f-k-checks
      └── f-k-checks-item: p2c(fk) -> p2(fk)
           └── semi-join (hash)
                ├── columns: fk:10
                ├── except
                │    ├── columns: fk:10
                │    ├── left columns: fk:10
                │    ├── right columns: fk:11
                │    ├── with-scan &1
                │    │    ├── columns: fk:10
                │    │    └── mapping:
                │    │         └──  p2.fk:7 => fk:10
                │    └── with-scan &1
                │         ├── columns: fk:11!null
                │         └── mapping:
                │              └──  column2:5 => fk:11
                ├── scan p2c
                │    └── columns: p2c.fk:13
                └── filters
                     └── fk:10 = p2c.fk:13

# This statement never removes existing values of the fk column; FK check is
# not needed.
build
INSERT INTO p2 VALUES (1, 1), (2, 2) ON CONFLICT (p) DO UPDATE SET p = excluded.p + 1
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── column2:5 => p2.fk:2
 ├── update-mapping:
 │    └── p:10 => p2.p:1
 └── project
      ├── columns: p:10!null fk:11 column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8 p:9!null
      ├── project
      │    ├── columns: p:9!null column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    ├── left-join (hash)
      │    │    ├── columns: column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    ├── grouping columns: column1:4!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    │    ├── (1, 1)
      │    │    │    │    └── (2, 2)
      │    │    │    └── aggregations
      │    │    │         └── first-agg [as=column2:5]
      │    │    │              └── column2:5
      │    │    ├── scan p2
      │    │    │    └── columns: p2.p:6!null p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    │    └── filters
      │    │         └── column1:4 = p2.p:6
      │    └── projections
      │         └── column1:4 + 1 [as=p:9]
      └── projections
           ├── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p:9 END [as=p:10]
           └── CASE WHEN p2.p:6 IS NULL THEN column2:5 ELSE p2.fk:7 END [as=fk:11]

# This statement can change existing values of the fk column, so the FK check
# is needed.
build
INSERT INTO p2 VALUES (1, 1), (2, 2) ON CONFLICT (p) DO UPDATE SET fk = excluded.fk + 1
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── column2:5 => p2.fk:2
 ├── update-mapping:
 │    └── fk:11 => p2.fk:2
 ├── input binding: &1
 ├── project
 │    ├── columns: p:10 fk:11!null column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8 fk:9!null
 │    ├── project
 │    │    ├── columns: fk:9!null column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    ├── grouping columns: column1:4!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    │    ├── (1, 1)
 │    │    │    │    │    └── (2, 2)
 │    │    │    │    └── aggregations
 │    │    │    │         └── first-agg [as=column2:5]
 │    │    │    │              └── column2:5
 │    │    │    ├── scan p2
 │    │    │    │    └── columns: p2.p:6!null p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    │    └── filters
 │    │    │         └── column1:4 = p2.p:6
 │    │    └── projections
 │    │         └── column2:5 + 1 [as=fk:9]
 │    └── projections
 │         ├── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p2.p:6 END [as=p:10]
 │         └── CASE WHEN p2.p:6 IS NULL THEN column2:5 ELSE fk:9 END [as=fk:11]
 └── f-k-checks
      └── f-k-checks-item: p2c(fk) -> p2(fk)
           └── semi-join (hash)
                ├── columns: fk:12
                ├── except
                │    ├── columns: fk:12
                │    ├── left columns: fk:12
                │    ├── right columns: fk:13
                │    ├── with-scan &1
                │    │    ├── columns: fk:12
                │    │    └── mapping:
                │    │         └──  p2.fk:7 => fk:12
                │    └── with-scan &1
                │         ├── columns: fk:13!null
                │         └── mapping:
                │              └──  fk:11 => fk:13
                ├── scan p2c
                │    └── columns: p2c.fk:15
                └── filters
                     └── fk:12 = p2c.fk:15

# This statement never removes existing values of the fk column; the FK check is
# not needed.
build
INSERT INTO p2 VALUES (1, 1), (2, 2) ON CONFLICT (fk) DO UPDATE SET p = excluded.p + 1
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: p2_fk_key
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── column2:5 => p2.fk:2
 ├── update-mapping:
 │    └── p:10 => p2.p:1
 └── project
      ├── columns: p:10!null fk:11 column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8 p:9!null
      ├── project
      │    ├── columns: p:9!null column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    ├── left-join (hash)
      │    │    ├── columns: column1:4!null column2:5!null p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    ├── grouping columns: column2:5!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    │    ├── (1, 1)
      │    │    │    │    └── (2, 2)
      │    │    │    └── aggregations
      │    │    │         └── first-agg [as=column1:4]
      │    │    │              └── column1:4
      │    │    ├── scan p2
      │    │    │    └── columns: p2.p:6!null p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    │    └── filters
      │    │         └── column2:5 = p2.fk:7
      │    └── projections
      │         └── column1:4 + 1 [as=p:9]
      └── projections
           ├── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p:9 END [as=p:10]
           └── CASE WHEN p2.p:6 IS NULL THEN column2:5 ELSE p2.fk:7 END [as=fk:11]

build
INSERT INTO p2 VALUES (1, 1), (2, 2) ON CONFLICT (fk) DO UPDATE SET fk = excluded.fk + 1
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: p2_fk_key
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── column2:5 => p2.fk:2
 ├── update-mapping:
 │    └── fk:11 => p2.fk:2
 ├── input binding: &1
 ├── project
 │    ├── columns: p:10 fk:11!null column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8 fk:9!null
 │    ├── project
 │    │    ├── columns: fk:9!null column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:4!null column2:5!null p2.p:6 p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    ├── grouping columns: column2:5!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:4!null column2:5!null
 │    │    │    │    │    ├── (1, 1)
 │    │    │    │    │    └── (2, 2)
 │    │    │    │    └── aggregations
 │    │    │    │         └── first-agg [as=column1:4]
 │    │    │    │              └── column1:4
 │    │    │    ├── scan p2
 │    │    │    │    └── columns: p2.p:6!null p2.fk:7 p2.crdb_internal_mvcc_timestamp:8
 │    │    │    └── filters
 │    │    │         └── column2:5 = p2.fk:7
 │    │    └── projections
 │    │         └── column2:5 + 1 [as=fk:9]
 │    └── projections
 │         ├── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p2.p:6 END [as=p:10]
 │         └── CASE WHEN p2.p:6 IS NULL THEN column2:5 ELSE fk:9 END [as=fk:11]
 └── f-k-checks
      └── f-k-checks-item: p2c(fk) -> p2(fk)
           └── semi-join (hash)
                ├── columns: fk:12
                ├── except
                │    ├── columns: fk:12
                │    ├── left columns: fk:12
                │    ├── right columns: fk:13
                │    ├── with-scan &1
                │    │    ├── columns: fk:12
                │    │    └── mapping:
                │    │         └──  p2.fk:7 => fk:12
                │    └── with-scan &1
                │         ├── columns: fk:13!null
                │         └── mapping:
                │              └──  fk:11 => fk:13
                ├── scan p2c
                │    └── columns: p2c.fk:15
                └── filters
                     └── fk:12 = p2c.fk:15

# This partial upsert never removes existing values of the fk column; the FK
# check is not needed.
build
UPSERT INTO p2(p) VALUES (1), (2)
----
upsert p2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: p2.p:6
 ├── fetch columns: p2.p:6 p2.fk:7
 ├── insert-mapping:
 │    ├── column1:4 => p2.p:1
 │    └── fk:5 => p2.fk:2
 └── project
      ├── columns: p:9 fk:10 column1:4!null fk:5 p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      ├── left-join (hash)
      │    ├── columns: column1:4!null fk:5 p2.p:6 p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: column1:4!null fk:5
      │    │    ├── grouping columns: column1:4!null
      │    │    ├── project
      │    │    │    ├── columns: fk:5 column1:4!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:4!null
      │    │    │    │    ├── (1,)
      │    │    │    │    └── (2,)
      │    │    │    └── projections
      │    │    │         └── NULL::INT8 [as=fk:5]
      │    │    └── aggregations
      │    │         └── first-agg [as=fk:5]
      │    │              └── fk:5
      │    ├── scan p2
      │    │    └── columns: p2.p:6!null p2.fk:7 crdb_internal_mvcc_timestamp:8
      │    └── filters
      │         └── column1:4 = p2.p:6
      └── projections
           ├── CASE WHEN p2.p:6 IS NULL THEN column1:4 ELSE p2.p:6 END [as=p:9]
           └── CASE WHEN p2.p:6 IS NULL THEN fk:5 ELSE p2.fk:7 END [as=fk:10]

# ------------------------------------------
# Inbound FK tests with multiple FK columns
# ------------------------------------------

build
UPSERT INTO pq VALUES (1, 1, 1, 1), (2, 2, 2, 2)
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: pq.k:10
 ├── fetch columns: pq.k:10 pq.p:11 pq.q:12 pq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── update-mapping:
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── input binding: &1
 ├── project
 │    ├── columns: k:15 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    ├── left-join (hash)
 │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    ├── grouping columns: column1:6!null
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    │    ├── (1, 1, 1, 1)
 │    │    │    │    └── (2, 2, 2, 2)
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=column2:7]
 │    │    │         │    └── column2:7
 │    │    │         ├── first-agg [as=column3:8]
 │    │    │         │    └── column3:8
 │    │    │         └── first-agg [as=column4:9]
 │    │    │              └── column4:9
 │    │    ├── scan pq
 │    │    │    └── columns: pq.k:10!null pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    └── filters
 │    │         └── column1:6 = pq.k:10
 │    └── projections
 │         └── CASE WHEN pq.k:10 IS NULL THEN column1:6 ELSE pq.k:10 END [as=k:15]
 └── f-k-checks
      ├── f-k-checks-item: cpq(p,q) -> pq(p,q)
      │    └── semi-join (hash)
      │         ├── columns: p:16 q:17
      │         ├── except
      │         │    ├── columns: p:16 q:17
      │         │    ├── left columns: p:16 q:17
      │         │    ├── right columns: p:18 q:19
      │         │    ├── with-scan &1
      │         │    │    ├── columns: p:16 q:17
      │         │    │    └── mapping:
      │         │    │         ├──  pq.p:11 => p:16
      │         │    │         └──  pq.q:12 => q:17
      │         │    └── with-scan &1
      │         │         ├── columns: p:18!null q:19!null
      │         │         └── mapping:
      │         │              ├──  column2:7 => p:18
      │         │              └──  column3:8 => q:19
      │         ├── scan cpq
      │         │    └── columns: cpq.p:21 cpq.q:22
      │         └── filters
      │              ├── p:16 = cpq.p:21
      │              └── q:17 = cpq.q:22
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── semi-join (hash)
                ├── columns: p:25 q:26
                ├── except
                │    ├── columns: p:25 q:26
                │    ├── left columns: p:25 q:26
                │    ├── right columns: p:27 q:28
                │    ├── with-scan &1
                │    │    ├── columns: p:25 q:26
                │    │    └── mapping:
                │    │         ├──  pq.p:11 => p:25
                │    │         └──  pq.q:12 => q:26
                │    └── with-scan &1
                │         ├── columns: p:27!null q:28!null
                │         └── mapping:
                │              ├──  column2:7 => p:27
                │              └──  column3:8 => q:28
                ├── scan cmulti
                │    └── columns: b:30!null cmulti.c:31
                └── filters
                     ├── p:25 = b:30
                     └── q:26 = cmulti.c:31

# Partial UPSERT doesn't remove (p,q) values; FK check not needed.
build
UPSERT INTO pq (k) VALUES (1), (2)
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: pq.k:8
 ├── fetch columns: pq.k:8 pq.p:9 pq.q:10 pq.other:11
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── p:7 => pq.p:2
 │    ├── p:7 => pq.q:3
 │    └── p:7 => pq.other:4
 └── project
      ├── columns: k:13 p:14 q:15 other:16 column1:6!null p:7 pq.k:8 pq.p:9 pq.q:10 pq.other:11 crdb_internal_mvcc_timestamp:12
      ├── left-join (hash)
      │    ├── columns: column1:6!null p:7 pq.k:8 pq.p:9 pq.q:10 pq.other:11 crdb_internal_mvcc_timestamp:12
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: column1:6!null p:7
      │    │    ├── grouping columns: column1:6!null
      │    │    ├── project
      │    │    │    ├── columns: p:7 column1:6!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:6!null
      │    │    │    │    ├── (1,)
      │    │    │    │    └── (2,)
      │    │    │    └── projections
      │    │    │         └── NULL::INT8 [as=p:7]
      │    │    └── aggregations
      │    │         └── first-agg [as=p:7]
      │    │              └── p:7
      │    ├── scan pq
      │    │    └── columns: pq.k:8!null pq.p:9 pq.q:10 pq.other:11 crdb_internal_mvcc_timestamp:12
      │    └── filters
      │         └── column1:6 = pq.k:8
      └── projections
           ├── CASE WHEN pq.k:8 IS NULL THEN column1:6 ELSE pq.k:8 END [as=k:13]
           ├── CASE WHEN pq.k:8 IS NULL THEN p:7 ELSE pq.p:9 END [as=p:14]
           ├── CASE WHEN pq.k:8 IS NULL THEN p:7 ELSE pq.q:10 END [as=q:15]
           └── CASE WHEN pq.k:8 IS NULL THEN p:7 ELSE pq.other:11 END [as=other:16]

build
UPSERT INTO pq (k,q) VALUES (1, 1), (2, 2)
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: pq.k:9
 ├── fetch columns: pq.k:9 pq.p:10 pq.q:11 pq.other:12
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── p:8 => pq.p:2
 │    ├── column2:7 => pq.q:3
 │    └── p:8 => pq.other:4
 ├── update-mapping:
 │    └── column2:7 => pq.q:3
 ├── input binding: &1
 ├── project
 │    ├── columns: k:14 p:15 other:16 column1:6!null column2:7!null p:8 pq.k:9 pq.p:10 pq.q:11 pq.other:12 pq.crdb_internal_mvcc_timestamp:13
 │    ├── left-join (hash)
 │    │    ├── columns: column1:6!null column2:7!null p:8 pq.k:9 pq.p:10 pq.q:11 pq.other:12 pq.crdb_internal_mvcc_timestamp:13
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:6!null column2:7!null p:8
 │    │    │    ├── grouping columns: column1:6!null
 │    │    │    ├── project
 │    │    │    │    ├── columns: p:8 column1:6!null column2:7!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:6!null column2:7!null
 │    │    │    │    │    ├── (1, 1)
 │    │    │    │    │    └── (2, 2)
 │    │    │    │    └── projections
 │    │    │    │         └── NULL::INT8 [as=p:8]
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=column2:7]
 │    │    │         │    └── column2:7
 │    │    │         └── first-agg [as=p:8]
 │    │    │              └── p:8
 │    │    ├── scan pq
 │    │    │    └── columns: pq.k:9!null pq.p:10 pq.q:11 pq.other:12 pq.crdb_internal_mvcc_timestamp:13
 │    │    └── filters
 │    │         └── column1:6 = pq.k:9
 │    └── projections
 │         ├── CASE WHEN pq.k:9 IS NULL THEN column1:6 ELSE pq.k:9 END [as=k:14]
 │         ├── CASE WHEN pq.k:9 IS NULL THEN p:8 ELSE pq.p:10 END [as=p:15]
 │         └── CASE WHEN pq.k:9 IS NULL THEN p:8 ELSE pq.other:12 END [as=other:16]
 └── f-k-checks
      ├── f-k-checks-item: cpq(p,q) -> pq(p,q)
      │    └── semi-join (hash)
      │         ├── columns: p:17 q:18
      │         ├── except
      │         │    ├── columns: p:17 q:18
      │         │    ├── left columns: p:17 q:18
      │         │    ├── right columns: p:19 q:20
      │         │    ├── with-scan &1
      │         │    │    ├── columns: p:17 q:18
      │         │    │    └── mapping:
      │         │    │         ├──  pq.p:10 => p:17
      │         │    │         └──  pq.q:11 => q:18
      │         │    └── with-scan &1
      │         │         ├── columns: p:19 q:20!null
      │         │         └── mapping:
      │         │              ├──  p:15 => p:19
      │         │              └──  column2:7 => q:20
      │         ├── scan cpq
      │         │    └── columns: cpq.p:22 cpq.q:23
      │         └── filters
      │              ├── p:17 = cpq.p:22
      │              └── q:18 = cpq.q:23
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── semi-join (hash)
                ├── columns: p:26 q:27
                ├── except
                │    ├── columns: p:26 q:27
                │    ├── left columns: p:26 q:27
                │    ├── right columns: p:28 q:29
                │    ├── with-scan &1
                │    │    ├── columns: p:26 q:27
                │    │    └── mapping:
                │    │         ├──  pq.p:10 => p:26
                │    │         └──  pq.q:11 => q:27
                │    └── with-scan &1
                │         ├── columns: p:28 q:29!null
                │         └── mapping:
                │              ├──  p:15 => p:28
                │              └──  column2:7 => q:29
                ├── scan cmulti
                │    └── columns: b:31!null cmulti.c:32
                └── filters
                     ├── p:26 = b:31
                     └── q:27 = cmulti.c:32

# Statement doesn't remove (p,q) values; FK check not needed.
build
INSERT INTO pq VALUES (1, 1, 1, 1), (2, 2, 2, 2) ON CONFLICT (p,q) DO UPDATE SET k = pq.k + 1
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: pq.k:10
 ├── fetch columns: pq.k:10 pq.p:11 pq.q:12 pq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── update-mapping:
 │    └── k:16 => pq.k:1
 └── project
      ├── columns: k:16 p:17 q:18 other:19 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14 k:15
      ├── project
      │    ├── columns: k:15 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    ├── left-join (hash)
      │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
      │    │    │    ├── grouping columns: column2:7!null column3:8!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
      │    │    │    │    ├── (1, 1, 1, 1)
      │    │    │    │    └── (2, 2, 2, 2)
      │    │    │    └── aggregations
      │    │    │         ├── first-agg [as=column1:6]
      │    │    │         │    └── column1:6
      │    │    │         └── first-agg [as=column4:9]
      │    │    │              └── column4:9
      │    │    ├── scan pq
      │    │    │    └── columns: pq.k:10!null pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    │    └── filters
      │    │         ├── column2:7 = pq.p:11
      │    │         └── column3:8 = pq.q:12
      │    └── projections
      │         └── pq.k:10 + 1 [as=k:15]
      └── projections
           ├── CASE WHEN pq.k:10 IS NULL THEN column1:6 ELSE k:15 END [as=k:16]
           ├── CASE WHEN pq.k:10 IS NULL THEN column2:7 ELSE pq.p:11 END [as=p:17]
           ├── CASE WHEN pq.k:10 IS NULL THEN column3:8 ELSE pq.q:12 END [as=q:18]
           └── CASE WHEN pq.k:10 IS NULL THEN column4:9 ELSE pq.other:13 END [as=other:19]

build
INSERT INTO pq VALUES (1, 1, 1, 1), (2, 2, 2, 2) ON CONFLICT (p,q) DO UPDATE SET p = pq.p + 1
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: pq.k:10
 ├── fetch columns: pq.k:10 pq.p:11 pq.q:12 pq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── update-mapping:
 │    └── p:17 => pq.p:2
 ├── input binding: &1
 ├── project
 │    ├── columns: k:16 p:17 q:18 other:19 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14 p:15
 │    ├── project
 │    │    ├── columns: p:15 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    │    ├── grouping columns: column2:7!null column3:8!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    │    │    ├── (1, 1, 1, 1)
 │    │    │    │    │    └── (2, 2, 2, 2)
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=column1:6]
 │    │    │    │         │    └── column1:6
 │    │    │    │         └── first-agg [as=column4:9]
 │    │    │    │              └── column4:9
 │    │    │    ├── scan pq
 │    │    │    │    └── columns: pq.k:10!null pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    │    └── filters
 │    │    │         ├── column2:7 = pq.p:11
 │    │    │         └── column3:8 = pq.q:12
 │    │    └── projections
 │    │         └── pq.p:11 + 1 [as=p:15]
 │    └── projections
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column1:6 ELSE pq.k:10 END [as=k:16]
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column2:7 ELSE p:15 END [as=p:17]
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column3:8 ELSE pq.q:12 END [as=q:18]
 │         └── CASE WHEN pq.k:10 IS NULL THEN column4:9 ELSE pq.other:13 END [as=other:19]
 └── f-k-checks
      ├── f-k-checks-item: cpq(p,q) -> pq(p,q)
      │    └── semi-join (hash)
      │         ├── columns: p:20 q:21
      │         ├── except
      │         │    ├── columns: p:20 q:21
      │         │    ├── left columns: p:20 q:21
      │         │    ├── right columns: p:22 q:23
      │         │    ├── with-scan &1
      │         │    │    ├── columns: p:20 q:21
      │         │    │    └── mapping:
      │         │    │         ├──  pq.p:11 => p:20
      │         │    │         └──  pq.q:12 => q:21
      │         │    └── with-scan &1
      │         │         ├── columns: p:22 q:23
      │         │         └── mapping:
      │         │              ├──  p:17 => p:22
      │         │              └──  q:18 => q:23
      │         ├── scan cpq
      │         │    └── columns: cpq.p:25 cpq.q:26
      │         └── filters
      │              ├── p:20 = cpq.p:25
      │              └── q:21 = cpq.q:26
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── semi-join (hash)
                ├── columns: p:29 q:30
                ├── except
                │    ├── columns: p:29 q:30
                │    ├── left columns: p:29 q:30
                │    ├── right columns: p:31 q:32
                │    ├── with-scan &1
                │    │    ├── columns: p:29 q:30
                │    │    └── mapping:
                │    │         ├──  pq.p:11 => p:29
                │    │         └──  pq.q:12 => q:30
                │    └── with-scan &1
                │         ├── columns: p:31 q:32
                │         └── mapping:
                │              ├──  p:17 => p:31
                │              └──  q:18 => q:32
                ├── scan cmulti
                │    └── columns: b:34!null cmulti.c:35
                └── filters
                     ├── p:29 = b:34
                     └── q:30 = cmulti.c:35

# Statement never removes (p,q) values; FK check not needed.
build
INSERT INTO pq VALUES (1, 1, 1, 1), (2, 2, 2, 2) ON CONFLICT (k) DO UPDATE SET other = 5
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: pq.k:10
 ├── fetch columns: pq.k:10 pq.p:11 pq.q:12 pq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── update-mapping:
 │    └── other:19 => pq.other:4
 └── project
      ├── columns: k:16 p:17 q:18 other:19!null column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14 other:15!null
      ├── project
      │    ├── columns: other:15!null column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    ├── left-join (hash)
      │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
      │    │    │    ├── grouping columns: column1:6!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
      │    │    │    │    ├── (1, 1, 1, 1)
      │    │    │    │    └── (2, 2, 2, 2)
      │    │    │    └── aggregations
      │    │    │         ├── first-agg [as=column2:7]
      │    │    │         │    └── column2:7
      │    │    │         ├── first-agg [as=column3:8]
      │    │    │         │    └── column3:8
      │    │    │         └── first-agg [as=column4:9]
      │    │    │              └── column4:9
      │    │    ├── scan pq
      │    │    │    └── columns: pq.k:10!null pq.p:11 pq.q:12 pq.other:13 crdb_internal_mvcc_timestamp:14
      │    │    └── filters
      │    │         └── column1:6 = pq.k:10
      │    └── projections
      │         └── 5 [as=other:15]
      └── projections
           ├── CASE WHEN pq.k:10 IS NULL THEN column1:6 ELSE pq.k:10 END [as=k:16]
           ├── CASE WHEN pq.k:10 IS NULL THEN column2:7 ELSE pq.p:11 END [as=p:17]
           ├── CASE WHEN pq.k:10 IS NULL THEN column3:8 ELSE pq.q:12 END [as=q:18]
           └── CASE WHEN pq.k:10 IS NULL THEN column4:9 ELSE other:15 END [as=other:19]

build
INSERT INTO pq VALUES (1, 1, 1, 1), (2, 2, 2, 2) ON CONFLICT (k) DO UPDATE SET q = 5
----
upsert pq
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: pq.k:10
 ├── fetch columns: pq.k:10 pq.p:11 pq.q:12 pq.other:13
 ├── insert-mapping:
 │    ├── column1:6 => pq.k:1
 │    ├── column2:7 => pq.p:2
 │    ├── column3:8 => pq.q:3
 │    └── column4:9 => pq.other:4
 ├── update-mapping:
 │    └── q:18 => pq.q:3
 ├── input binding: &1
 ├── project
 │    ├── columns: k:16 p:17 q:18!null other:19 column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14 q:15!null
 │    ├── project
 │    │    ├── columns: q:15!null column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null pq.k:10 pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    │    ├── grouping columns: column1:6!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column4:9!null
 │    │    │    │    │    ├── (1, 1, 1, 1)
 │    │    │    │    │    └── (2, 2, 2, 2)
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=column2:7]
 │    │    │    │         │    └── column2:7
 │    │    │    │         ├── first-agg [as=column3:8]
 │    │    │    │         │    └── column3:8
 │    │    │    │         └── first-agg [as=column4:9]
 │    │    │    │              └── column4:9
 │    │    │    ├── scan pq
 │    │    │    │    └── columns: pq.k:10!null pq.p:11 pq.q:12 pq.other:13 pq.crdb_internal_mvcc_timestamp:14
 │    │    │    └── filters
 │    │    │         └── column1:6 = pq.k:10
 │    │    └── projections
 │    │         └── 5 [as=q:15]
 │    └── projections
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column1:6 ELSE pq.k:10 END [as=k:16]
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column2:7 ELSE pq.p:11 END [as=p:17]
 │         ├── CASE WHEN pq.k:10 IS NULL THEN column3:8 ELSE q:15 END [as=q:18]
 │         └── CASE WHEN pq.k:10 IS NULL THEN column4:9 ELSE pq.other:13 END [as=other:19]
 └── f-k-checks
      ├── f-k-checks-item: cpq(p,q) -> pq(p,q)
      │    └── semi-join (hash)
      │         ├── columns: p:20 q:21
      │         ├── except
      │         │    ├── columns: p:20 q:21
      │         │    ├── left columns: p:20 q:21
      │         │    ├── right columns: p:22 q:23
      │         │    ├── with-scan &1
      │         │    │    ├── columns: p:20 q:21
      │         │    │    └── mapping:
      │         │    │         ├──  pq.p:11 => p:20
      │         │    │         └──  pq.q:12 => q:21
      │         │    └── with-scan &1
      │         │         ├── columns: p:22 q:23!null
      │         │         └── mapping:
      │         │              ├──  p:17 => p:22
      │         │              └──  q:18 => q:23
      │         ├── scan cpq
      │         │    └── columns: cpq.p:25 cpq.q:26
      │         └── filters
      │              ├── p:20 = cpq.p:25
      │              └── q:21 = cpq.q:26
      └── f-k-checks-item: cmulti(b,c) -> pq(p,q)
           └── semi-join (hash)
                ├── columns: p:29 q:30
                ├── except
                │    ├── columns: p:29 q:30
                │    ├── left columns: p:29 q:30
                │    ├── right columns: p:31 q:32
                │    ├── with-scan &1
                │    │    ├── columns: p:29 q:30
                │    │    └── mapping:
                │    │         ├──  pq.p:11 => p:29
                │    │         └──  pq.q:12 => q:30
                │    └── with-scan &1
                │         ├── columns: p:31 q:32!null
                │         └── mapping:
                │              ├──  p:17 => p:31
                │              └──  q:18 => q:32
                ├── scan cmulti
                │    └── columns: b:34!null cmulti.c:35
                └── filters
                     ├── p:29 = b:34
                     └── q:30 = cmulti.c:35

# -------------------------------------
# Inbound + outbound combination tests
# -------------------------------------

exec-ddl
CREATE TABLE tab1 (
  a INT PRIMARY KEY,
  b INT UNIQUE
)
----

exec-ddl
CREATE TABLE tab2 (
  c INT PRIMARY KEY,
  d INT REFERENCES tab1(b),
  e INT UNIQUE
)
----

exec-ddl
CREATE TABLE tab3 (
  f INT PRIMARY KEY,
  g INT REFERENCES tab2(e)
)
----

build
UPSERT INTO tab2 VALUES (1,NULL,NULL), (2,2,2)
----
upsert tab2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: tab2.c:8
 ├── fetch columns: tab2.c:8 tab2.d:9 tab2.e:10
 ├── insert-mapping:
 │    ├── column1:5 => tab2.c:1
 │    ├── column2:6 => tab2.d:2
 │    └── column3:7 => tab2.e:3
 ├── update-mapping:
 │    ├── column2:6 => tab2.d:2
 │    └── column3:7 => tab2.e:3
 ├── input binding: &1
 ├── project
 │    ├── columns: c:12 column1:5!null column2:6 column3:7 tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    ├── left-join (hash)
 │    │    ├── columns: column1:5!null column2:6 column3:7 tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: column1:5!null column2:6 column3:7
 │    │    │    ├── grouping columns: column1:5!null
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:5!null column2:6 column3:7
 │    │    │    │    ├── (1, NULL::INT8, NULL::INT8)
 │    │    │    │    └── (2, 2, 2)
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=column2:6]
 │    │    │         │    └── column2:6
 │    │    │         └── first-agg [as=column3:7]
 │    │    │              └── column3:7
 │    │    ├── scan tab2
 │    │    │    └── columns: tab2.c:8!null tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    └── filters
 │    │         └── column1:5 = tab2.c:8
 │    └── projections
 │         └── CASE WHEN tab2.c:8 IS NULL THEN column1:5 ELSE tab2.c:8 END [as=c:12]
 └── f-k-checks
      ├── f-k-checks-item: tab2(d) -> tab1(b)
      │    └── anti-join (hash)
      │         ├── columns: d:13!null
      │         ├── select
      │         │    ├── columns: d:13!null
      │         │    ├── with-scan &1
      │         │    │    ├── columns: d:13
      │         │    │    └── mapping:
      │         │    │         └──  column2:6 => d:13
      │         │    └── filters
      │         │         └── d:13 IS NOT NULL
      │         ├── scan tab1
      │         │    └── columns: b:15
      │         └── filters
      │              └── d:13 = b:15
      └── f-k-checks-item: tab3(g) -> tab2(e)
           └── semi-join (hash)
                ├── columns: e:17
                ├── except
                │    ├── columns: e:17
                │    ├── left columns: e:17
                │    ├── right columns: e:18
                │    ├── with-scan &1
                │    │    ├── columns: e:17
                │    │    └── mapping:
                │    │         └──  tab2.e:10 => e:17
                │    └── with-scan &1
                │         ├── columns: e:18
                │         └── mapping:
                │              └──  column3:7 => e:18
                ├── scan tab3
                │    └── columns: g:20
                └── filters
                     └── e:17 = g:20

build
INSERT INTO tab2 VALUES (1,1,1) ON CONFLICT (c) DO UPDATE SET e = tab2.e + 1
----
upsert tab2
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: tab2.c:8
 ├── fetch columns: tab2.c:8 tab2.d:9 tab2.e:10
 ├── insert-mapping:
 │    ├── column1:5 => tab2.c:1
 │    ├── column2:6 => tab2.d:2
 │    └── column3:7 => tab2.e:3
 ├── update-mapping:
 │    └── e:15 => tab2.e:3
 ├── input binding: &1
 ├── project
 │    ├── columns: c:13 d:14 e:15 column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11 e:12
 │    ├── project
 │    │    ├── columns: e:12 column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │    │    │    │    ├── grouping columns: column1:5!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │    │    │    │    │    └── (1, 1, 1)
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=column2:6]
 │    │    │    │         │    └── column2:6
 │    │    │    │         └── first-agg [as=column3:7]
 │    │    │    │              └── column3:7
 │    │    │    ├── scan tab2
 │    │    │    │    └── columns: tab2.c:8!null tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    │    └── filters
 │    │    │         └── column1:5 = tab2.c:8
 │    │    └── projections
 │    │         └── tab2.e:10 + 1 [as=e:12]
 │    └── projections
 │         ├── CASE WHEN tab2.c:8 IS NULL THEN column1:5 ELSE tab2.c:8 END [as=c:13]
 │         ├── CASE WHEN tab2.c:8 IS NULL THEN column2:6 ELSE tab2.d:9 END [as=d:14]
 │         └── CASE WHEN tab2.c:8 IS NULL THEN column3:7 ELSE e:12 END [as=e:15]
 └── f-k-checks
      ├── f-k-checks-item: tab2(d) -> tab1(b)
      │    └── anti-join (hash)
      │         ├── columns: d:16!null
      │         ├── select
      │         │    ├── columns: d:16!null
      │         │    ├── with-scan &1
      │         │    │    ├── columns: d:16
      │         │    │    └── mapping:
      │         │    │         └──  d:14 => d:16
      │         │    └── filters
      │         │         └── d:16 IS NOT NULL
      │         ├── scan tab1
      │         │    └── columns: b:18
      │         └── filters
      │              └── d:16 = b:18
      └── f-k-checks-item: tab3(g) -> tab2(e)
           └── semi-join (hash)
                ├── columns: e:20
                ├── except
                │    ├── columns: e:20
                │    ├── left columns: e:20
                │    ├── right columns: e:21
                │    ├── with-scan &1
                │    │    ├── columns: e:20
                │    │    └── mapping:
                │    │         └──  tab2.e:10 => e:20
                │    └── with-scan &1
                │         ├── columns: e:21
                │         └── mapping:
                │              └──  e:15 => e:21
                ├── scan tab3
                │    └── columns: g:23
                └── filters
                     └── e:20 = g:23

# Statement never removes values from e column; the inbound check is not necessary.
build
INSERT INTO tab2 VALUES (1,1,1) ON CONFLICT (e) DO UPDATE SET d = tab2.d + 1
----
upsert tab2
 ├── columns: <none>
 ├── arbiter indexes: tab2_e_key
 ├── canary column: tab2.c:8
 ├── fetch columns: tab2.c:8 tab2.d:9 tab2.e:10
 ├── insert-mapping:
 │    ├── column1:5 => tab2.c:1
 │    ├── column2:6 => tab2.d:2
 │    └── column3:7 => tab2.e:3
 ├── update-mapping:
 │    └── d:14 => tab2.d:2
 ├── input binding: &1
 ├── project
 │    ├── columns: c:13 d:14 e:15 column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11 d:12
 │    ├── project
 │    │    ├── columns: d:12 column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null tab2.c:8 tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    │    ├── ensure-upsert-distinct-on
 │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │    │    │    │    ├── grouping columns: column3:7!null
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │    │    │    │    │    └── (1, 1, 1)
 │    │    │    │    └── aggregations
 │    │    │    │         ├── first-agg [as=column1:5]
 │    │    │    │         │    └── column1:5
 │    │    │    │         └── first-agg [as=column2:6]
 │    │    │    │              └── column2:6
 │    │    │    ├── scan tab2
 │    │    │    │    └── columns: tab2.c:8!null tab2.d:9 tab2.e:10 tab2.crdb_internal_mvcc_timestamp:11
 │    │    │    └── filters
 │    │    │         └── column3:7 = tab2.e:10
 │    │    └── projections
 │    │         └── tab2.d:9 + 1 [as=d:12]
 │    └── projections
 │         ├── CASE WHEN tab2.c:8 IS NULL THEN column1:5 ELSE tab2.c:8 END [as=c:13]
 │         ├── CASE WHEN tab2.c:8 IS NULL THEN column2:6 ELSE d:12 END [as=d:14]
 │         └── CASE WHEN tab2.c:8 IS NULL THEN column3:7 ELSE tab2.e:10 END [as=e:15]
 └── f-k-checks
      └── f-k-checks-item: tab2(d) -> tab1(b)
           └── anti-join (hash)
                ├── columns: d:16!null
                ├── select
                │    ├── columns: d:16!null
                │    ├── with-scan &1
                │    │    ├── columns: d:16
                │    │    └── mapping:
                │    │         └──  d:14 => d:16
                │    └── filters
                │         └── d:16 IS NOT NULL
                ├── scan tab1
                │    └── columns: b:18
                └── filters
                     └── d:16 = b:18

exec-ddl
CREATE TABLE self (
 a INT,
 b INT,
 c INT,
 d INT,
 PRIMARY KEY (a,b),
 UNIQUE (b,d),
 UNIQUE (c),
 FOREIGN KEY (a,b) REFERENCES self(b,d),
 FOREIGN KEY (d) REFERENCES self(c)
)
----

build
UPSERT INTO self SELECT x, y, z, w FROM xyzw
----
upsert self
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: self.a:12
 ├── fetch columns: self.a:12 self.b:13 self.c:14 self.d:15
 ├── insert-mapping:
 │    ├── x:6 => self.a:1
 │    ├── y:7 => self.b:2
 │    ├── z:8 => self.c:3
 │    └── w:9 => self.d:4
 ├── update-mapping:
 │    ├── z:8 => self.c:3
 │    └── w:9 => self.d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: a:17 b:18 x:6 y:7 z:8 w:9 self.a:12 self.b:13 self.c:14 self.d:15 self.crdb_internal_mvcc_timestamp:16
 │    ├── left-join (hash)
 │    │    ├── columns: x:6 y:7 z:8 w:9 self.a:12 self.b:13 self.c:14 self.d:15 self.crdb_internal_mvcc_timestamp:16
 │    │    ├── ensure-upsert-distinct-on
 │    │    │    ├── columns: x:6 y:7 z:8 w:9
 │    │    │    ├── grouping columns: x:6 y:7
 │    │    │    ├── project
 │    │    │    │    ├── columns: x:6 y:7 z:8 w:9
 │    │    │    │    └── scan xyzw
 │    │    │    │         └── columns: x:6 y:7 z:8 w:9 rowid:10!null xyzw.crdb_internal_mvcc_timestamp:11
 │    │    │    └── aggregations
 │    │    │         ├── first-agg [as=z:8]
 │    │    │         │    └── z:8
 │    │    │         └── first-agg [as=w:9]
 │    │    │              └── w:9
 │    │    ├── scan self
 │    │    │    └── columns: self.a:12!null self.b:13!null self.c:14 self.d:15 self.crdb_internal_mvcc_timestamp:16
 │    │    └── filters
 │    │         ├── x:6 = self.a:12
 │    │         └── y:7 = self.b:13
 │    └── projections
 │         ├── CASE WHEN self.a:12 IS NULL THEN x:6 ELSE self.a:12 END [as=a:17]
 │         └── CASE WHEN self.a:12 IS NULL THEN y:7 ELSE self.b:13 END [as=b:18]
 └── f-k-checks
      ├── f-k-checks-item: self(a,b) -> self(b,d)
      │    └── anti-join (hash)
      │         ├── columns: a:19 b:20
      │         ├── with-scan &1
      │         │    ├── columns: a:19 b:20
      │         │    └── mapping:
      │         │         ├──  a:17 => a:19
      │         │         └──  b:18 => b:20
      │         ├── scan self
      │         │    └── columns: self.b:22!null self.d:24
      │         └── filters
      │              ├── a:19 = self.b:22
      │              └── b:20 = self.d:24
      ├── f-k-checks-item: self(d) -> self(c)
      │    └── anti-join (hash)
      │         ├── columns: d:26!null
      │         ├── select
      │         │    ├── columns: d:26!null
      │         │    ├── with-scan &1
      │         │    │    ├── columns: d:26
      │         │    │    └── mapping:
      │         │    │         └──  w:9 => d:26
      │         │    └── filters
      │         │         └── d:26 IS NOT NULL
      │         ├── scan self
      │         │    └── columns: self.c:29
      │         └── filters
      │              └── d:26 = self.c:29
      ├── f-k-checks-item: self(a,b) -> self(b,d)
      │    └── semi-join (hash)
      │         ├── columns: b:32 d:33
      │         ├── except
      │         │    ├── columns: b:32 d:33
      │         │    ├── left columns: b:32 d:33
      │         │    ├── right columns: b:34 d:35
      │         │    ├── with-scan &1
      │         │    │    ├── columns: b:32 d:33
      │         │    │    └── mapping:
      │         │    │         ├──  self.b:13 => b:32
      │         │    │         └──  self.d:15 => d:33
      │         │    └── with-scan &1
      │         │         ├── columns: b:34 d:35
      │         │         └── mapping:
      │         │              ├──  b:18 => b:34
      │         │              └──  w:9 => d:35
      │         ├── scan self
      │         │    └── columns: self.a:36!null self.b:37!null
      │         └── filters
      │              ├── b:32 = self.a:36
      │              └── d:33 = self.b:37
      └── f-k-checks-item: self(d) -> self(c)
           └── semi-join (hash)
                ├── columns: c:41
                ├── except
                │    ├── columns: c:41
                │    ├── left columns: c:41
                │    ├── right columns: c:42
                │    ├── with-scan &1
                │    │    ├── columns: c:41
                │    │    └── mapping:
                │    │         └──  self.c:14 => c:41
                │    └── with-scan &1
                │         ├── columns: c:42
                │         └── mapping:
                │              └──  z:8 => c:42
                ├── scan self
                │    └── columns: self.d:46
                └── filters
                     └── c:41 = self.d:46
