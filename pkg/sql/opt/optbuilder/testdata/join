# LogicTest: default parallel-stmts distsql distsql-disk

# The join condition logic is tricky to get right with NULL
# values. Simple implementations can deal well with NULLs on the first
# or last row but fail to handle them in the middle. So the test table
# must contain at least 3 rows with a null in the middle. This test
# table also contains the pair 44/42 so that a test with a non-trivial
# ON condition can be written.
exec-ddl
CREATE TABLE onecolumn (x INT)
----
TABLE onecolumn
 ├── x int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM onecolumn AS a(x) CROSS JOIN onecolumn AS b(y)
----
project
 ├── columns: x:1(int) y:3(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

# Check that name resolution chokes on ambiguity when it needs to.
build
SELECT x FROM onecolumn AS a, onecolumn AS b
----
error: column reference "x" is ambiguous (candidates: a.x, b.x)

# Check that name resolution does not choke on ambiguity if an
# unqualified column name is requested and there is an anonymous
# source providing this name in addition to two or more named sources
# that also provide it.
build
SELECT x FROM (SELECT 1 AS x), onecolumn AS a, onecolumn AS b
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: x:1(int) onecolumn.x:2(int) onecolumn.rowid:3(int!null) onecolumn.x:4(int) onecolumn.rowid:5(int!null)
 │    ├── inner-join
 │    │    ├── columns: x:1(int) onecolumn.x:2(int) onecolumn.rowid:3(int!null)
 │    │    ├── project
 │    │    │    ├── columns: x:1(int)
 │    │    │    ├── values
 │    │    │    │    └── tuple [type=tuple{}]
 │    │    │    └── projections
 │    │    │         └── const: 1 [type=int]
 │    │    ├── scan
 │    │    │    └── columns: onecolumn.x:2(int) onecolumn.rowid:3(int!null)
 │    │    └── true [type=bool]
 │    ├── scan
 │    │    └── columns: onecolumn.x:4(int) onecolumn.rowid:5(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1)]
      └── variable: x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a(x) JOIN onecolumn AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a JOIN onecolumn as b USING(x) ORDER BY x
----
project
 ├── columns: x:1(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a NATURAL JOIN onecolumn as b
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a(x) LEFT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── left-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a LEFT OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
project
 ├── columns: x:1(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── ordering: +1
 │    └── left-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

# Check that ORDER BY chokes on ambiguity if no table less columns
# were introduced by USING. (#12239)
# TODO(rytaft): This is a bug. This query is invalid.
build
SELECT * FROM onecolumn AS a, onecolumn AS b ORDER BY x
----
project
 ├── columns: x:1(int) x:3(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         └── true [type=bool]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a NATURAL LEFT OUTER JOIN onecolumn AS b
----
project
 ├── columns: x:1(int)
 ├── left-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a(x) RIGHT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── right-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a RIGHT OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
project
 ├── columns: x:3(int)
 ├── ordering: +3
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── ordering: +3
 │    └── right-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(3)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a NATURAL RIGHT OUTER JOIN onecolumn AS b
----
project
 ├── columns: x:3(int)
 ├── right-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(3)]
      └── variable: onecolumn.x [type=int, outer=(3)]

exec-ddl
CREATE TABLE onecolumn_w(w INT)
----
TABLE onecolumn_w
 ├── w int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM onecolumn AS a NATURAL JOIN onecolumn_w as b
----
project
 ├── columns: x:1(int) w:3(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) onecolumn_w.w:3(int) onecolumn_w.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn_w.w:3(int) onecolumn_w.rowid:4(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: onecolumn_w.w [type=int, outer=(3)]

exec-ddl
CREATE TABLE othercolumn (x INT)
----
TABLE othercolumn
 ├── x int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b ON a.x = b.x ORDER BY a.x,b.x
----
project
 ├── columns: x:1(int) x:3(int)
 ├── ordering: +1,+3
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │    ├── ordering: +1,+3
 │    └── full-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: othercolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: othercolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b USING(x) ORDER BY x
----
project
 ├── columns: x:5(int)
 ├── ordering: +5
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int) x:5(int)
 │    ├── ordering: +5
 │    └── project
 │         ├── columns: x:5(int) onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         ├── full-join
 │         │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         │    ├── scan
 │         │    │    └── columns: othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │         │    └── eq [type=bool, outer=(1,3)]
 │         │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │         └── variable: othercolumn.x [type=int, outer=(3)]
 │         └── projections [outer=(1-4)]
 │              ├── coalesce [type=int, outer=(1,3)]
 │              │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │              │    └── variable: othercolumn.x [type=int, outer=(3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              ├── variable: onecolumn.rowid [type=int, outer=(2)]
 │              ├── variable: othercolumn.x [type=int, outer=(3)]
 │              └── variable: othercolumn.rowid [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: x [type=int, outer=(5)]

# Check that the source columns can be selected separately from the
# USING column (#12033).
build
SELECT x AS s, a.x, b.x FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b USING(x) ORDER BY s
----
project
 ├── columns: s:5(int) x:1(int) x:3(int)
 ├── ordering: +5
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int) x:5(int)
 │    ├── ordering: +5
 │    └── project
 │         ├── columns: x:5(int) onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         ├── full-join
 │         │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         │    ├── scan
 │         │    │    └── columns: othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │         │    └── eq [type=bool, outer=(1,3)]
 │         │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │         └── variable: othercolumn.x [type=int, outer=(3)]
 │         └── projections [outer=(1-4)]
 │              ├── coalesce [type=int, outer=(1,3)]
 │              │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │              │    └── variable: othercolumn.x [type=int, outer=(3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              ├── variable: onecolumn.rowid [type=int, outer=(2)]
 │              ├── variable: othercolumn.x [type=int, outer=(3)]
 │              └── variable: othercolumn.rowid [type=int, outer=(4)]
 └── projections [outer=(1,3,5)]
      ├── variable: x [type=int, outer=(5)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: othercolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a NATURAL FULL OUTER JOIN othercolumn AS b ORDER BY x
----
project
 ├── columns: x:5(int)
 ├── ordering: +5
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int) x:5(int)
 │    ├── ordering: +5
 │    └── project
 │         ├── columns: x:5(int) onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         ├── full-join
 │         │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) othercolumn.x:3(int) othercolumn.rowid:4(int)
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         │    ├── scan
 │         │    │    └── columns: othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │         │    └── eq [type=bool, outer=(1,3)]
 │         │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │         └── variable: othercolumn.x [type=int, outer=(3)]
 │         └── projections [outer=(1-4)]
 │              ├── coalesce [type=int, outer=(1,3)]
 │              │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │              │    └── variable: othercolumn.x [type=int, outer=(3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              ├── variable: onecolumn.rowid [type=int, outer=(2)]
 │              ├── variable: othercolumn.x [type=int, outer=(3)]
 │              └── variable: othercolumn.rowid [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: x [type=int, outer=(5)]

# TODO(rytaft): LIMIT not yet supported.
# Check that a limit on the JOIN's result do not cause rows from the
# JOIN operands to become invisible to the JOIN.
#build
#SELECT * FROM (SELECT x FROM onecolumn ORDER BY x DESC) NATURAL JOIN (VALUES (42)) AS v(x) LIMIT 1
#----

exec-ddl
CREATE TABLE empty (x INT)
----
TABLE empty
 ├── x int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM onecolumn AS a(x) CROSS JOIN empty AS b(y)
----
project
 ├── columns: x:1(int) y:3(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM empty AS a CROSS JOIN onecolumn AS b
----
project
 ├── columns: x:1(int) x:3(int)
 ├── inner-join
 │    ├── columns: empty.x:1(int) empty.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1,3)]
      ├── variable: empty.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a(x) JOIN empty AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a JOIN empty AS b USING(x)
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

build
SELECT * FROM empty AS a(x) JOIN onecolumn AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── inner-join
 │    ├── columns: empty.x:1(int) empty.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: empty.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: empty.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM empty AS a JOIN onecolumn AS b USING(x)
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: empty.x:1(int) empty.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: empty.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: empty.x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a(x) LEFT OUTER JOIN empty AS b(y) ON a.x = b.y ORDER BY a.x
----
project
 ├── columns: x:1(int) y:3(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int)
 │    ├── ordering: +1
 │    └── left-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a LEFT OUTER JOIN empty AS b USING(x) ORDER BY x
----
project
 ├── columns: x:1(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int)
 │    ├── ordering: +1
 │    └── left-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) empty.x:3(int) empty.rowid:4(int)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

build
SELECT * FROM empty AS a(x) LEFT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── left-join
 │    ├── columns: empty.x:1(int) empty.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── scan
 │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: empty.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: empty.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM empty AS a LEFT OUTER JOIN onecolumn AS b USING(x)
----
project
 ├── columns: x:1(int)
 ├── left-join
 │    ├── columns: empty.x:1(int) empty.rowid:2(int!null) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── scan
 │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: empty.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: empty.x [type=int, outer=(1)]

build
SELECT * FROM onecolumn AS a(x) RIGHT OUTER JOIN empty AS b(y) ON a.x = b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── right-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a RIGHT OUTER JOIN empty AS b USING(x)
----
project
 ├── columns: x:3(int)
 ├── right-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(3)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM empty AS a(x) FULL OUTER JOIN onecolumn AS b(y) ON a.x = b.y ORDER BY b.y
----
project
 ├── columns: x:1(int) y:3(int)
 ├── ordering: +3
 ├── sort
 │    ├── columns: empty.x:1(int) empty.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │    ├── ordering: +3
 │    └── full-join
 │         ├── columns: empty.x:1(int) empty.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │         ├── scan
 │         │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: empty.x [type=int, outer=(1)]
 │              └── variable: onecolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: empty.x [type=int, outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(3)]

build
SELECT * FROM empty AS a FULL OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
project
 ├── columns: x:5(int)
 ├── ordering: +5
 ├── sort
 │    ├── columns: empty.x:1(int) empty.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int) x:5(int)
 │    ├── ordering: +5
 │    └── project
 │         ├── columns: x:5(int) empty.x:1(int) empty.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │         ├── full-join
 │         │    ├── columns: empty.x:1(int) empty.rowid:2(int) onecolumn.x:3(int) onecolumn.rowid:4(int)
 │         │    ├── scan
 │         │    │    └── columns: empty.x:1(int) empty.rowid:2(int!null)
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │         │    └── eq [type=bool, outer=(1,3)]
 │         │         ├── variable: empty.x [type=int, outer=(1)]
 │         │         └── variable: onecolumn.x [type=int, outer=(3)]
 │         └── projections [outer=(1-4)]
 │              ├── coalesce [type=int, outer=(1,3)]
 │              │    ├── variable: empty.x [type=int, outer=(1)]
 │              │    └── variable: onecolumn.x [type=int, outer=(3)]
 │              ├── variable: empty.x [type=int, outer=(1)]
 │              ├── variable: empty.rowid [type=int, outer=(2)]
 │              ├── variable: onecolumn.x [type=int, outer=(3)]
 │              └── variable: onecolumn.rowid [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: x [type=int, outer=(5)]

build
SELECT * FROM onecolumn AS a(x) FULL OUTER JOIN empty AS b(y) ON a.x = b.y ORDER BY a.x
----
project
 ├── columns: x:1(int) y:3(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int)
 │    ├── ordering: +1
 │    └── full-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int)
 │         ├── scan
 │         │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── variable: empty.x [type=int, outer=(3)]
 └── projections [outer=(1,3)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: empty.x [type=int, outer=(3)]

build
SELECT * FROM onecolumn AS a FULL OUTER JOIN empty AS b USING(x) ORDER BY x
----
project
 ├── columns: x:5(int)
 ├── ordering: +5
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int) x:5(int)
 │    ├── ordering: +5
 │    └── project
 │         ├── columns: x:5(int) onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int)
 │         ├── full-join
 │         │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int) empty.x:3(int) empty.rowid:4(int)
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         │    ├── scan
 │         │    │    └── columns: empty.x:3(int) empty.rowid:4(int!null)
 │         │    └── eq [type=bool, outer=(1,3)]
 │         │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │         └── variable: empty.x [type=int, outer=(3)]
 │         └── projections [outer=(1-4)]
 │              ├── coalesce [type=int, outer=(1,3)]
 │              │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │              │    └── variable: empty.x [type=int, outer=(3)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              ├── variable: onecolumn.rowid [type=int, outer=(2)]
 │              ├── variable: empty.x [type=int, outer=(3)]
 │              └── variable: empty.rowid [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: x [type=int, outer=(5)]

exec-ddl
CREATE TABLE twocolumn (x INT, y INT)
----
TABLE twocolumn
 ├── x int
 ├── y int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

# Natural joins with partial match
build
SELECT * FROM onecolumn NATURAL JOIN twocolumn
----
project
 ├── columns: x:1(int) y:4(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT * FROM onecolumn JOIN twocolumn USING(x)
----
project
 ├── columns: x:1(int) y:4(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.x [type=int, outer=(3)]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = b.y
----
project
 ├── columns: x:1(int) y:2(int) x:4(int) y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── eq [type=bool, outer=(1,5)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.y [type=int, outer=(5)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.y [type=int, outer=(2)]
      ├── variable: twocolumn.x [type=int, outer=(4)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = a.y
----
project
 ├── columns: x:1(int) y:2(int) x:4(int) y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── eq [type=bool, outer=(1,2)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.y [type=int, outer=(2)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.y [type=int, outer=(2)]
      ├── variable: twocolumn.x [type=int, outer=(4)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT * FROM onecolumn AS a JOIN twocolumn AS b ON ((a.x)) = ((b.y))
----
project
 ├── columns: x:1(int) x:3(int) y:4(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,4)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.y [type=int, outer=(4)]
 └── projections [outer=(1,3,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.x [type=int, outer=(3)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT * FROM onecolumn JOIN twocolumn ON onecolumn.x = twocolumn.y
----
project
 ├── columns: x:1(int) x:3(int) y:4(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,4)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.y [type=int, outer=(4)]
 └── projections [outer=(1,3,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.x [type=int, outer=(3)]
      └── variable: twocolumn.y [type=int, outer=(4)]

# Inner join with filter predicate
build
SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = 44
----
project
 ├── columns: x:1(int) y:2(int) x:4(int) y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── eq [type=bool, outer=(1)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── const: 44 [type=int]
 └── projections [outer=(1,2,4,5)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.y [type=int, outer=(2)]
      ├── variable: twocolumn.x [type=int, outer=(4)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT o.x, t.y FROM onecolumn o INNER JOIN twocolumn t ON (o.x=t.x AND t.y=53)
----
project
 ├── columns: x:1(int) y:4(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── and [type=bool, outer=(1,3,4)]
 │         ├── eq [type=bool, outer=(1,3)]
 │         │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │    └── variable: twocolumn.x [type=int, outer=(3)]
 │         └── eq [type=bool, outer=(4)]
 │              ├── variable: twocolumn.y [type=int, outer=(4)]
 │              └── const: 53 [type=int]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

# Outer joins with filter predicate
build
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND t.y=53)
----
project
 ├── columns: x:1(int) y:4(int)
 ├── left-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── and [type=bool, outer=(1,3,4)]
 │         ├── eq [type=bool, outer=(1,3)]
 │         │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │    └── variable: twocolumn.x [type=int, outer=(3)]
 │         └── eq [type=bool, outer=(4)]
 │              ├── variable: twocolumn.y [type=int, outer=(4)]
 │              └── const: 53 [type=int]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND o.x=44)
----
project
 ├── columns: x:1(int) y:4(int)
 ├── left-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── and [type=bool, outer=(1,3)]
 │         ├── eq [type=bool, outer=(1,3)]
 │         │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │    └── variable: twocolumn.x [type=int, outer=(3)]
 │         └── eq [type=bool, outer=(1)]
 │              ├── variable: onecolumn.x [type=int, outer=(1)]
 │              └── const: 44 [type=int]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND t.x=44)
----
project
 ├── columns: x:1(int) y:4(int)
 ├── left-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │    └── and [type=bool, outer=(1,3)]
 │         ├── eq [type=bool, outer=(1,3)]
 │         │    ├── variable: onecolumn.x [type=int, outer=(1)]
 │         │    └── variable: twocolumn.x [type=int, outer=(3)]
 │         └── eq [type=bool, outer=(3)]
 │              ├── variable: twocolumn.x [type=int, outer=(3)]
 │              └── const: 44 [type=int]
 └── projections [outer=(1,4)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(4)]

build
SELECT x, a.x, b.y FROM (SELECT * FROM onecolumn AS a NATURAL JOIN twocolumn AS b) AS q
----
error: no data source matches prefix: a

build
SELECT x, a.x, b.y FROM (SELECT * FROM onecolumn AS a NATURAL JOIN twocolumn AS b)
----
error: no data source matches prefix: a


## Simple test cases for inner, left, right, and outer joins

exec-ddl
CREATE TABLE a (i int)
----
TABLE a
 ├── i int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

exec-ddl
CREATE TABLE b (i int, b bool)
----
TABLE b
 ├── i int
 ├── b bool
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM a INNER JOIN b ON a.i = b.i
----
project
 ├── columns: i:1(int) i:3(int) b:4(bool)
 ├── inner-join
 │    ├── columns: a.i:1(int) a.rowid:2(int!null) b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: a.i:1(int) a.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: a.i [type=int, outer=(1)]
 │         └── variable: b.i [type=int, outer=(3)]
 └── projections [outer=(1,3,4)]
      ├── variable: a.i [type=int, outer=(1)]
      ├── variable: b.i [type=int, outer=(3)]
      └── variable: b.b [type=bool, outer=(4)]

build
SELECT * FROM a LEFT OUTER JOIN b ON a.i = b.i
----
project
 ├── columns: i:1(int) i:3(int) b:4(bool)
 ├── left-join
 │    ├── columns: a.i:1(int) a.rowid:2(int!null) b.i:3(int) b.b:4(bool) b.rowid:5(int)
 │    ├── scan
 │    │    └── columns: a.i:1(int) a.rowid:2(int!null)
 │    ├── scan
 │    │    └── columns: b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │    └── eq [type=bool, outer=(1,3)]
 │         ├── variable: a.i [type=int, outer=(1)]
 │         └── variable: b.i [type=int, outer=(3)]
 └── projections [outer=(1,3,4)]
      ├── variable: a.i [type=int, outer=(1)]
      ├── variable: b.i [type=int, outer=(3)]
      └── variable: b.b [type=bool, outer=(4)]

build
SELECT * FROM a RIGHT OUTER JOIN b ON a.i = b.i ORDER BY b.i, b.b
----
project
 ├── columns: i:1(int) i:3(int) b:4(bool)
 ├── ordering: +3,+4
 ├── sort
 │    ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │    ├── ordering: +3,+4
 │    └── right-join
 │         ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │         ├── scan
 │         │    └── columns: a.i:1(int) a.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: a.i [type=int, outer=(1)]
 │              └── variable: b.i [type=int, outer=(3)]
 └── projections [outer=(1,3,4)]
      ├── variable: a.i [type=int, outer=(1)]
      ├── variable: b.i [type=int, outer=(3)]
      └── variable: b.b [type=bool, outer=(4)]

build
SELECT * FROM a FULL OUTER JOIN b ON a.i = b.i ORDER BY b.i, b.b
----
project
 ├── columns: i:1(int) i:3(int) b:4(bool)
 ├── ordering: +3,+4
 ├── sort
 │    ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int)
 │    ├── ordering: +3,+4
 │    └── full-join
 │         ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int)
 │         ├── scan
 │         │    └── columns: a.i:1(int) a.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │         └── eq [type=bool, outer=(1,3)]
 │              ├── variable: a.i [type=int, outer=(1)]
 │              └── variable: b.i [type=int, outer=(3)]
 └── projections [outer=(1,3,4)]
      ├── variable: a.i [type=int, outer=(1)]
      ├── variable: b.i [type=int, outer=(3)]
      └── variable: b.b [type=bool, outer=(4)]

# Full outer join with filter predicate
build
SELECT * FROM a FULL OUTER JOIN b ON (a.i = b.i and a.i>2) ORDER BY a.i, b.i
----
project
 ├── columns: i:1(int) i:3(int) b:4(bool)
 ├── ordering: +1,+3
 ├── sort
 │    ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int)
 │    ├── ordering: +1,+3
 │    └── full-join
 │         ├── columns: a.i:1(int) a.rowid:2(int) b.i:3(int) b.b:4(bool) b.rowid:5(int)
 │         ├── scan
 │         │    └── columns: a.i:1(int) a.rowid:2(int!null)
 │         ├── scan
 │         │    └── columns: b.i:3(int) b.b:4(bool) b.rowid:5(int!null)
 │         └── and [type=bool, outer=(1,3)]
 │              ├── eq [type=bool, outer=(1,3)]
 │              │    ├── variable: a.i [type=int, outer=(1)]
 │              │    └── variable: b.i [type=int, outer=(3)]
 │              └── gt [type=bool, outer=(1)]
 │                   ├── variable: a.i [type=int, outer=(1)]
 │                   └── const: 2 [type=int]
 └── projections [outer=(1,3,4)]
      ├── variable: a.i [type=int, outer=(1)]
      ├── variable: b.i [type=int, outer=(3)]
      └── variable: b.b [type=bool, outer=(4)]

# Check column orders and names.
build
SELECT * FROM (onecolumn CROSS JOIN twocolumn JOIN onecolumn AS a(b) ON a.b=twocolumn.x JOIN twocolumn AS c(d,e) ON a.b=c.d AND c.d=onecolumn.x) ORDER BY 1
----
project
 ├── columns: x:1(int) x:3(int) y:4(int) b:6(int) d:8(int) e:9(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null) onecolumn.x:6(int) onecolumn.rowid:7(int!null) twocolumn.x:8(int) twocolumn.y:9(int) twocolumn.rowid:10(int!null)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null) onecolumn.x:6(int) onecolumn.rowid:7(int!null) twocolumn.x:8(int) twocolumn.y:9(int) twocolumn.rowid:10(int!null)
 │         ├── inner-join
 │         │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null) onecolumn.x:6(int) onecolumn.rowid:7(int!null)
 │         │    ├── inner-join
 │         │    │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │         │    │    ├── scan
 │         │    │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │         │    │    ├── scan
 │         │    │    │    └── columns: twocolumn.x:3(int) twocolumn.y:4(int) twocolumn.rowid:5(int!null)
 │         │    │    └── true [type=bool]
 │         │    ├── scan
 │         │    │    └── columns: onecolumn.x:6(int) onecolumn.rowid:7(int!null)
 │         │    └── eq [type=bool, outer=(3,6)]
 │         │         ├── variable: onecolumn.x [type=int, outer=(6)]
 │         │         └── variable: twocolumn.x [type=int, outer=(3)]
 │         ├── scan
 │         │    └── columns: twocolumn.x:8(int) twocolumn.y:9(int) twocolumn.rowid:10(int!null)
 │         └── and [type=bool, outer=(1,6,8)]
 │              ├── eq [type=bool, outer=(6,8)]
 │              │    ├── variable: onecolumn.x [type=int, outer=(6)]
 │              │    └── variable: twocolumn.x [type=int, outer=(8)]
 │              └── eq [type=bool, outer=(1,8)]
 │                   ├── variable: twocolumn.x [type=int, outer=(8)]
 │                   └── variable: onecolumn.x [type=int, outer=(1)]
 └── projections [outer=(1,3,4,6,8,9)]
      ├── variable: onecolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.x [type=int, outer=(3)]
      ├── variable: twocolumn.y [type=int, outer=(4)]
      ├── variable: onecolumn.x [type=int, outer=(6)]
      ├── variable: twocolumn.x [type=int, outer=(8)]
      └── variable: twocolumn.y [type=int, outer=(9)]

build
SELECT * FROM onecolumn JOIN (SELECT x + 2 AS x FROM onecolumn) USING(x)
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) x:5(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    ├── project
 │    │    ├── columns: x:5(int)
 │    │    ├── scan
 │    │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    │    └── projections [outer=(3)]
 │    │         └── plus [type=int, outer=(3)]
 │    │              ├── variable: onecolumn.x [type=int, outer=(3)]
 │    │              └── const: 2 [type=int]
 │    └── eq [type=bool, outer=(1,5)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: x [type=int, outer=(5)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

# Check that a single column can have multiple table aliases.
build
SELECT * FROM (twocolumn AS a JOIN twocolumn AS b USING(x) JOIN twocolumn AS c USING(x)) ORDER BY x
----
project
 ├── columns: x:1(int) y:2(int) y:5(int) y:8(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null) twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null) twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │         ├── inner-join
 │         │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │         │    ├── scan
 │         │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │         │    ├── scan
 │         │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │         │    └── eq [type=bool, outer=(1,4)]
 │         │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         │         └── variable: twocolumn.x [type=int, outer=(4)]
 │         ├── scan
 │         │    └── columns: twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │         └── eq [type=bool, outer=(1,7)]
 │              ├── variable: twocolumn.x [type=int, outer=(1)]
 │              └── variable: twocolumn.x [type=int, outer=(7)]
 └── projections [outer=(1,2,5,8)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.y [type=int, outer=(2)]
      ├── variable: twocolumn.y [type=int, outer=(5)]
      └── variable: twocolumn.y [type=int, outer=(8)]

build
SELECT a.x AS s, b.x, c.x, a.y, b.y, c.y FROM (twocolumn AS a JOIN twocolumn AS b USING(x) JOIN twocolumn AS c USING(x)) ORDER BY s
----
project
 ├── columns: s:1(int) x:4(int) x:7(int) y:2(int) y:5(int) y:8(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null) twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null) twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │         ├── inner-join
 │         │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │         │    ├── scan
 │         │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │         │    ├── scan
 │         │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │         │    └── eq [type=bool, outer=(1,4)]
 │         │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         │         └── variable: twocolumn.x [type=int, outer=(4)]
 │         ├── scan
 │         │    └── columns: twocolumn.x:7(int) twocolumn.y:8(int) twocolumn.rowid:9(int!null)
 │         └── eq [type=bool, outer=(1,7)]
 │              ├── variable: twocolumn.x [type=int, outer=(1)]
 │              └── variable: twocolumn.x [type=int, outer=(7)]
 └── projections [outer=(1,2,4,5,7,8)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      ├── variable: twocolumn.x [type=int, outer=(4)]
      ├── variable: twocolumn.x [type=int, outer=(7)]
      ├── variable: twocolumn.y [type=int, outer=(2)]
      ├── variable: twocolumn.y [type=int, outer=(5)]
      └── variable: twocolumn.y [type=int, outer=(8)]

build
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b USING(y))
----
error: column "y" specified in USING clause does not exist in left table

build
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b USING(x, x))
----
error: column "x" appears more than once in USING clause

exec-ddl
CREATE TABLE othertype (x TEXT)
----
TABLE othertype
 ├── x string
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM (onecolumn AS a JOIN othertype AS b USING(x))
----
error: JOIN/USING types int for left and string for right cannot be matched for column x

build
SELECT * FROM (onecolumn JOIN onecolumn USING(x))
----
error: cannot join columns from the same source name "onecolumn" (missing AS clause)

build
SELECT * FROM (onecolumn JOIN twocolumn USING(x) JOIN onecolumn USING(x))
----
error: cannot join columns from the same source name "onecolumn" (missing AS clause)

# Check that star expansion works across anonymous sources.
build
SELECT * FROM (SELECT * FROM onecolumn), (SELECT * FROM onecolumn)
----
inner-join
 ├── columns: x:1(int) x:3(int)
 ├── project
 │    ├── columns: onecolumn.x:1(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    └── projections [outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(1)]
 ├── project
 │    ├── columns: onecolumn.x:3(int)
 │    ├── scan
 │    │    └── columns: onecolumn.x:3(int) onecolumn.rowid:4(int!null)
 │    └── projections [outer=(3)]
 │         └── variable: onecolumn.x [type=int, outer=(3)]
 └── true [type=bool]

# Check that anonymous sources are properly looked up without ambiguity.
build
SELECT x FROM (onecolumn JOIN othercolumn USING (x)) JOIN (onecolumn AS a JOIN othercolumn AS b USING(x)) USING(x)
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) othercolumn.x:3(int) othercolumn.rowid:4(int!null) onecolumn.x:5(int) onecolumn.rowid:6(int!null) othercolumn.x:7(int) othercolumn.rowid:8(int!null)
 │    ├── inner-join
 │    │    ├── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null) othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │    │    ├── scan
 │    │    │    └── columns: onecolumn.x:1(int) onecolumn.rowid:2(int!null)
 │    │    ├── scan
 │    │    │    └── columns: othercolumn.x:3(int) othercolumn.rowid:4(int!null)
 │    │    └── eq [type=bool, outer=(1,3)]
 │    │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │    │         └── variable: othercolumn.x [type=int, outer=(3)]
 │    ├── inner-join
 │    │    ├── columns: onecolumn.x:5(int) onecolumn.rowid:6(int!null) othercolumn.x:7(int) othercolumn.rowid:8(int!null)
 │    │    ├── scan
 │    │    │    └── columns: onecolumn.x:5(int) onecolumn.rowid:6(int!null)
 │    │    ├── scan
 │    │    │    └── columns: othercolumn.x:7(int) othercolumn.rowid:8(int!null)
 │    │    └── eq [type=bool, outer=(5,7)]
 │    │         ├── variable: onecolumn.x [type=int, outer=(5)]
 │    │         └── variable: othercolumn.x [type=int, outer=(7)]
 │    └── eq [type=bool, outer=(1,5)]
 │         ├── variable: onecolumn.x [type=int, outer=(1)]
 │         └── variable: onecolumn.x [type=int, outer=(5)]
 └── projections [outer=(1)]
      └── variable: onecolumn.x [type=int, outer=(1)]

# Check that multiple anonymous sources cause proper ambiguity errors.
build
SELECT x FROM (SELECT * FROM onecolumn), (SELECT * FROM onecolumn)
----
error: column reference "x" is ambiguous (candidates: <anonymous>.x, <anonymous>.x)

build
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b ON x > 32)
----
error: column reference "x" is ambiguous (candidates: a.x, b.x)

build
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b ON a.y > y)
----
error: column name "a.y" not found

# THe following queries verify that only the necessary columns are scanned.
build
SELECT a.x, b.y FROM twocolumn AS a, twocolumn AS b
----
project
 ├── columns: x:1(int) y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1,5)]
      ├── variable: twocolumn.x [type=int, outer=(1)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT b.y FROM (twocolumn AS a JOIN twocolumn AS b USING(x))
----
project
 ├── columns: y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── eq [type=bool, outer=(1,4)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.x [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT b.y FROM (twocolumn AS a JOIN twocolumn AS b ON a.x = b.x)
----
project
 ├── columns: y:5(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── eq [type=bool, outer=(1,4)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.x [type=int, outer=(4)]
 └── projections [outer=(5)]
      └── variable: twocolumn.y [type=int, outer=(5)]

build
SELECT a.x FROM (twocolumn AS a JOIN twocolumn AS b ON a.x < b.y)
----
project
 ├── columns: x:1(int)
 ├── inner-join
 │    ├── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null) twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:1(int) twocolumn.y:2(int) twocolumn.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: twocolumn.x:4(int) twocolumn.y:5(int) twocolumn.rowid:6(int!null)
 │    └── lt [type=bool, outer=(1,5)]
 │         ├── variable: twocolumn.x [type=int, outer=(1)]
 │         └── variable: twocolumn.y [type=int, outer=(5)]
 └── projections [outer=(1)]
      └── variable: twocolumn.x [type=int, outer=(1)]

build
SELECT * FROM (SELECT * FROM (VALUES (9, 1), (8, 2)) AS a (u, k) ORDER BY k)
  INNER JOIN (VALUES (1, 1), (2, 2)) AS b (k, w) USING (k) ORDER BY u
----
project
 ├── columns: k:2(int) u:1(int) w:4(int)
 ├── ordering: +1
 ├── sort
 │    ├── columns: column1:1(int) column2:2(int) column1:3(int) column2:4(int)
 │    ├── ordering: +1
 │    └── inner-join
 │         ├── columns: column1:1(int) column2:2(int) column1:3(int) column2:4(int)
 │         ├── values
 │         │    ├── columns: column1:1(int) column2:2(int)
 │         │    ├── tuple [type=tuple{int, int}]
 │         │    │    ├── const: 9 [type=int]
 │         │    │    └── const: 1 [type=int]
 │         │    └── tuple [type=tuple{int, int}]
 │         │         ├── const: 8 [type=int]
 │         │         └── const: 2 [type=int]
 │         ├── values
 │         │    ├── columns: column1:3(int) column2:4(int)
 │         │    ├── tuple [type=tuple{int, int}]
 │         │    │    ├── const: 1 [type=int]
 │         │    │    └── const: 1 [type=int]
 │         │    └── tuple [type=tuple{int, int}]
 │         │         ├── const: 2 [type=int]
 │         │         └── const: 2 [type=int]
 │         └── eq [type=bool, outer=(2,3)]
 │              ├── variable: column2 [type=int, outer=(2)]
 │              └── variable: column1 [type=int, outer=(3)]
 └── projections [outer=(1,2,4)]
      ├── variable: column2 [type=int, outer=(2)]
      ├── variable: column1 [type=int, outer=(1)]
      └── variable: column2 [type=int, outer=(4)]

# Tests for filter propagation through joins.

exec-ddl
CREATE TABLE square (n INT PRIMARY KEY, sq INT)
----
TABLE square
 ├── n int not null
 ├── sq int
 └── INDEX primary
      └── n int not null

exec-ddl
CREATE TABLE pairs (a INT, b INT)
----
TABLE pairs
 ├── a int
 ├── b int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

# The filter expression becomes an equality constraint.
build
SELECT * FROM pairs, square WHERE pairs.b = square.n
----
project
 ├── columns: a:1(int) b:2(int) n:4(int!null) sq:5(int)
 ├── select
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    ├── inner-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── true [type=bool]
 │    └── eq [type=bool, outer=(2,4)]
 │         ├── variable: pairs.b [type=int, outer=(2)]
 │         └── variable: square.n [type=int, outer=(4)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: pairs.a [type=int, outer=(1)]
      ├── variable: pairs.b [type=int, outer=(2)]
      ├── variable: square.n [type=int, outer=(4)]
      └── variable: square.sq [type=int, outer=(5)]

# The filter expression becomes an ON predicate.
build
SELECT * FROM pairs, square WHERE pairs.a + pairs.b = square.sq
----
project
 ├── columns: a:1(int) b:2(int) n:4(int!null) sq:5(int)
 ├── select
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    ├── inner-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── true [type=bool]
 │    └── eq [type=bool, outer=(1,2,5)]
 │         ├── plus [type=int, outer=(1,2)]
 │         │    ├── variable: pairs.a [type=int, outer=(1)]
 │         │    └── variable: pairs.b [type=int, outer=(2)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: pairs.a [type=int, outer=(1)]
      ├── variable: pairs.b [type=int, outer=(2)]
      ├── variable: square.n [type=int, outer=(4)]
      └── variable: square.sq [type=int, outer=(5)]

# Query similar to the one above, but the filter refers to a rendered
# expression and can't "break through". See the comment for propagateFilters
# in fitler_opt.go for all the details.
build
SELECT a, b, n, sq FROM (SELECT a, b, a + b AS sum, n, sq FROM pairs, square) WHERE sum = sq
----
project
 ├── columns: a:1(int) b:2(int) n:4(int!null) sq:5(int)
 ├── select
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) square.n:4(int!null) square.sq:5(int) sum:6(int)
 │    ├── project
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) sum:6(int) square.n:4(int!null) square.sq:5(int)
 │    │    ├── inner-join
 │    │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    │    │    ├── scan
 │    │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    │    ├── scan
 │    │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    │    └── true [type=bool]
 │    │    └── projections [outer=(1,2,4,5)]
 │    │         ├── variable: pairs.a [type=int, outer=(1)]
 │    │         ├── variable: pairs.b [type=int, outer=(2)]
 │    │         ├── plus [type=int, outer=(1,2)]
 │    │         │    ├── variable: pairs.a [type=int, outer=(1)]
 │    │         │    └── variable: pairs.b [type=int, outer=(2)]
 │    │         ├── variable: square.n [type=int, outer=(4)]
 │    │         └── variable: square.sq [type=int, outer=(5)]
 │    └── eq [type=bool, outer=(5,6)]
 │         ├── variable: sum [type=int, outer=(6)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: pairs.a [type=int, outer=(1)]
      ├── variable: pairs.b [type=int, outer=(2)]
      ├── variable: square.n [type=int, outer=(4)]
      └── variable: square.sq [type=int, outer=(5)]

# The filter expression must stay on top of the outer join.
build
SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq
----
project
 ├── columns: a:1(int) b:2(int) n:4(int) sq:5(int)
 ├── full-join
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int) square.n:4(int) square.sq:5(int)
 │    ├── scan
 │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    ├── scan
 │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    └── eq [type=bool, outer=(1,2,5)]
 │         ├── plus [type=int, outer=(1,2)]
 │         │    ├── variable: pairs.a [type=int, outer=(1)]
 │         │    └── variable: pairs.b [type=int, outer=(2)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── projections [outer=(1,2,4,5)]
      ├── variable: pairs.a [type=int, outer=(1)]
      ├── variable: pairs.b [type=int, outer=(2)]
      ├── variable: square.n [type=int, outer=(4)]
      └── variable: square.sq [type=int, outer=(5)]

build
SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq WHERE pairs.b%2 <> square.sq%2
----
project
 ├── columns: a:1(int) b:2(int) n:4(int) sq:5(int)
 ├── select
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int) square.n:4(int) square.sq:5(int)
 │    ├── full-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int) square.n:4(int) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── eq [type=bool, outer=(1,2,5)]
 │    │         ├── plus [type=int, outer=(1,2)]
 │    │         │    ├── variable: pairs.a [type=int, outer=(1)]
 │    │         │    └── variable: pairs.b [type=int, outer=(2)]
 │    │         └── variable: square.sq [type=int, outer=(5)]
 │    └── ne [type=bool, outer=(2,5)]
 │         ├── mod [type=int, outer=(2)]
 │         │    ├── variable: pairs.b [type=int, outer=(2)]
 │         │    └── const: 2 [type=int]
 │         └── mod [type=int, outer=(5)]
 │              ├── variable: square.sq [type=int, outer=(5)]
 │              └── const: 2 [type=int]
 └── projections [outer=(1,2,4,5)]
      ├── variable: pairs.a [type=int, outer=(1)]
      ├── variable: pairs.b [type=int, outer=(2)]
      ├── variable: square.n [type=int, outer=(4)]
      └── variable: square.sq [type=int, outer=(5)]

# Filter propagation through outer joins.

build
SELECT *
  FROM (SELECT * FROM pairs LEFT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE b > 1 AND (n IS NULL OR n > 1) AND (n IS NULL OR a  < sq)
----
select
 ├── columns: a:1(int) b:2(int) n:4(int) sq:5(int)
 ├── project
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) square.n:4(int) square.sq:5(int)
 │    ├── left-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── and [type=bool, outer=(1,2,5)]
 │    │         │    ├── eq [type=bool, outer=(2,5)]
 │    │         │    │    ├── variable: pairs.b [type=int, outer=(2)]
 │    │         │    │    └── variable: square.sq [type=int, outer=(5)]
 │    │         │    └── gt [type=bool, outer=(1)]
 │    │         │         ├── variable: pairs.a [type=int, outer=(1)]
 │    │         │         └── const: 1 [type=int]
 │    │         └── lt [type=bool, outer=(4)]
 │    │              ├── variable: square.n [type=int, outer=(4)]
 │    │              └── const: 6 [type=int]
 │    └── projections [outer=(1,2,4,5)]
 │         ├── variable: pairs.a [type=int, outer=(1)]
 │         ├── variable: pairs.b [type=int, outer=(2)]
 │         ├── variable: square.n [type=int, outer=(4)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(2,4)]
      │    ├── gt [type=bool, outer=(2)]
      │    │    ├── variable: pairs.b [type=int, outer=(2)]
      │    │    └── const: 1 [type=int]
      │    └── or [type=bool, outer=(4)]
      │         ├── is [type=bool, outer=(4)]
      │         │    ├── variable: square.n [type=int, outer=(4)]
      │         │    └── null [type=unknown]
      │         └── gt [type=bool, outer=(4)]
      │              ├── variable: square.n [type=int, outer=(4)]
      │              └── const: 1 [type=int]
      └── or [type=bool, outer=(1,4,5)]
           ├── is [type=bool, outer=(4)]
           │    ├── variable: square.n [type=int, outer=(4)]
           │    └── null [type=unknown]
           └── lt [type=bool, outer=(1,5)]
                ├── variable: pairs.a [type=int, outer=(1)]
                └── variable: square.sq [type=int, outer=(5)]

build
SELECT *
  FROM (SELECT * FROM pairs RIGHT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE (a IS NULL OR a > 2) AND n > 1 AND (a IS NULL OR a < sq)
----
select
 ├── columns: a:1(int) b:2(int) n:4(int!null) sq:5(int)
 ├── project
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) square.n:4(int!null) square.sq:5(int)
 │    ├── right-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int) square.n:4(int!null) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── and [type=bool, outer=(1,2,5)]
 │    │         │    ├── eq [type=bool, outer=(2,5)]
 │    │         │    │    ├── variable: pairs.b [type=int, outer=(2)]
 │    │         │    │    └── variable: square.sq [type=int, outer=(5)]
 │    │         │    └── gt [type=bool, outer=(1)]
 │    │         │         ├── variable: pairs.a [type=int, outer=(1)]
 │    │         │         └── const: 1 [type=int]
 │    │         └── lt [type=bool, outer=(4)]
 │    │              ├── variable: square.n [type=int, outer=(4)]
 │    │              └── const: 6 [type=int]
 │    └── projections [outer=(1,2,4,5)]
 │         ├── variable: pairs.a [type=int, outer=(1)]
 │         ├── variable: pairs.b [type=int, outer=(2)]
 │         ├── variable: square.n [type=int, outer=(4)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── and [type=bool, outer=(1,4,5)]
      ├── and [type=bool, outer=(1,4)]
      │    ├── or [type=bool, outer=(1)]
      │    │    ├── is [type=bool, outer=(1)]
      │    │    │    ├── variable: pairs.a [type=int, outer=(1)]
      │    │    │    └── null [type=unknown]
      │    │    └── gt [type=bool, outer=(1)]
      │    │         ├── variable: pairs.a [type=int, outer=(1)]
      │    │         └── const: 2 [type=int]
      │    └── gt [type=bool, outer=(4)]
      │         ├── variable: square.n [type=int, outer=(4)]
      │         └── const: 1 [type=int]
      └── or [type=bool, outer=(1,5)]
           ├── is [type=bool, outer=(1)]
           │    ├── variable: pairs.a [type=int, outer=(1)]
           │    └── null [type=unknown]
           └── lt [type=bool, outer=(1,5)]
                ├── variable: pairs.a [type=int, outer=(1)]
                └── variable: square.sq [type=int, outer=(5)]

# The simpler plan for an inner join, to compare.
build
SELECT *
  FROM (SELECT * FROM pairs JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE (a IS NULL OR a > 2) AND n > 1 AND (a IS NULL OR a < sq)
----
select
 ├── columns: a:1(int) b:2(int) n:4(int!null) sq:5(int)
 ├── project
 │    ├── columns: pairs.a:1(int) pairs.b:2(int) square.n:4(int!null) square.sq:5(int)
 │    ├── inner-join
 │    │    ├── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null) square.n:4(int!null) square.sq:5(int)
 │    │    ├── scan
 │    │    │    └── columns: pairs.a:1(int) pairs.b:2(int) pairs.rowid:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: square.n:4(int!null) square.sq:5(int)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── and [type=bool, outer=(1,2,5)]
 │    │         │    ├── eq [type=bool, outer=(2,5)]
 │    │         │    │    ├── variable: pairs.b [type=int, outer=(2)]
 │    │         │    │    └── variable: square.sq [type=int, outer=(5)]
 │    │         │    └── gt [type=bool, outer=(1)]
 │    │         │         ├── variable: pairs.a [type=int, outer=(1)]
 │    │         │         └── const: 1 [type=int]
 │    │         └── lt [type=bool, outer=(4)]
 │    │              ├── variable: square.n [type=int, outer=(4)]
 │    │              └── const: 6 [type=int]
 │    └── projections [outer=(1,2,4,5)]
 │         ├── variable: pairs.a [type=int, outer=(1)]
 │         ├── variable: pairs.b [type=int, outer=(2)]
 │         ├── variable: square.n [type=int, outer=(4)]
 │         └── variable: square.sq [type=int, outer=(5)]
 └── and [type=bool, outer=(1,4,5)]
      ├── and [type=bool, outer=(1,4)]
      │    ├── or [type=bool, outer=(1)]
      │    │    ├── is [type=bool, outer=(1)]
      │    │    │    ├── variable: pairs.a [type=int, outer=(1)]
      │    │    │    └── null [type=unknown]
      │    │    └── gt [type=bool, outer=(1)]
      │    │         ├── variable: pairs.a [type=int, outer=(1)]
      │    │         └── const: 2 [type=int]
      │    └── gt [type=bool, outer=(4)]
      │         ├── variable: square.n [type=int, outer=(4)]
      │         └── const: 1 [type=int]
      └── or [type=bool, outer=(1,5)]
           ├── is [type=bool, outer=(1)]
           │    ├── variable: pairs.a [type=int, outer=(1)]
           │    └── null [type=unknown]
           └── lt [type=bool, outer=(1,5)]
                ├── variable: pairs.a [type=int, outer=(1)]
                └── variable: square.sq [type=int, outer=(5)]


exec-ddl
CREATE TABLE t1 (col1 INT, x INT, col2 INT, y INT)
----
TABLE t1
 ├── col1 int
 ├── x int
 ├── col2 int
 ├── y int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

exec-ddl
CREATE TABLE t2 (col3 INT, y INT, x INT, col4 INT)
----
TABLE t2
 ├── col3 int
 ├── y int
 ├── x int
 ├── col4 int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT * FROM t1 JOIN t2 USING(x)
----
project
 ├── columns: x:2(int) col1:1(int) col2:3(int) y:4(int) col3:6(int) y:7(int) col4:9(int)
 ├── inner-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,8)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         └── variable: t2.x [type=int, outer=(8)]
 └── projections [outer=(1-4,6,7,9)]
      ├── variable: t1.x [type=int, outer=(2)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t1.y [type=int, outer=(4)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      ├── variable: t2.y [type=int, outer=(7)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT * FROM t1 NATURAL JOIN t2
----
project
 ├── columns: x:2(int) y:4(int) col1:1(int) col2:3(int) col3:6(int) col4:9(int)
 ├── inner-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    └── and [type=bool, outer=(2,4,7,8)]
 │         ├── eq [type=bool, outer=(2,8)]
 │         │    ├── variable: t1.x [type=int, outer=(2)]
 │         │    └── variable: t2.x [type=int, outer=(8)]
 │         └── eq [type=bool, outer=(4,7)]
 │              ├── variable: t1.y [type=int, outer=(4)]
 │              └── variable: t2.y [type=int, outer=(7)]
 └── projections [outer=(1-4,6,9)]
      ├── variable: t1.x [type=int, outer=(2)]
      ├── variable: t1.y [type=int, outer=(4)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT * FROM t1 JOIN t2 ON t2.x=t1.x
----
project
 ├── columns: col1:1(int) x:2(int) col2:3(int) y:4(int) col3:6(int) y:7(int) x:8(int) col4:9(int)
 ├── inner-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,8)]
 │         ├── variable: t2.x [type=int, outer=(8)]
 │         └── variable: t1.x [type=int, outer=(2)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.x [type=int, outer=(2)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t1.y [type=int, outer=(4)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      ├── variable: t2.y [type=int, outer=(7)]
      ├── variable: t2.x [type=int, outer=(8)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT * FROM t1 FULL OUTER JOIN t2 USING(x)
----
project
 ├── columns: x:11(int) col1:1(int) col2:3(int) y:4(int) col3:6(int) y:7(int) col4:9(int)
 ├── project
 │    ├── columns: x:11(int) t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    ├── full-join
 │    │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    │    ├── scan
 │    │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    │    └── eq [type=bool, outer=(2,8)]
 │    │         ├── variable: t1.x [type=int, outer=(2)]
 │    │         └── variable: t2.x [type=int, outer=(8)]
 │    └── projections [outer=(1-10)]
 │         ├── coalesce [type=int, outer=(2,8)]
 │         │    ├── variable: t1.x [type=int, outer=(2)]
 │         │    └── variable: t2.x [type=int, outer=(8)]
 │         ├── variable: t1.col1 [type=int, outer=(1)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         ├── variable: t1.col2 [type=int, outer=(3)]
 │         ├── variable: t1.y [type=int, outer=(4)]
 │         ├── variable: t1.rowid [type=int, outer=(5)]
 │         ├── variable: t2.col3 [type=int, outer=(6)]
 │         ├── variable: t2.y [type=int, outer=(7)]
 │         ├── variable: t2.x [type=int, outer=(8)]
 │         ├── variable: t2.col4 [type=int, outer=(9)]
 │         └── variable: t2.rowid [type=int, outer=(10)]
 └── projections [outer=(1,3,4,6,7,9,11)]
      ├── variable: x [type=int, outer=(11)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t1.y [type=int, outer=(4)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      ├── variable: t2.y [type=int, outer=(7)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT * FROM t1 NATURAL FULL OUTER JOIN t2
----
project
 ├── columns: x:11(int) y:12(int) col1:1(int) col2:3(int) col3:6(int) col4:9(int)
 ├── project
 │    ├── columns: x:11(int) y:12(int) t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    ├── full-join
 │    │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    │    ├── scan
 │    │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    │    └── and [type=bool, outer=(2,4,7,8)]
 │    │         ├── eq [type=bool, outer=(2,8)]
 │    │         │    ├── variable: t1.x [type=int, outer=(2)]
 │    │         │    └── variable: t2.x [type=int, outer=(8)]
 │    │         └── eq [type=bool, outer=(4,7)]
 │    │              ├── variable: t1.y [type=int, outer=(4)]
 │    │              └── variable: t2.y [type=int, outer=(7)]
 │    └── projections [outer=(1-10)]
 │         ├── coalesce [type=int, outer=(2,8)]
 │         │    ├── variable: t1.x [type=int, outer=(2)]
 │         │    └── variable: t2.x [type=int, outer=(8)]
 │         ├── coalesce [type=int, outer=(4,7)]
 │         │    ├── variable: t1.y [type=int, outer=(4)]
 │         │    └── variable: t2.y [type=int, outer=(7)]
 │         ├── variable: t1.col1 [type=int, outer=(1)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         ├── variable: t1.col2 [type=int, outer=(3)]
 │         ├── variable: t1.y [type=int, outer=(4)]
 │         ├── variable: t1.rowid [type=int, outer=(5)]
 │         ├── variable: t2.col3 [type=int, outer=(6)]
 │         ├── variable: t2.y [type=int, outer=(7)]
 │         ├── variable: t2.x [type=int, outer=(8)]
 │         ├── variable: t2.col4 [type=int, outer=(9)]
 │         └── variable: t2.rowid [type=int, outer=(10)]
 └── projections [outer=(1,3,6,9,11,12)]
      ├── variable: x [type=int, outer=(11)]
      ├── variable: y [type=int, outer=(12)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.x=t2.x
----
project
 ├── columns: col1:1(int) x:2(int) col2:3(int) y:4(int) col3:6(int) y:7(int) x:8(int) col4:9(int)
 ├── full-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,8)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         └── variable: t2.x [type=int, outer=(8)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: t1.col1 [type=int, outer=(1)]
      ├── variable: t1.x [type=int, outer=(2)]
      ├── variable: t1.col2 [type=int, outer=(3)]
      ├── variable: t1.y [type=int, outer=(4)]
      ├── variable: t2.col3 [type=int, outer=(6)]
      ├── variable: t2.y [type=int, outer=(7)]
      ├── variable: t2.x [type=int, outer=(8)]
      └── variable: t2.col4 [type=int, outer=(9)]

build
SELECT t2.x, t1.x, x FROM t1 JOIN t2 USING(x)
----
project
 ├── columns: x:8(int) x:2(int) x:2(int)
 ├── inner-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,8)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         └── variable: t2.x [type=int, outer=(8)]
 └── projections [outer=(2,8)]
      ├── variable: t2.x [type=int, outer=(8)]
      ├── variable: t1.x [type=int, outer=(2)]
      └── variable: t1.x [type=int, outer=(2)]

build
SELECT t2.x, t1.x, x FROM t1 FULL OUTER JOIN t2 USING(x)
----
project
 ├── columns: x:8(int) x:2(int) x:11(int)
 ├── project
 │    ├── columns: x:11(int) t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    ├── full-join
 │    │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int)
 │    │    ├── scan
 │    │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    │    └── eq [type=bool, outer=(2,8)]
 │    │         ├── variable: t1.x [type=int, outer=(2)]
 │    │         └── variable: t2.x [type=int, outer=(8)]
 │    └── projections [outer=(1-10)]
 │         ├── coalesce [type=int, outer=(2,8)]
 │         │    ├── variable: t1.x [type=int, outer=(2)]
 │         │    └── variable: t2.x [type=int, outer=(8)]
 │         ├── variable: t1.col1 [type=int, outer=(1)]
 │         ├── variable: t1.x [type=int, outer=(2)]
 │         ├── variable: t1.col2 [type=int, outer=(3)]
 │         ├── variable: t1.y [type=int, outer=(4)]
 │         ├── variable: t1.rowid [type=int, outer=(5)]
 │         ├── variable: t2.col3 [type=int, outer=(6)]
 │         ├── variable: t2.y [type=int, outer=(7)]
 │         ├── variable: t2.x [type=int, outer=(8)]
 │         ├── variable: t2.col4 [type=int, outer=(9)]
 │         └── variable: t2.rowid [type=int, outer=(10)]
 └── projections [outer=(2,8,11)]
      ├── variable: t2.x [type=int, outer=(8)]
      ├── variable: t1.x [type=int, outer=(2)]
      └── variable: x [type=int, outer=(11)]

# Test for #19536.
build
SELECT x FROM t1 NATURAL JOIN (SELECT * FROM t2)
----
project
 ├── columns: x:2(int)
 ├── inner-join
 │    ├── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null) t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int)
 │    ├── scan
 │    │    └── columns: t1.col1:1(int) t1.x:2(int) t1.col2:3(int) t1.y:4(int) t1.rowid:5(int!null)
 │    ├── project
 │    │    ├── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int)
 │    │    ├── scan
 │    │    │    └── columns: t2.col3:6(int) t2.y:7(int) t2.x:8(int) t2.col4:9(int) t2.rowid:10(int!null)
 │    │    └── projections [outer=(6-9)]
 │    │         ├── variable: t2.col3 [type=int, outer=(6)]
 │    │         ├── variable: t2.y [type=int, outer=(7)]
 │    │         ├── variable: t2.x [type=int, outer=(8)]
 │    │         └── variable: t2.col4 [type=int, outer=(9)]
 │    └── and [type=bool, outer=(2,4,7,8)]
 │         ├── eq [type=bool, outer=(2,8)]
 │         │    ├── variable: t1.x [type=int, outer=(2)]
 │         │    └── variable: t2.x [type=int, outer=(8)]
 │         └── eq [type=bool, outer=(4,7)]
 │              ├── variable: t1.y [type=int, outer=(4)]
 │              └── variable: t2.y [type=int, outer=(7)]
 └── projections [outer=(2)]
      └── variable: t1.x [type=int, outer=(2)]

# Tests for merge join ordering information.
exec-ddl
CREATE TABLE pkBA (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a))
----
TABLE pkba
 ├── a int not null
 ├── b int not null
 ├── c int
 ├── d int
 └── INDEX primary
      ├── b int not null
      └── a int not null

exec-ddl
CREATE TABLE pkBC (a INT, b INT, c INT, d INT, PRIMARY KEY(b,c))
----
TABLE pkbc
 ├── a int
 ├── b int not null
 ├── c int not null
 ├── d int
 └── INDEX primary
      ├── b int not null
      └── c int not null

exec-ddl
CREATE TABLE pkBAC (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a,c))
----
TABLE pkbac
 ├── a int not null
 ├── b int not null
 ├── c int not null
 ├── d int
 └── INDEX primary
      ├── b int not null
      ├── a int not null
      └── c int not null

exec-ddl
CREATE TABLE pkBAD (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a,d))
----
TABLE pkbad
 ├── a int not null
 ├── b int not null
 ├── c int
 ├── d int not null
 └── INDEX primary
      ├── b int not null
      ├── a int not null
      └── d int not null

build
SELECT * FROM pkBA AS l JOIN pkBC AS r ON l.a = r.a AND l.b = r.b AND l.c = r.c
----
inner-join
 ├── columns: a:1(int!null) b:2(int!null) c:3(int) d:4(int) a:5(int) b:6(int!null) c:7(int!null) d:8(int)
 ├── scan
 │    └── columns: pkba.a:1(int!null) pkba.b:2(int!null) pkba.c:3(int) pkba.d:4(int)
 ├── scan
 │    └── columns: pkbc.a:5(int) pkbc.b:6(int!null) pkbc.c:7(int!null) pkbc.d:8(int)
 └── and [type=bool, outer=(1-3,5-7)]
      ├── and [type=bool, outer=(1,2,5,6)]
      │    ├── eq [type=bool, outer=(1,5)]
      │    │    ├── variable: pkba.a [type=int, outer=(1)]
      │    │    └── variable: pkbc.a [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(2,6)]
      │         ├── variable: pkba.b [type=int, outer=(2)]
      │         └── variable: pkbc.b [type=int, outer=(6)]
      └── eq [type=bool, outer=(3,7)]
           ├── variable: pkba.c [type=int, outer=(3)]
           └── variable: pkbc.c [type=int, outer=(7)]

build
SELECT * FROM pkBA NATURAL JOIN pkBAD
----
project
 ├── columns: a:1(int!null) b:2(int!null) c:3(int) d:4(int)
 ├── inner-join
 │    ├── columns: pkba.a:1(int!null) pkba.b:2(int!null) pkba.c:3(int) pkba.d:4(int) pkbad.a:5(int!null) pkbad.b:6(int!null) pkbad.c:7(int) pkbad.d:8(int!null)
 │    ├── scan
 │    │    └── columns: pkba.a:1(int!null) pkba.b:2(int!null) pkba.c:3(int) pkba.d:4(int)
 │    ├── scan
 │    │    └── columns: pkbad.a:5(int!null) pkbad.b:6(int!null) pkbad.c:7(int) pkbad.d:8(int!null)
 │    └── and [type=bool, outer=(1-8)]
 │         ├── eq [type=bool, outer=(1,5)]
 │         │    ├── variable: pkba.a [type=int, outer=(1)]
 │         │    └── variable: pkbad.a [type=int, outer=(5)]
 │         ├── eq [type=bool, outer=(2,6)]
 │         │    ├── variable: pkba.b [type=int, outer=(2)]
 │         │    └── variable: pkbad.b [type=int, outer=(6)]
 │         ├── eq [type=bool, outer=(3,7)]
 │         │    ├── variable: pkba.c [type=int, outer=(3)]
 │         │    └── variable: pkbad.c [type=int, outer=(7)]
 │         └── eq [type=bool, outer=(4,8)]
 │              ├── variable: pkba.d [type=int, outer=(4)]
 │              └── variable: pkbad.d [type=int, outer=(8)]
 └── projections [outer=(1-4)]
      ├── variable: pkba.a [type=int, outer=(1)]
      ├── variable: pkba.b [type=int, outer=(2)]
      ├── variable: pkba.c [type=int, outer=(3)]
      └── variable: pkba.d [type=int, outer=(4)]

build
SELECT * FROM pkBAC AS l JOIN pkBAC AS r USING(a, b, c)
----
project
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) d:4(int) d:8(int)
 ├── inner-join
 │    ├── columns: pkbac.a:1(int!null) pkbac.b:2(int!null) pkbac.c:3(int!null) pkbac.d:4(int) pkbac.a:5(int!null) pkbac.b:6(int!null) pkbac.c:7(int!null) pkbac.d:8(int)
 │    ├── scan
 │    │    └── columns: pkbac.a:1(int!null) pkbac.b:2(int!null) pkbac.c:3(int!null) pkbac.d:4(int)
 │    ├── scan
 │    │    └── columns: pkbac.a:5(int!null) pkbac.b:6(int!null) pkbac.c:7(int!null) pkbac.d:8(int)
 │    └── and [type=bool, outer=(1-3,5-7)]
 │         ├── eq [type=bool, outer=(1,5)]
 │         │    ├── variable: pkbac.a [type=int, outer=(1)]
 │         │    └── variable: pkbac.a [type=int, outer=(5)]
 │         ├── eq [type=bool, outer=(2,6)]
 │         │    ├── variable: pkbac.b [type=int, outer=(2)]
 │         │    └── variable: pkbac.b [type=int, outer=(6)]
 │         └── eq [type=bool, outer=(3,7)]
 │              ├── variable: pkbac.c [type=int, outer=(3)]
 │              └── variable: pkbac.c [type=int, outer=(7)]
 └── projections [outer=(1-4,8)]
      ├── variable: pkbac.a [type=int, outer=(1)]
      ├── variable: pkbac.b [type=int, outer=(2)]
      ├── variable: pkbac.c [type=int, outer=(3)]
      ├── variable: pkbac.d [type=int, outer=(4)]
      └── variable: pkbac.d [type=int, outer=(8)]

build
SELECT * FROM pkBAC AS l JOIN pkBAD AS r ON l.c = r.d AND l.a = r.a AND l.b = r.b
----
inner-join
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) d:4(int) a:5(int!null) b:6(int!null) c:7(int) d:8(int!null)
 ├── scan
 │    └── columns: pkbac.a:1(int!null) pkbac.b:2(int!null) pkbac.c:3(int!null) pkbac.d:4(int)
 ├── scan
 │    └── columns: pkbad.a:5(int!null) pkbad.b:6(int!null) pkbad.c:7(int) pkbad.d:8(int!null)
 └── and [type=bool, outer=(1-3,5,6,8)]
      ├── and [type=bool, outer=(1,3,5,8)]
      │    ├── eq [type=bool, outer=(3,8)]
      │    │    ├── variable: pkbac.c [type=int, outer=(3)]
      │    │    └── variable: pkbad.d [type=int, outer=(8)]
      │    └── eq [type=bool, outer=(1,5)]
      │         ├── variable: pkbac.a [type=int, outer=(1)]
      │         └── variable: pkbad.a [type=int, outer=(5)]
      └── eq [type=bool, outer=(2,6)]
           ├── variable: pkbac.b [type=int, outer=(2)]
           └── variable: pkbad.b [type=int, outer=(6)]

# Tests with joins with merged columns of collated string type.
exec-ddl
CREATE TABLE str1 (a INT PRIMARY KEY, s STRING COLLATE en_u_ks_level1)
----
TABLE str1
 ├── a int not null
 ├── s collatedstring{en_u_ks_level1}
 └── INDEX primary
      └── a int not null

exec-ddl
CREATE TABLE str2 (a INT PRIMARY KEY, s STRING COLLATE en_u_ks_level1)
----
TABLE str2
 ├── a int not null
 ├── s collatedstring{en_u_ks_level1}
 └── INDEX primary
      └── a int not null

build
SELECT s, str1.s, str2.s FROM str1 INNER JOIN str2 USING(s)
----
project
 ├── columns: s:2(collatedstring{en_u_ks_level1}) s:2(collatedstring{en_u_ks_level1}) s:4(collatedstring{en_u_ks_level1})
 ├── inner-join
 │    ├── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    ├── scan
 │    │    └── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1})
 │    ├── scan
 │    │    └── columns: str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    └── eq [type=bool, outer=(2,4)]
 │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 └── projections [outer=(2,4)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]

build
SELECT s, str1.s, str2.s FROM str1 LEFT OUTER JOIN str2 USING(s)
----
project
 ├── columns: s:2(collatedstring{en_u_ks_level1}) s:2(collatedstring{en_u_ks_level1}) s:4(collatedstring{en_u_ks_level1})
 ├── left-join
 │    ├── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int) str2.s:4(collatedstring{en_u_ks_level1})
 │    ├── scan
 │    │    └── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1})
 │    ├── scan
 │    │    └── columns: str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    └── eq [type=bool, outer=(2,4)]
 │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 └── projections [outer=(2,4)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]

build
SELECT s, str1.s, str2.s FROM str1 RIGHT OUTER JOIN str2 USING(s)
----
project
 ├── columns: s:5(collatedstring{en_u_ks_level1}) s:2(collatedstring{en_u_ks_level1}) s:4(collatedstring{en_u_ks_level1})
 ├── project
 │    ├── columns: s:5(collatedstring{en_u_ks_level1}) str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    ├── right-join
 │    │    ├── columns: str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    └── eq [type=bool, outer=(2,4)]
 │    │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │    │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │    └── projections [outer=(1-4)]
 │         ├── coalesce [type=collatedstring{en_u_ks_level1}, outer=(2,4)]
 │         │    ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         │    └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │         ├── variable: str1.a [type=int, outer=(1)]
 │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         ├── variable: str2.a [type=int, outer=(3)]
 │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 └── projections [outer=(2,4,5)]
      ├── variable: s [type=collatedstring{en_u_ks_level1}, outer=(5)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]

build
SELECT s, str1.s, str2.s FROM str1 FULL OUTER JOIN str2 USING(s)
----
project
 ├── columns: s:5(collatedstring{en_u_ks_level1}) s:2(collatedstring{en_u_ks_level1}) s:4(collatedstring{en_u_ks_level1})
 ├── project
 │    ├── columns: s:5(collatedstring{en_u_ks_level1}) str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int) str2.s:4(collatedstring{en_u_ks_level1})
 │    ├── full-join
 │    │    ├── columns: str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    └── eq [type=bool, outer=(2,4)]
 │    │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │    │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │    └── projections [outer=(1-4)]
 │         ├── coalesce [type=collatedstring{en_u_ks_level1}, outer=(2,4)]
 │         │    ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         │    └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │         ├── variable: str1.a [type=int, outer=(1)]
 │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         ├── variable: str2.a [type=int, outer=(3)]
 │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 └── projections [outer=(2,4,5)]
      ├── variable: s [type=collatedstring{en_u_ks_level1}, outer=(5)]
      ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
      └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]

# Verify that we resolve the merged column a to str2.a but use IFNULL for
# column s which is a collated string.
build
SELECT * FROM str1 RIGHT OUTER JOIN str2 USING(a, s)
----
project
 ├── columns: a:3(int!null) s:5(collatedstring{en_u_ks_level1})
 ├── project
 │    ├── columns: str2.a:3(int!null) s:5(collatedstring{en_u_ks_level1}) str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.s:4(collatedstring{en_u_ks_level1})
 │    ├── right-join
 │    │    ├── columns: str1.a:1(int) str1.s:2(collatedstring{en_u_ks_level1}) str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str1.a:1(int!null) str1.s:2(collatedstring{en_u_ks_level1})
 │    │    ├── scan
 │    │    │    └── columns: str2.a:3(int!null) str2.s:4(collatedstring{en_u_ks_level1})
 │    │    └── and [type=bool, outer=(1-4)]
 │    │         ├── eq [type=bool, outer=(1,3)]
 │    │         │    ├── variable: str1.a [type=int, outer=(1)]
 │    │         │    └── variable: str2.a [type=int, outer=(3)]
 │    │         └── eq [type=bool, outer=(2,4)]
 │    │              ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │    │              └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │    └── projections [outer=(1-4)]
 │         ├── variable: str2.a [type=int, outer=(3)]
 │         ├── coalesce [type=collatedstring{en_u_ks_level1}, outer=(2,4)]
 │         │    ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         │    └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 │         ├── variable: str1.a [type=int, outer=(1)]
 │         ├── variable: str1.s [type=collatedstring{en_u_ks_level1}, outer=(2)]
 │         └── variable: str2.s [type=collatedstring{en_u_ks_level1}, outer=(4)]
 └── projections [outer=(3,5)]
      ├── variable: str2.a [type=int, outer=(3)]
      └── variable: s [type=collatedstring{en_u_ks_level1}, outer=(5)]


exec-ddl
CREATE TABLE xyu (x INT, y INT, u INT, PRIMARY KEY(x,y,u))
----
TABLE xyu
 ├── x int not null
 ├── y int not null
 ├── u int not null
 └── INDEX primary
      ├── x int not null
      ├── y int not null
      └── u int not null

exec-ddl
CREATE TABLE xyv (x INT, y INT, v INT, PRIMARY KEY(x,y,v))
----
TABLE xyv
 ├── x int not null
 ├── y int not null
 ├── v int not null
 └── INDEX primary
      ├── x int not null
      ├── y int not null
      └── v int not null

build
SELECT * FROM xyu INNER JOIN xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) v:6(int!null)
 ├── select
 │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    ├── inner-join
 │    │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(1)]
 │         ├── variable: xyu.x [type=int, outer=(1)]
 │         └── const: 2 [type=int]
 └── projections [outer=(1-3,6)]
      ├── variable: xyu.x [type=int, outer=(1)]
      ├── variable: xyu.y [type=int, outer=(2)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM xyu LEFT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) v:6(int)
 ├── select
 │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    ├── left-join
 │    │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(1)]
 │         ├── variable: xyu.x [type=int, outer=(1)]
 │         └── const: 2 [type=int]
 └── projections [outer=(1-3,6)]
      ├── variable: xyu.x [type=int, outer=(1)]
      ├── variable: xyu.y [type=int, outer=(2)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM xyu RIGHT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:4(int!null) y:5(int!null) u:3(int) v:6(int!null)
 ├── select
 │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    ├── right-join
 │    │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(4)]
 │         ├── variable: xyv.x [type=int, outer=(4)]
 │         └── const: 2 [type=int]
 └── projections [outer=(3-6)]
      ├── variable: xyv.x [type=int, outer=(4)]
      ├── variable: xyv.y [type=int, outer=(5)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM xyu FULL OUTER JOIN xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:7(int) y:8(int) u:3(int) v:6(int)
 ├── select
 │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int) x:7(int) y:8(int)
 │    ├── project
 │    │    ├── columns: x:7(int) y:8(int) xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    ├── full-join
 │    │    │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    │    ├── scan
 │    │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    │    ├── scan
 │    │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │    │         ├── eq [type=bool, outer=(1,4)]
 │    │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │    │         └── eq [type=bool, outer=(2,5)]
 │    │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    │    └── projections [outer=(1-6)]
 │    │         ├── coalesce [type=int, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         ├── coalesce [type=int, outer=(2,5)]
 │    │         │    ├── variable: xyu.y [type=int, outer=(2)]
 │    │         │    └── variable: xyv.y [type=int, outer=(5)]
 │    │         ├── variable: xyu.x [type=int, outer=(1)]
 │    │         ├── variable: xyu.y [type=int, outer=(2)]
 │    │         ├── variable: xyu.u [type=int, outer=(3)]
 │    │         ├── variable: xyv.x [type=int, outer=(4)]
 │    │         ├── variable: xyv.y [type=int, outer=(5)]
 │    │         └── variable: xyv.v [type=int, outer=(6)]
 │    └── gt [type=bool, outer=(7)]
 │         ├── variable: x [type=int, outer=(7)]
 │         └── const: 2 [type=int]
 └── projections [outer=(3,6-8)]
      ├── variable: x [type=int, outer=(7)]
      ├── variable: y [type=int, outer=(8)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

# Verify that we transfer constraints between the two sides.
build
SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y WHERE xyu.x = 1 AND xyu.y < 10
----
select
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) x:4(int!null) y:5(int!null) v:6(int!null)
 ├── inner-join
 │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    ├── scan
 │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    ├── scan
 │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    └── and [type=bool, outer=(1,2,4,5)]
 │         ├── eq [type=bool, outer=(1,4)]
 │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │         │    └── variable: xyv.x [type=int, outer=(4)]
 │         └── eq [type=bool, outer=(2,5)]
 │              ├── variable: xyu.y [type=int, outer=(2)]
 │              └── variable: xyv.y [type=int, outer=(5)]
 └── and [type=bool, outer=(1,2)]
      ├── eq [type=bool, outer=(1)]
      │    ├── variable: xyu.x [type=int, outer=(1)]
      │    └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]

build
SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
inner-join
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) x:4(int!null) y:5(int!null) v:6(int!null)
 ├── scan
 │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 ├── scan
 │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(1,2,4,5)]
      │    ├── and [type=bool, outer=(1,2,4,5)]
      │    │    ├── eq [type=bool, outer=(1,4)]
      │    │    │    ├── variable: xyu.x [type=int, outer=(1)]
      │    │    │    └── variable: xyv.x [type=int, outer=(4)]
      │    │    └── eq [type=bool, outer=(2,5)]
      │    │         ├── variable: xyu.y [type=int, outer=(2)]
      │    │         └── variable: xyv.y [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(1)]
      │         ├── variable: xyu.x [type=int, outer=(1)]
      │         └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]

build
SELECT * FROM xyu LEFT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
left-join
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) x:4(int) y:5(int) v:6(int)
 ├── scan
 │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 ├── scan
 │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(1,2,4,5)]
      │    ├── and [type=bool, outer=(1,2,4,5)]
      │    │    ├── eq [type=bool, outer=(1,4)]
      │    │    │    ├── variable: xyu.x [type=int, outer=(1)]
      │    │    │    └── variable: xyv.x [type=int, outer=(4)]
      │    │    └── eq [type=bool, outer=(2,5)]
      │    │         ├── variable: xyu.y [type=int, outer=(2)]
      │    │         └── variable: xyv.y [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(1)]
      │         ├── variable: xyu.x [type=int, outer=(1)]
      │         └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]

build
SELECT * FROM xyu RIGHT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
right-join
 ├── columns: x:1(int) y:2(int) u:3(int) x:4(int!null) y:5(int!null) v:6(int!null)
 ├── scan
 │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 ├── scan
 │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(1,2,4,5)]
      │    ├── and [type=bool, outer=(1,2,4,5)]
      │    │    ├── eq [type=bool, outer=(1,4)]
      │    │    │    ├── variable: xyu.x [type=int, outer=(1)]
      │    │    │    └── variable: xyv.x [type=int, outer=(4)]
      │    │    └── eq [type=bool, outer=(2,5)]
      │    │         ├── variable: xyu.y [type=int, outer=(2)]
      │    │         └── variable: xyv.y [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(1)]
      │         ├── variable: xyu.x [type=int, outer=(1)]
      │         └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]


# Test OUTER joins that are run in the distSQL merge joiner

build
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) v:6(int)
 ├── select
 │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    ├── left-join
 │    │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(1)]
 │         ├── variable: xyu.x [type=int, outer=(1)]
 │         └── const: 2 [type=int]
 └── projections [outer=(1-3,6)]
      ├── variable: xyu.x [type=int, outer=(1)]
      ├── variable: xyu.y [type=int, outer=(2)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:4(int!null) y:5(int!null) u:3(int) v:6(int!null)
 ├── select
 │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    ├── right-join
 │    │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(4)]
 │         ├── variable: xyv.x [type=int, outer=(4)]
 │         └── const: 2 [type=int]
 └── projections [outer=(3-6)]
      ├── variable: xyv.x [type=int, outer=(4)]
      ├── variable: xyv.y [type=int, outer=(5)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu FULL OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
project
 ├── columns: x:7(int) y:8(int) u:3(int) v:6(int)
 ├── select
 │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int) x:7(int) y:8(int)
 │    ├── project
 │    │    ├── columns: x:7(int) y:8(int) xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    ├── full-join
 │    │    │    ├── columns: xyu.x:1(int) xyu.y:2(int) xyu.u:3(int) xyv.x:4(int) xyv.y:5(int) xyv.v:6(int)
 │    │    │    ├── scan
 │    │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    │    ├── scan
 │    │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │    │         ├── eq [type=bool, outer=(1,4)]
 │    │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │    │         └── eq [type=bool, outer=(2,5)]
 │    │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    │    └── projections [outer=(1-6)]
 │    │         ├── coalesce [type=int, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         ├── coalesce [type=int, outer=(2,5)]
 │    │         │    ├── variable: xyu.y [type=int, outer=(2)]
 │    │         │    └── variable: xyv.y [type=int, outer=(5)]
 │    │         ├── variable: xyu.x [type=int, outer=(1)]
 │    │         ├── variable: xyu.y [type=int, outer=(2)]
 │    │         ├── variable: xyu.u [type=int, outer=(3)]
 │    │         ├── variable: xyv.x [type=int, outer=(4)]
 │    │         ├── variable: xyv.y [type=int, outer=(5)]
 │    │         └── variable: xyv.v [type=int, outer=(6)]
 │    └── gt [type=bool, outer=(7)]
 │         ├── variable: x [type=int, outer=(7)]
 │         └── const: 2 [type=int]
 └── projections [outer=(3,6-8)]
      ├── variable: x [type=int, outer=(7)]
      ├── variable: y [type=int, outer=(8)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]

build
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
left-join
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) x:4(int) y:5(int) v:6(int)
 ├── scan
 │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 ├── scan
 │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(1,2,4,5)]
      │    ├── and [type=bool, outer=(1,2,4,5)]
      │    │    ├── eq [type=bool, outer=(1,4)]
      │    │    │    ├── variable: xyu.x [type=int, outer=(1)]
      │    │    │    └── variable: xyv.x [type=int, outer=(4)]
      │    │    └── eq [type=bool, outer=(2,5)]
      │    │         ├── variable: xyu.y [type=int, outer=(2)]
      │    │         └── variable: xyv.y [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(1)]
      │         ├── variable: xyu.x [type=int, outer=(1)]
      │         └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]

build
SELECT * FROM xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
right-join
 ├── columns: x:1(int) y:2(int) u:3(int) x:4(int!null) y:5(int!null) v:6(int!null)
 ├── scan
 │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 ├── scan
 │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 └── and [type=bool, outer=(1,2,4,5)]
      ├── and [type=bool, outer=(1,2,4,5)]
      │    ├── and [type=bool, outer=(1,2,4,5)]
      │    │    ├── eq [type=bool, outer=(1,4)]
      │    │    │    ├── variable: xyu.x [type=int, outer=(1)]
      │    │    │    └── variable: xyv.x [type=int, outer=(4)]
      │    │    └── eq [type=bool, outer=(2,5)]
      │    │         ├── variable: xyu.y [type=int, outer=(2)]
      │    │         └── variable: xyv.y [type=int, outer=(5)]
      │    └── eq [type=bool, outer=(1)]
      │         ├── variable: xyu.x [type=int, outer=(1)]
      │         └── const: 1 [type=int]
      └── lt [type=bool, outer=(2)]
           ├── variable: xyu.y [type=int, outer=(2)]
           └── const: 10 [type=int]

# Regression test for #20472: break up tuple inequalities.
build
SELECT * FROM xyu JOIN xyv USING(x, y) WHERE (x, y, u) > (1, 2, 3)
----
project
 ├── columns: x:1(int!null) y:2(int!null) u:3(int!null) v:6(int!null)
 ├── select
 │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    ├── inner-join
 │    │    ├── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null) xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyu.x:1(int!null) xyu.y:2(int!null) xyu.u:3(int!null)
 │    │    ├── scan
 │    │    │    └── columns: xyv.x:4(int!null) xyv.y:5(int!null) xyv.v:6(int!null)
 │    │    └── and [type=bool, outer=(1,2,4,5)]
 │    │         ├── eq [type=bool, outer=(1,4)]
 │    │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │    │         │    └── variable: xyv.x [type=int, outer=(4)]
 │    │         └── eq [type=bool, outer=(2,5)]
 │    │              ├── variable: xyu.y [type=int, outer=(2)]
 │    │              └── variable: xyv.y [type=int, outer=(5)]
 │    └── gt [type=bool, outer=(1-3)]
 │         ├── tuple [type=tuple{int, int, int}, outer=(1-3)]
 │         │    ├── variable: xyu.x [type=int, outer=(1)]
 │         │    ├── variable: xyu.y [type=int, outer=(2)]
 │         │    └── variable: xyu.u [type=int, outer=(3)]
 │         └── tuple [type=tuple{int, int, int}]
 │              ├── const: 1 [type=int]
 │              ├── const: 2 [type=int]
 │              └── const: 3 [type=int]
 └── projections [outer=(1-3,6)]
      ├── variable: xyu.x [type=int, outer=(1)]
      ├── variable: xyu.y [type=int, outer=(2)]
      ├── variable: xyu.u [type=int, outer=(3)]
      └── variable: xyv.v [type=int, outer=(6)]


# Regression test for #20858.

exec-ddl
CREATE TABLE l (a INT PRIMARY KEY)
----
TABLE l
 ├── a int not null
 └── INDEX primary
      └── a int not null

exec-ddl
CREATE TABLE r (a INT PRIMARY KEY)
----
TABLE r
 ├── a int not null
 └── INDEX primary
      └── a int not null

build
SELECT * FROM l LEFT OUTER JOIN r ON l.a = r.a WHERE l.a = 3;
----
select
 ├── columns: a:1(int!null) a:2(int)
 ├── left-join
 │    ├── columns: l.a:1(int!null) r.a:2(int)
 │    ├── scan
 │    │    └── columns: l.a:1(int!null)
 │    ├── scan
 │    │    └── columns: r.a:2(int!null)
 │    └── eq [type=bool, outer=(1,2)]
 │         ├── variable: l.a [type=int, outer=(1)]
 │         └── variable: r.a [type=int, outer=(2)]
 └── eq [type=bool, outer=(1)]
      ├── variable: l.a [type=int, outer=(1)]
      └── const: 3 [type=int]

build
SELECT * FROM l RIGHT OUTER JOIN r ON l.a = r.a WHERE r.a = 3;
----
select
 ├── columns: a:1(int) a:2(int!null)
 ├── right-join
 │    ├── columns: l.a:1(int) r.a:2(int!null)
 │    ├── scan
 │    │    └── columns: l.a:1(int!null)
 │    ├── scan
 │    │    └── columns: r.a:2(int!null)
 │    └── eq [type=bool, outer=(1,2)]
 │         ├── variable: l.a [type=int, outer=(1)]
 │         └── variable: r.a [type=int, outer=(2)]
 └── eq [type=bool, outer=(2)]
      ├── variable: r.a [type=int, outer=(2)]
      └── const: 3 [type=int]

build
SELECT * FROM l LEFT OUTER JOIN r USING(a) WHERE a = 1
----
project
 ├── columns: a:1(int!null)
 ├── select
 │    ├── columns: l.a:1(int!null) r.a:2(int)
 │    ├── left-join
 │    │    ├── columns: l.a:1(int!null) r.a:2(int)
 │    │    ├── scan
 │    │    │    └── columns: l.a:1(int!null)
 │    │    ├── scan
 │    │    │    └── columns: r.a:2(int!null)
 │    │    └── eq [type=bool, outer=(1,2)]
 │    │         ├── variable: l.a [type=int, outer=(1)]
 │    │         └── variable: r.a [type=int, outer=(2)]
 │    └── eq [type=bool, outer=(1)]
 │         ├── variable: l.a [type=int, outer=(1)]
 │         └── const: 1 [type=int]
 └── projections [outer=(1)]
      └── variable: l.a [type=int, outer=(1)]

build
SELECT * FROM l RIGHT OUTER JOIN r USING(a) WHERE a = 3
----
project
 ├── columns: a:2(int!null)
 ├── select
 │    ├── columns: l.a:1(int) r.a:2(int!null)
 │    ├── right-join
 │    │    ├── columns: l.a:1(int) r.a:2(int!null)
 │    │    ├── scan
 │    │    │    └── columns: l.a:1(int!null)
 │    │    ├── scan
 │    │    │    └── columns: r.a:2(int!null)
 │    │    └── eq [type=bool, outer=(1,2)]
 │    │         ├── variable: l.a [type=int, outer=(1)]
 │    │         └── variable: r.a [type=int, outer=(2)]
 │    └── eq [type=bool, outer=(2)]
 │         ├── variable: r.a [type=int, outer=(2)]
 │         └── const: 3 [type=int]
 └── projections [outer=(2)]
      └── variable: r.a [type=int, outer=(2)]

# Regression tests for #21243
exec-ddl
CREATE TABLE abcdef (
  a INT NOT NULL,
  b INT NOT NULL,
  c INT NOT NULL,
  d INT NOT NULL,
  e INT NULL,
  f INT NULL,
  PRIMARY KEY (a ASC, b ASC, c DESC, d ASC)
)
----
TABLE abcdef
 ├── a int not null
 ├── b int not null
 ├── c int not null
 ├── d int not null
 ├── e int
 ├── f int
 └── INDEX primary
      ├── a int not null
      ├── b int not null
      ├── c int not null desc
      └── d int not null

exec-ddl
CREATE TABLE abg (
  a INT NOT NULL,
  b INT NOT NULL,
  g INT NULL,
  PRIMARY KEY (a ASC, b ASC)
);
----
TABLE abg
 ├── a int not null
 ├── b int not null
 ├── g int
 └── INDEX primary
      ├── a int not null
      └── b int not null

build
SELECT * FROM abcdef join (select * from abg) USING (a,b) WHERE ((a,b)>(1,2) OR ((a,b)=(1,2) AND c < 6) OR ((a,b,c)=(1,2,6) AND d > 8))
----
project
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) d:4(int!null) e:5(int) f:6(int) g:9(int)
 ├── select
 │    ├── columns: abcdef.a:1(int!null) abcdef.b:2(int!null) abcdef.c:3(int!null) abcdef.d:4(int!null) abcdef.e:5(int) abcdef.f:6(int) abg.a:7(int!null) abg.b:8(int!null) abg.g:9(int)
 │    ├── inner-join
 │    │    ├── columns: abcdef.a:1(int!null) abcdef.b:2(int!null) abcdef.c:3(int!null) abcdef.d:4(int!null) abcdef.e:5(int) abcdef.f:6(int) abg.a:7(int!null) abg.b:8(int!null) abg.g:9(int)
 │    │    ├── scan
 │    │    │    └── columns: abcdef.a:1(int!null) abcdef.b:2(int!null) abcdef.c:3(int!null) abcdef.d:4(int!null) abcdef.e:5(int) abcdef.f:6(int)
 │    │    ├── scan
 │    │    │    └── columns: abg.a:7(int!null) abg.b:8(int!null) abg.g:9(int)
 │    │    └── and [type=bool, outer=(1,2,7,8)]
 │    │         ├── eq [type=bool, outer=(1,7)]
 │    │         │    ├── variable: abcdef.a [type=int, outer=(1)]
 │    │         │    └── variable: abg.a [type=int, outer=(7)]
 │    │         └── eq [type=bool, outer=(2,8)]
 │    │              ├── variable: abcdef.b [type=int, outer=(2)]
 │    │              └── variable: abg.b [type=int, outer=(8)]
 │    └── or [type=bool, outer=(1-4)]
 │         ├── or [type=bool, outer=(1-3)]
 │         │    ├── gt [type=bool, outer=(1,2)]
 │         │    │    ├── tuple [type=tuple{int, int}, outer=(1,2)]
 │         │    │    │    ├── variable: abcdef.a [type=int, outer=(1)]
 │         │    │    │    └── variable: abcdef.b [type=int, outer=(2)]
 │         │    │    └── tuple [type=tuple{int, int}]
 │         │    │         ├── const: 1 [type=int]
 │         │    │         └── const: 2 [type=int]
 │         │    └── and [type=bool, outer=(1-3)]
 │         │         ├── eq [type=bool, outer=(1,2)]
 │         │         │    ├── tuple [type=tuple{int, int}, outer=(1,2)]
 │         │         │    │    ├── variable: abcdef.a [type=int, outer=(1)]
 │         │         │    │    └── variable: abcdef.b [type=int, outer=(2)]
 │         │         │    └── tuple [type=tuple{int, int}]
 │         │         │         ├── const: 1 [type=int]
 │         │         │         └── const: 2 [type=int]
 │         │         └── lt [type=bool, outer=(3)]
 │         │              ├── variable: abcdef.c [type=int, outer=(3)]
 │         │              └── const: 6 [type=int]
 │         └── and [type=bool, outer=(1-4)]
 │              ├── eq [type=bool, outer=(1-3)]
 │              │    ├── tuple [type=tuple{int, int, int}, outer=(1-3)]
 │              │    │    ├── variable: abcdef.a [type=int, outer=(1)]
 │              │    │    ├── variable: abcdef.b [type=int, outer=(2)]
 │              │    │    └── variable: abcdef.c [type=int, outer=(3)]
 │              │    └── tuple [type=tuple{int, int, int}]
 │              │         ├── const: 1 [type=int]
 │              │         ├── const: 2 [type=int]
 │              │         └── const: 6 [type=int]
 │              └── gt [type=bool, outer=(4)]
 │                   ├── variable: abcdef.d [type=int, outer=(4)]
 │                   └── const: 8 [type=int]
 └── projections [outer=(1-6,9)]
      ├── variable: abcdef.a [type=int, outer=(1)]
      ├── variable: abcdef.b [type=int, outer=(2)]
      ├── variable: abcdef.c [type=int, outer=(3)]
      ├── variable: abcdef.d [type=int, outer=(4)]
      ├── variable: abcdef.e [type=int, outer=(5)]
      ├── variable: abcdef.f [type=int, outer=(6)]
      └── variable: abg.g [type=int, outer=(9)]

# Regression tests for mixed-type equality columns (#22514).
exec-ddl
CREATE TABLE foo (
  a INT,
  b INT,
  c FLOAT,
  d FLOAT
)
----
TABLE foo
 ├── a int
 ├── b int
 ├── c float
 ├── d float
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

exec-ddl
CREATE TABLE bar (
  a INT,
  b FLOAT,
  c FLOAT,
  d INT
)
----
TABLE bar
 ├── a int
 ├── b float
 ├── c float
 ├── d int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

# Only a and c can be equality columns.
build
SELECT * FROM foo NATURAL JOIN bar
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── and [type=bool, outer=(1-4,6-9)]
 │         ├── eq [type=bool, outer=(1,6)]
 │         │    ├── variable: foo.a [type=int, outer=(1)]
 │         │    └── variable: bar.a [type=int, outer=(6)]
 │         ├── eq [type=bool, outer=(2,7)]
 │         │    ├── variable: foo.b [type=int, outer=(2)]
 │         │    └── variable: bar.b [type=float, outer=(7)]
 │         ├── eq [type=bool, outer=(3,8)]
 │         │    ├── variable: foo.c [type=float, outer=(3)]
 │         │    └── variable: bar.c [type=float, outer=(8)]
 │         └── eq [type=bool, outer=(4,9)]
 │              ├── variable: foo.d [type=float, outer=(4)]
 │              └── variable: bar.d [type=int, outer=(9)]
 └── projections [outer=(1-4)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      └── variable: foo.d [type=float, outer=(4)]

# b can't be an equality column.
build
SELECT * FROM foo JOIN bar USING (b)
----
project
 ├── columns: b:2(int) a:1(int) c:3(float) d:4(float) a:6(int) c:8(float) d:9(int)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,7)]
 │         ├── variable: foo.b [type=int, outer=(2)]
 │         └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,6,8,9)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.a [type=int, outer=(6)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

# Only a can be an equality column.
build
SELECT * FROM foo JOIN bar USING (a, b)
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) c:8(float) d:9(int)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── and [type=bool, outer=(1,2,6,7)]
 │         ├── eq [type=bool, outer=(1,6)]
 │         │    ├── variable: foo.a [type=int, outer=(1)]
 │         │    └── variable: bar.a [type=int, outer=(6)]
 │         └── eq [type=bool, outer=(2,7)]
 │              ├── variable: foo.b [type=int, outer=(2)]
 │              └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,8,9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

# Only a and c can be equality columns.
build
SELECT * FROM foo JOIN bar USING (a, b, c)
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) d:9(int)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── and [type=bool, outer=(1-3,6-8)]
 │         ├── eq [type=bool, outer=(1,6)]
 │         │    ├── variable: foo.a [type=int, outer=(1)]
 │         │    └── variable: bar.a [type=int, outer=(6)]
 │         ├── eq [type=bool, outer=(2,7)]
 │         │    ├── variable: foo.b [type=int, outer=(2)]
 │         │    └── variable: bar.b [type=float, outer=(7)]
 │         └── eq [type=bool, outer=(3,8)]
 │              ├── variable: foo.c [type=float, outer=(3)]
 │              └── variable: bar.c [type=float, outer=(8)]
 └── projections [outer=(1-4,9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      └── variable: bar.d [type=int, outer=(9)]

# b can't be an equality column.
build
SELECT * FROM foo JOIN bar ON foo.b = bar.b
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) a:6(int) b:7(float) c:8(float) d:9(int)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── eq [type=bool, outer=(2,7)]
 │         ├── variable: foo.b [type=int, outer=(2)]
 │         └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.a [type=int, outer=(6)]
      ├── variable: bar.b [type=float, outer=(7)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

# Only a can be an equality column.
build
SELECT * FROM foo JOIN bar ON foo.a = bar.a AND foo.b = bar.b
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) a:6(int) b:7(float) c:8(float) d:9(int)
 ├── inner-join
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── scan
 │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    ├── scan
 │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    └── and [type=bool, outer=(1,2,6,7)]
 │         ├── eq [type=bool, outer=(1,6)]
 │         │    ├── variable: foo.a [type=int, outer=(1)]
 │         │    └── variable: bar.a [type=int, outer=(6)]
 │         └── eq [type=bool, outer=(2,7)]
 │              ├── variable: foo.b [type=int, outer=(2)]
 │              └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.a [type=int, outer=(6)]
      ├── variable: bar.b [type=float, outer=(7)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

build
SELECT * FROM foo, bar WHERE foo.b = bar.b
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) a:6(int) b:7(float) c:8(float) d:9(int)
 ├── select
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── inner-join
 │    │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    ├── scan
 │    │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    └── true [type=bool]
 │    └── eq [type=bool, outer=(2,7)]
 │         ├── variable: foo.b [type=int, outer=(2)]
 │         └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.a [type=int, outer=(6)]
      ├── variable: bar.b [type=float, outer=(7)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

# Only a can be an equality column.
build
SELECT * FROM foo, bar WHERE foo.a = bar.a AND foo.b = bar.b
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) a:6(int) b:7(float) c:8(float) d:9(int)
 ├── select
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── inner-join
 │    │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    ├── scan
 │    │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    └── true [type=bool]
 │    └── and [type=bool, outer=(1,2,6,7)]
 │         ├── eq [type=bool, outer=(1,6)]
 │         │    ├── variable: foo.a [type=int, outer=(1)]
 │         │    └── variable: bar.a [type=int, outer=(6)]
 │         └── eq [type=bool, outer=(2,7)]
 │              ├── variable: foo.b [type=int, outer=(2)]
 │              └── variable: bar.b [type=float, outer=(7)]
 └── projections [outer=(1-4,6-9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.a [type=int, outer=(6)]
      ├── variable: bar.b [type=float, outer=(7)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

# Only a and c can be equality columns.
build
SELECT * FROM foo JOIN bar USING (a, b) WHERE foo.c = bar.c AND foo.d = bar.d
----
project
 ├── columns: a:1(int) b:2(int) c:3(float) d:4(float) c:8(float) d:9(int)
 ├── select
 │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    ├── inner-join
 │    │    ├── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null) bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    ├── scan
 │    │    │    └── columns: foo.a:1(int) foo.b:2(int) foo.c:3(float) foo.d:4(float) foo.rowid:5(int!null)
 │    │    ├── scan
 │    │    │    └── columns: bar.a:6(int) bar.b:7(float) bar.c:8(float) bar.d:9(int) bar.rowid:10(int!null)
 │    │    └── and [type=bool, outer=(1,2,6,7)]
 │    │         ├── eq [type=bool, outer=(1,6)]
 │    │         │    ├── variable: foo.a [type=int, outer=(1)]
 │    │         │    └── variable: bar.a [type=int, outer=(6)]
 │    │         └── eq [type=bool, outer=(2,7)]
 │    │              ├── variable: foo.b [type=int, outer=(2)]
 │    │              └── variable: bar.b [type=float, outer=(7)]
 │    └── and [type=bool, outer=(3,4,8,9)]
 │         ├── eq [type=bool, outer=(3,8)]
 │         │    ├── variable: foo.c [type=float, outer=(3)]
 │         │    └── variable: bar.c [type=float, outer=(8)]
 │         └── eq [type=bool, outer=(4,9)]
 │              ├── variable: foo.d [type=float, outer=(4)]
 │              └── variable: bar.d [type=int, outer=(9)]
 └── projections [outer=(1-4,8,9)]
      ├── variable: foo.a [type=int, outer=(1)]
      ├── variable: foo.b [type=int, outer=(2)]
      ├── variable: foo.c [type=float, outer=(3)]
      ├── variable: foo.d [type=float, outer=(4)]
      ├── variable: bar.c [type=float, outer=(8)]
      └── variable: bar.d [type=int, outer=(9)]

exec-ddl
CREATE TABLE t.kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----
TABLE kv
 ├── k int not null
 ├── v int
 ├── w int
 ├── s string
 └── INDEX primary
      └── k int not null

build
SELECT k FROM kv, (SELECT 1 AS k)
----
project
 ├── columns: k:5(int)
 ├── inner-join
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) k:5(int)
 │    ├── scan
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    ├── project
 │    │    ├── columns: k:5(int)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple{}]
 │    │    └── projections
 │    │         └── const: 1 [type=int]
 │    └── true [type=bool]
 └── projections [outer=(5)]
      └── variable: k [type=int, outer=(5)]

# TODO(rytaft): This test case will fail until we implement subquery
# replacement.
# build
# select * from (select 1 as k), (select 2 as k) where 1 in (select k from kv)
# ----
# select
#  ├── columns: k:int:null:1 k:int:null:2
#  ├── inner-join
#  │    ├── columns: k:int:null:1 k:int:null:2
#  │    ├── project
#  │    │    ├── columns: k:int:null:1
#  │    │    ├── values
#  │    │    │    └── tuple [type=tuple{}]
#  │    │    └── projections
#  │    │         └── const: 1 [type=int]
#  │    ├── project
#  │    │    ├── columns: k:int:null:2
#  │    │    ├── values
#  │    │    │    └── tuple [type=tuple{}]
#  │    │    └── projections
#  │    │         └── const: 2 [type=int]
#  │    └── true [type=bool]
#  └── in [type=bool]
#       ├── const: 1 [type=int]
#       └── subquery [type=unknown]
#            ├── project
#            │    ├── columns: kv.k:int:3
#            │    ├── scan
#            │    │    └── columns: kv.k:int:3 kv.v:int:null:4 kv.w:int:null:5 kv.s:string:null:6
#            │    └── projections
#            │         └── variable: kv.k [type=int]
#            └── variable: kv.k [type=int]

# Test natural outer join when the left side has unknown type
build
SELECT * FROM (VALUES (NULL, NULL)) NATURAL FULL OUTER JOIN (SELECT * FROM (VALUES (1, 1)))
----
project
 ├── columns: column1:5(int) column2:6(int)
 ├── project
 │    ├── columns: column1:5(int) column2:6(int) column1:1(unknown) column2:2(unknown) column1:3(int) column2:4(int)
 │    ├── full-join
 │    │    ├── columns: column1:1(unknown) column2:2(unknown) column1:3(int) column2:4(int)
 │    │    ├── values
 │    │    │    ├── columns: column1:1(unknown) column2:2(unknown)
 │    │    │    └── tuple [type=tuple{unknown, unknown}]
 │    │    │         ├── null [type=unknown]
 │    │    │         └── null [type=unknown]
 │    │    ├── values
 │    │    │    ├── columns: column1:3(int) column2:4(int)
 │    │    │    └── tuple [type=tuple{int, int}]
 │    │    │         ├── const: 1 [type=int]
 │    │    │         └── const: 1 [type=int]
 │    │    └── and [type=bool, outer=(1-4)]
 │    │         ├── eq [type=bool, outer=(1,3)]
 │    │         │    ├── variable: column1 [type=unknown, outer=(1)]
 │    │         │    └── variable: column1 [type=int, outer=(3)]
 │    │         └── eq [type=bool, outer=(2,4)]
 │    │              ├── variable: column2 [type=unknown, outer=(2)]
 │    │              └── variable: column2 [type=int, outer=(4)]
 │    └── projections [outer=(1-4)]
 │         ├── coalesce [type=int, outer=(1,3)]
 │         │    ├── variable: column1 [type=unknown, outer=(1)]
 │         │    └── variable: column1 [type=int, outer=(3)]
 │         ├── coalesce [type=int, outer=(2,4)]
 │         │    ├── variable: column2 [type=unknown, outer=(2)]
 │         │    └── variable: column2 [type=int, outer=(4)]
 │         ├── variable: column1 [type=unknown, outer=(1)]
 │         ├── variable: column2 [type=unknown, outer=(2)]
 │         ├── variable: column1 [type=int, outer=(3)]
 │         └── variable: column2 [type=int, outer=(4)]
 └── projections [outer=(5,6)]
      ├── variable: column1 [type=int, outer=(5)]
      └── variable: column2 [type=int, outer=(6)]
