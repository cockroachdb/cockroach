exec-ddl
CREATE TABLE uniq (
  k INT PRIMARY KEY,
  v INT UNIQUE,
  w INT UNIQUE WITHOUT INDEX,
  x INT,
  y INT,
  UNIQUE WITHOUT INDEX (x, y)
)
----

# None of the inserted values have nulls.
build
INSERT INTO uniq VALUES (1, 1, 1, 1, 1), (2, 2, 2, 2, 2)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    ├── values
 │    │    ├── columns: column1:8!null column2:9!null column3:10!null column4:11!null column5:12!null
 │    │    ├── (1, 1, 1, 1, 1)
 │    │    └── (2, 2, 2, 2, 2)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:13]
 │         │    └── column1:8
 │         ├── assignment-cast: INT8 [as=column2:14]
 │         │    └── column2:9
 │         ├── assignment-cast: INT8 [as=column3:15]
 │         │    └── column3:10
 │         ├── assignment-cast: INT8 [as=column4:16]
 │         │    └── column4:11
 │         └── assignment-cast: INT8 [as=column5:17]
 │              └── column5:12
 └── unique-checks
      ├── unique-checks-item: uniq(w)
      │    └── project
      │         ├── columns: w:27!null
      │         └── semi-join (hash)
      │              ├── columns: k:25!null v:26!null w:27!null x:28!null y:29!null
      │              ├── with-scan &1
      │              │    ├── columns: k:25!null v:26!null w:27!null x:28!null y:29!null
      │              │    └── mapping:
      │              │         ├──  column1:13 => k:25
      │              │         ├──  column2:14 => v:26
      │              │         ├──  column3:15 => w:27
      │              │         ├──  column4:16 => x:28
      │              │         └──  column5:17 => y:29
      │              ├── scan uniq
      │              │    └── columns: uniq.k:18!null uniq.v:19 uniq.w:20 uniq.x:21 uniq.y:22
      │              └── filters
      │                   ├── w:27 = uniq.w:20
      │                   └── k:25 != uniq.k:18
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:40!null y:41!null
                └── semi-join (hash)
                     ├── columns: k:37!null v:38!null w:39!null x:40!null y:41!null
                     ├── with-scan &1
                     │    ├── columns: k:37!null v:38!null w:39!null x:40!null y:41!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:37
                     │         ├──  column2:14 => v:38
                     │         ├──  column3:15 => w:39
                     │         ├──  column4:16 => x:40
                     │         └──  column5:17 => y:41
                     ├── scan uniq
                     │    └── columns: uniq.k:30!null uniq.v:31 uniq.w:32 uniq.x:33 uniq.y:34
                     └── filters
                          ├── x:40 = uniq.x:33
                          ├── y:41 = uniq.y:34
                          └── k:37 != uniq.k:30

# Some of the inserted values have nulls.
build
INSERT INTO uniq VALUES (1, 1, 1, 1, 1), (2, 2, 2, 2, 2), (3, NULL, NULL, NULL, 3)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:13!null column2:14 column3:15 column4:16 column5:17!null
 │    ├── values
 │    │    ├── columns: column1:8!null column2:9 column3:10 column4:11 column5:12!null
 │    │    ├── (1, 1, 1, 1, 1)
 │    │    ├── (2, 2, 2, 2, 2)
 │    │    └── (3, NULL::INT8, NULL::INT8, NULL::INT8, 3)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:13]
 │         │    └── column1:8
 │         ├── assignment-cast: INT8 [as=column2:14]
 │         │    └── column2:9
 │         ├── assignment-cast: INT8 [as=column3:15]
 │         │    └── column3:10
 │         ├── assignment-cast: INT8 [as=column4:16]
 │         │    └── column4:11
 │         └── assignment-cast: INT8 [as=column5:17]
 │              └── column5:12
 └── unique-checks
      ├── unique-checks-item: uniq(w)
      │    └── project
      │         ├── columns: w:27
      │         └── semi-join (hash)
      │              ├── columns: k:25!null v:26 w:27 x:28 y:29!null
      │              ├── with-scan &1
      │              │    ├── columns: k:25!null v:26 w:27 x:28 y:29!null
      │              │    └── mapping:
      │              │         ├──  column1:13 => k:25
      │              │         ├──  column2:14 => v:26
      │              │         ├──  column3:15 => w:27
      │              │         ├──  column4:16 => x:28
      │              │         └──  column5:17 => y:29
      │              ├── scan uniq
      │              │    └── columns: uniq.k:18!null uniq.v:19 uniq.w:20 uniq.x:21 uniq.y:22
      │              └── filters
      │                   ├── w:27 = uniq.w:20
      │                   └── k:25 != uniq.k:18
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:40 y:41!null
                └── semi-join (hash)
                     ├── columns: k:37!null v:38 w:39 x:40 y:41!null
                     ├── with-scan &1
                     │    ├── columns: k:37!null v:38 w:39 x:40 y:41!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:37
                     │         ├──  column2:14 => v:38
                     │         ├──  column3:15 => w:39
                     │         ├──  column4:16 => x:40
                     │         └──  column5:17 => y:41
                     ├── scan uniq
                     │    └── columns: uniq.k:30!null uniq.v:31 uniq.w:32 uniq.x:33 uniq.y:34
                     └── filters
                          ├── x:40 = uniq.x:33
                          ├── y:41 = uniq.y:34
                          └── k:37 != uniq.k:30

# No need to plan checks for w since it's always null.
# NOTE: We use the norm directive here so that assignment casts are eliminated
# by normalization rules, allowing removal of unique checks.
norm
INSERT INTO uniq VALUES (1, 1, NULL, 1, 1), (2, 2, NULL, 2, 2)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── values
 │    ├── columns: column1:13!null column2:14!null column3:15 column4:16!null column5:17!null
 │    ├── (1, 1, NULL, 1, 1)
 │    └── (2, 2, NULL, 2, 2)
 └── unique-checks
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:28!null y:29!null
                └── semi-join (hash)
                     ├── columns: k:25!null x:28!null y:29!null
                     ├── with-scan &1
                     │    ├── columns: k:25!null x:28!null y:29!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:25
                     │         ├──  column4:16 => x:28
                     │         └──  column5:17 => y:29
                     ├── scan uniq
                     │    └── columns: uniq.k:18!null uniq.x:21 uniq.y:22
                     └── filters
                          ├── x:28 = uniq.x:21
                          ├── y:29 = uniq.y:22
                          └── k:25 != uniq.k:18

# No need to plan checks for x,y since x is always null.
# NOTE: We use the norm directive here so that assignment casts are eliminated
# by normalization rules, allowing removal of unique checks.
norm
INSERT INTO uniq VALUES (1, 1, 1, NULL, 1), (2, 2, NULL, NULL, 2)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── values
 │    ├── columns: column1:13!null column2:14!null column3:15 column4:16 column5:17!null
 │    ├── (1, 1, 1, NULL, 1)
 │    └── (2, 2, NULL, NULL, 2)
 └── unique-checks
      └── unique-checks-item: uniq(w)
           └── project
                ├── columns: w:27
                └── semi-join (hash)
                     ├── columns: k:25!null w:27
                     ├── with-scan &1
                     │    ├── columns: k:25!null w:27
                     │    └── mapping:
                     │         ├──  column1:13 => k:25
                     │         └──  column3:15 => w:27
                     ├── scan uniq
                     │    └── columns: uniq.k:18!null uniq.w:20
                     └── filters
                          ├── w:27 = uniq.w:20
                          └── k:25 != uniq.k:18

# No need to plan checks for x,y since y is always null.
# NOTE: We use the norm directive here so that assignment casts are eliminated
# by normalization rules, allowing removal of unique checks.
norm
INSERT INTO uniq VALUES (1, 1, 1, 1, NULL), (2, 2, 2, 2, NULL)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── values
 │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17
 │    ├── (1, 1, 1, 1, NULL)
 │    └── (2, 2, 2, 2, NULL)
 └── unique-checks
      └── unique-checks-item: uniq(w)
           └── project
                ├── columns: w:27!null
                └── semi-join (hash)
                     ├── columns: k:25!null w:27!null
                     ├── with-scan &1
                     │    ├── columns: k:25!null w:27!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:25
                     │         └──  column3:15 => w:27
                     ├── scan uniq
                     │    └── columns: uniq.k:18!null uniq.w:20
                     └── filters
                          ├── w:27 = uniq.w:20
                          └── k:25 != uniq.k:18

# No need to plan any checks, since w, x and y are always null.
# NOTE: We use the norm directive here so that assignment casts are eliminated
# by normalization rules, allowing removal of unique checks.
norm
INSERT INTO uniq VALUES (1, 1, NULL, NULL, NULL), (2, 2, NULL, NULL, NULL)
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => k:1
 │    ├── column2:14 => v:2
 │    ├── column3:15 => w:3
 │    ├── column4:16 => x:4
 │    └── column5:17 => y:5
 └── values
      ├── columns: column1:13!null column2:14!null column3:15 column4:16 column5:17
      ├── (1, 1, NULL, NULL, NULL)
      └── (2, 2, NULL, NULL, NULL)

# Use all the unique indexes and constraints as arbiters for DO NOTHING with no
# conflict columns.
build
INSERT INTO uniq VALUES (1, 2, 3, 4, 5) ON CONFLICT DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter indexes: uniq_pkey uniq_v_key
 ├── arbiter constraints: unique_w unique_x_y
 ├── insert-mapping:
 │    ├── column1:13 => k:1
 │    ├── column2:14 => v:2
 │    ├── column3:15 => w:3
 │    ├── column4:16 => x:4
 │    └── column5:17 => y:5
 └── upsert-distinct-on
      ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      ├── grouping columns: column4:16!null column5:17!null
      ├── upsert-distinct-on
      │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    ├── grouping columns: column3:15!null
      │    ├── upsert-distinct-on
      │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    ├── grouping columns: column2:14!null
      │    │    ├── upsert-distinct-on
      │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    ├── grouping columns: column1:13!null
      │    │    │    ├── anti-join (hash)
      │    │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    │    ├── anti-join (hash)
      │    │    │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    │    │    ├── anti-join (hash)
      │    │    │    │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    │    │    │    ├── anti-join (hash)
      │    │    │    │    │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    │    │    │    │    ├── project
      │    │    │    │    │    │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
      │    │    │    │    │    │    │    │    ├── values
      │    │    │    │    │    │    │    │    │    ├── columns: column1:8!null column2:9!null column3:10!null column4:11!null column5:12!null
      │    │    │    │    │    │    │    │    │    └── (1, 2, 3, 4, 5)
      │    │    │    │    │    │    │    │    └── projections
      │    │    │    │    │    │    │    │         ├── assignment-cast: INT8 [as=column1:13]
      │    │    │    │    │    │    │    │         │    └── column1:8
      │    │    │    │    │    │    │    │         ├── assignment-cast: INT8 [as=column2:14]
      │    │    │    │    │    │    │    │         │    └── column2:9
      │    │    │    │    │    │    │    │         ├── assignment-cast: INT8 [as=column3:15]
      │    │    │    │    │    │    │    │         │    └── column3:10
      │    │    │    │    │    │    │    │         ├── assignment-cast: INT8 [as=column4:16]
      │    │    │    │    │    │    │    │         │    └── column4:11
      │    │    │    │    │    │    │    │         └── assignment-cast: INT8 [as=column5:17]
      │    │    │    │    │    │    │    │              └── column5:12
      │    │    │    │    │    │    │    ├── scan uniq
      │    │    │    │    │    │    │    │    └── columns: k:18!null v:19 w:20 x:21 y:22
      │    │    │    │    │    │    │    └── filters
      │    │    │    │    │    │    │         └── column1:13 = k:18
      │    │    │    │    │    │    ├── scan uniq
      │    │    │    │    │    │    │    └── columns: k:25!null v:26 w:27 x:28 y:29
      │    │    │    │    │    │    └── filters
      │    │    │    │    │    │         └── column2:14 = v:26
      │    │    │    │    │    ├── scan uniq
      │    │    │    │    │    │    └── columns: k:32!null v:33 w:34 x:35 y:36
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── column3:15 = w:34
      │    │    │    │    ├── scan uniq
      │    │    │    │    │    └── columns: k:39!null v:40 w:41 x:42 y:43
      │    │    │    │    └── filters
      │    │    │    │         ├── column4:16 = x:42
      │    │    │    │         └── column5:17 = y:43
      │    │    │    └── aggregations
      │    │    │         ├── first-agg [as=column2:14]
      │    │    │         │    └── column2:14
      │    │    │         ├── first-agg [as=column3:15]
      │    │    │         │    └── column3:15
      │    │    │         ├── first-agg [as=column4:16]
      │    │    │         │    └── column4:16
      │    │    │         └── first-agg [as=column5:17]
      │    │    │              └── column5:17
      │    │    └── aggregations
      │    │         ├── first-agg [as=column1:13]
      │    │         │    └── column1:13
      │    │         ├── first-agg [as=column3:15]
      │    │         │    └── column3:15
      │    │         ├── first-agg [as=column4:16]
      │    │         │    └── column4:16
      │    │         └── first-agg [as=column5:17]
      │    │              └── column5:17
      │    └── aggregations
      │         ├── first-agg [as=column1:13]
      │         │    └── column1:13
      │         ├── first-agg [as=column2:14]
      │         │    └── column2:14
      │         ├── first-agg [as=column4:16]
      │         │    └── column4:16
      │         └── first-agg [as=column5:17]
      │              └── column5:17
      └── aggregations
           ├── first-agg [as=column1:13]
           │    └── column1:13
           ├── first-agg [as=column2:14]
           │    └── column2:14
           └── first-agg [as=column3:15]
                └── column3:15

# On conflict clause references unique without index constraint.
build
INSERT INTO uniq VALUES (1, 2, 3, 4, 5) ON CONFLICT (w) DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter constraints: unique_w
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── upsert-distinct-on
 │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    ├── grouping columns: column3:15!null
 │    ├── anti-join (hash)
 │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    │    ├── project
 │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:8!null column2:9!null column3:10!null column4:11!null column5:12!null
 │    │    │    │    └── (1, 2, 3, 4, 5)
 │    │    │    └── projections
 │    │    │         ├── assignment-cast: INT8 [as=column1:13]
 │    │    │         │    └── column1:8
 │    │    │         ├── assignment-cast: INT8 [as=column2:14]
 │    │    │         │    └── column2:9
 │    │    │         ├── assignment-cast: INT8 [as=column3:15]
 │    │    │         │    └── column3:10
 │    │    │         ├── assignment-cast: INT8 [as=column4:16]
 │    │    │         │    └── column4:11
 │    │    │         └── assignment-cast: INT8 [as=column5:17]
 │    │    │              └── column5:12
 │    │    ├── scan uniq
 │    │    │    └── columns: uniq.k:18!null uniq.v:19 uniq.w:20 uniq.x:21 uniq.y:22
 │    │    └── filters
 │    │         └── column3:15 = uniq.w:20
 │    └── aggregations
 │         ├── first-agg [as=column1:13]
 │         │    └── column1:13
 │         ├── first-agg [as=column2:14]
 │         │    └── column2:14
 │         ├── first-agg [as=column4:16]
 │         │    └── column4:16
 │         └── first-agg [as=column5:17]
 │              └── column5:17
 └── unique-checks
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:35!null y:36!null
                └── semi-join (hash)
                     ├── columns: k:32!null v:33!null w:34!null x:35!null y:36!null
                     ├── with-scan &1
                     │    ├── columns: k:32!null v:33!null w:34!null x:35!null y:36!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:32
                     │         ├──  column2:14 => v:33
                     │         ├──  column3:15 => w:34
                     │         ├──  column4:16 => x:35
                     │         └──  column5:17 => y:36
                     ├── scan uniq
                     │    └── columns: uniq.k:25!null uniq.v:26 uniq.w:27 uniq.x:28 uniq.y:29
                     └── filters
                          ├── x:35 = uniq.x:28
                          ├── y:36 = uniq.y:29
                          └── k:32 != uniq.k:25

# On conflict clause references unique without index constraint explicitly.
build
INSERT INTO uniq VALUES (1, 2, 3, 4, 5) ON CONFLICT ON CONSTRAINT unique_w DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter constraints: unique_w
 ├── insert-mapping:
 │    ├── column1:13 => uniq.k:1
 │    ├── column2:14 => uniq.v:2
 │    ├── column3:15 => uniq.w:3
 │    ├── column4:16 => uniq.x:4
 │    └── column5:17 => uniq.y:5
 ├── input binding: &1
 ├── upsert-distinct-on
 │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    ├── grouping columns: column3:15!null
 │    ├── anti-join (hash)
 │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    │    ├── project
 │    │    │    ├── columns: column1:13!null column2:14!null column3:15!null column4:16!null column5:17!null
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:8!null column2:9!null column3:10!null column4:11!null column5:12!null
 │    │    │    │    └── (1, 2, 3, 4, 5)
 │    │    │    └── projections
 │    │    │         ├── assignment-cast: INT8 [as=column1:13]
 │    │    │         │    └── column1:8
 │    │    │         ├── assignment-cast: INT8 [as=column2:14]
 │    │    │         │    └── column2:9
 │    │    │         ├── assignment-cast: INT8 [as=column3:15]
 │    │    │         │    └── column3:10
 │    │    │         ├── assignment-cast: INT8 [as=column4:16]
 │    │    │         │    └── column4:11
 │    │    │         └── assignment-cast: INT8 [as=column5:17]
 │    │    │              └── column5:12
 │    │    ├── scan uniq
 │    │    │    └── columns: uniq.k:18!null uniq.v:19 uniq.w:20 uniq.x:21 uniq.y:22
 │    │    └── filters
 │    │         └── column3:15 = uniq.w:20
 │    └── aggregations
 │         ├── first-agg [as=column1:13]
 │         │    └── column1:13
 │         ├── first-agg [as=column2:14]
 │         │    └── column2:14
 │         ├── first-agg [as=column4:16]
 │         │    └── column4:16
 │         └── first-agg [as=column5:17]
 │              └── column5:17
 └── unique-checks
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:35!null y:36!null
                └── semi-join (hash)
                     ├── columns: k:32!null v:33!null w:34!null x:35!null y:36!null
                     ├── with-scan &1
                     │    ├── columns: k:32!null v:33!null w:34!null x:35!null y:36!null
                     │    └── mapping:
                     │         ├──  column1:13 => k:32
                     │         ├──  column2:14 => v:33
                     │         ├──  column3:15 => w:34
                     │         ├──  column4:16 => x:35
                     │         └──  column5:17 => y:36
                     ├── scan uniq
                     │    └── columns: uniq.k:25!null uniq.v:26 uniq.w:27 uniq.x:28 uniq.y:29
                     └── filters
                          ├── x:35 = uniq.x:28
                          ├── y:36 = uniq.y:29
                          └── k:32 != uniq.k:25

exec-ddl
CREATE TABLE other (k INT, v INT, w INT NOT NULL, x INT, y INT)
----

# Insert with non-constant input.
build
INSERT INTO uniq SELECT k, v, w, x, y FROM other
----
insert uniq
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:16 => uniq.k:1
 │    ├── v:17 => uniq.v:2
 │    ├── w:18 => uniq.w:3
 │    ├── x:19 => uniq.x:4
 │    └── y:20 => uniq.y:5
 ├── input binding: &1
 ├── project
 │    ├── columns: k:16 v:17 w:18!null x:19 y:20
 │    ├── project
 │    │    ├── columns: other.k:8 other.v:9 other.w:10!null other.x:11 other.y:12
 │    │    └── scan other
 │    │         └── columns: other.k:8 other.v:9 other.w:10!null other.x:11 other.y:12 rowid:13!null other.crdb_internal_mvcc_timestamp:14 other.tableoid:15
 │    └── projections
 │         ├── assignment-cast: INT8 [as=k:16]
 │         │    └── other.k:8
 │         ├── assignment-cast: INT8 [as=v:17]
 │         │    └── other.v:9
 │         ├── assignment-cast: INT8 [as=w:18]
 │         │    └── other.w:10
 │         ├── assignment-cast: INT8 [as=x:19]
 │         │    └── other.x:11
 │         └── assignment-cast: INT8 [as=y:20]
 │              └── other.y:12
 └── unique-checks
      ├── unique-checks-item: uniq(w)
      │    └── project
      │         ├── columns: w:30!null
      │         └── semi-join (hash)
      │              ├── columns: k:28 v:29 w:30!null x:31 y:32
      │              ├── with-scan &1
      │              │    ├── columns: k:28 v:29 w:30!null x:31 y:32
      │              │    └── mapping:
      │              │         ├──  k:16 => k:28
      │              │         ├──  v:17 => v:29
      │              │         ├──  w:18 => w:30
      │              │         ├──  x:19 => x:31
      │              │         └──  y:20 => y:32
      │              ├── scan uniq
      │              │    └── columns: uniq.k:21!null uniq.v:22 uniq.w:23 uniq.x:24 uniq.y:25
      │              └── filters
      │                   ├── w:30 = uniq.w:23
      │                   └── k:28 != uniq.k:21
      └── unique-checks-item: uniq(x,y)
           └── project
                ├── columns: x:43 y:44
                └── semi-join (hash)
                     ├── columns: k:40 v:41 w:42!null x:43 y:44
                     ├── with-scan &1
                     │    ├── columns: k:40 v:41 w:42!null x:43 y:44
                     │    └── mapping:
                     │         ├──  k:16 => k:40
                     │         ├──  v:17 => v:41
                     │         ├──  w:18 => w:42
                     │         ├──  x:19 => x:43
                     │         └──  y:20 => y:44
                     ├── scan uniq
                     │    └── columns: uniq.k:33!null uniq.v:34 uniq.w:35 uniq.x:36 uniq.y:37
                     └── filters
                          ├── x:43 = uniq.x:36
                          ├── y:44 = uniq.y:37
                          └── k:40 != uniq.k:33

exec-ddl
CREATE TABLE uniq_overlaps_pk (
  a INT,
  b INT,
  c INT,
  d INT,
  PRIMARY KEY (a, b),
  UNIQUE WITHOUT INDEX (b, c),
  UNIQUE WITHOUT INDEX (a, b, d),
  UNIQUE WITHOUT INDEX (a),
  UNIQUE WITHOUT INDEX (c, d)
)
----

# Insert with constant input.
# Add inequality filters for the primary key columns that are not part of each
# unique constraint to prevent rows from matching themselves in the semi join.
build
INSERT INTO uniq_overlaps_pk VALUES (1, 1, 1, 1), (2, 2, 2, 2)
----
insert uniq_overlaps_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:11 => uniq_overlaps_pk.a:1
 │    ├── column2:12 => uniq_overlaps_pk.b:2
 │    ├── column3:13 => uniq_overlaps_pk.c:3
 │    └── column4:14 => uniq_overlaps_pk.d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:11!null column2:12!null column3:13!null column4:14!null
 │    ├── values
 │    │    ├── columns: column1:7!null column2:8!null column3:9!null column4:10!null
 │    │    ├── (1, 1, 1, 1)
 │    │    └── (2, 2, 2, 2)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:11]
 │         │    └── column1:7
 │         ├── assignment-cast: INT8 [as=column2:12]
 │         │    └── column2:8
 │         ├── assignment-cast: INT8 [as=column3:13]
 │         │    └── column3:9
 │         └── assignment-cast: INT8 [as=column4:14]
 │              └── column4:10
 └── unique-checks
      ├── unique-checks-item: uniq_overlaps_pk(b,c)
      │    └── project
      │         ├── columns: b:22!null c:23!null
      │         └── semi-join (hash)
      │              ├── columns: a:21!null b:22!null c:23!null d:24!null
      │              ├── with-scan &1
      │              │    ├── columns: a:21!null b:22!null c:23!null d:24!null
      │              │    └── mapping:
      │              │         ├──  column1:11 => a:21
      │              │         ├──  column2:12 => b:22
      │              │         ├──  column3:13 => c:23
      │              │         └──  column4:14 => d:24
      │              ├── scan uniq_overlaps_pk
      │              │    └── columns: uniq_overlaps_pk.a:15!null uniq_overlaps_pk.b:16!null uniq_overlaps_pk.c:17 uniq_overlaps_pk.d:18
      │              └── filters
      │                   ├── b:22 = uniq_overlaps_pk.b:16
      │                   ├── c:23 = uniq_overlaps_pk.c:17
      │                   └── a:21 != uniq_overlaps_pk.a:15
      ├── unique-checks-item: uniq_overlaps_pk(a)
      │    └── project
      │         ├── columns: a:31!null
      │         └── semi-join (hash)
      │              ├── columns: a:31!null b:32!null c:33!null d:34!null
      │              ├── with-scan &1
      │              │    ├── columns: a:31!null b:32!null c:33!null d:34!null
      │              │    └── mapping:
      │              │         ├──  column1:11 => a:31
      │              │         ├──  column2:12 => b:32
      │              │         ├──  column3:13 => c:33
      │              │         └──  column4:14 => d:34
      │              ├── scan uniq_overlaps_pk
      │              │    └── columns: uniq_overlaps_pk.a:25!null uniq_overlaps_pk.b:26!null uniq_overlaps_pk.c:27 uniq_overlaps_pk.d:28
      │              └── filters
      │                   ├── a:31 = uniq_overlaps_pk.a:25
      │                   └── b:32 != uniq_overlaps_pk.b:26
      └── unique-checks-item: uniq_overlaps_pk(c,d)
           └── project
                ├── columns: c:43!null d:44!null
                └── semi-join (hash)
                     ├── columns: a:41!null b:42!null c:43!null d:44!null
                     ├── with-scan &1
                     │    ├── columns: a:41!null b:42!null c:43!null d:44!null
                     │    └── mapping:
                     │         ├──  column1:11 => a:41
                     │         ├──  column2:12 => b:42
                     │         ├──  column3:13 => c:43
                     │         └──  column4:14 => d:44
                     ├── scan uniq_overlaps_pk
                     │    └── columns: uniq_overlaps_pk.a:35!null uniq_overlaps_pk.b:36!null uniq_overlaps_pk.c:37 uniq_overlaps_pk.d:38
                     └── filters
                          ├── c:43 = uniq_overlaps_pk.c:37
                          ├── d:44 = uniq_overlaps_pk.d:38
                          └── (a:41 != uniq_overlaps_pk.a:35) OR (b:42 != uniq_overlaps_pk.b:36)

# Insert with non-constant input.
# Add inequality filters for the primary key columns that are not part of each
# unique constraint to prevent rows from matching themselves in the semi join.
build
INSERT INTO uniq_overlaps_pk SELECT k, v, x, y FROM other
----
insert uniq_overlaps_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:15 => uniq_overlaps_pk.a:1
 │    ├── v:16 => uniq_overlaps_pk.b:2
 │    ├── x:17 => uniq_overlaps_pk.c:3
 │    └── y:18 => uniq_overlaps_pk.d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: k:15 v:16 x:17 y:18
 │    ├── project
 │    │    ├── columns: other.k:7 other.v:8 other.x:10 other.y:11
 │    │    └── scan other
 │    │         └── columns: other.k:7 other.v:8 w:9!null other.x:10 other.y:11 rowid:12!null other.crdb_internal_mvcc_timestamp:13 other.tableoid:14
 │    └── projections
 │         ├── assignment-cast: INT8 [as=k:15]
 │         │    └── other.k:7
 │         ├── assignment-cast: INT8 [as=v:16]
 │         │    └── other.v:8
 │         ├── assignment-cast: INT8 [as=x:17]
 │         │    └── other.x:10
 │         └── assignment-cast: INT8 [as=y:18]
 │              └── other.y:11
 └── unique-checks
      ├── unique-checks-item: uniq_overlaps_pk(b,c)
      │    └── project
      │         ├── columns: b:26 c:27
      │         └── semi-join (hash)
      │              ├── columns: a:25 b:26 c:27 d:28
      │              ├── with-scan &1
      │              │    ├── columns: a:25 b:26 c:27 d:28
      │              │    └── mapping:
      │              │         ├──  k:15 => a:25
      │              │         ├──  v:16 => b:26
      │              │         ├──  x:17 => c:27
      │              │         └──  y:18 => d:28
      │              ├── scan uniq_overlaps_pk
      │              │    └── columns: uniq_overlaps_pk.a:19!null uniq_overlaps_pk.b:20!null uniq_overlaps_pk.c:21 uniq_overlaps_pk.d:22
      │              └── filters
      │                   ├── b:26 = uniq_overlaps_pk.b:20
      │                   ├── c:27 = uniq_overlaps_pk.c:21
      │                   └── a:25 != uniq_overlaps_pk.a:19
      ├── unique-checks-item: uniq_overlaps_pk(a)
      │    └── project
      │         ├── columns: a:35
      │         └── semi-join (hash)
      │              ├── columns: a:35 b:36 c:37 d:38
      │              ├── with-scan &1
      │              │    ├── columns: a:35 b:36 c:37 d:38
      │              │    └── mapping:
      │              │         ├──  k:15 => a:35
      │              │         ├──  v:16 => b:36
      │              │         ├──  x:17 => c:37
      │              │         └──  y:18 => d:38
      │              ├── scan uniq_overlaps_pk
      │              │    └── columns: uniq_overlaps_pk.a:29!null uniq_overlaps_pk.b:30!null uniq_overlaps_pk.c:31 uniq_overlaps_pk.d:32
      │              └── filters
      │                   ├── a:35 = uniq_overlaps_pk.a:29
      │                   └── b:36 != uniq_overlaps_pk.b:30
      └── unique-checks-item: uniq_overlaps_pk(c,d)
           └── project
                ├── columns: c:47 d:48
                └── semi-join (hash)
                     ├── columns: a:45 b:46 c:47 d:48
                     ├── with-scan &1
                     │    ├── columns: a:45 b:46 c:47 d:48
                     │    └── mapping:
                     │         ├──  k:15 => a:45
                     │         ├──  v:16 => b:46
                     │         ├──  x:17 => c:47
                     │         └──  y:18 => d:48
                     ├── scan uniq_overlaps_pk
                     │    └── columns: uniq_overlaps_pk.a:39!null uniq_overlaps_pk.b:40!null uniq_overlaps_pk.c:41 uniq_overlaps_pk.d:42
                     └── filters
                          ├── c:47 = uniq_overlaps_pk.c:41
                          ├── d:48 = uniq_overlaps_pk.d:42
                          └── (a:45 != uniq_overlaps_pk.a:39) OR (b:46 != uniq_overlaps_pk.b:40)

exec-ddl
CREATE TABLE uniq_hidden_pk (
  a INT,
  b INT,
  c INT,
  d INT,
  UNIQUE WITHOUT INDEX (b, c),
  UNIQUE WITHOUT INDEX (a, b, d),
  UNIQUE WITHOUT INDEX (a)
)
----

# Insert with constant input.
# Add inequality filters for the hidden primary key column.
build
INSERT INTO uniq_hidden_pk VALUES (1, 1, 1, 1), (2, 2, 2, 2)
----
insert uniq_hidden_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:12 => uniq_hidden_pk.a:1
 │    ├── column2:13 => uniq_hidden_pk.b:2
 │    ├── column3:14 => uniq_hidden_pk.c:3
 │    ├── column4:15 => uniq_hidden_pk.d:4
 │    └── rowid_default:16 => uniq_hidden_pk.rowid:5
 ├── input binding: &1
 ├── project
 │    ├── columns: rowid_default:16 column1:12!null column2:13!null column3:14!null column4:15!null
 │    ├── project
 │    │    ├── columns: column1:12!null column2:13!null column3:14!null column4:15!null
 │    │    ├── values
 │    │    │    ├── columns: column1:8!null column2:9!null column3:10!null column4:11!null
 │    │    │    ├── (1, 1, 1, 1)
 │    │    │    └── (2, 2, 2, 2)
 │    │    └── projections
 │    │         ├── assignment-cast: INT8 [as=column1:12]
 │    │         │    └── column1:8
 │    │         ├── assignment-cast: INT8 [as=column2:13]
 │    │         │    └── column2:9
 │    │         ├── assignment-cast: INT8 [as=column3:14]
 │    │         │    └── column3:10
 │    │         └── assignment-cast: INT8 [as=column4:15]
 │    │              └── column4:11
 │    └── projections
 │         └── unique_rowid() [as=rowid_default:16]
 └── unique-checks
      ├── unique-checks-item: uniq_hidden_pk(b,c)
      │    └── project
      │         ├── columns: b:25!null c:26!null
      │         └── semi-join (hash)
      │              ├── columns: a:24!null b:25!null c:26!null d:27!null rowid:28
      │              ├── with-scan &1
      │              │    ├── columns: a:24!null b:25!null c:26!null d:27!null rowid:28
      │              │    └── mapping:
      │              │         ├──  column1:12 => a:24
      │              │         ├──  column2:13 => b:25
      │              │         ├──  column3:14 => c:26
      │              │         ├──  column4:15 => d:27
      │              │         └──  rowid_default:16 => rowid:28
      │              ├── scan uniq_hidden_pk
      │              │    └── columns: uniq_hidden_pk.a:17 uniq_hidden_pk.b:18 uniq_hidden_pk.c:19 uniq_hidden_pk.d:20 uniq_hidden_pk.rowid:21!null
      │              └── filters
      │                   ├── b:25 = uniq_hidden_pk.b:18
      │                   ├── c:26 = uniq_hidden_pk.c:19
      │                   └── rowid:28 != uniq_hidden_pk.rowid:21
      ├── unique-checks-item: uniq_hidden_pk(a,b,d)
      │    └── project
      │         ├── columns: a:36!null b:37!null d:39!null
      │         └── semi-join (hash)
      │              ├── columns: a:36!null b:37!null c:38!null d:39!null rowid:40
      │              ├── with-scan &1
      │              │    ├── columns: a:36!null b:37!null c:38!null d:39!null rowid:40
      │              │    └── mapping:
      │              │         ├──  column1:12 => a:36
      │              │         ├──  column2:13 => b:37
      │              │         ├──  column3:14 => c:38
      │              │         ├──  column4:15 => d:39
      │              │         └──  rowid_default:16 => rowid:40
      │              ├── scan uniq_hidden_pk
      │              │    └── columns: uniq_hidden_pk.a:29 uniq_hidden_pk.b:30 uniq_hidden_pk.c:31 uniq_hidden_pk.d:32 uniq_hidden_pk.rowid:33!null
      │              └── filters
      │                   ├── a:36 = uniq_hidden_pk.a:29
      │                   ├── b:37 = uniq_hidden_pk.b:30
      │                   ├── d:39 = uniq_hidden_pk.d:32
      │                   └── rowid:40 != uniq_hidden_pk.rowid:33
      └── unique-checks-item: uniq_hidden_pk(a)
           └── project
                ├── columns: a:48!null
                └── semi-join (hash)
                     ├── columns: a:48!null b:49!null c:50!null d:51!null rowid:52
                     ├── with-scan &1
                     │    ├── columns: a:48!null b:49!null c:50!null d:51!null rowid:52
                     │    └── mapping:
                     │         ├──  column1:12 => a:48
                     │         ├──  column2:13 => b:49
                     │         ├──  column3:14 => c:50
                     │         ├──  column4:15 => d:51
                     │         └──  rowid_default:16 => rowid:52
                     ├── scan uniq_hidden_pk
                     │    └── columns: uniq_hidden_pk.a:41 uniq_hidden_pk.b:42 uniq_hidden_pk.c:43 uniq_hidden_pk.d:44 uniq_hidden_pk.rowid:45!null
                     └── filters
                          ├── a:48 = uniq_hidden_pk.a:41
                          └── rowid:52 != uniq_hidden_pk.rowid:45

# Insert with non-constant input.
# Add inequality filters for the hidden primary key column.
build
INSERT INTO uniq_hidden_pk SELECT k, v, x, y FROM other
----
insert uniq_hidden_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:16 => uniq_hidden_pk.a:1
 │    ├── v:17 => uniq_hidden_pk.b:2
 │    ├── x:18 => uniq_hidden_pk.c:3
 │    ├── y:19 => uniq_hidden_pk.d:4
 │    └── rowid_default:20 => uniq_hidden_pk.rowid:5
 ├── input binding: &1
 ├── project
 │    ├── columns: rowid_default:20 k:16 v:17 x:18 y:19
 │    ├── project
 │    │    ├── columns: k:16 v:17 x:18 y:19
 │    │    ├── project
 │    │    │    ├── columns: other.k:8 other.v:9 other.x:11 other.y:12
 │    │    │    └── scan other
 │    │    │         └── columns: other.k:8 other.v:9 w:10!null other.x:11 other.y:12 other.rowid:13!null other.crdb_internal_mvcc_timestamp:14 other.tableoid:15
 │    │    └── projections
 │    │         ├── assignment-cast: INT8 [as=k:16]
 │    │         │    └── other.k:8
 │    │         ├── assignment-cast: INT8 [as=v:17]
 │    │         │    └── other.v:9
 │    │         ├── assignment-cast: INT8 [as=x:18]
 │    │         │    └── other.x:11
 │    │         └── assignment-cast: INT8 [as=y:19]
 │    │              └── other.y:12
 │    └── projections
 │         └── unique_rowid() [as=rowid_default:20]
 └── unique-checks
      ├── unique-checks-item: uniq_hidden_pk(b,c)
      │    └── project
      │         ├── columns: b:29 c:30
      │         └── semi-join (hash)
      │              ├── columns: a:28 b:29 c:30 d:31 rowid:32
      │              ├── with-scan &1
      │              │    ├── columns: a:28 b:29 c:30 d:31 rowid:32
      │              │    └── mapping:
      │              │         ├──  k:16 => a:28
      │              │         ├──  v:17 => b:29
      │              │         ├──  x:18 => c:30
      │              │         ├──  y:19 => d:31
      │              │         └──  rowid_default:20 => rowid:32
      │              ├── scan uniq_hidden_pk
      │              │    └── columns: uniq_hidden_pk.a:21 uniq_hidden_pk.b:22 uniq_hidden_pk.c:23 uniq_hidden_pk.d:24 uniq_hidden_pk.rowid:25!null
      │              └── filters
      │                   ├── b:29 = uniq_hidden_pk.b:22
      │                   ├── c:30 = uniq_hidden_pk.c:23
      │                   └── rowid:32 != uniq_hidden_pk.rowid:25
      ├── unique-checks-item: uniq_hidden_pk(a,b,d)
      │    └── project
      │         ├── columns: a:40 b:41 d:43
      │         └── semi-join (hash)
      │              ├── columns: a:40 b:41 c:42 d:43 rowid:44
      │              ├── with-scan &1
      │              │    ├── columns: a:40 b:41 c:42 d:43 rowid:44
      │              │    └── mapping:
      │              │         ├──  k:16 => a:40
      │              │         ├──  v:17 => b:41
      │              │         ├──  x:18 => c:42
      │              │         ├──  y:19 => d:43
      │              │         └──  rowid_default:20 => rowid:44
      │              ├── scan uniq_hidden_pk
      │              │    └── columns: uniq_hidden_pk.a:33 uniq_hidden_pk.b:34 uniq_hidden_pk.c:35 uniq_hidden_pk.d:36 uniq_hidden_pk.rowid:37!null
      │              └── filters
      │                   ├── a:40 = uniq_hidden_pk.a:33
      │                   ├── b:41 = uniq_hidden_pk.b:34
      │                   ├── d:43 = uniq_hidden_pk.d:36
      │                   └── rowid:44 != uniq_hidden_pk.rowid:37
      └── unique-checks-item: uniq_hidden_pk(a)
           └── project
                ├── columns: a:52
                └── semi-join (hash)
                     ├── columns: a:52 b:53 c:54 d:55 rowid:56
                     ├── with-scan &1
                     │    ├── columns: a:52 b:53 c:54 d:55 rowid:56
                     │    └── mapping:
                     │         ├──  k:16 => a:52
                     │         ├──  v:17 => b:53
                     │         ├──  x:18 => c:54
                     │         ├──  y:19 => d:55
                     │         └──  rowid_default:20 => rowid:56
                     ├── scan uniq_hidden_pk
                     │    └── columns: uniq_hidden_pk.a:45 uniq_hidden_pk.b:46 uniq_hidden_pk.c:47 uniq_hidden_pk.d:48 uniq_hidden_pk.rowid:49!null
                     └── filters
                          ├── a:52 = uniq_hidden_pk.a:45
                          └── rowid:56 != uniq_hidden_pk.rowid:49

exec-ddl
CREATE TABLE uniq_partial (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  UNIQUE WITHOUT INDEX (a) WHERE b > 0
)
----

# None of the inserted values have nulls.
build
INSERT INTO uniq_partial VALUES (1, 1, 1), (2, 2, 2)
----
insert uniq_partial
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:9 => uniq_partial.k:1
 │    ├── column2:10 => uniq_partial.a:2
 │    └── column3:11 => uniq_partial.b:3
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:9!null column2:10!null column3:11!null
 │    ├── values
 │    │    ├── columns: column1:6!null column2:7!null column3:8!null
 │    │    ├── (1, 1, 1)
 │    │    └── (2, 2, 2)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:9]
 │         │    └── column1:6
 │         ├── assignment-cast: INT8 [as=column2:10]
 │         │    └── column2:7
 │         └── assignment-cast: INT8 [as=column3:11]
 │              └── column3:8
 └── unique-checks
      └── unique-checks-item: uniq_partial(a)
           └── project
                ├── columns: a:18!null
                └── semi-join (hash)
                     ├── columns: k:17!null a:18!null b:19!null
                     ├── with-scan &1
                     │    ├── columns: k:17!null a:18!null b:19!null
                     │    └── mapping:
                     │         ├──  column1:9 => k:17
                     │         ├──  column2:10 => a:18
                     │         └──  column3:11 => b:19
                     ├── scan uniq_partial
                     │    └── columns: uniq_partial.k:12!null uniq_partial.a:13 uniq_partial.b:14
                     └── filters
                          ├── a:18 = uniq_partial.a:13
                          ├── b:19 > 0
                          ├── uniq_partial.b:14 > 0
                          └── k:17 != uniq_partial.k:12

# Some of the inserted values have nulls.
build
INSERT INTO uniq_partial VALUES (1, 1, 1), (2, 2, 2), (3, NULL, 3)
----
insert uniq_partial
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:9 => uniq_partial.k:1
 │    ├── column2:10 => uniq_partial.a:2
 │    └── column3:11 => uniq_partial.b:3
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:9!null column2:10 column3:11!null
 │    ├── values
 │    │    ├── columns: column1:6!null column2:7 column3:8!null
 │    │    ├── (1, 1, 1)
 │    │    ├── (2, 2, 2)
 │    │    └── (3, NULL::INT8, 3)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:9]
 │         │    └── column1:6
 │         ├── assignment-cast: INT8 [as=column2:10]
 │         │    └── column2:7
 │         └── assignment-cast: INT8 [as=column3:11]
 │              └── column3:8
 └── unique-checks
      └── unique-checks-item: uniq_partial(a)
           └── project
                ├── columns: a:18
                └── semi-join (hash)
                     ├── columns: k:17!null a:18 b:19!null
                     ├── with-scan &1
                     │    ├── columns: k:17!null a:18 b:19!null
                     │    └── mapping:
                     │         ├──  column1:9 => k:17
                     │         ├──  column2:10 => a:18
                     │         └──  column3:11 => b:19
                     ├── scan uniq_partial
                     │    └── columns: uniq_partial.k:12!null uniq_partial.a:13 uniq_partial.b:14
                     └── filters
                          ├── a:18 = uniq_partial.a:13
                          ├── b:19 > 0
                          ├── uniq_partial.b:14 > 0
                          └── k:17 != uniq_partial.k:12

# No need to plan checks for a since it's always null.
# NOTE: We use the norm directive here so that assignment casts are eliminated
# by normalization rules, allowing removal of unique checks.
norm
INSERT INTO uniq_partial VALUES (1, NULL, 1), (2, NULL, 2)
----
insert uniq_partial
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:9 => k:1
 │    ├── column2:10 => a:2
 │    └── column3:11 => b:3
 └── values
      ├── columns: column1:9!null column2:10 column3:11!null
      ├── (1, NULL, 1)
      └── (2, NULL, 2)

# Use all the unique constraint as an arbiter for DO NOTHING with no conflict
# columns.
build
INSERT INTO uniq_partial VALUES (1, 2, 3), (2, 2, 3) ON CONFLICT DO NOTHING
----
insert uniq_partial
 ├── columns: <none>
 ├── arbiter indexes: uniq_partial_pkey
 ├── arbiter constraints: unique_a
 ├── insert-mapping:
 │    ├── column1:9 => k:1
 │    ├── column2:10 => a:2
 │    └── column3:11 => b:3
 └── project
      ├── columns: column1:9!null column2:10!null column3:11!null
      └── upsert-distinct-on
           ├── columns: column1:9!null column2:10!null column3:11!null arbiter_unique_a_distinct:22
           ├── grouping columns: column2:10!null arbiter_unique_a_distinct:22
           ├── project
           │    ├── columns: arbiter_unique_a_distinct:22 column1:9!null column2:10!null column3:11!null
           │    ├── upsert-distinct-on
           │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    ├── grouping columns: column1:9!null
           │    │    ├── anti-join (hash)
           │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    │    ├── anti-join (hash)
           │    │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    │    │    ├── project
           │    │    │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    │    │    │    ├── values
           │    │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
           │    │    │    │    │    │    ├── (1, 2, 3)
           │    │    │    │    │    │    └── (2, 2, 3)
           │    │    │    │    │    └── projections
           │    │    │    │    │         ├── assignment-cast: INT8 [as=column1:9]
           │    │    │    │    │         │    └── column1:6
           │    │    │    │    │         ├── assignment-cast: INT8 [as=column2:10]
           │    │    │    │    │         │    └── column2:7
           │    │    │    │    │         └── assignment-cast: INT8 [as=column3:11]
           │    │    │    │    │              └── column3:8
           │    │    │    │    ├── scan uniq_partial
           │    │    │    │    │    └── columns: k:12!null a:13 b:14
           │    │    │    │    └── filters
           │    │    │    │         └── column1:9 = k:12
           │    │    │    ├── select
           │    │    │    │    ├── columns: k:17!null a:18 b:19!null
           │    │    │    │    ├── scan uniq_partial
           │    │    │    │    │    └── columns: k:17!null a:18 b:19
           │    │    │    │    └── filters
           │    │    │    │         └── b:19 > 0
           │    │    │    └── filters
           │    │    │         ├── column2:10 = a:18
           │    │    │         └── column3:11 > 0
           │    │    └── aggregations
           │    │         ├── first-agg [as=column2:10]
           │    │         │    └── column2:10
           │    │         └── first-agg [as=column3:11]
           │    │              └── column3:11
           │    └── projections
           │         └── (column3:11 > 0) OR NULL::BOOL [as=arbiter_unique_a_distinct:22]
           └── aggregations
                ├── first-agg [as=column1:9]
                │    └── column1:9
                └── first-agg [as=column3:11]
                     └── column3:11

# Error when there is no arbiter predicate to match the partial unique
# constraint predicate.
build
INSERT INTO uniq_partial VALUES (1, 2, 3) ON CONFLICT (a) DO NOTHING
----
error (42P10): there is no unique or exclusion constraint matching the ON CONFLICT specification

# Error when trying to select a partial unique without index constraint
# explicitly, which is not allowed.
build
INSERT INTO uniq_partial VALUES (1, 2, 3) ON CONFLICT ON CONSTRAINT unique_a DO NOTHING
----
error (42809): unique constraint "unique_a" for table "uniq_partial" is partial, so cannot be used as an arbiter via the ON CONSTRAINT syntax

# On conflict clause references unique without index constraint.
build
INSERT INTO uniq_partial VALUES (1, 2, 3) ON CONFLICT (a) WHERE b > 0 DO NOTHING
----
insert uniq_partial
 ├── columns: <none>
 ├── arbiter constraints: unique_a
 ├── insert-mapping:
 │    ├── column1:9 => k:1
 │    ├── column2:10 => a:2
 │    └── column3:11 => b:3
 └── project
      ├── columns: column1:9!null column2:10!null column3:11!null
      └── upsert-distinct-on
           ├── columns: column1:9!null column2:10!null column3:11!null arbiter_unique_a_distinct:17
           ├── grouping columns: column2:10!null arbiter_unique_a_distinct:17
           ├── project
           │    ├── columns: arbiter_unique_a_distinct:17 column1:9!null column2:10!null column3:11!null
           │    ├── anti-join (hash)
           │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    ├── project
           │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
           │    │    │    ├── values
           │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
           │    │    │    │    └── (1, 2, 3)
           │    │    │    └── projections
           │    │    │         ├── assignment-cast: INT8 [as=column1:9]
           │    │    │         │    └── column1:6
           │    │    │         ├── assignment-cast: INT8 [as=column2:10]
           │    │    │         │    └── column2:7
           │    │    │         └── assignment-cast: INT8 [as=column3:11]
           │    │    │              └── column3:8
           │    │    ├── select
           │    │    │    ├── columns: k:12!null a:13 b:14!null
           │    │    │    ├── scan uniq_partial
           │    │    │    │    └── columns: k:12!null a:13 b:14
           │    │    │    └── filters
           │    │    │         └── b:14 > 0
           │    │    └── filters
           │    │         ├── column2:10 = a:13
           │    │         └── column3:11 > 0
           │    └── projections
           │         └── (column3:11 > 0) OR NULL::BOOL [as=arbiter_unique_a_distinct:17]
           └── aggregations
                ├── first-agg [as=column1:9]
                │    └── column1:9
                └── first-agg [as=column3:11]
                     └── column3:11

# Insert with non-constant input.
build
INSERT INTO uniq_partial SELECT k, v, w FROM other
----
insert uniq_partial
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:14 => uniq_partial.k:1
 │    ├── v:15 => uniq_partial.a:2
 │    └── w:16 => uniq_partial.b:3
 ├── input binding: &1
 ├── project
 │    ├── columns: k:14 v:15 w:16!null
 │    ├── project
 │    │    ├── columns: other.k:6 other.v:7 other.w:8!null
 │    │    └── scan other
 │    │         └── columns: other.k:6 other.v:7 other.w:8!null x:9 y:10 rowid:11!null other.crdb_internal_mvcc_timestamp:12 other.tableoid:13
 │    └── projections
 │         ├── assignment-cast: INT8 [as=k:14]
 │         │    └── other.k:6
 │         ├── assignment-cast: INT8 [as=v:15]
 │         │    └── other.v:7
 │         └── assignment-cast: INT8 [as=w:16]
 │              └── other.w:8
 └── unique-checks
      └── unique-checks-item: uniq_partial(a)
           └── project
                ├── columns: a:23
                └── semi-join (hash)
                     ├── columns: k:22 a:23 b:24!null
                     ├── with-scan &1
                     │    ├── columns: k:22 a:23 b:24!null
                     │    └── mapping:
                     │         ├──  k:14 => k:22
                     │         ├──  v:15 => a:23
                     │         └──  w:16 => b:24
                     ├── scan uniq_partial
                     │    └── columns: uniq_partial.k:17!null uniq_partial.a:18 uniq_partial.b:19
                     └── filters
                          ├── a:23 = uniq_partial.a:18
                          ├── b:24 > 0
                          ├── uniq_partial.b:19 > 0
                          └── k:22 != uniq_partial.k:17

exec-ddl
CREATE TABLE uniq_partial_overlaps_pk (
  a INT,
  b INT,
  c INT,
  d INT,
  PRIMARY KEY (a, b),
  UNIQUE WITHOUT INDEX (c) WHERE d > 0,
  UNIQUE WITHOUT INDEX (a) WHERE d > 0,
  UNIQUE WITHOUT INDEX (a, b) WHERE d > 0,
  UNIQUE WITHOUT INDEX (b, c) WHERE d > 0,
  UNIQUE WITHOUT INDEX (a, b, c) WHERE d > 0
)
----

# Insert with constant input.
# Do not build uniqueness checks when the primary key columns are a subset of
# the partial unique constraint columns.
build
INSERT INTO uniq_partial_overlaps_pk VALUES (1, 1, 1, 1), (2, 2, 2, 2)
----
insert uniq_partial_overlaps_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:11 => uniq_partial_overlaps_pk.a:1
 │    ├── column2:12 => uniq_partial_overlaps_pk.b:2
 │    ├── column3:13 => uniq_partial_overlaps_pk.c:3
 │    └── column4:14 => uniq_partial_overlaps_pk.d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: column1:11!null column2:12!null column3:13!null column4:14!null
 │    ├── values
 │    │    ├── columns: column1:7!null column2:8!null column3:9!null column4:10!null
 │    │    ├── (1, 1, 1, 1)
 │    │    └── (2, 2, 2, 2)
 │    └── projections
 │         ├── assignment-cast: INT8 [as=column1:11]
 │         │    └── column1:7
 │         ├── assignment-cast: INT8 [as=column2:12]
 │         │    └── column2:8
 │         ├── assignment-cast: INT8 [as=column3:13]
 │         │    └── column3:9
 │         └── assignment-cast: INT8 [as=column4:14]
 │              └── column4:10
 └── unique-checks
      ├── unique-checks-item: uniq_partial_overlaps_pk(c)
      │    └── project
      │         ├── columns: c:23!null
      │         └── semi-join (hash)
      │              ├── columns: a:21!null b:22!null c:23!null d:24!null
      │              ├── with-scan &1
      │              │    ├── columns: a:21!null b:22!null c:23!null d:24!null
      │              │    └── mapping:
      │              │         ├──  column1:11 => a:21
      │              │         ├──  column2:12 => b:22
      │              │         ├──  column3:13 => c:23
      │              │         └──  column4:14 => d:24
      │              ├── scan uniq_partial_overlaps_pk
      │              │    └── columns: uniq_partial_overlaps_pk.a:15!null uniq_partial_overlaps_pk.b:16!null uniq_partial_overlaps_pk.c:17 uniq_partial_overlaps_pk.d:18
      │              └── filters
      │                   ├── c:23 = uniq_partial_overlaps_pk.c:17
      │                   ├── d:24 > 0
      │                   ├── uniq_partial_overlaps_pk.d:18 > 0
      │                   └── (a:21 != uniq_partial_overlaps_pk.a:15) OR (b:22 != uniq_partial_overlaps_pk.b:16)
      ├── unique-checks-item: uniq_partial_overlaps_pk(a)
      │    └── project
      │         ├── columns: a:31!null
      │         └── semi-join (hash)
      │              ├── columns: a:31!null b:32!null c:33!null d:34!null
      │              ├── with-scan &1
      │              │    ├── columns: a:31!null b:32!null c:33!null d:34!null
      │              │    └── mapping:
      │              │         ├──  column1:11 => a:31
      │              │         ├──  column2:12 => b:32
      │              │         ├──  column3:13 => c:33
      │              │         └──  column4:14 => d:34
      │              ├── scan uniq_partial_overlaps_pk
      │              │    └── columns: uniq_partial_overlaps_pk.a:25!null uniq_partial_overlaps_pk.b:26!null uniq_partial_overlaps_pk.c:27 uniq_partial_overlaps_pk.d:28
      │              └── filters
      │                   ├── a:31 = uniq_partial_overlaps_pk.a:25
      │                   ├── d:34 > 0
      │                   ├── uniq_partial_overlaps_pk.d:28 > 0
      │                   └── b:32 != uniq_partial_overlaps_pk.b:26
      └── unique-checks-item: uniq_partial_overlaps_pk(b,c)
           └── project
                ├── columns: b:42!null c:43!null
                └── semi-join (hash)
                     ├── columns: a:41!null b:42!null c:43!null d:44!null
                     ├── with-scan &1
                     │    ├── columns: a:41!null b:42!null c:43!null d:44!null
                     │    └── mapping:
                     │         ├──  column1:11 => a:41
                     │         ├──  column2:12 => b:42
                     │         ├──  column3:13 => c:43
                     │         └──  column4:14 => d:44
                     ├── scan uniq_partial_overlaps_pk
                     │    └── columns: uniq_partial_overlaps_pk.a:35!null uniq_partial_overlaps_pk.b:36!null uniq_partial_overlaps_pk.c:37 uniq_partial_overlaps_pk.d:38
                     └── filters
                          ├── b:42 = uniq_partial_overlaps_pk.b:36
                          ├── c:43 = uniq_partial_overlaps_pk.c:37
                          ├── d:44 > 0
                          ├── uniq_partial_overlaps_pk.d:38 > 0
                          └── a:41 != uniq_partial_overlaps_pk.a:35

# Insert with non-constant input.
# Do not build uniqueness checks when the primary key columns are a subset of
# the partial unique constraint columns.
build
INSERT INTO uniq_partial_overlaps_pk SELECT k, v, x, y FROM other
----
insert uniq_partial_overlaps_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:15 => uniq_partial_overlaps_pk.a:1
 │    ├── v:16 => uniq_partial_overlaps_pk.b:2
 │    ├── x:17 => uniq_partial_overlaps_pk.c:3
 │    └── y:18 => uniq_partial_overlaps_pk.d:4
 ├── input binding: &1
 ├── project
 │    ├── columns: k:15 v:16 x:17 y:18
 │    ├── project
 │    │    ├── columns: other.k:7 other.v:8 other.x:10 other.y:11
 │    │    └── scan other
 │    │         └── columns: other.k:7 other.v:8 w:9!null other.x:10 other.y:11 rowid:12!null other.crdb_internal_mvcc_timestamp:13 other.tableoid:14
 │    └── projections
 │         ├── assignment-cast: INT8 [as=k:15]
 │         │    └── other.k:7
 │         ├── assignment-cast: INT8 [as=v:16]
 │         │    └── other.v:8
 │         ├── assignment-cast: INT8 [as=x:17]
 │         │    └── other.x:10
 │         └── assignment-cast: INT8 [as=y:18]
 │              └── other.y:11
 └── unique-checks
      ├── unique-checks-item: uniq_partial_overlaps_pk(c)
      │    └── project
      │         ├── columns: c:27
      │         └── semi-join (hash)
      │              ├── columns: a:25 b:26 c:27 d:28
      │              ├── with-scan &1
      │              │    ├── columns: a:25 b:26 c:27 d:28
      │              │    └── mapping:
      │              │         ├──  k:15 => a:25
      │              │         ├──  v:16 => b:26
      │              │         ├──  x:17 => c:27
      │              │         └──  y:18 => d:28
      │              ├── scan uniq_partial_overlaps_pk
      │              │    └── columns: uniq_partial_overlaps_pk.a:19!null uniq_partial_overlaps_pk.b:20!null uniq_partial_overlaps_pk.c:21 uniq_partial_overlaps_pk.d:22
      │              └── filters
      │                   ├── c:27 = uniq_partial_overlaps_pk.c:21
      │                   ├── d:28 > 0
      │                   ├── uniq_partial_overlaps_pk.d:22 > 0
      │                   └── (a:25 != uniq_partial_overlaps_pk.a:19) OR (b:26 != uniq_partial_overlaps_pk.b:20)
      ├── unique-checks-item: uniq_partial_overlaps_pk(a)
      │    └── project
      │         ├── columns: a:35
      │         └── semi-join (hash)
      │              ├── columns: a:35 b:36 c:37 d:38
      │              ├── with-scan &1
      │              │    ├── columns: a:35 b:36 c:37 d:38
      │              │    └── mapping:
      │              │         ├──  k:15 => a:35
      │              │         ├──  v:16 => b:36
      │              │         ├──  x:17 => c:37
      │              │         └──  y:18 => d:38
      │              ├── scan uniq_partial_overlaps_pk
      │              │    └── columns: uniq_partial_overlaps_pk.a:29!null uniq_partial_overlaps_pk.b:30!null uniq_partial_overlaps_pk.c:31 uniq_partial_overlaps_pk.d:32
      │              └── filters
      │                   ├── a:35 = uniq_partial_overlaps_pk.a:29
      │                   ├── d:38 > 0
      │                   ├── uniq_partial_overlaps_pk.d:32 > 0
      │                   └── b:36 != uniq_partial_overlaps_pk.b:30
      └── unique-checks-item: uniq_partial_overlaps_pk(b,c)
           └── project
                ├── columns: b:46 c:47
                └── semi-join (hash)
                     ├── columns: a:45 b:46 c:47 d:48
                     ├── with-scan &1
                     │    ├── columns: a:45 b:46 c:47 d:48
                     │    └── mapping:
                     │         ├──  k:15 => a:45
                     │         ├──  v:16 => b:46
                     │         ├──  x:17 => c:47
                     │         └──  y:18 => d:48
                     ├── scan uniq_partial_overlaps_pk
                     │    └── columns: uniq_partial_overlaps_pk.a:39!null uniq_partial_overlaps_pk.b:40!null uniq_partial_overlaps_pk.c:41 uniq_partial_overlaps_pk.d:42
                     └── filters
                          ├── b:46 = uniq_partial_overlaps_pk.b:40
                          ├── c:47 = uniq_partial_overlaps_pk.c:41
                          ├── d:48 > 0
                          ├── uniq_partial_overlaps_pk.d:42 > 0
                          └── a:45 != uniq_partial_overlaps_pk.a:39

exec-ddl
CREATE TABLE uniq_partial_hidden_pk (
  a INT,
  b INT,
  c INT,
  UNIQUE WITHOUT INDEX (b) WHERE c > 0
)
----

# Insert with constant input.
# Add inequality filters for the hidden primary key column.
build
INSERT INTO uniq_partial_hidden_pk VALUES (1, 1), (2, 2)
----
insert uniq_partial_hidden_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:9 => uniq_partial_hidden_pk.a:1
 │    ├── column2:10 => uniq_partial_hidden_pk.b:2
 │    ├── c_default:11 => uniq_partial_hidden_pk.c:3
 │    └── rowid_default:12 => uniq_partial_hidden_pk.rowid:4
 ├── input binding: &1
 ├── project
 │    ├── columns: c_default:11 rowid_default:12 column1:9!null column2:10!null
 │    ├── project
 │    │    ├── columns: column1:9!null column2:10!null
 │    │    ├── values
 │    │    │    ├── columns: column1:7!null column2:8!null
 │    │    │    ├── (1, 1)
 │    │    │    └── (2, 2)
 │    │    └── projections
 │    │         ├── assignment-cast: INT8 [as=column1:9]
 │    │         │    └── column1:7
 │    │         └── assignment-cast: INT8 [as=column2:10]
 │    │              └── column2:8
 │    └── projections
 │         ├── NULL::INT8 [as=c_default:11]
 │         └── unique_rowid() [as=rowid_default:12]
 └── unique-checks
      └── unique-checks-item: uniq_partial_hidden_pk(b)
           └── project
                ├── columns: b:20!null
                └── semi-join (hash)
                     ├── columns: a:19!null b:20!null c:21 rowid:22
                     ├── with-scan &1
                     │    ├── columns: a:19!null b:20!null c:21 rowid:22
                     │    └── mapping:
                     │         ├──  column1:9 => a:19
                     │         ├──  column2:10 => b:20
                     │         ├──  c_default:11 => c:21
                     │         └──  rowid_default:12 => rowid:22
                     ├── scan uniq_partial_hidden_pk
                     │    └── columns: uniq_partial_hidden_pk.a:13 uniq_partial_hidden_pk.b:14 uniq_partial_hidden_pk.c:15 uniq_partial_hidden_pk.rowid:16!null
                     └── filters
                          ├── b:20 = uniq_partial_hidden_pk.b:14
                          ├── c:21 > 0
                          ├── uniq_partial_hidden_pk.c:15 > 0
                          └── rowid:22 != uniq_partial_hidden_pk.rowid:16

# Add inequality filters for the hidden primary key column.
build
INSERT INTO uniq_partial_hidden_pk SELECT k, v FROM other
----
insert uniq_partial_hidden_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── k:15 => uniq_partial_hidden_pk.a:1
 │    ├── v:16 => uniq_partial_hidden_pk.b:2
 │    ├── c_default:17 => uniq_partial_hidden_pk.c:3
 │    └── rowid_default:18 => uniq_partial_hidden_pk.rowid:4
 ├── input binding: &1
 ├── project
 │    ├── columns: c_default:17 rowid_default:18 k:15 v:16
 │    ├── project
 │    │    ├── columns: k:15 v:16
 │    │    ├── project
 │    │    │    ├── columns: other.k:7 other.v:8
 │    │    │    └── scan other
 │    │    │         └── columns: other.k:7 other.v:8 w:9!null x:10 y:11 other.rowid:12!null other.crdb_internal_mvcc_timestamp:13 other.tableoid:14
 │    │    └── projections
 │    │         ├── assignment-cast: INT8 [as=k:15]
 │    │         │    └── other.k:7
 │    │         └── assignment-cast: INT8 [as=v:16]
 │    │              └── other.v:8
 │    └── projections
 │         ├── NULL::INT8 [as=c_default:17]
 │         └── unique_rowid() [as=rowid_default:18]
 └── unique-checks
      └── unique-checks-item: uniq_partial_hidden_pk(b)
           └── project
                ├── columns: b:26
                └── semi-join (hash)
                     ├── columns: a:25 b:26 c:27 rowid:28
                     ├── with-scan &1
                     │    ├── columns: a:25 b:26 c:27 rowid:28
                     │    └── mapping:
                     │         ├──  k:15 => a:25
                     │         ├──  v:16 => b:26
                     │         ├──  c_default:17 => c:27
                     │         └──  rowid_default:18 => rowid:28
                     ├── scan uniq_partial_hidden_pk
                     │    └── columns: uniq_partial_hidden_pk.a:19 uniq_partial_hidden_pk.b:20 uniq_partial_hidden_pk.c:21 uniq_partial_hidden_pk.rowid:22!null
                     └── filters
                          ├── b:26 = uniq_partial_hidden_pk.b:20
                          ├── c:27 > 0
                          ├── uniq_partial_hidden_pk.c:21 > 0
                          └── rowid:28 != uniq_partial_hidden_pk.rowid:22

exec-ddl
CREATE TABLE uniq_partial_constraint_and_index (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  UNIQUE INDEX (a) WHERE true,
  UNIQUE WITHOUT INDEX (a) WHERE b > 10
)
----

# Use a pseudo-partial index as the only arbiter. Note that we use the "norm"
# directive instead of "build" to ensure that partial index predicates are fully
# normalized when choosing arbiter indexes.
norm
INSERT INTO uniq_partial_constraint_and_index VALUES (1, 1, 1)
ON CONFLICT (a) WHERE b > 10 DO NOTHING
----
insert uniq_partial_constraint_and_index
 ├── columns: <none>
 ├── arbiter indexes: uniq_partial_constraint_and_index_a_key
 ├── insert-mapping:
 │    ├── column1:9 => uniq_partial_constraint_and_index.k:1
 │    ├── column2:10 => uniq_partial_constraint_and_index.a:2
 │    └── column3:11 => uniq_partial_constraint_and_index.b:3
 ├── partial index put columns: partial_index_put1:18
 ├── input binding: &1
 ├── project
 │    ├── columns: partial_index_put1:18!null column1:9!null column2:10!null column3:11!null
 │    ├── anti-join (cross)
 │    │    ├── columns: column1:9!null column2:10!null column3:11!null
 │    │    ├── values
 │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
 │    │    │    └── (1, 1, 1)
 │    │    ├── select
 │    │    │    ├── columns: uniq_partial_constraint_and_index.a:13!null
 │    │    │    ├── scan uniq_partial_constraint_and_index
 │    │    │    │    ├── columns: uniq_partial_constraint_and_index.a:13
 │    │    │    │    └── partial index predicates
 │    │    │    │         └── uniq_partial_constraint_and_index_a_key: filters (true)
 │    │    │    └── filters
 │    │    │         └── uniq_partial_constraint_and_index.a:13 = 1
 │    │    └── filters (true)
 │    └── projections
 │         └── true [as=partial_index_put1:18]
 └── unique-checks
      └── unique-checks-item: uniq_partial_constraint_and_index(a)
           └── project
                ├── columns: a:25!null
                └── semi-join (hash)
                     ├── columns: k:24!null a:25!null b:26!null
                     ├── select
                     │    ├── columns: k:24!null a:25!null b:26!null
                     │    ├── with-scan &1
                     │    │    ├── columns: k:24!null a:25!null b:26!null
                     │    │    └── mapping:
                     │    │         ├──  column1:9 => k:24
                     │    │         ├──  column2:10 => a:25
                     │    │         └──  column3:11 => b:26
                     │    └── filters
                     │         └── b:26 > 10
                     ├── select
                     │    ├── columns: uniq_partial_constraint_and_index.k:19!null uniq_partial_constraint_and_index.a:20 uniq_partial_constraint_and_index.b:21!null
                     │    ├── scan uniq_partial_constraint_and_index
                     │    │    ├── columns: uniq_partial_constraint_and_index.k:19!null uniq_partial_constraint_and_index.a:20 uniq_partial_constraint_and_index.b:21
                     │    │    └── partial index predicates
                     │    │         └── uniq_partial_constraint_and_index_a_key: filters (true)
                     │    └── filters
                     │         └── uniq_partial_constraint_and_index.b:21 > 10
                     └── filters
                          ├── a:25 = uniq_partial_constraint_and_index.a:20
                          └── k:24 != uniq_partial_constraint_and_index.k:19

exec-ddl
CREATE TABLE uniq_constraint_and_partial_index (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  UNIQUE INDEX (a) WHERE b > 0,
  UNIQUE WITHOUT INDEX (a) WHERE true
)
----

# Use a pseudo-partial constraint as the only arbiter. Note that we use the
# "norm" directive instead of "build" to ensure that partial index predicates
# are fully normalized when choosing arbiter indexes.
norm
INSERT INTO uniq_constraint_and_partial_index VALUES (1, 1, 1)
ON CONFLICT (a) WHERE b > 0 DO NOTHING
----
insert uniq_constraint_and_partial_index
 ├── columns: <none>
 ├── arbiter constraints: unique_a
 ├── insert-mapping:
 │    ├── column1:9 => k:1
 │    ├── column2:10 => a:2
 │    └── column3:11 => b:3
 ├── partial index put columns: partial_index_put1:18
 └── project
      ├── columns: partial_index_put1:18!null column1:9!null column2:10!null column3:11!null
      ├── anti-join (cross)
      │    ├── columns: column1:9!null column2:10!null column3:11!null
      │    ├── values
      │    │    ├── columns: column1:9!null column2:10!null column3:11!null
      │    │    └── (1, 1, 1)
      │    ├── select
      │    │    ├── columns: a:13!null
      │    │    ├── scan uniq_constraint_and_partial_index
      │    │    │    ├── columns: a:13
      │    │    │    └── partial index predicates
      │    │    │         └── uniq_constraint_and_partial_index_a_key: filters
      │    │    │              └── b:14 > 0
      │    │    └── filters
      │    │         └── a:13 = 1
      │    └── filters (true)
      └── projections
           └── column3:11 > 0 [as=partial_index_put1:18]

exec-ddl
CREATE TABLE uniq_partial_constraint_and_partial_index (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  UNIQUE INDEX (a) WHERE b > 0,
  UNIQUE WITHOUT INDEX (a) WHERE b > 10
)
----

# Use both a partial index and partial constraint as arbiters when both
# predicates are implied by the arbiter predicate.
build
INSERT INTO uniq_partial_constraint_and_partial_index VALUES (1, 1, 1)
ON CONFLICT (a) WHERE b > 10 DO NOTHING
----
insert uniq_partial_constraint_and_partial_index
 ├── columns: <none>
 ├── arbiter indexes: uniq_partial_constraint_and_partial_index_a_key
 ├── arbiter constraints: unique_a
 ├── insert-mapping:
 │    ├── column1:9 => k:1
 │    ├── column2:10 => a:2
 │    └── column3:11 => b:3
 ├── partial index put columns: partial_index_put1:24
 └── project
      ├── columns: partial_index_put1:24!null column1:9!null column2:10!null column3:11!null
      ├── project
      │    ├── columns: column1:9!null column2:10!null column3:11!null
      │    └── upsert-distinct-on
      │         ├── columns: column1:9!null column2:10!null column3:11!null arbiter_unique_a_distinct:23
      │         ├── grouping columns: column2:10!null arbiter_unique_a_distinct:23
      │         ├── project
      │         │    ├── columns: arbiter_unique_a_distinct:23 column1:9!null column2:10!null column3:11!null
      │         │    ├── project
      │         │    │    ├── columns: column1:9!null column2:10!null column3:11!null
      │         │    │    └── upsert-distinct-on
      │         │    │         ├── columns: column1:9!null column2:10!null column3:11!null arbiter_uniq_partial_constraint_and_partial_index_a_key_distinct:22
      │         │    │         ├── grouping columns: column2:10!null arbiter_uniq_partial_constraint_and_partial_index_a_key_distinct:22
      │         │    │         ├── project
      │         │    │         │    ├── columns: arbiter_uniq_partial_constraint_and_partial_index_a_key_distinct:22 column1:9!null column2:10!null column3:11!null
      │         │    │         │    ├── anti-join (hash)
      │         │    │         │    │    ├── columns: column1:9!null column2:10!null column3:11!null
      │         │    │         │    │    ├── anti-join (hash)
      │         │    │         │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
      │         │    │         │    │    │    ├── project
      │         │    │         │    │    │    │    ├── columns: column1:9!null column2:10!null column3:11!null
      │         │    │         │    │    │    │    ├── values
      │         │    │         │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
      │         │    │         │    │    │    │    │    └── (1, 1, 1)
      │         │    │         │    │    │    │    └── projections
      │         │    │         │    │    │    │         ├── assignment-cast: INT8 [as=column1:9]
      │         │    │         │    │    │    │         │    └── column1:6
      │         │    │         │    │    │    │         ├── assignment-cast: INT8 [as=column2:10]
      │         │    │         │    │    │    │         │    └── column2:7
      │         │    │         │    │    │    │         └── assignment-cast: INT8 [as=column3:11]
      │         │    │         │    │    │    │              └── column3:8
      │         │    │         │    │    │    ├── select
      │         │    │         │    │    │    │    ├── columns: k:12!null a:13 b:14!null
      │         │    │         │    │    │    │    ├── scan uniq_partial_constraint_and_partial_index
      │         │    │         │    │    │    │    │    ├── columns: k:12!null a:13 b:14
      │         │    │         │    │    │    │    │    └── partial index predicates
      │         │    │         │    │    │    │    │         └── uniq_partial_constraint_and_partial_index_a_key: filters
      │         │    │         │    │    │    │    │              └── b:14 > 0
      │         │    │         │    │    │    │    └── filters
      │         │    │         │    │    │    │         └── b:14 > 0
      │         │    │         │    │    │    └── filters
      │         │    │         │    │    │         ├── column2:10 = a:13
      │         │    │         │    │    │         └── column3:11 > 0
      │         │    │         │    │    ├── select
      │         │    │         │    │    │    ├── columns: k:17!null a:18 b:19!null
      │         │    │         │    │    │    ├── scan uniq_partial_constraint_and_partial_index
      │         │    │         │    │    │    │    ├── columns: k:17!null a:18 b:19
      │         │    │         │    │    │    │    └── partial index predicates
      │         │    │         │    │    │    │         └── uniq_partial_constraint_and_partial_index_a_key: filters
      │         │    │         │    │    │    │              └── b:19 > 0
      │         │    │         │    │    │    └── filters
      │         │    │         │    │    │         └── b:19 > 10
      │         │    │         │    │    └── filters
      │         │    │         │    │         ├── column2:10 = a:18
      │         │    │         │    │         └── column3:11 > 10
      │         │    │         │    └── projections
      │         │    │         │         └── (column3:11 > 0) OR NULL::BOOL [as=arbiter_uniq_partial_constraint_and_partial_index_a_key_distinct:22]
      │         │    │         └── aggregations
      │         │    │              ├── first-agg [as=column1:9]
      │         │    │              │    └── column1:9
      │         │    │              └── first-agg [as=column3:11]
      │         │    │                   └── column3:11
      │         │    └── projections
      │         │         └── (column3:11 > 10) OR NULL::BOOL [as=arbiter_unique_a_distinct:23]
      │         └── aggregations
      │              ├── first-agg [as=column1:9]
      │              │    └── column1:9
      │              └── first-agg [as=column3:11]
      │                   └── column3:11
      └── projections
           └── column3:11 > 0 [as=partial_index_put1:24]

exec-ddl
CREATE TABLE uniq_computed_pk (
  i INT,
  s STRING,
  d DECIMAL,
  c_i_expr STRING AS (CASE WHEN i < 0 THEN 'foo' ELSE 'bar' END) STORED,
  c_s STRING AS (s) VIRTUAL,
  c_d DECIMAL AS (d) STORED,
  c_d_expr STRING AS (d::string) STORED,
  PRIMARY KEY (c_i_expr, i),
  UNIQUE (c_s, s),
  UNIQUE (c_d_expr, d),
  UNIQUE WITHOUT INDEX (i),
  UNIQUE WITHOUT INDEX (s),
  UNIQUE WITHOUT INDEX (d)
)
----

# We can eliminate uniqueness checks for i and s due to functional dependencies.
# We cannot eliminate checks for d, since functional dependencies could not be
# inferred due to composite sensitivity of d::string.
build
INSERT INTO uniq_computed_pk (i, s, d) VALUES (1, 'a', 1.0), (2, 'b', 2.0)
----
insert uniq_computed_pk
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:13 => uniq_computed_pk.i:1
 │    ├── column2:14 => uniq_computed_pk.s:2
 │    ├── column3:15 => uniq_computed_pk.d:3
 │    ├── c_i_expr_comp:16 => uniq_computed_pk.c_i_expr:4
 │    ├── column2:14 => uniq_computed_pk.c_s:5
 │    ├── column3:15 => uniq_computed_pk.c_d:6
 │    └── c_d_expr_comp:17 => uniq_computed_pk.c_d_expr:7
 ├── input binding: &1
 ├── project
 │    ├── columns: c_i_expr_comp:16!null c_d_expr_comp:17!null column1:13!null column2:14!null column3:15!null
 │    ├── project
 │    │    ├── columns: column1:13!null column2:14!null column3:15!null
 │    │    ├── values
 │    │    │    ├── columns: column1:10!null column2:11!null column3:12!null
 │    │    │    ├── (1, 'a', 1.0)
 │    │    │    └── (2, 'b', 2.0)
 │    │    └── projections
 │    │         ├── assignment-cast: INT8 [as=column1:13]
 │    │         │    └── column1:10
 │    │         ├── assignment-cast: STRING [as=column2:14]
 │    │         │    └── column2:11
 │    │         └── assignment-cast: DECIMAL [as=column3:15]
 │    │              └── column3:12
 │    └── projections
 │         ├── CASE WHEN column1:13 < 0 THEN 'foo' ELSE 'bar' END [as=c_i_expr_comp:16]
 │         └── column3:15::STRING [as=c_d_expr_comp:17]
 └── unique-checks
      └── unique-checks-item: uniq_computed_pk(d)
           └── project
                ├── columns: d:47!null
                └── semi-join (hash)
                     ├── columns: i:45!null s:46!null d:47!null c_i_expr:48!null c_s:49!null c_d:50!null c_d_expr:51!null
                     ├── with-scan &1
                     │    ├── columns: i:45!null s:46!null d:47!null c_i_expr:48!null c_s:49!null c_d:50!null c_d_expr:51!null
                     │    └── mapping:
                     │         ├──  column1:13 => i:45
                     │         ├──  column2:14 => s:46
                     │         ├──  column3:15 => d:47
                     │         ├──  c_i_expr_comp:16 => c_i_expr:48
                     │         ├──  column2:14 => c_s:49
                     │         ├──  column3:15 => c_d:50
                     │         └──  c_d_expr_comp:17 => c_d_expr:51
                     ├── project
                     │    ├── columns: uniq_computed_pk.c_s:40 uniq_computed_pk.i:36!null uniq_computed_pk.s:37 uniq_computed_pk.d:38 uniq_computed_pk.c_i_expr:39!null uniq_computed_pk.c_d:41 uniq_computed_pk.c_d_expr:42
                     │    ├── scan uniq_computed_pk
                     │    │    ├── columns: uniq_computed_pk.i:36!null uniq_computed_pk.s:37 uniq_computed_pk.d:38 uniq_computed_pk.c_i_expr:39!null uniq_computed_pk.c_d:41 uniq_computed_pk.c_d_expr:42
                     │    │    └── computed column expressions
                     │    │         ├── uniq_computed_pk.c_i_expr:39
                     │    │         │    └── CASE WHEN uniq_computed_pk.i:36 < 0 THEN 'foo' ELSE 'bar' END
                     │    │         ├── uniq_computed_pk.c_s:40
                     │    │         │    └── uniq_computed_pk.s:37
                     │    │         ├── uniq_computed_pk.c_d:41
                     │    │         │    └── uniq_computed_pk.d:38
                     │    │         └── uniq_computed_pk.c_d_expr:42
                     │    │              └── uniq_computed_pk.d:38::STRING
                     │    └── projections
                     │         └── uniq_computed_pk.s:37 [as=uniq_computed_pk.c_s:40]
                     └── filters
                          ├── d:47 = uniq_computed_pk.d:38
                          └── (i:45 != uniq_computed_pk.i:36) OR (c_i_expr:48 != uniq_computed_pk.c_i_expr:39)
