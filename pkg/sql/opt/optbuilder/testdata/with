exec-ddl
CREATE TABLE x(a INT, b INT)
----

exec-ddl
CREATE TABLE y(a INT)
----

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM x NATURAL JOIN t
----
with &1 (t)
 ├── columns: a:3!null b:4
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null y.rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 y.rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── project
      ├── columns: x.a:3!null b:4
      └── inner-join (hash)
           ├── columns: x.a:3!null b:4 x.rowid:5!null a:6!null
           ├── scan x
           │    └── columns: x.a:3 b:4 x.rowid:5!null
           ├── with-scan &1 (t)
           │    ├── columns: a:6!null
           │    └── mapping:
           │         └──  y.a:1 => a:6
           └── filters
                └── x.a:3 = a:6

build
EXPLAIN
  WITH t AS (SELECT a FROM y WHERE a < 3)
    SELECT * FROM x NATURAL JOIN t
----
explain
 ├── columns: tree:7 field:8 description:9
 └── with &1 (t)
      ├── columns: a:3!null b:4
      ├── project
      │    ├── columns: y.a:1!null
      │    └── select
      │         ├── columns: y.a:1!null y.rowid:2!null
      │         ├── scan y
      │         │    └── columns: y.a:1 y.rowid:2!null
      │         └── filters
      │              └── y.a:1 < 3
      └── project
           ├── columns: x.a:3!null b:4
           └── inner-join (hash)
                ├── columns: x.a:3!null b:4 x.rowid:5!null a:6!null
                ├── scan x
                │    └── columns: x.a:3 b:4 x.rowid:5!null
                ├── with-scan &1 (t)
                │    ├── columns: a:6!null
                │    └── mapping:
                │         └──  y.a:1 => a:6
                └── filters
                     └── x.a:3 = a:6

build
WITH
    q AS (SELECT NULL)
SELECT
    1 + (SELECT * FROM q)
----
with &1 (q)
 ├── columns: "?column?":3
 ├── project
 │    ├── columns: "?column?":1
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         └── NULL [as="?column?":1]
 └── project
      ├── columns: "?column?":3
      ├── values
      │    └── ()
      └── projections
           └── NULL [as="?column?":3]

build
CREATE VIEW v1 AS
  WITH t AS (SELECT a FROM y WHERE a < 3)
    SELECT 1 FROM x NATURAL JOIN t
----
create-view t.public.v1
 ├── WITH t AS (SELECT a FROM t.public.y WHERE a < 3) SELECT 1 FROM t.public.x NATURAL JOIN t
 ├── columns: "?column?":7
 └── dependencies
      ├── y [columns: (0,1)]
      └── x [columns: (0-2)]

build
CREATE TABLE t1 AS
  WITH t AS (SELECT a FROM y WHERE a < 3)
    SELECT 1 FROM x NATURAL JOIN t
----
create-table
 ├── CREATE TABLE t1 AS WITH t AS (SELECT a FROM t.public.y WHERE a < 3) SELECT 1 FROM t.public.x NATURAL JOIN t
 └── project
      ├── columns: rowid:8 "?column?":7!null
      ├── with &1 (t)
      │    ├── columns: "?column?":7!null
      │    ├── project
      │    │    ├── columns: y.a:1!null
      │    │    └── select
      │    │         ├── columns: y.a:1!null y.rowid:2!null
      │    │         ├── scan y
      │    │         │    └── columns: y.a:1 y.rowid:2!null
      │    │         └── filters
      │    │              └── y.a:1 < 3
      │    └── project
      │         ├── columns: "?column?":7!null
      │         ├── inner-join (hash)
      │         │    ├── columns: x.a:3!null b:4 x.rowid:5!null a:6!null
      │         │    ├── scan x
      │         │    │    └── columns: x.a:3 b:4 x.rowid:5!null
      │         │    ├── with-scan &1 (t)
      │         │    │    ├── columns: a:6!null
      │         │    │    └── mapping:
      │         │    │         └──  y.a:1 => a:6
      │         │    └── filters
      │         │         └── x.a:3 = a:6
      │         └── projections
      │              └── 1 [as="?column?":7]
      └── projections
           └── unique_rowid() [as=rowid:8]

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM t
----
with &1 (t)
 ├── columns: a:3!null
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── with-scan &1 (t)
      ├── columns: a:3!null
      └── mapping:
           └──  y.a:1 => a:3

# Chaining multiple CTEs.
build
WITH
    t1 AS (SELECT a FROM y WHERE a < 3),
    t2 AS (SELECT * FROM t1 WHERE a > 1)
SELECT * FROM t2
----
with &1 (t1)
 ├── columns: a:4!null
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── with &2 (t2)
      ├── columns: a:4!null
      ├── select
      │    ├── columns: a:3!null
      │    ├── with-scan &1 (t1)
      │    │    ├── columns: a:3!null
      │    │    └── mapping:
      │    │         └──  y.a:1 => a:3
      │    └── filters
      │         └── a:3 > 1
      └── with-scan &2 (t2)
           ├── columns: a:4!null
           └── mapping:
                └──  a:3 => a:4

build
WITH
    t1 AS (SELECT a FROM y WHERE a < 3),
    t2 AS (SELECT * FROM t1 WHERE a > 1),
    t3 AS (SELECT * FROM t2 WHERE a = 2)
SELECT * FROM t3
----
with &1 (t1)
 ├── columns: a:5!null
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── with &2 (t2)
      ├── columns: a:5!null
      ├── select
      │    ├── columns: a:3!null
      │    ├── with-scan &1 (t1)
      │    │    ├── columns: a:3!null
      │    │    └── mapping:
      │    │         └──  y.a:1 => a:3
      │    └── filters
      │         └── a:3 > 1
      └── with &3 (t3)
           ├── columns: a:5!null
           ├── select
           │    ├── columns: a:4!null
           │    ├── with-scan &2 (t2)
           │    │    ├── columns: a:4!null
           │    │    └── mapping:
           │    │         └──  a:3 => a:4
           │    └── filters
           │         └── a:4 = 2
           └── with-scan &3 (t3)
                ├── columns: a:5!null
                └── mapping:
                     └──  a:4 => a:5

build
WITH
    t1 AS (SELECT * FROM y WHERE a < 3),
    t2 AS (SELECT * FROM y WHERE a > 1),
    t3 AS (SELECT * FROM t1 WHERE a < 4),
    t4 AS (SELECT * FROM t2 WHERE a > 3)
SELECT * FROM t3 NATURAL JOIN t4
----
with &1 (t1)
 ├── columns: a:7!null
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── with &2 (t2)
      ├── columns: a:7!null
      ├── project
      │    ├── columns: y.a:3!null
      │    └── select
      │         ├── columns: y.a:3!null rowid:4!null
      │         ├── scan y
      │         │    └── columns: y.a:3 rowid:4!null
      │         └── filters
      │              └── y.a:3 > 1
      └── with &3 (t3)
           ├── columns: a:7!null
           ├── select
           │    ├── columns: a:5!null
           │    ├── with-scan &1 (t1)
           │    │    ├── columns: a:5!null
           │    │    └── mapping:
           │    │         └──  y.a:1 => a:5
           │    └── filters
           │         └── a:5 < 4
           └── with &4 (t4)
                ├── columns: a:7!null
                ├── select
                │    ├── columns: a:6!null
                │    ├── with-scan &2 (t2)
                │    │    ├── columns: a:6!null
                │    │    └── mapping:
                │    │         └──  y.a:3 => a:6
                │    └── filters
                │         └── a:6 > 3
                └── project
                     ├── columns: a:7!null
                     └── inner-join (hash)
                          ├── columns: a:7!null a:8!null
                          ├── with-scan &3 (t3)
                          │    ├── columns: a:7!null
                          │    └── mapping:
                          │         └──  a:5 => a:7
                          ├── with-scan &4 (t4)
                          │    ├── columns: a:8!null
                          │    └── mapping:
                          │         └──  a:6 => a:8
                          └── filters
                               └── a:7 = a:8

# Make sure they scope properly.
build
WITH t AS (SELECT true) SELECT * FROM (WITH t AS (SELECT false) SELECT * FROM t)
----
with &1 (t)
 ├── columns: bool:3!null
 ├── project
 │    ├── columns: bool:1!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         └── true [as=bool:1]
 └── with &2 (t)
      ├── columns: bool:3!null
      ├── project
      │    ├── columns: bool:2!null
      │    ├── values
      │    │    └── ()
      │    └── projections
      │         └── false [as=bool:2]
      └── with-scan &2 (t)
           ├── columns: bool:3!null
           └── mapping:
                └──  bool:2 => bool:3

build
WITH
    t AS (SELECT true),
    t AS (SELECT false)
SELECT * FROM t
----
error (42712): WITH query name t specified more than once

# Using a CTE once in another CTE and once otherwise.
build
WITH
    t1 AS (SELECT true),
    t2 AS (SELECT * FROM t1)
SELECT * FROM t1 NATURAL JOIN t2
----
with &1 (t1)
 ├── columns: bool:3!null
 ├── project
 │    ├── columns: bool:1!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         └── true [as=bool:1]
 └── with &2 (t2)
      ├── columns: bool:3!null
      ├── with-scan &1 (t1)
      │    ├── columns: bool:2!null
      │    └── mapping:
      │         └──  bool:1 => bool:2
      └── project
           ├── columns: bool:3!null
           └── inner-join (hash)
                ├── columns: bool:3!null bool:4!null
                ├── with-scan &1 (t1)
                │    ├── columns: bool:3!null
                │    └── mapping:
                │         └──  bool:1 => bool:3
                ├── with-scan &2 (t2)
                │    ├── columns: bool:4!null
                │    └── mapping:
                │         └──  bool:2 => bool:4
                └── filters
                     └── bool:3 = bool:4

build
WITH
    t1 AS (SELECT * FROM x),
    t2 AS (SELECT * FROM x NATURAL JOIN t1)
SELECT * FROM t2 NATURAL JOIN x
----
with &1 (t1)
 ├── columns: a:9!null b:10!null
 ├── project
 │    ├── columns: x.a:1 x.b:2
 │    └── scan x
 │         └── columns: x.a:1 x.b:2 rowid:3!null
 └── with &2 (t2)
      ├── columns: a:9!null b:10!null
      ├── project
      │    ├── columns: x.a:4!null x.b:5!null
      │    └── inner-join (hash)
      │         ├── columns: x.a:4!null x.b:5!null rowid:6!null a:7!null b:8!null
      │         ├── scan x
      │         │    └── columns: x.a:4 x.b:5 rowid:6!null
      │         ├── with-scan &1 (t1)
      │         │    ├── columns: a:7 b:8
      │         │    └── mapping:
      │         │         ├──  x.a:1 => a:7
      │         │         └──  x.b:2 => b:8
      │         └── filters
      │              ├── x.a:4 = a:7
      │              └── x.b:5 = b:8
      └── project
           ├── columns: a:9!null b:10!null
           └── inner-join (hash)
                ├── columns: a:9!null b:10!null x.a:11!null x.b:12!null rowid:13!null
                ├── with-scan &2 (t2)
                │    ├── columns: a:9!null b:10!null
                │    └── mapping:
                │         ├──  x.a:4 => a:9
                │         └──  x.b:5 => b:10
                ├── scan x
                │    └── columns: x.a:11 x.b:12 rowid:13!null
                └── filters
                     ├── a:9 = x.a:11
                     └── b:10 = x.b:12

build
WITH t AS (SELECT a FROM y WHERE a < 3)
  SELECT * FROM t NATURAL JOIN t
----
error (42712): source name "t" specified more than once (missing AS clause)

build
WITH t(x) AS (SELECT a FROM x)
  SELECT x FROM (SELECT x FROM t)
----
with &1 (t)
 ├── columns: x:4
 ├── project
 │    ├── columns: a:1
 │    └── scan x
 │         └── columns: a:1 b:2 rowid:3!null
 └── with-scan &1 (t)
      ├── columns: x:4
      └── mapping:
           └──  a:1 => x:4

build
WITH t(a, b) AS (SELECT true a, false b)
  SELECT a, b FROM t
----
with &1 (t)
 ├── columns: a:3!null b:4!null
 ├── project
 │    ├── columns: a:1!null b:2!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         ├── true [as=a:1]
 │         └── false [as=b:2]
 └── with-scan &1 (t)
      ├── columns: a:3!null b:4!null
      └── mapping:
           ├──  a:1 => a:3
           └──  b:2 => b:4

build
WITH t(b, a) AS (SELECT true a, false b)
  SELECT a, b FROM t
----
with &1 (t)
 ├── columns: a:4!null b:3!null
 ├── project
 │    ├── columns: a:1!null b:2!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         ├── true [as=a:1]
 │         └── false [as=b:2]
 └── with-scan &1 (t)
      ├── columns: b:3!null a:4!null
      └── mapping:
           ├──  a:1 => b:3
           └──  b:2 => a:4

build
WITH t AS (SELECT a FROM x)
    SELECT * FROM y WHERE a IN (SELECT * FROM t)
----
with &1 (t)
 ├── columns: a:4
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 x.rowid:3!null
 └── project
      ├── columns: y.a:4
      └── select
           ├── columns: y.a:4 y.rowid:5!null
           ├── scan y
           │    └── columns: y.a:4 y.rowid:5!null
           └── filters
                └── any: eq
                     ├── with-scan &1 (t)
                     │    ├── columns: a:6
                     │    └── mapping:
                     │         └──  x.a:1 => a:6
                     └── y.a:4

build
WITH t(x) AS (SELECT a FROM x)
    SELECT * FROM y WHERE a IN (SELECT x FROM t)
----
with &1 (t)
 ├── columns: a:4
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 x.rowid:3!null
 └── project
      ├── columns: y.a:4
      └── select
           ├── columns: y.a:4 y.rowid:5!null
           ├── scan y
           │    └── columns: y.a:4 y.rowid:5!null
           └── filters
                └── any: eq
                     ├── with-scan &1 (t)
                     │    ├── columns: x:6
                     │    └── mapping:
                     │         └──  x.a:1 => x:6
                     └── y.a:4

# Using a subquery inside a CTE
build
SELECT * FROM x WHERE a IN
  (WITH t AS (SELECT * FROM y WHERE a < 3) SELECT * FROM t)
----
with &1 (t)
 ├── columns: a:1 b:2
 ├── project
 │    ├── columns: y.a:4!null
 │    └── select
 │         ├── columns: y.a:4!null y.rowid:5!null
 │         ├── scan y
 │         │    └── columns: y.a:4 y.rowid:5!null
 │         └── filters
 │              └── y.a:4 < 3
 └── project
      ├── columns: x.a:1 b:2
      └── select
           ├── columns: x.a:1 b:2 x.rowid:3!null
           ├── scan x
           │    └── columns: x.a:1 b:2 x.rowid:3!null
           └── filters
                └── any: eq
                     ├── with-scan &1 (t)
                     │    ├── columns: a:6!null
                     │    └── mapping:
                     │         └──  y.a:4 => a:6
                     └── x.a:1

# Using a correlated subquery inside a CTE
build
SELECT (WITH t AS (SELECT * FROM y WHERE x.a = y.a) SELECT * FROM t LIMIT 1) FROM x
----
error (0A000): CTEs may not be correlated

# Rename columns
build
WITH t(b) AS (SELECT a FROM x) SELECT b, t.b FROM t
----
with &1 (t)
 ├── columns: b:4 b:4
 ├── project
 │    ├── columns: a:1
 │    └── scan x
 │         └── columns: a:1 x.b:2 rowid:3!null
 └── with-scan &1 (t)
      ├── columns: b:4
      └── mapping:
           └──  a:1 => b:4

build
WITH t(b, c) AS (SELECT a FROM x) SELECT b, t.b FROM t
----
error (42P10): source "t" has 1 columns available but 2 columns specified

# Ensure you can't reference the original table name
build
WITH t AS (SELECT a FROM x) SELECT a, x.t FROM t
----
error (42P01): no data source matches prefix: x

# Nested WITH, name shadowing
build
WITH t(x) AS (WITH t(x) AS (SELECT 1) SELECT x * 10 FROM t) SELECT x + 2 FROM t
----
with &1 (t)
 ├── columns: "?column?":5!null
 ├── project
 │    ├── columns: "?column?":1!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         └── 1 [as="?column?":1]
 └── with &2 (t)
      ├── columns: "?column?":5!null
      ├── project
      │    ├── columns: "?column?":3!null
      │    ├── with-scan &1 (t)
      │    │    ├── columns: x:2!null
      │    │    └── mapping:
      │    │         └──  "?column?":1 => x:2
      │    └── projections
      │         └── x:2 * 10 [as="?column?":3]
      └── project
           ├── columns: "?column?":5!null
           ├── with-scan &2 (t)
           │    ├── columns: x:4!null
           │    └── mapping:
           │         └──  "?column?":3 => x:4
           └── projections
                └── x:4 + 2 [as="?column?":5]

build
WITH one AS (SELECT a AS u FROM x),
     two AS (SELECT a AS v FROM (SELECT a FROM y UNION ALL SELECT u FROM one))
  SELECT * FROM one JOIN two ON u = v
----
with &1 (one)
 ├── columns: u:8!null v:9!null
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 x.rowid:3!null
 └── with &2 (two)
      ├── columns: u:8!null v:9!null
      ├── union-all
      │    ├── columns: a:7
      │    ├── left columns: y.a:4
      │    ├── right columns: u:6
      │    ├── project
      │    │    ├── columns: y.a:4
      │    │    └── scan y
      │    │         └── columns: y.a:4 y.rowid:5!null
      │    └── with-scan &1 (one)
      │         ├── columns: u:6
      │         └── mapping:
      │              └──  x.a:1 => u:6
      └── inner-join (hash)
           ├── columns: u:8!null v:9!null
           ├── with-scan &1 (one)
           │    ├── columns: u:8
           │    └── mapping:
           │         └──  x.a:1 => u:8
           ├── with-scan &2 (two)
           │    ├── columns: v:9
           │    └── mapping:
           │         └──  a:7 => v:9
           └── filters
                └── u:8 = v:9

build
WITH foo AS (SELECT x.a FROM x ORDER by x.a) SELECT * FROM foo
----
with &1 (foo)
 ├── columns: a:4
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 rowid:3!null
 └── with-scan &1 (foo)
      ├── columns: a:4
      └── mapping:
           └──  x.a:1 => a:4

# Mutations.
build
WITH t AS (SELECT a FROM x) INSERT INTO x SELECT a + 20 FROM t RETURNING *
----
with &1 (t)
 ├── columns: a:4 b:5
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 rowid:3!null
 └── project
      ├── columns: x.a:4 b:5
      └── insert x
           ├── columns: x.a:4 b:5 rowid:6!null
           ├── insert-mapping:
           │    ├── "?column?":8 => x.a:4
           │    ├── column9:9 => b:5
           │    └── column10:10 => rowid:6
           └── project
                ├── columns: column9:9 column10:10 "?column?":8
                ├── project
                │    ├── columns: "?column?":8
                │    ├── with-scan &1 (t)
                │    │    ├── columns: a:7
                │    │    └── mapping:
                │    │         └──  x.a:1 => a:7
                │    └── projections
                │         └── a:7 + 20 [as="?column?":8]
                └── projections
                     ├── NULL::INT8 [as=column9:9]
                     └── unique_rowid() [as=column10:10]

build
WITH t AS (SELECT a FROM x) UPDATE x SET a = (SELECT * FROM t) RETURNING *
----
with &1 (t)
 ├── columns: a:4 b:5
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 rowid:3!null
 └── project
      ├── columns: x.a:4 b:5
      └── update x
           ├── columns: x.a:4 b:5 rowid:6!null
           ├── fetch columns: x.a:7 b:8 rowid:9
           ├── update-mapping:
           │    └── a_new:11 => x.a:4
           └── project
                ├── columns: a_new:11 x.a:7 b:8 rowid:9!null
                ├── scan x
                │    └── columns: x.a:7 b:8 rowid:9!null
                └── projections
                     └── subquery [as=a_new:11]
                          └── max1-row
                               ├── columns: a:10
                               └── with-scan &1 (t)
                                    ├── columns: a:10
                                    └── mapping:
                                         └──  x.a:1 => a:10

build
WITH t AS (SELECT a FROM x) DELETE FROM x WHERE a = (SELECT * FROM t) RETURNING *
----
with &1 (t)
 ├── columns: a:4!null b:5
 ├── project
 │    ├── columns: x.a:1
 │    └── scan x
 │         └── columns: x.a:1 b:2 rowid:3!null
 └── project
      ├── columns: x.a:4!null b:5
      └── delete x
           ├── columns: x.a:4!null b:5 rowid:6!null
           ├── fetch columns: x.a:7 b:8 rowid:9
           └── select
                ├── columns: x.a:7!null b:8 rowid:9!null
                ├── scan x
                │    └── columns: x.a:7 b:8 rowid:9!null
                └── filters
                     └── eq
                          ├── x.a:7
                          └── subquery
                               └── max1-row
                                    ├── columns: a:10
                                    └── with-scan &1 (t)
                                         ├── columns: a:10
                                         └── mapping:
                                              └──  x.a:1 => a:10

# Correlated WITH is not allowed.

build
SELECT (WITH foo AS (SELECT x.a FROM x WHERE x.a = y.a) SELECT a FROM foo) FROM y
----
error (0A000): CTEs may not be correlated

build
SELECT (WITH foo AS (SELECT (SELECT y.a) FROM x) SELECT a FROM foo) FROM y
----
error (0A000): CTEs may not be correlated

# Regression test for #40407.
exec-ddl
CREATE TABLE xy (x INT, y INT, z TIMESTAMP);
----

exec-ddl
CREATE TABLE uv (u INT, v INT);
----

build
WITH
    t AS (SELECT xy.x FROM xy INNER JOIN uv ON xy.x = uv.u ORDER BY uv.v DESC LIMIT 5)
DELETE FROM
    xy
WHERE
    x = ANY (SELECT * FROM t);
----
with &1 (t)
 ├── project
 │    ├── columns: xy.x:1!null
 │    └── limit
 │         ├── columns: xy.x:1!null v:6
 │         ├── internal-ordering: -6
 │         ├── sort
 │         │    ├── columns: xy.x:1!null v:6
 │         │    ├── ordering: -6
 │         │    ├── limit hint: 5.00
 │         │    └── project
 │         │         ├── columns: xy.x:1!null v:6
 │         │         └── inner-join (hash)
 │         │              ├── columns: xy.x:1!null y:2 z:3 xy.rowid:4!null u:5!null v:6 uv.rowid:7!null
 │         │              ├── scan xy
 │         │              │    └── columns: xy.x:1 y:2 z:3 xy.rowid:4!null
 │         │              ├── scan uv
 │         │              │    └── columns: u:5 v:6 uv.rowid:7!null
 │         │              └── filters
 │         │                   └── xy.x:1 = u:5
 │         └── 5
 └── delete xy
      ├── columns: <none>
      ├── fetch columns: xy.x:12 y:13 z:14 xy.rowid:15
      └── select
           ├── columns: xy.x:12 y:13 z:14 xy.rowid:15!null
           ├── scan xy
           │    └── columns: xy.x:12 y:13 z:14 xy.rowid:15!null
           └── filters
                └── any: eq
                     ├── with-scan &1 (t)
                     │    ├── columns: x:16!null
                     │    └── mapping:
                     │         └──  xy.x:1 => x:16
                     └── xy.x:12

# Check hidden column handling: level, node_type should not be output.
build
WITH cte AS (EXPLAIN (VERBOSE) SELECT 1) SELECT * FROM cte
----
with &1 (cte)
 ├── columns: tree:9 field:10 description:11 columns:12 ordering:13
 ├── project
 │    ├── columns: tree:2 field:5 description:6 columns:7 ordering:8
 │    └── explain
 │         ├── columns: tree:2 level:3 node_type:4 field:5 description:6 columns:7 ordering:8
 │         ├── mode: verbose
 │         └── project
 │              ├── columns: "?column?":1!null
 │              ├── values
 │              │    └── ()
 │              └── projections
 │                   └── 1 [as="?column?":1]
 └── with-scan &1 (cte)
      ├── columns: tree:9 field:10 description:11 columns:12 ordering:13
      └── mapping:
           ├──  tree:2 => tree:9
           ├──  field:5 => field:10
           ├──  description:6 => description:11
           ├──  columns:7 => columns:12
           └──  ordering:8 => ordering:13

# WITH RECURSIVE examples from postgres docs.

build
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
----
with &2 (t)
 ├── columns: sum:6
 ├── recursive-c-t-e
 │    ├── columns: n:2
 │    ├── working table binding: &1
 │    ├── initial columns: column1:1
 │    ├── recursive columns: "?column?":4
 │    ├── values
 │    │    ├── columns: column1:1!null
 │    │    └── (1,)
 │    └── project
 │         ├── columns: "?column?":4!null
 │         ├── select
 │         │    ├── columns: n:3!null
 │         │    ├── with-scan &1 (t)
 │         │    │    ├── columns: n:3
 │         │    │    └── mapping:
 │         │    │         └──  n:2 => n:3
 │         │    └── filters
 │         │         └── n:3 < 100
 │         └── projections
 │              └── n:3 + 1 [as="?column?":4]
 └── scalar-group-by
      ├── columns: sum:6
      ├── with-scan &2 (t)
      │    ├── columns: n:5
      │    └── mapping:
      │         └──  n:2 => n:5
      └── aggregations
           └── sum [as=sum:6]
                └── n:5

exec-ddl
CREATE TABLE parts (part STRING, sub_part STRING, quantity INT)
----

build
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts AS pr, parts AS p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, sum(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
----
with &2 (included_parts)
 ├── columns: sub_part:15 total_quantity:18
 ├── recursive-c-t-e
 │    ├── columns: sub_part:5 part:6 quantity:7
 │    ├── working table binding: &1
 │    ├── initial columns: parts.sub_part:2 parts.part:1 parts.quantity:3
 │    ├── recursive columns: p.sub_part:12 p.part:11 p.quantity:13
 │    ├── project
 │    │    ├── columns: parts.part:1!null parts.sub_part:2 parts.quantity:3
 │    │    └── select
 │    │         ├── columns: parts.part:1!null parts.sub_part:2 parts.quantity:3 parts.rowid:4!null
 │    │         ├── scan parts
 │    │         │    └── columns: parts.part:1 parts.sub_part:2 parts.quantity:3 parts.rowid:4!null
 │    │         └── filters
 │    │              └── parts.part:1 = 'our_product'
 │    └── project
 │         ├── columns: p.part:11!null p.sub_part:12 p.quantity:13
 │         └── select
 │              ├── columns: sub_part:8!null part:9 quantity:10 p.part:11!null p.sub_part:12 p.quantity:13 p.rowid:14!null
 │              ├── inner-join (cross)
 │              │    ├── columns: sub_part:8 part:9 quantity:10 p.part:11 p.sub_part:12 p.quantity:13 p.rowid:14!null
 │              │    ├── with-scan &1 (included_parts)
 │              │    │    ├── columns: sub_part:8 part:9 quantity:10
 │              │    │    └── mapping:
 │              │    │         ├──  sub_part:5 => sub_part:8
 │              │    │         ├──  part:6 => part:9
 │              │    │         └──  quantity:7 => quantity:10
 │              │    ├── scan p
 │              │    │    └── columns: p.part:11 p.sub_part:12 p.quantity:13 p.rowid:14!null
 │              │    └── filters (true)
 │              └── filters
 │                   └── p.part:11 = sub_part:8
 └── group-by
      ├── columns: sub_part:15 sum:18
      ├── grouping columns: sub_part:15
      ├── project
      │    ├── columns: sub_part:15 quantity:17
      │    └── with-scan &2 (included_parts)
      │         ├── columns: sub_part:15 part:16 quantity:17
      │         └── mapping:
      │              ├──  sub_part:5 => sub_part:15
      │              ├──  part:6 => part:16
      │              └──  quantity:7 => quantity:17
      └── aggregations
           └── sum [as=sum:18]
                └── quantity:17


exec-ddl
CREATE TABLE graph (id INT PRIMARY KEY, link INT, data STRING)
----

build
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[g.id],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || g.id,
      g.id = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph
----
with &2 (search_graph)
 ├── columns: id:25 link:26 data:27 depth:28 path:29 cycle:30
 ├── recursive-c-t-e
 │    ├── columns: id:7 link:8 data:9 depth:10 path:11 cycle:12
 │    ├── working table binding: &1
 │    ├── initial columns: g.id:1 g.link:2 g.data:3 "?column?":4 array:5 bool:6
 │    ├── recursive columns: g.id:13 g.link:14 g.data:15 "?column?":22 "?column?":23 "?column?":24
 │    ├── project
 │    │    ├── columns: "?column?":4!null array:5!null bool:6!null g.id:1!null g.link:2 g.data:3
 │    │    ├── scan g
 │    │    │    └── columns: g.id:1!null g.link:2 g.data:3
 │    │    └── projections
 │    │         ├── 1 [as="?column?":4]
 │    │         ├── ARRAY[g.id:1] [as=array:5]
 │    │         └── false [as=bool:6]
 │    └── project
 │         ├── columns: "?column?":22 "?column?":23 "?column?":24 g.id:13!null g.link:14 g.data:15
 │         ├── select
 │         │    ├── columns: g.id:13!null g.link:14 g.data:15 id:16 link:17!null data:18 depth:19 path:20 cycle:21!null
 │         │    ├── inner-join (cross)
 │         │    │    ├── columns: g.id:13!null g.link:14 g.data:15 id:16 link:17 data:18 depth:19 path:20 cycle:21
 │         │    │    ├── scan g
 │         │    │    │    └── columns: g.id:13!null g.link:14 g.data:15
 │         │    │    ├── with-scan &1 (search_graph)
 │         │    │    │    ├── columns: id:16 link:17 data:18 depth:19 path:20 cycle:21
 │         │    │    │    └── mapping:
 │         │    │    │         ├──  id:7 => id:16
 │         │    │    │         ├──  link:8 => link:17
 │         │    │    │         ├──  data:9 => data:18
 │         │    │    │         ├──  depth:10 => depth:19
 │         │    │    │         ├──  path:11 => path:20
 │         │    │    │         └──  cycle:12 => cycle:21
 │         │    │    └── filters (true)
 │         │    └── filters
 │         │         └── (g.id:13 = link:17) AND (NOT cycle:21)
 │         └── projections
 │              ├── depth:19 + 1 [as="?column?":22]
 │              ├── path:20 || g.id:13 [as="?column?":23]
 │              └── g.id:13 = ANY path:20 [as="?column?":24]
 └── with-scan &2 (search_graph)
      ├── columns: id:25 link:26 data:27 depth:28 path:29 cycle:30
      └── mapping:
           ├──  id:7 => id:25
           ├──  link:8 => link:26
           ├──  data:9 => data:27
           ├──  depth:10 => depth:28
           ├──  path:11 => path:29
           └──  cycle:12 => cycle:30

# Test where initial query has duplicate columns.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 0, 0
  UNION ALL
    SELECT a+1, b+10 FROM cte WHERE a < 5
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:8 b:9
 ├── recursive-c-t-e
 │    ├── columns: a:2 b:3
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1 "?column?":1
 │    ├── recursive columns: "?column?":6 "?column?":7
 │    ├── project
 │    │    ├── columns: "?column?":1!null
 │    │    ├── values
 │    │    │    └── ()
 │    │    └── projections
 │    │         └── 0 [as="?column?":1]
 │    └── project
 │         ├── columns: "?column?":6!null "?column?":7
 │         ├── select
 │         │    ├── columns: a:4!null b:5
 │         │    ├── with-scan &1 (cte)
 │         │    │    ├── columns: a:4 b:5
 │         │    │    └── mapping:
 │         │    │         ├──  a:2 => a:4
 │         │    │         └──  b:3 => b:5
 │         │    └── filters
 │         │         └── a:4 < 5
 │         └── projections
 │              ├── a:4 + 1 [as="?column?":6]
 │              └── b:5 + 10 [as="?column?":7]
 └── with-scan &2 (cte)
      ├── columns: a:8 b:9
      └── mapping:
           ├──  a:2 => a:8
           └──  b:3 => b:9

# Test where recursive query has duplicate columns.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 0, 1
  UNION ALL
    SELECT a+1, a+1 FROM cte WHERE a < 5
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:8 b:9
 ├── recursive-c-t-e
 │    ├── columns: a:3 b:4
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1 "?column?":2
 │    ├── recursive columns: "?column?":7 "?column?":7
 │    ├── project
 │    │    ├── columns: "?column?":1!null "?column?":2!null
 │    │    ├── values
 │    │    │    └── ()
 │    │    └── projections
 │    │         ├── 0 [as="?column?":1]
 │    │         └── 1 [as="?column?":2]
 │    └── project
 │         ├── columns: "?column?":7!null
 │         ├── select
 │         │    ├── columns: a:5!null b:6
 │         │    ├── with-scan &1 (cte)
 │         │    │    ├── columns: a:5 b:6
 │         │    │    └── mapping:
 │         │    │         ├──  a:3 => a:5
 │         │    │         └──  b:4 => b:6
 │         │    └── filters
 │         │         └── a:5 < 5
 │         └── projections
 │              └── a:5 + 1 [as="?column?":7]
 └── with-scan &2 (cte)
      ├── columns: a:8 b:9
      └── mapping:
           ├──  a:3 => a:8
           └──  b:4 => b:9

# Allow non-recursive CTE when RECURSIVE is used.
build
WITH RECURSIVE cte(a, b) AS (
  SELECT 1, 2
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:3!null b:4!null
 ├── project
 │    ├── columns: "?column?":1!null "?column?":2!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         ├── 1 [as="?column?":1]
 │         └── 2 [as="?column?":2]
 └── with-scan &2 (cte)
      ├── columns: a:3!null b:4!null
      └── mapping:
           ├──  "?column?":1 => a:3
           └──  "?column?":2 => b:4

# Allow non-recursive CTE even when it has UNION ALL.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    SELECT 3, 4
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:9!null b:10!null
 ├── union
 │    ├── columns: "?column?":7!null "?column?":8!null
 │    ├── left columns: "?column?":1 "?column?":2
 │    ├── right columns: "?column?":5 "?column?":6
 │    ├── project
 │    │    ├── columns: "?column?":1!null "?column?":2!null
 │    │    ├── values
 │    │    │    └── ()
 │    │    └── projections
 │    │         ├── 1 [as="?column?":1]
 │    │         └── 2 [as="?column?":2]
 │    └── project
 │         ├── columns: "?column?":5!null "?column?":6!null
 │         ├── values
 │         │    └── ()
 │         └── projections
 │              ├── 3 [as="?column?":5]
 │              └── 4 [as="?column?":6]
 └── with-scan &2 (cte)
      ├── columns: a:9!null b:10!null
      └── mapping:
           ├──  "?column?":7 => a:9
           └──  "?column?":8 => b:10

# Allow non-recursive CTE even when it has UNION.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION
    SELECT 3, 4
) SELECT * FROM cte;
----
with &2 (cte)
 ├── columns: a:7!null b:8!null
 ├── union
 │    ├── columns: "?column?":5!null "?column?":6!null
 │    ├── left columns: "?column?":1 "?column?":2
 │    ├── right columns: "?column?":3 "?column?":4
 │    ├── project
 │    │    ├── columns: "?column?":1!null "?column?":2!null
 │    │    ├── values
 │    │    │    └── ()
 │    │    └── projections
 │    │         ├── 1 [as="?column?":1]
 │    │         └── 2 [as="?column?":2]
 │    └── project
 │         ├── columns: "?column?":3!null "?column?":4!null
 │         ├── values
 │         │    └── ()
 │         └── projections
 │              ├── 3 [as="?column?":3]
 │              └── 4 [as="?column?":4]
 └── with-scan &2 (cte)
      ├── columns: a:7!null b:8!null
      └── mapping:
           ├──  "?column?":5 => a:7
           └──  "?column?":6 => b:8

# Error cases.
build
WITH RECURSIVE cte(a, b) AS (
  SELECT 1+a, 1+b FROM cte
) SELECT * FROM cte;
----
error (42601): recursive query "cte" does not have the form non-recursive-term UNION ALL recursive-term

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION
    SELECT 1+a, 1+b FROM cte
) SELECT * FROM cte;
----
error (0A000): unimplemented: recursive query "cte" uses UNION which is not implemented (only UNION ALL is supported)

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1+a, 1+b FROM cte
  UNION ALL
    SELECT 3, 4
) SELECT * FROM cte;
----
error (42601): recursive reference to query "cte" must not appear within its non-recursive term

build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    SELECT c1.a+c2.a, c1.b+c2.b FROM cte AS c1, cte AS c2
) SELECT * FROM cte;
----
error (42601): recursive reference to query "cte" must not appear more than once

# If we really need to reference the working table multiple times, we can use
# an inner WITH.
build
WITH RECURSIVE cte(a, b) AS (
    SELECT 1, 2
  UNION ALL
    (WITH foo AS (SELECT * FROM cte) SELECT c1.a+c2.a, c1.b+c2.b FROM foo AS c1, foo AS c2)
) SELECT * FROM cte;
----
with &3 (cte)
 ├── columns: a:13 b:14
 ├── recursive-c-t-e
 │    ├── columns: a:3 b:4
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":1 "?column?":2
 │    ├── recursive columns: "?column?":11 "?column?":12
 │    ├── project
 │    │    ├── columns: "?column?":1!null "?column?":2!null
 │    │    ├── values
 │    │    │    └── ()
 │    │    └── projections
 │    │         ├── 1 [as="?column?":1]
 │    │         └── 2 [as="?column?":2]
 │    └── with &2 (foo)
 │         ├── columns: "?column?":11 "?column?":12
 │         ├── with-scan &1 (cte)
 │         │    ├── columns: a:5 b:6
 │         │    └── mapping:
 │         │         ├──  a:3 => a:5
 │         │         └──  b:4 => b:6
 │         └── project
 │              ├── columns: "?column?":11 "?column?":12
 │              ├── inner-join (cross)
 │              │    ├── columns: a:7 b:8 a:9 b:10
 │              │    ├── with-scan &2 (foo)
 │              │    │    ├── columns: a:7 b:8
 │              │    │    └── mapping:
 │              │    │         ├──  a:5 => a:7
 │              │    │         └──  b:6 => b:8
 │              │    ├── with-scan &2 (foo)
 │              │    │    ├── columns: a:9 b:10
 │              │    │    └── mapping:
 │              │    │         ├──  a:5 => a:9
 │              │    │         └──  b:6 => b:10
 │              │    └── filters (true)
 │              └── projections
 │                   ├── a:7 + a:9 [as="?column?":11]
 │                   └── b:8 + b:10 [as="?column?":12]
 └── with-scan &3 (cte)
      ├── columns: a:13 b:14
      └── mapping:
           ├──  a:3 => a:13
           └──  b:4 => b:14

# Veryify use of WITH inside the initial statement.
build
WITH RECURSIVE cte(a) AS (
    (WITH v(x) AS (VALUES (1), (2)) SELECT v.x + v1.x FROM v, v AS v1)
  UNION ALL
    (SELECT a*10 FROM cte WHERE a < 100)
) SELECT * FROM cte;
----
with &3 (cte)
 ├── columns: a:8
 ├── recursive-c-t-e
 │    ├── columns: a:5
 │    ├── working table binding: &1
 │    ├── initial columns: "?column?":4
 │    ├── recursive columns: "?column?":7
 │    ├── with &2 (v)
 │    │    ├── columns: "?column?":4!null
 │    │    ├── values
 │    │    │    ├── columns: column1:1!null
 │    │    │    ├── (1,)
 │    │    │    └── (2,)
 │    │    └── project
 │    │         ├── columns: "?column?":4!null
 │    │         ├── inner-join (cross)
 │    │         │    ├── columns: x:2!null x:3!null
 │    │         │    ├── with-scan &2 (v)
 │    │         │    │    ├── columns: x:2!null
 │    │         │    │    └── mapping:
 │    │         │    │         └──  column1:1 => x:2
 │    │         │    ├── with-scan &2 (v)
 │    │         │    │    ├── columns: x:3!null
 │    │         │    │    └── mapping:
 │    │         │    │         └──  column1:1 => x:3
 │    │         │    └── filters (true)
 │    │         └── projections
 │    │              └── x:2 + x:3 [as="?column?":4]
 │    └── project
 │         ├── columns: "?column?":7!null
 │         ├── select
 │         │    ├── columns: a:6!null
 │         │    ├── with-scan &1 (cte)
 │         │    │    ├── columns: a:6
 │         │    │    └── mapping:
 │         │    │         └──  a:5 => a:6
 │         │    └── filters
 │         │         └── a:6 < 100
 │         └── projections
 │              └── a:6 * 10 [as="?column?":7]
 └── with-scan &3 (cte)
      ├── columns: a:8
      └── mapping:
           └──  a:5 => a:8

# Mutating WITHs not allowed at non-root positions.
build
SELECT * FROM (WITH foo AS (INSERT INTO y VALUES (1) RETURNING *) SELECT * FROM foo)
----
error (0A000): WITH clause containing a data-modifying statement must be at the top level

build
SELECT (WITH foo AS (INSERT INTO y VALUES (1) RETURNING *) SELECT * FROM foo)
----
error (0A000): WITH clause containing a data-modifying statement must be at the top level

build
SELECT (WITH foo AS (UPDATE y SET a = 4 RETURNING *) SELECT * FROM foo)
----
error (0A000): WITH clause containing a data-modifying statement must be at the top level

# Certain contexts besides the literal root allow mutating CTEs, like
# underneath an EXPLAIN.
build
EXPLAIN WITH foo AS (INSERT INTO y VALUES (1) RETURNING *) SELECT * FROM foo
----
explain
 ├── columns: tree:6 field:7 description:8
 └── with &1 (foo)
      ├── columns: a:5!null
      ├── project
      │    ├── columns: y.a:1!null
      │    └── insert y
      │         ├── columns: y.a:1!null rowid:2!null
      │         ├── insert-mapping:
      │         │    ├── column1:3 => y.a:1
      │         │    └── column4:4 => rowid:2
      │         └── project
      │              ├── columns: column4:4 column1:3!null
      │              ├── values
      │              │    ├── columns: column1:3!null
      │              │    └── (1,)
      │              └── projections
      │                   └── unique_rowid() [as=column4:4]
      └── with-scan &1 (foo)
           ├── columns: a:5!null
           └── mapping:
                └──  y.a:1 => a:5

exec-ddl
CREATE TABLE a(x INT);
----

build
INSERT INTO a(x)
        (WITH b(z) AS (VALUES (1),(2),(3)) SELECT z+1 AS w FROM b)
----
with &1 (b)
 ├── values
 │    ├── columns: column1:3!null
 │    ├── (1,)
 │    ├── (2,)
 │    └── (3,)
 └── insert a
      ├── columns: <none>
      ├── insert-mapping:
      │    ├── w:5 => x:1
      │    └── column6:6 => rowid:2
      └── project
           ├── columns: column6:6 w:5!null
           ├── project
           │    ├── columns: w:5!null
           │    ├── with-scan &1 (b)
           │    │    ├── columns: z:4!null
           │    │    └── mapping:
           │    │         └──  column1:3 => z:4
           │    └── projections
           │         └── z:4 + 1 [as=w:5]
           └── projections
                └── unique_rowid() [as=column6:6]

build
SELECT
    *
FROM
    (VALUES (1), (2)) AS v (x),
    LATERAL (SELECT * FROM (WITH foo AS (SELECT 1 + x) SELECT * FROM foo))
----
error (0A000): CTEs may not be correlated

# Subquery as a whole is correlated, but the WITH is not.
build
SELECT (WITH foo as (VALUES (1)) SELECT x) FROM (VALUES (1)) AS v(x)
----
with &1 (foo)
 ├── columns: x:4
 ├── values
 │    ├── columns: column1:2!null
 │    └── (1,)
 └── project
      ├── columns: x:4
      ├── values
      │    ├── columns: column1:1!null
      │    └── (1,)
      └── projections
           └── subquery [as=x:4]
                └── max1-row
                     ├── columns: x:3
                     └── project
                          ├── columns: x:3
                          ├── values
                          │    └── ()
                          └── projections
                               └── column1:1 [as=x:3]

# Regression test for #43963.
build
WITH a AS (SELECT 1 AS testval) SELECT a.testval FROM a
----
with &1 (a)
 ├── columns: testval:2!null
 ├── project
 │    ├── columns: testval:1!null
 │    ├── values
 │    │    └── ()
 │    └── projections
 │         └── 1 [as=testval:1]
 └── with-scan &1 (a)
      ├── columns: testval:2!null
      └── mapping:
           └──  testval:1 => testval:2

build
WITH t AS MATERIALIZED (SELECT a FROM y WHERE a < 3)
  SELECT * FROM x NATURAL JOIN t
----
with &1 (t)
 ├── columns: a:3!null b:4
 ├── materialized
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null y.rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 y.rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── project
      ├── columns: x.a:3!null b:4
      └── inner-join (hash)
           ├── columns: x.a:3!null b:4 x.rowid:5!null a:6!null
           ├── scan x
           │    └── columns: x.a:3 b:4 x.rowid:5!null
           ├── with-scan &1 (t)
           │    ├── columns: a:6!null
           │    └── mapping:
           │         └──  y.a:1 => a:6
           └── filters
                └── x.a:3 = a:6

build
WITH t AS NOT MATERIALIZED (SELECT a FROM y WHERE a < 3)
  SELECT * FROM x NATURAL JOIN t
----
with &1 (t)
 ├── columns: a:3!null b:4
 ├── not-materialized
 ├── project
 │    ├── columns: y.a:1!null
 │    └── select
 │         ├── columns: y.a:1!null y.rowid:2!null
 │         ├── scan y
 │         │    └── columns: y.a:1 y.rowid:2!null
 │         └── filters
 │              └── y.a:1 < 3
 └── project
      ├── columns: x.a:3!null b:4
      └── inner-join (hash)
           ├── columns: x.a:3!null b:4 x.rowid:5!null a:6!null
           ├── scan x
           │    └── columns: x.a:3 b:4 x.rowid:5!null
           ├── with-scan &1 (t)
           │    ├── columns: a:6!null
           │    └── mapping:
           │         └──  y.a:1 => a:6
           └── filters
                └── x.a:3 = a:6
