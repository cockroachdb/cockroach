exec-ddl
CREATE TABLE a (x INT PRIMARY KEY, y FLOAT)
----

exec-ddl
CREATE TABLE b (x INT, y FLOAT)
----

exec-ddl
CREATE TABLE c (x INT, y FLOAT, z VARCHAR, CONSTRAINT fk_x_ref_a FOREIGN KEY (x) REFERENCES a (x))
----

build
SELECT * FROM a, b
----
project
 ├── columns: x:1(int!null) y:2(float) x:3(int) y:4(float)
 └── inner-join (hash)
      ├── columns: a.x:1(int!null) a.y:2(float) b.x:3(int) b.y:4(float) rowid:5(int!null)
      ├── scan a
      │    └── columns: a.x:1(int!null) a.y:2(float)
      ├── scan b
      │    └── columns: b.x:3(int) b.y:4(float) rowid:5(int!null)
      └── filters (true)

build
SELECT a.x, b.y FROM a, b WHERE a.x = b.x
----
project
 ├── columns: x:1(int!null) y:4(float)
 └── select
      ├── columns: a.x:1(int!null) a.y:2(float) b.x:3(int!null) b.y:4(float) rowid:5(int!null)
      ├── inner-join (hash)
      │    ├── columns: a.x:1(int!null) a.y:2(float) b.x:3(int) b.y:4(float) rowid:5(int!null)
      │    ├── scan a
      │    │    └── columns: a.x:1(int!null) a.y:2(float)
      │    ├── scan b
      │    │    └── columns: b.x:3(int) b.y:4(float) rowid:5(int!null)
      │    └── filters (true)
      └── filters
           └── eq [type=bool]
                ├── variable: a.x [type=int]
                └── variable: b.x [type=int]

build
SELECT * FROM c, b, a WHERE c.x = a.x AND b.x = a.x
----
project
 ├── columns: x:1(int!null) y:2(float) z:3(varchar) x:5(int!null) y:6(float) x:8(int!null) y:9(float)
 └── select
      ├── columns: c.x:1(int!null) c.y:2(float) z:3(varchar) c.rowid:4(int!null) b.x:5(int!null) b.y:6(float) b.rowid:7(int!null) a.x:8(int!null) a.y:9(float)
      ├── inner-join (hash)
      │    ├── columns: c.x:1(int) c.y:2(float) z:3(varchar) c.rowid:4(int!null) b.x:5(int) b.y:6(float) b.rowid:7(int!null) a.x:8(int!null) a.y:9(float)
      │    ├── scan c
      │    │    └── columns: c.x:1(int) c.y:2(float) z:3(varchar) c.rowid:4(int!null)
      │    ├── inner-join (hash)
      │    │    ├── columns: b.x:5(int) b.y:6(float) b.rowid:7(int!null) a.x:8(int!null) a.y:9(float)
      │    │    ├── scan b
      │    │    │    └── columns: b.x:5(int) b.y:6(float) b.rowid:7(int!null)
      │    │    ├── scan a
      │    │    │    └── columns: a.x:8(int!null) a.y:9(float)
      │    │    └── filters (true)
      │    └── filters (true)
      └── filters
           └── and [type=bool]
                ├── eq [type=bool]
                │    ├── variable: c.x [type=int]
                │    └── variable: a.x [type=int]
                └── eq [type=bool]
                     ├── variable: b.x [type=int]
                     └── variable: a.x [type=int]

exec-ddl
CREATE TABLE db1.a (x INT PRIMARY KEY, y FLOAT, z STRING)
----

exec-ddl
CREATE TABLE db2.a (x INT PRIMARY KEY, y FLOAT)
----

build fully-qualify-names
SELECT a.x FROM db1.a, db2.a
----
error (42P09): ambiguous source name: "a"

build fully-qualify-names
SELECT x FROM a, b
----
error (42702): column reference "x" is ambiguous (candidates: a.x, b.x)

build fully-qualify-names
SELECT * FROM db1.a, db2.a
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(float) z:3(string) x:4(int!null) y:5(float)
 ├── scan db1.public.a
 │    └── columns: db1.public.a.x:1(int!null) db1.public.a.y:2(float) db1.public.a.z:3(string)
 ├── scan db2.public.a
 │    └── columns: db2.public.a.x:4(int!null) db2.public.a.y:5(float)
 └── filters (true)

build fully-qualify-names
SELECT * FROM a, a
----
error (42712): source name "a" specified more than once (missing AS clause)

# TODO(justin): this case should be rejected for having a name specified twice.
build fully-qualify-names
SELECT * FROM a, (SELECT * FROM a) AS a
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(float) x:3(int!null) y:4(float)
 ├── scan t.public.a
 │    └── columns: t.public.a.x:1(int!null) t.public.a.y:2(float)
 ├── scan t.public.a
 │    └── columns: t.public.a.x:3(int!null) t.public.a.y:4(float)
 └── filters (true)

build fully-qualify-names
SELECT * FROM t.a, a
----
error (42712): source name "a" specified more than once (missing AS clause)

build fully-qualify-names
SELECT * FROM t.a, a AS a
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(float) x:3(int!null) y:4(float)
 ├── scan t.public.a
 │    └── columns: t.public.a.x:1(int!null) t.public.a.y:2(float)
 ├── scan t.public.a
 │    └── columns: t.public.a.x:3(int!null) t.public.a.y:4(float)
 └── filters (true)

build fully-qualify-names
SELECT a.* FROM t.a, a AS a
----
error (42P09): ambiguous source name: "a"

exec-ddl
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, c));
----

exec-ddl
CREATE TABLE def (d INT, e INT, f INT, PRIMARY KEY (f, e));
----

exec-ddl
ALTER TABLE abc INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'
----

exec-ddl
ALTER TABLE def INJECT STATISTICS '[
  {
    "columns": ["f"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'
----

# Test the CommuteSemiJoinRule creates an appropriate inner join.
opt
SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=d)
----
project
 ├── columns: a:1(int!null) b:2(int) c:3(int!null)
 └── inner-join (hash)
      ├── columns: a:1(int!null) b:2(int) c:3(int!null) d:4(int!null)
      ├── distinct-on
      │    ├── columns: d:4(int)
      │    ├── grouping columns: d:4(int)
      │    └── scan def
      │         └── columns: d:4(int)
      ├── scan abc
      │    └── columns: a:1(int!null) b:2(int) c:3(int!null)
      └── filters
           └── eq [type=bool]
                ├── variable: a [type=int]
                └── variable: d [type=int]

opt disable=CommuteSemiJoin format=show-all
SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
semi-join (lookup def)
 ├── columns: a:1(int!null) b:2(int) c:3(int!null)
 ├── key columns: [1 3] = [6 5]
 ├── stats: [rows=100]
 ├── cost: 712.03
 ├── key: (1,3)
 ├── fd: (1,3)-->(2)
 ├── prune: (2)
 ├── interesting orderings: (+1,+3)
 ├── scan t.public.abc
 │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int!null)
 │    ├── stats: [rows=100]
 │    ├── cost: 106.02
 │    ├── key: (1,3)
 │    ├── fd: (1,3)-->(2)
 │    ├── prune: (1-3)
 │    └── interesting orderings: (+1,+3)
 └── filters (true)

# This test doesn't test anything but is here to highlight some interesting behavior.
# The above plan is essentially equivalent to this one except this one has a much lower
# cost which I think is incorrect. I believe this is because when we collect stats for the
# joins, the semi join incorrectly collects statistics and assumes that the filters on a
# semi-join have no effect. And so the cardinality of the semi join is much higher than
# what it should be.
# Also, it also looks like the inner join cardinality estimates are off
# as well. In the presence of filters they look like they are underestimating the rowcount of
# the join. Its these two factors that make the optimizer pick the inner join plan over the
# above semi-join one. I don't expect this is be very costly, but this is a potential blocker
# for the CommuteSemiJoin rule and so I wanted to bring it up.
# TODO(ridwanmsharif): Is this acceptable? Also remove this before merging.
opt format=show-all
SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
project
 ├── columns: a:1(int!null) b:2(int) c:3(int!null)
 ├── stats: [rows=100]
 ├── cost: 507.246
 ├── key: (1,3)
 ├── fd: (1,3)-->(2)
 ├── prune: (2)
 ├── interesting orderings: (+1,+3)
 └── inner-join (lookup def)
      ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int!null) t.public.def.d:4(int) t.public.def.e:5(int!null) t.public.def.f:6(int!null)
      ├── key columns: [1 3] = [6 5]
      ├── stats: [rows=0.1, distinct(1)=0.1, null(1)=0, distinct(3)=0.1, null(3)=0, distinct(5)=0.1, null(5)=0, distinct(6)=0.1, null(6)=0]
      ├── cost: 506.236
      ├── key: (5,6)
      ├── fd: (1,3)-->(2), (5,6)-->(4), (1)==(6), (6)==(1), (3)==(5), (5)==(3)
      ├── interesting orderings: (+1,+3)
      ├── scan t.public.abc
      │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int!null)
      │    ├── stats: [rows=100, distinct(1)=100, null(1)=0, distinct(3)=10, null(3)=0]
      │    ├── cost: 106.02
      │    ├── key: (1,3)
      │    ├── fd: (1,3)-->(2)
      │    ├── prune: (1-3)
      │    └── interesting orderings: (+1,+3)
      └── filters (true)

exec-ddl
CREATE TABLE customers (id INT PRIMARY KEY, name STRING)
----

exec-ddl
CREATE TABLE orders (id INT PRIMARY KEY, cust_id INT REFERENCES customers (id), order_date DATE, INDEX (order_date) STORING (cust_id))
----

exec-ddl
ALTER TABLE customers INJECT STATISTICS '[
  {
    "columns": ["id"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100000,
    "distinct_count": 100000
  }
]'
----

exec-ddl
ALTER TABLE orders INJECT STATISTICS '[
  {
    "columns": ["id"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 1000000
  },
  {
    "columns": ["cust_id"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 10000000
  },
  {
    "columns": ["order_date"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 1000000
  }
]'
----

opt disable=CommuteSemiJoin
SELECT *
FROM customers c
WHERE EXISTS(SELECT * FROM orders o WHERE o.cust_id=c.id AND o.order_date='2019-01-01')
----
semi-join (merge)
 ├── columns: id:1(int!null) name:2(string)
 ├── left ordering: +1
 ├── right ordering: +4
 ├── scan c
 │    ├── columns: c.id:1(int!null) name:2(string)
 │    └── ordering: +1
 ├── sort
 │    ├── columns: o.id:3(int!null) cust_id:4(int) order_date:5(date!null)
 │    ├── ordering: +4 opt(5)
 │    └── scan o@secondary
 │         ├── columns: o.id:3(int!null) cust_id:4(int) order_date:5(date!null)
 │         └── constraint: /5/3: [/'2019-01-01' - /'2019-01-01']
 └── filters (true)

# The CommuteSemiJoin rule allows a much better plan because we can use
# a lookup join.
opt
SELECT *
FROM customers c
WHERE EXISTS(SELECT * FROM orders o WHERE o.cust_id=c.id AND o.order_date='2019-01-01')
----
project
 ├── columns: id:1(int!null) name:2(string)
 └── inner-join (lookup customers)
      ├── columns: c.id:1(int!null) name:2(string) cust_id:4(int!null)
      ├── key columns: [4] = [1]
      ├── distinct-on
      │    ├── columns: cust_id:4(int)
      │    ├── grouping columns: cust_id:4(int)
      │    └── scan o@secondary
      │         ├── columns: cust_id:4(int) order_date:5(date!null)
      │         └── constraint: /5/3: [/'2019-01-01' - /'2019-01-01']
      └── filters (true)
