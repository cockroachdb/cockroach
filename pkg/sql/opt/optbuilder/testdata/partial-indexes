exec-ddl
CREATE TABLE partial_indexes (
    a INT PRIMARY KEY,
    b INT,
    c STRING,
    UNIQUE (b, c),
    INDEX (b),
    INDEX (b) WHERE c = 'foo',
    INDEX (c) WHERE a > b AND c = 'bar',
    INDEX "b:delete-only" (b) WHERE c = 'delete-only',
    INDEX "b:write-only" (b) WHERE c = 'write-only'
)
----

exec-ddl
CREATE TABLE uniq (
    a INT PRIMARY KEY,
    b INT,
    c STRING,
    UNIQUE INDEX (b) WHERE c = 'foo'
)
----


exec-ddl
CREATE TABLE partial_index_virtual (
    a INT PRIMARY KEY,
    b INT,
    c STRING,
    d STRING AS (lower(c)) VIRTUAL,
    INDEX (b) WHERE d = 'foo'
)
----

exec-ddl
CREATE TABLE ambig (
    partial_index_put1 INT,
    partial_index_del1 INT,
    UNIQUE INDEX (partial_index_put1) WHERE partial_index_put1 > 0,
    UNIQUE INDEX (partial_index_del1) WHERE partial_index_del1 > 0
)
----

# -- SELECT tests --

# Populate table metadata with partial index predicates.
# TODO(mgartner): Use the partial_indexes table instead.
exec-ddl
CREATE TABLE partial_index (
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u (u) WHERE u = 1,
    INDEX uv (u, v),
    INDEX v (v) WHERE v > 100 AND v < 200 AND u > 50
)
----

build
SELECT k FROM partial_index
----
project
 ├── columns: k:1!null
 └── scan partial_index
      ├── columns: k:1!null u:2 v:3 crdb_internal_mvcc_timestamp:4
      └── partial index predicates
           ├── u: filters
           │    └── u:2 = 1
           └── v: filters
                └── ((v:3 > 100) AND (v:3 < 200)) AND (u:2 > 50)

# TODO(mgartner): Replace partial_index_virt with partial_index_comp.
exec-ddl
CREATE TABLE partial_index_comp (
  k INT PRIMARY KEY,
  u INT,
  v INT AS (u + 10) VIRTUAL,
  w INT AS (u + 100) STORED,
  INDEX v_idx (u) WHERE v > 0,
  INDEX w_idx (u) WHERE w > 0
)
----

# Inline virtual computed column expressions in partial index predicates in
# table metadata. Do not inline stored computed column expressions.
build
SELECT k FROM partial_index_comp
----
project
 ├── columns: k:1!null
 └── project
      ├── columns: v:3 k:1!null u:2 w:4 crdb_internal_mvcc_timestamp:5
      ├── scan partial_index_comp
      │    ├── columns: k:1!null u:2 w:4 crdb_internal_mvcc_timestamp:5
      │    ├── computed column expressions
      │    │    ├── v:3
      │    │    │    └── u:2 + 10
      │    │    └── w:4
      │    │         └── u:2 + 100
      │    └── partial index predicates
      │         ├── v_idx: filters
      │         │    └── (u:2 + 10) > 0
      │         └── w_idx: filters
      │              └── w:4 > 0
      └── projections
           └── u:2 + 10 [as=v:3]

# -- INSERT tests --

build
INSERT INTO partial_indexes VALUES (2, 1, 'bar')
----
insert partial_indexes
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:8 partial_index_put2:9 partial_index_put3:10 partial_index_put4:11
 └── project
      ├── columns: partial_index_put1:8!null partial_index_put2:9!null partial_index_put3:10!null partial_index_put4:11!null column1:5!null column2:6!null column3:7!null
      ├── values
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    └── (2, 1, 'bar')
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:8]
           ├── (column1:5 > column2:6) AND (column3:7 = 'bar') [as=partial_index_put2:9]
           ├── column3:7 = 'delete-only' [as=partial_index_put3:10]
           └── column3:7 = 'write-only' [as=partial_index_put4:11]

# Do not error with "column reference is ambiguous" when table column names
# match synthesized column names.
build
INSERT INTO ambig (partial_index_put1) VALUES (1)
----
insert ambig
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:5 => ambig.partial_index_put1:1
 │    ├── column6:6 => partial_index_del1:2
 │    └── column7:7 => rowid:3
 ├── partial index put columns: partial_index_put1:8 partial_index_put2:9
 └── project
      ├── columns: partial_index_put1:8!null partial_index_put2:9 column1:5!null column6:6 column7:7
      ├── project
      │    ├── columns: column6:6 column7:7 column1:5!null
      │    ├── values
      │    │    ├── columns: column1:5!null
      │    │    └── (1,)
      │    └── projections
      │         ├── NULL::INT8 [as=column6:6]
      │         └── unique_rowid() [as=column7:7]
      └── projections
           ├── column1:5 > 0 [as=partial_index_put1:8]
           └── column6:6 > 0 [as=partial_index_put2:9]

build
INSERT INTO partial_index_virtual (a, b, c) VALUES (2, 1, 'Foo')
----
insert partial_index_virtual
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:6 => a:1
 │    ├── column2:7 => b:2
 │    ├── column3:8 => c:3
 │    └── column9:9 => d:4
 ├── partial index put columns: partial_index_put1:10
 └── project
      ├── columns: partial_index_put1:10 column1:6!null column2:7!null column3:8!null column9:9
      ├── project
      │    ├── columns: column9:9 column1:6!null column2:7!null column3:8!null
      │    ├── values
      │    │    ├── columns: column1:6!null column2:7!null column3:8!null
      │    │    └── (2, 1, 'Foo')
      │    └── projections
      │         └── lower(column3:8) [as=column9:9]
      └── projections
           └── column9:9 = 'foo' [as=partial_index_put1:10]

# Regression test for issue #52546. Building partial index predicate expressions
# that are only a single column reference should not panic.

exec-ddl
CREATE TABLE t52546 (a INT, b BOOL, INDEX (a) WHERE b)
----

build
INSERT INTO t52546 VALUES (1, true)
----
insert t52546
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column7:7 => rowid:3
 ├── partial index put columns: column2:6
 └── project
      ├── columns: column7:7 column1:5!null column2:6!null
      ├── values
      │    ├── columns: column1:5!null column2:6!null
      │    └── (1, true)
      └── projections
           └── unique_rowid() [as=column7:7]

# -- DELETE tests --

build
DELETE FROM partial_indexes
----
delete partial_indexes
 ├── columns: <none>
 ├── fetch columns: a:5 b:6 c:7
 ├── partial index del columns: partial_index_del1:9 partial_index_del2:10 partial_index_del3:11 partial_index_del4:12
 └── project
      ├── columns: partial_index_del1:9 partial_index_del2:10 partial_index_del3:11 partial_index_del4:12 a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      ├── scan partial_indexes
      │    ├── columns: a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      │    └── partial index predicates
      │         ├── secondary: filters
      │         │    └── c:7 = 'foo'
      │         ├── secondary: filters
      │         │    └── (a:5 > b:6) AND (c:7 = 'bar')
      │         ├── b: filters
      │         │    └── c:7 = 'delete-only'
      │         └── b: filters
      │              └── c:7 = 'write-only'
      └── projections
           ├── c:7 = 'foo' [as=partial_index_del1:9]
           ├── (a:5 > b:6) AND (c:7 = 'bar') [as=partial_index_del2:10]
           ├── c:7 = 'delete-only' [as=partial_index_del3:11]
           └── c:7 = 'write-only' [as=partial_index_del4:12]

# Do not error with "column reference is ambiguous" when table column names
# match synthesized column names.
build
DELETE FROM ambig WHERE partial_index_del1 = 5
----
delete ambig
 ├── columns: <none>
 ├── fetch columns: partial_index_put1:5 ambig.partial_index_del1:6 rowid:7
 ├── partial index del columns: partial_index_del1:9 partial_index_del2:10
 └── project
      ├── columns: partial_index_del1:9 partial_index_del2:10!null partial_index_put1:5 ambig.partial_index_del1:6!null rowid:7!null crdb_internal_mvcc_timestamp:8
      ├── select
      │    ├── columns: partial_index_put1:5 ambig.partial_index_del1:6!null rowid:7!null crdb_internal_mvcc_timestamp:8
      │    ├── scan ambig
      │    │    ├── columns: partial_index_put1:5 ambig.partial_index_del1:6 rowid:7!null crdb_internal_mvcc_timestamp:8
      │    │    └── partial index predicates
      │    │         ├── secondary: filters
      │    │         │    └── partial_index_put1:5 > 0
      │    │         └── secondary: filters
      │    │              └── ambig.partial_index_del1:6 > 0
      │    └── filters
      │         └── ambig.partial_index_del1:6 = 5
      └── projections
           ├── partial_index_put1:5 > 0 [as=partial_index_del1:9]
           └── ambig.partial_index_del1:6 > 0 [as=partial_index_del2:10]

build
DELETE FROM partial_index_virtual
----
delete partial_index_virtual
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8 d:9
 ├── partial index del columns: partial_index_del1:11
 └── project
      ├── columns: partial_index_del1:11 a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10
      ├── project
      │    ├── columns: d:9 a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    ├── scan partial_index_virtual
      │    │    ├── columns: a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    │    ├── computed column expressions
      │    │    │    └── d:9
      │    │    │         └── lower(c:8)
      │    │    └── partial index predicates
      │    │         └── secondary: filters
      │    │              └── lower(c:8) = 'foo'
      │    └── projections
      │         └── lower(c:8) [as=d:9]
      └── projections
           └── d:9 = 'foo' [as=partial_index_del1:11]

# -- UPDATE tests --

build
UPDATE partial_indexes SET a = 1
----
update partial_indexes
 ├── columns: <none>
 ├── fetch columns: a:5 b:6 c:7
 ├── update-mapping:
 │    └── a_new:9 => a:1
 ├── partial index put columns: partial_index_put1:10 partial_index_put2:11 partial_index_put3:13 partial_index_put4:14
 ├── partial index del columns: partial_index_put1:10 partial_index_del2:12 partial_index_put3:13 partial_index_put4:14
 └── project
      ├── columns: partial_index_put1:10 partial_index_put2:11 partial_index_del2:12 partial_index_put3:13 partial_index_put4:14 a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8 a_new:9!null
      ├── project
      │    ├── columns: a_new:9!null a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      │    ├── scan partial_indexes
      │    │    ├── columns: a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      │    │    └── partial index predicates
      │    │         ├── secondary: filters
      │    │         │    └── c:7 = 'foo'
      │    │         ├── secondary: filters
      │    │         │    └── (a:5 > b:6) AND (c:7 = 'bar')
      │    │         ├── b: filters
      │    │         │    └── c:7 = 'delete-only'
      │    │         └── b: filters
      │    │              └── c:7 = 'write-only'
      │    └── projections
      │         └── 1 [as=a_new:9]
      └── projections
           ├── c:7 = 'foo' [as=partial_index_put1:10]
           ├── (a_new:9 > b:6) AND (c:7 = 'bar') [as=partial_index_put2:11]
           ├── (a:5 > b:6) AND (c:7 = 'bar') [as=partial_index_del2:12]
           ├── c:7 = 'delete-only' [as=partial_index_put3:13]
           └── c:7 = 'write-only' [as=partial_index_put4:14]

build
UPDATE partial_indexes SET a = a + 5 RETURNING *
----
update partial_indexes
 ├── columns: a:1!null b:2 c:3
 ├── fetch columns: a:5 b:6 c:7
 ├── update-mapping:
 │    └── a_new:9 => a:1
 ├── partial index put columns: partial_index_put1:10 partial_index_put2:11 partial_index_put3:13 partial_index_put4:14
 ├── partial index del columns: partial_index_put1:10 partial_index_del2:12 partial_index_put3:13 partial_index_put4:14
 └── project
      ├── columns: partial_index_put1:10 partial_index_put2:11 partial_index_del2:12 partial_index_put3:13 partial_index_put4:14 a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8 a_new:9!null
      ├── project
      │    ├── columns: a_new:9!null a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      │    ├── scan partial_indexes
      │    │    ├── columns: a:5!null b:6 c:7 crdb_internal_mvcc_timestamp:8
      │    │    └── partial index predicates
      │    │         ├── secondary: filters
      │    │         │    └── c:7 = 'foo'
      │    │         ├── secondary: filters
      │    │         │    └── (a:5 > b:6) AND (c:7 = 'bar')
      │    │         ├── b: filters
      │    │         │    └── c:7 = 'delete-only'
      │    │         └── b: filters
      │    │              └── c:7 = 'write-only'
      │    └── projections
      │         └── a:5 + 5 [as=a_new:9]
      └── projections
           ├── c:7 = 'foo' [as=partial_index_put1:10]
           ├── (a_new:9 > b:6) AND (c:7 = 'bar') [as=partial_index_put2:11]
           ├── (a:5 > b:6) AND (c:7 = 'bar') [as=partial_index_del2:12]
           ├── c:7 = 'delete-only' [as=partial_index_put3:13]
           └── c:7 = 'write-only' [as=partial_index_put4:14]

# Do not error with "column reference is ambiguous" when table column names
# match synthesized column names.
build
UPDATE ambig SET partial_index_put1 = 1, partial_index_del1 = 2 WHERE partial_index_put1 = 10 and partial_index_del1 = 20
----
update ambig
 ├── columns: <none>
 ├── fetch columns: ambig.partial_index_put1:5 ambig.partial_index_del1:6 rowid:7
 ├── update-mapping:
 │    ├── partial_index_put1_new:9 => ambig.partial_index_put1:1
 │    └── partial_index_del1_new:10 => ambig.partial_index_del1:2
 ├── partial index put columns: partial_index_put1:11 partial_index_put2:13
 ├── partial index del columns: partial_index_del1:12 partial_index_del2:14
 └── project
      ├── columns: partial_index_put1:11!null partial_index_del1:12!null partial_index_put2:13!null partial_index_del2:14!null ambig.partial_index_put1:5!null ambig.partial_index_del1:6!null rowid:7!null crdb_internal_mvcc_timestamp:8 partial_index_put1_new:9!null partial_index_del1_new:10!null
      ├── project
      │    ├── columns: partial_index_put1_new:9!null partial_index_del1_new:10!null ambig.partial_index_put1:5!null ambig.partial_index_del1:6!null rowid:7!null crdb_internal_mvcc_timestamp:8
      │    ├── select
      │    │    ├── columns: ambig.partial_index_put1:5!null ambig.partial_index_del1:6!null rowid:7!null crdb_internal_mvcc_timestamp:8
      │    │    ├── scan ambig
      │    │    │    ├── columns: ambig.partial_index_put1:5 ambig.partial_index_del1:6 rowid:7!null crdb_internal_mvcc_timestamp:8
      │    │    │    └── partial index predicates
      │    │    │         ├── secondary: filters
      │    │    │         │    └── ambig.partial_index_put1:5 > 0
      │    │    │         └── secondary: filters
      │    │    │              └── ambig.partial_index_del1:6 > 0
      │    │    └── filters
      │    │         └── (ambig.partial_index_put1:5 = 10) AND (ambig.partial_index_del1:6 = 20)
      │    └── projections
      │         ├── 1 [as=partial_index_put1_new:9]
      │         └── 2 [as=partial_index_del1_new:10]
      └── projections
           ├── partial_index_put1_new:9 > 0 [as=partial_index_put1:11]
           ├── ambig.partial_index_put1:5 > 0 [as=partial_index_del1:12]
           ├── partial_index_del1_new:10 > 0 [as=partial_index_put2:13]
           └── ambig.partial_index_del1:6 > 0 [as=partial_index_del2:14]

build
UPDATE partial_index_virtual SET b = 1
----
update partial_index_virtual
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8 d:9
 ├── update-mapping:
 │    └── b_new:11 => b:2
 ├── partial index put columns: partial_index_put1:13
 ├── partial index del columns: partial_index_put1:13
 └── project
      ├── columns: partial_index_put1:13 a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10 b_new:11!null column12:12
      ├── project
      │    ├── columns: column12:12 a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10 b_new:11!null
      │    ├── project
      │    │    ├── columns: b_new:11!null a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10
      │    │    ├── project
      │    │    │    ├── columns: d:9 a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    │    │    ├── scan partial_index_virtual
      │    │    │    │    ├── columns: a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    │    │    │    ├── computed column expressions
      │    │    │    │    │    └── d:9
      │    │    │    │    │         └── lower(c:8)
      │    │    │    │    └── partial index predicates
      │    │    │    │         └── secondary: filters
      │    │    │    │              └── lower(c:8) = 'foo'
      │    │    │    └── projections
      │    │    │         └── lower(c:8) [as=d:9]
      │    │    └── projections
      │    │         └── 1 [as=b_new:11]
      │    └── projections
      │         └── lower(c:8) [as=column12:12]
      └── projections
           └── d:9 = 'foo' [as=partial_index_put1:13]

build
UPDATE partial_index_virtual SET c = 'Bar'
----
update partial_index_virtual
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8 d:9
 ├── update-mapping:
 │    ├── c_new:11 => c:3
 │    └── column12:12 => d:4
 ├── partial index put columns: partial_index_put1:13
 ├── partial index del columns: partial_index_del1:14
 └── project
      ├── columns: partial_index_put1:13 partial_index_del1:14 a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10 c_new:11!null column12:12
      ├── project
      │    ├── columns: column12:12 a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10 c_new:11!null
      │    ├── project
      │    │    ├── columns: c_new:11!null a:6!null b:7 c:8 d:9 crdb_internal_mvcc_timestamp:10
      │    │    ├── project
      │    │    │    ├── columns: d:9 a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    │    │    ├── scan partial_index_virtual
      │    │    │    │    ├── columns: a:6!null b:7 c:8 crdb_internal_mvcc_timestamp:10
      │    │    │    │    ├── computed column expressions
      │    │    │    │    │    └── d:9
      │    │    │    │    │         └── lower(c:8)
      │    │    │    │    └── partial index predicates
      │    │    │    │         └── secondary: filters
      │    │    │    │              └── lower(c:8) = 'foo'
      │    │    │    └── projections
      │    │    │         └── lower(c:8) [as=d:9]
      │    │    └── projections
      │    │         └── 'Bar' [as=c_new:11]
      │    └── projections
      │         └── lower(c_new:11) [as=column12:12]
      └── projections
           ├── column12:12 = 'foo' [as=partial_index_put1:13]
           └── d:9 = 'foo' [as=partial_index_del1:14]

# -- UPSERT / INSERT ON CONFLICT tests --

build
INSERT INTO partial_indexes VALUES (2, 1, 'bar') ON CONFLICT DO NOTHING
----
insert partial_indexes
 ├── columns: <none>
 ├── arbiter indexes: primary secondary
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:16 partial_index_put2:17 partial_index_put3:18 partial_index_put4:19
 └── project
      ├── columns: partial_index_put1:16!null partial_index_put2:17!null partial_index_put3:18!null partial_index_put4:19!null column1:5!null column2:6!null column3:7!null
      ├── upsert-distinct-on
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    ├── grouping columns: column2:6!null column3:7!null
      │    ├── upsert-distinct-on
      │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    ├── grouping columns: column1:5!null
      │    │    ├── anti-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    ├── anti-join (hash)
      │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    ├── values
      │    │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    │    └── (2, 1, 'bar')
      │    │    │    │    ├── scan partial_indexes
      │    │    │    │    │    ├── columns: a:8!null b:9 c:10
      │    │    │    │    │    └── partial index predicates
      │    │    │    │    │         ├── secondary: filters
      │    │    │    │    │         │    └── c:10 = 'foo'
      │    │    │    │    │         ├── secondary: filters
      │    │    │    │    │         │    └── (a:8 > b:9) AND (c:10 = 'bar')
      │    │    │    │    │         ├── b: filters
      │    │    │    │    │         │    └── c:10 = 'delete-only'
      │    │    │    │    │         └── b: filters
      │    │    │    │    │              └── c:10 = 'write-only'
      │    │    │    │    └── filters
      │    │    │    │         └── column1:5 = a:8
      │    │    │    ├── scan partial_indexes
      │    │    │    │    ├── columns: a:12!null b:13 c:14
      │    │    │    │    └── partial index predicates
      │    │    │    │         ├── secondary: filters
      │    │    │    │         │    └── c:14 = 'foo'
      │    │    │    │         ├── secondary: filters
      │    │    │    │         │    └── (a:12 > b:13) AND (c:14 = 'bar')
      │    │    │    │         ├── b: filters
      │    │    │    │         │    └── c:14 = 'delete-only'
      │    │    │    │         └── b: filters
      │    │    │    │              └── c:14 = 'write-only'
      │    │    │    └── filters
      │    │    │         ├── column2:6 = b:13
      │    │    │         └── column3:7 = c:14
      │    │    └── aggregations
      │    │         ├── first-agg [as=column2:6]
      │    │         │    └── column2:6
      │    │         └── first-agg [as=column3:7]
      │    │              └── column3:7
      │    └── aggregations
      │         └── first-agg [as=column1:5]
      │              └── column1:5
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:16]
           ├── (column1:5 > column2:6) AND (column3:7 = 'bar') [as=partial_index_put2:17]
           ├── column3:7 = 'delete-only' [as=partial_index_put3:18]
           └── column3:7 = 'write-only' [as=partial_index_put4:19]

build
INSERT INTO partial_indexes VALUES (2, 1, 'bar') ON CONFLICT (b, c) DO UPDATE SET b = partial_indexes.b + 1, c = 'baz'
----
upsert partial_indexes
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: a:8
 ├── fetch columns: a:8 b:9 c:10
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── update-mapping:
 │    ├── upsert_b:15 => b:2
 │    └── upsert_c:16 => c:3
 ├── partial index put columns: partial_index_put1:17 partial_index_put2:19 partial_index_put3:21 partial_index_put4:23
 ├── partial index del columns: partial_index_del1:18 partial_index_del2:20 partial_index_del3:22 partial_index_del4:24
 └── project
      ├── columns: partial_index_put1:17!null partial_index_del1:18 partial_index_put2:19 partial_index_del2:20 partial_index_put3:21!null partial_index_del3:22 partial_index_put4:23!null partial_index_del4:24 column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11 b_new:12 c_new:13!null upsert_a:14 upsert_b:15 upsert_c:16!null
      ├── project
      │    ├── columns: upsert_a:14 upsert_b:15 upsert_c:16!null column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11 b_new:12 c_new:13!null
      │    ├── project
      │    │    ├── columns: b_new:12 c_new:13!null column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    │    │    ├── ensure-upsert-distinct-on
      │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    ├── grouping columns: column2:6!null column3:7!null
      │    │    │    │    ├── values
      │    │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    │    └── (2, 1, 'bar')
      │    │    │    │    └── aggregations
      │    │    │    │         └── first-agg [as=column1:5]
      │    │    │    │              └── column1:5
      │    │    │    ├── scan partial_indexes
      │    │    │    │    ├── columns: a:8!null b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    │    │    │    └── partial index predicates
      │    │    │    │         ├── secondary: filters
      │    │    │    │         │    └── c:10 = 'foo'
      │    │    │    │         ├── secondary: filters
      │    │    │    │         │    └── (a:8 > b:9) AND (c:10 = 'bar')
      │    │    │    │         ├── b: filters
      │    │    │    │         │    └── c:10 = 'delete-only'
      │    │    │    │         └── b: filters
      │    │    │    │              └── c:10 = 'write-only'
      │    │    │    └── filters
      │    │    │         ├── column2:6 = b:9
      │    │    │         └── column3:7 = c:10
      │    │    └── projections
      │    │         ├── b:9 + 1 [as=b_new:12]
      │    │         └── 'baz' [as=c_new:13]
      │    └── projections
      │         ├── CASE WHEN a:8 IS NULL THEN column1:5 ELSE a:8 END [as=upsert_a:14]
      │         ├── CASE WHEN a:8 IS NULL THEN column2:6 ELSE b_new:12 END [as=upsert_b:15]
      │         └── CASE WHEN a:8 IS NULL THEN column3:7 ELSE c_new:13 END [as=upsert_c:16]
      └── projections
           ├── upsert_c:16 = 'foo' [as=partial_index_put1:17]
           ├── c:10 = 'foo' [as=partial_index_del1:18]
           ├── (upsert_a:14 > upsert_b:15) AND (upsert_c:16 = 'bar') [as=partial_index_put2:19]
           ├── (a:8 > b:9) AND (c:10 = 'bar') [as=partial_index_del2:20]
           ├── upsert_c:16 = 'delete-only' [as=partial_index_put3:21]
           ├── c:10 = 'delete-only' [as=partial_index_del3:22]
           ├── upsert_c:16 = 'write-only' [as=partial_index_put4:23]
           └── c:10 = 'write-only' [as=partial_index_del4:24]

build
UPSERT INTO partial_indexes VALUES (2, 1, 'bar')
----
upsert partial_indexes
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: a:8
 ├── fetch columns: a:8 b:9 c:10
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── update-mapping:
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:13 partial_index_put2:15 partial_index_put3:17 partial_index_put4:19
 ├── partial index del columns: partial_index_del1:14 partial_index_del2:16 partial_index_del3:18 partial_index_del4:20
 └── project
      ├── columns: partial_index_put1:13!null partial_index_del1:14 partial_index_put2:15 partial_index_del2:16 partial_index_put3:17!null partial_index_del3:18 partial_index_put4:19!null partial_index_del4:20 column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11 upsert_a:12
      ├── project
      │    ├── columns: upsert_a:12 column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    ├── left-join (hash)
      │    │    ├── columns: column1:5!null column2:6!null column3:7!null a:8 b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    ├── grouping columns: column1:5!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    └── (2, 1, 'bar')
      │    │    │    └── aggregations
      │    │    │         ├── first-agg [as=column2:6]
      │    │    │         │    └── column2:6
      │    │    │         └── first-agg [as=column3:7]
      │    │    │              └── column3:7
      │    │    ├── scan partial_indexes
      │    │    │    ├── columns: a:8!null b:9 c:10 crdb_internal_mvcc_timestamp:11
      │    │    │    └── partial index predicates
      │    │    │         ├── secondary: filters
      │    │    │         │    └── c:10 = 'foo'
      │    │    │         ├── secondary: filters
      │    │    │         │    └── (a:8 > b:9) AND (c:10 = 'bar')
      │    │    │         ├── b: filters
      │    │    │         │    └── c:10 = 'delete-only'
      │    │    │         └── b: filters
      │    │    │              └── c:10 = 'write-only'
      │    │    └── filters
      │    │         └── column1:5 = a:8
      │    └── projections
      │         └── CASE WHEN a:8 IS NULL THEN column1:5 ELSE a:8 END [as=upsert_a:12]
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:13]
           ├── c:10 = 'foo' [as=partial_index_del1:14]
           ├── (upsert_a:12 > column2:6) AND (column3:7 = 'bar') [as=partial_index_put2:15]
           ├── (a:8 > b:9) AND (c:10 = 'bar') [as=partial_index_del2:16]
           ├── column3:7 = 'delete-only' [as=partial_index_put3:17]
           ├── c:10 = 'delete-only' [as=partial_index_del3:18]
           ├── column3:7 = 'write-only' [as=partial_index_put4:19]
           └── c:10 = 'write-only' [as=partial_index_del4:20]

# Columns referenced in the SET expression are ambiguous without a table name.
# Is it the value of the column being inserted or the value of the column
# currently in the table?
build
INSERT INTO partial_indexes (a, b, c) VALUES (1, 1, 'foo') ON CONFLICT (a) DO UPDATE SET b = b + 1
----
error (42702): column reference "b" is ambiguous (candidates: excluded.b, partial_indexes.b)

build
INSERT INTO partial_index_virtual VALUES (2, 1, 'Foo') ON CONFLICT DO NOTHING
----
insert partial_index_virtual
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── insert-mapping:
 │    ├── column1:6 => a:1
 │    ├── column2:7 => b:2
 │    ├── column3:8 => c:3
 │    └── column9:9 => d:4
 ├── partial index put columns: partial_index_put1:15
 └── project
      ├── columns: partial_index_put1:15 column1:6!null column2:7!null column3:8!null column9:9
      ├── upsert-distinct-on
      │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9
      │    ├── grouping columns: column1:6!null
      │    ├── anti-join (hash)
      │    │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9
      │    │    ├── project
      │    │    │    ├── columns: column9:9 column1:6!null column2:7!null column3:8!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
      │    │    │    │    └── (2, 1, 'Foo')
      │    │    │    └── projections
      │    │    │         └── lower(column3:8) [as=column9:9]
      │    │    ├── project
      │    │    │    ├── columns: d:13 a:10!null b:11 c:12
      │    │    │    ├── scan partial_index_virtual
      │    │    │    │    ├── columns: a:10!null b:11 c:12
      │    │    │    │    ├── computed column expressions
      │    │    │    │    │    └── d:13
      │    │    │    │    │         └── lower(c:12)
      │    │    │    │    └── partial index predicates
      │    │    │    │         └── secondary: filters
      │    │    │    │              └── lower(c:12) = 'foo'
      │    │    │    └── projections
      │    │    │         └── lower(c:12) [as=d:13]
      │    │    └── filters
      │    │         └── column1:6 = a:10
      │    └── aggregations
      │         ├── first-agg [as=column2:7]
      │         │    └── column2:7
      │         ├── first-agg [as=column3:8]
      │         │    └── column3:8
      │         └── first-agg [as=column9:9]
      │              └── column9:9
      └── projections
           └── column9:9 = 'foo' [as=partial_index_put1:15]

build
INSERT INTO partial_index_virtual VALUES (2, 1, 'Foo') ON CONFLICT (a) DO UPDATE SET b = partial_index_virtual.b + 1, c = 'Bar'
----
upsert partial_index_virtual
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: a:10
 ├── fetch columns: a:10 b:11 c:12 d:13
 ├── insert-mapping:
 │    ├── column1:6 => a:1
 │    ├── column2:7 => b:2
 │    ├── column3:8 => c:3
 │    └── column9:9 => d:4
 ├── update-mapping:
 │    ├── upsert_b:19 => b:2
 │    ├── upsert_c:20 => c:3
 │    └── upsert_d:21 => d:4
 ├── partial index put columns: partial_index_put1:22
 ├── partial index del columns: partial_index_del1:23
 └── project
      ├── columns: partial_index_put1:22 partial_index_del1:23 column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14 b_new:15 c_new:16!null column17:17 upsert_a:18 upsert_b:19 upsert_c:20!null upsert_d:21
      ├── project
      │    ├── columns: upsert_a:18 upsert_b:19 upsert_c:20!null upsert_d:21 column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14 b_new:15 c_new:16!null column17:17
      │    ├── project
      │    │    ├── columns: column17:17 column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14 b_new:15 c_new:16!null
      │    │    ├── project
      │    │    │    ├── columns: b_new:15 c_new:16!null column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14
      │    │    │    ├── left-join (hash)
      │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14
      │    │    │    │    ├── ensure-upsert-distinct-on
      │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9
      │    │    │    │    │    ├── grouping columns: column1:6!null
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: column9:9 column1:6!null column2:7!null column3:8!null
      │    │    │    │    │    │    ├── values
      │    │    │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
      │    │    │    │    │    │    │    └── (2, 1, 'Foo')
      │    │    │    │    │    │    └── projections
      │    │    │    │    │    │         └── lower(column3:8) [as=column9:9]
      │    │    │    │    │    └── aggregations
      │    │    │    │    │         ├── first-agg [as=column2:7]
      │    │    │    │    │         │    └── column2:7
      │    │    │    │    │         ├── first-agg [as=column3:8]
      │    │    │    │    │         │    └── column3:8
      │    │    │    │    │         └── first-agg [as=column9:9]
      │    │    │    │    │              └── column9:9
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: d:13 a:10!null b:11 c:12 crdb_internal_mvcc_timestamp:14
      │    │    │    │    │    ├── scan partial_index_virtual
      │    │    │    │    │    │    ├── columns: a:10!null b:11 c:12 crdb_internal_mvcc_timestamp:14
      │    │    │    │    │    │    ├── computed column expressions
      │    │    │    │    │    │    │    └── d:13
      │    │    │    │    │    │    │         └── lower(c:12)
      │    │    │    │    │    │    └── partial index predicates
      │    │    │    │    │    │         └── secondary: filters
      │    │    │    │    │    │              └── lower(c:12) = 'foo'
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── lower(c:12) [as=d:13]
      │    │    │    │    └── filters
      │    │    │    │         └── column1:6 = a:10
      │    │    │    └── projections
      │    │    │         ├── b:11 + 1 [as=b_new:15]
      │    │    │         └── 'Bar' [as=c_new:16]
      │    │    └── projections
      │    │         └── lower(c_new:16) [as=column17:17]
      │    └── projections
      │         ├── CASE WHEN a:10 IS NULL THEN column1:6 ELSE a:10 END [as=upsert_a:18]
      │         ├── CASE WHEN a:10 IS NULL THEN column2:7 ELSE b_new:15 END [as=upsert_b:19]
      │         ├── CASE WHEN a:10 IS NULL THEN column3:8 ELSE c_new:16 END [as=upsert_c:20]
      │         └── CASE WHEN a:10 IS NULL THEN column9:9 ELSE column17:17 END [as=upsert_d:21]
      └── projections
           ├── upsert_d:21 = 'foo' [as=partial_index_put1:22]
           └── d:13 = 'foo' [as=partial_index_del1:23]

build
UPSERT INTO partial_index_virtual VALUES (2, 1, 'Foo')
----
upsert partial_index_virtual
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: a:10
 ├── fetch columns: a:10 b:11 c:12 d:13
 ├── insert-mapping:
 │    ├── column1:6 => a:1
 │    ├── column2:7 => b:2
 │    ├── column3:8 => c:3
 │    └── column9:9 => d:4
 ├── update-mapping:
 │    ├── column2:7 => b:2
 │    ├── column3:8 => c:3
 │    └── column9:9 => d:4
 ├── partial index put columns: partial_index_put1:16
 ├── partial index del columns: partial_index_del1:17
 └── project
      ├── columns: partial_index_put1:16 partial_index_del1:17 column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14 upsert_a:15
      ├── project
      │    ├── columns: upsert_a:15 column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14
      │    ├── left-join (hash)
      │    │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9 a:10 b:11 c:12 d:13 crdb_internal_mvcc_timestamp:14
      │    │    ├── ensure-upsert-distinct-on
      │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null column9:9
      │    │    │    ├── grouping columns: column1:6!null
      │    │    │    ├── project
      │    │    │    │    ├── columns: column9:9 column1:6!null column2:7!null column3:8!null
      │    │    │    │    ├── values
      │    │    │    │    │    ├── columns: column1:6!null column2:7!null column3:8!null
      │    │    │    │    │    └── (2, 1, 'Foo')
      │    │    │    │    └── projections
      │    │    │    │         └── lower(column3:8) [as=column9:9]
      │    │    │    └── aggregations
      │    │    │         ├── first-agg [as=column2:7]
      │    │    │         │    └── column2:7
      │    │    │         ├── first-agg [as=column3:8]
      │    │    │         │    └── column3:8
      │    │    │         └── first-agg [as=column9:9]
      │    │    │              └── column9:9
      │    │    ├── project
      │    │    │    ├── columns: d:13 a:10!null b:11 c:12 crdb_internal_mvcc_timestamp:14
      │    │    │    ├── scan partial_index_virtual
      │    │    │    │    ├── columns: a:10!null b:11 c:12 crdb_internal_mvcc_timestamp:14
      │    │    │    │    ├── computed column expressions
      │    │    │    │    │    └── d:13
      │    │    │    │    │         └── lower(c:12)
      │    │    │    │    └── partial index predicates
      │    │    │    │         └── secondary: filters
      │    │    │    │              └── lower(c:12) = 'foo'
      │    │    │    └── projections
      │    │    │         └── lower(c:12) [as=d:13]
      │    │    └── filters
      │    │         └── column1:6 = a:10
      │    └── projections
      │         └── CASE WHEN a:10 IS NULL THEN column1:6 ELSE a:10 END [as=upsert_a:15]
      └── projections
           ├── column9:9 = 'foo' [as=partial_index_put1:16]
           └── d:13 = 'foo' [as=partial_index_del1:17]

build
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter indexes: primary secondary
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:17
 └── project
      ├── columns: partial_index_put1:17!null column1:5!null column2:6!null column3:7!null
      ├── project
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    └── upsert-distinct-on
      │         ├── columns: column1:5!null column2:6!null column3:7!null upsert_partial_index_distinct1:16
      │         ├── grouping columns: column2:6!null upsert_partial_index_distinct1:16
      │         ├── project
      │         │    ├── columns: upsert_partial_index_distinct1:16 column1:5!null column2:6!null column3:7!null
      │         │    ├── upsert-distinct-on
      │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │    ├── grouping columns: column1:5!null
      │         │    │    ├── anti-join (hash)
      │         │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │    │    ├── anti-join (hash)
      │         │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │    │    │    ├── values
      │         │    │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │    │    │    │    └── (1, 1, 'bar')
      │         │    │    │    │    ├── scan uniq
      │         │    │    │    │    │    ├── columns: a:8!null b:9 c:10
      │         │    │    │    │    │    └── partial index predicates
      │         │    │    │    │    │         └── secondary: filters
      │         │    │    │    │    │              └── c:10 = 'foo'
      │         │    │    │    │    └── filters
      │         │    │    │    │         └── column1:5 = a:8
      │         │    │    │    ├── select
      │         │    │    │    │    ├── columns: a:12!null b:13 c:14!null
      │         │    │    │    │    ├── scan uniq
      │         │    │    │    │    │    ├── columns: a:12!null b:13 c:14
      │         │    │    │    │    │    └── partial index predicates
      │         │    │    │    │    │         └── secondary: filters
      │         │    │    │    │    │              └── c:14 = 'foo'
      │         │    │    │    │    └── filters
      │         │    │    │    │         └── c:14 = 'foo'
      │         │    │    │    └── filters
      │         │    │    │         ├── column2:6 = b:13
      │         │    │    │         └── column3:7 = 'foo'
      │         │    │    └── aggregations
      │         │    │         ├── first-agg [as=column2:6]
      │         │    │         │    └── column2:6
      │         │    │         └── first-agg [as=column3:7]
      │         │    │              └── column3:7
      │         │    └── projections
      │         │         └── (column3:7 = 'foo') OR NULL::BOOL [as=upsert_partial_index_distinct1:16]
      │         └── aggregations
      │              ├── first-agg [as=column1:5]
      │              │    └── column1:5
      │              └── first-agg [as=column3:7]
      │                   └── column3:7
      └── projections
           └── column3:7 = 'foo' [as=partial_index_put1:17]

exec-ddl
CREATE UNIQUE INDEX u2 ON uniq (b) WHERE c = 'bar'
----

# Build scans for both partial indexes when the arbiter predicate implies them.
build
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT (b) WHERE c = 'foo' AND c = 'bar' DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter indexes: secondary u2
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:18 partial_index_put2:19
 └── project
      ├── columns: partial_index_put1:18!null partial_index_put2:19!null column1:5!null column2:6!null column3:7!null
      ├── project
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    └── upsert-distinct-on
      │         ├── columns: column1:5!null column2:6!null column3:7!null upsert_partial_index_distinct2:17
      │         ├── grouping columns: column2:6!null upsert_partial_index_distinct2:17
      │         ├── project
      │         │    ├── columns: upsert_partial_index_distinct2:17 column1:5!null column2:6!null column3:7!null
      │         │    ├── project
      │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │    └── upsert-distinct-on
      │         │    │         ├── columns: column1:5!null column2:6!null column3:7!null upsert_partial_index_distinct1:16
      │         │    │         ├── grouping columns: column2:6!null upsert_partial_index_distinct1:16
      │         │    │         ├── project
      │         │    │         │    ├── columns: upsert_partial_index_distinct1:16 column1:5!null column2:6!null column3:7!null
      │         │    │         │    ├── anti-join (hash)
      │         │    │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │         │    │    ├── anti-join (hash)
      │         │    │         │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │         │    │    │    ├── values
      │         │    │         │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │         │    │         │    │    │    │    └── (1, 1, 'bar')
      │         │    │         │    │    │    ├── select
      │         │    │         │    │    │    │    ├── columns: a:8!null b:9 c:10!null
      │         │    │         │    │    │    │    ├── scan uniq
      │         │    │         │    │    │    │    │    ├── columns: a:8!null b:9 c:10
      │         │    │         │    │    │    │    │    └── partial index predicates
      │         │    │         │    │    │    │    │         ├── secondary: filters
      │         │    │         │    │    │    │    │         │    └── c:10 = 'foo'
      │         │    │         │    │    │    │    │         └── u2: filters
      │         │    │         │    │    │    │    │              └── c:10 = 'bar'
      │         │    │         │    │    │    │    └── filters
      │         │    │         │    │    │    │         └── c:10 = 'foo'
      │         │    │         │    │    │    └── filters
      │         │    │         │    │    │         ├── column2:6 = b:9
      │         │    │         │    │    │         └── column3:7 = 'foo'
      │         │    │         │    │    ├── select
      │         │    │         │    │    │    ├── columns: a:12!null b:13 c:14!null
      │         │    │         │    │    │    ├── scan uniq
      │         │    │         │    │    │    │    ├── columns: a:12!null b:13 c:14
      │         │    │         │    │    │    │    └── partial index predicates
      │         │    │         │    │    │    │         ├── secondary: filters
      │         │    │         │    │    │    │         │    └── c:14 = 'foo'
      │         │    │         │    │    │    │         └── u2: filters
      │         │    │         │    │    │    │              └── c:14 = 'bar'
      │         │    │         │    │    │    └── filters
      │         │    │         │    │    │         └── c:14 = 'bar'
      │         │    │         │    │    └── filters
      │         │    │         │    │         ├── column2:6 = b:13
      │         │    │         │    │         └── column3:7 = 'bar'
      │         │    │         │    └── projections
      │         │    │         │         └── (column3:7 = 'foo') OR NULL::BOOL [as=upsert_partial_index_distinct1:16]
      │         │    │         └── aggregations
      │         │    │              ├── first-agg [as=column1:5]
      │         │    │              │    └── column1:5
      │         │    │              └── first-agg [as=column3:7]
      │         │    │                   └── column3:7
      │         │    └── projections
      │         │         └── (column3:7 = 'bar') OR NULL::BOOL [as=upsert_partial_index_distinct2:17]
      │         └── aggregations
      │              ├── first-agg [as=column1:5]
      │              │    └── column1:5
      │              └── first-agg [as=column3:7]
      │                   └── column3:7
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:18]
           └── column3:7 = 'bar' [as=partial_index_put2:19]

exec-ddl
CREATE UNIQUE INDEX u3 ON uniq (b)
----

# If there is a non-partial unique index, then it is the only arbiter.
build
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT (b) WHERE c = 'foo' AND c = 'bar' DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter indexes: u3
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:12 partial_index_put2:13
 └── project
      ├── columns: partial_index_put1:12!null partial_index_put2:13!null column1:5!null column2:6!null column3:7!null
      ├── upsert-distinct-on
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    ├── grouping columns: column2:6!null
      │    ├── anti-join (hash)
      │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    ├── values
      │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    └── (1, 1, 'bar')
      │    │    ├── scan uniq
      │    │    │    ├── columns: a:8!null b:9 c:10
      │    │    │    └── partial index predicates
      │    │    │         ├── secondary: filters
      │    │    │         │    └── c:10 = 'foo'
      │    │    │         └── u2: filters
      │    │    │              └── c:10 = 'bar'
      │    │    └── filters
      │    │         └── column2:6 = b:9
      │    └── aggregations
      │         ├── first-agg [as=column1:5]
      │         │    └── column1:5
      │         └── first-agg [as=column3:7]
      │              └── column3:7
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:12]
           └── column3:7 = 'bar' [as=partial_index_put2:13]

exec-ddl
DROP INDEX u3
----

exec-ddl
CREATE UNIQUE INDEX u4 ON uniq (b) WHERE 1 = 1
----

# If there is a pseudo-partial unique index, then it is the only arbiter. Note
# that the "opt" test directive is used here rather than "build". This is
# because "build" disables optimization like constant-folding. This causes the
# predicate of the pseudo-partial index, (1 = 1), to not fold to an empty
# FiltersExpr (which is equivalent to true). The mutationBuilder.arbiterIndexes
# function therefore cannot detect that the index is pseudo-partial. The "opt"
# directive does not disable optimizations, resulting in more accurate
# representation of real-world behavior and allowing the output of this test to
# reflect that the pseudo-partial index is the only arbiter.
opt
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT (b) WHERE c = 'foo' AND c = 'bar' DO NOTHING
----
insert uniq
 ├── columns: <none>
 ├── arbiter indexes: u4
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── partial index put columns: partial_index_put1:13 partial_index_put2:14 partial_index_put3:15
 └── project
      ├── columns: partial_index_put1:13!null partial_index_put2:14!null partial_index_put3:15!null column1:5!null column2:6!null column3:7!null
      ├── anti-join (cross)
      │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    ├── values
      │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    └── (1, 1, 'bar')
      │    ├── select
      │    │    ├── columns: b:9!null
      │    │    ├── scan uniq@u4,partial
      │    │    │    └── columns: b:9
      │    │    └── filters
      │    │         └── b:9 = 1
      │    └── filters (true)
      └── projections
           ├── column3:7 = 'foo' [as=partial_index_put1:13]
           ├── column3:7 = 'bar' [as=partial_index_put2:14]
           └── true [as=partial_index_put3:15]

exec-ddl
DROP INDEX u4
----

# Error when two arbiter indexes are found for ON CONFLICT DO UPDATE.
build
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT (b) WHERE c = 'foo' AND c = 'bar' DO UPDATE SET b = 10
----
error (0A000): unimplemented: there are multiple unique or exclusion constraints matching the ON CONFLICT specification

build
INSERT INTO uniq VALUES (1, 1, 'bar') ON CONFLICT (b) WHERE c = 'foo' DO UPDATE SET b = 10
----
upsert uniq
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: a:9
 ├── fetch columns: a:9 b:10 c:11
 ├── insert-mapping:
 │    ├── column1:5 => a:1
 │    ├── column2:6 => b:2
 │    └── column3:7 => c:3
 ├── update-mapping:
 │    └── upsert_b:15 => b:2
 ├── partial index put columns: partial_index_put1:17 partial_index_put2:19
 ├── partial index del columns: partial_index_del1:18 partial_index_del2:20
 └── project
      ├── columns: partial_index_put1:17 partial_index_del1:18 partial_index_put2:19 partial_index_del2:20 column1:5!null column2:6!null column3:7!null a:9 b:10 c:11 crdb_internal_mvcc_timestamp:12 b_new:13!null upsert_a:14 upsert_b:15!null upsert_c:16
      ├── project
      │    ├── columns: upsert_a:14 upsert_b:15!null upsert_c:16 column1:5!null column2:6!null column3:7!null a:9 b:10 c:11 crdb_internal_mvcc_timestamp:12 b_new:13!null
      │    ├── project
      │    │    ├── columns: b_new:13!null column1:5!null column2:6!null column3:7!null a:9 b:10 c:11 crdb_internal_mvcc_timestamp:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null a:9 b:10 c:11 crdb_internal_mvcc_timestamp:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    └── ensure-upsert-distinct-on
      │    │    │    │         ├── columns: column1:5!null column2:6!null column3:7!null upsert_partial_index_distinct1:8
      │    │    │    │         ├── grouping columns: column2:6!null upsert_partial_index_distinct1:8
      │    │    │    │         ├── project
      │    │    │    │         │    ├── columns: upsert_partial_index_distinct1:8 column1:5!null column2:6!null column3:7!null
      │    │    │    │         │    ├── values
      │    │    │    │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │         │    │    └── (1, 1, 'bar')
      │    │    │    │         │    └── projections
      │    │    │    │         │         └── (column3:7 = 'foo') OR NULL::BOOL [as=upsert_partial_index_distinct1:8]
      │    │    │    │         └── aggregations
      │    │    │    │              ├── first-agg [as=column1:5]
      │    │    │    │              │    └── column1:5
      │    │    │    │              └── first-agg [as=column3:7]
      │    │    │    │                   └── column3:7
      │    │    │    ├── select
      │    │    │    │    ├── columns: a:9!null b:10 c:11!null crdb_internal_mvcc_timestamp:12
      │    │    │    │    ├── scan uniq
      │    │    │    │    │    ├── columns: a:9!null b:10 c:11 crdb_internal_mvcc_timestamp:12
      │    │    │    │    │    └── partial index predicates
      │    │    │    │    │         ├── secondary: filters
      │    │    │    │    │         │    └── c:11 = 'foo'
      │    │    │    │    │         └── u2: filters
      │    │    │    │    │              └── c:11 = 'bar'
      │    │    │    │    └── filters
      │    │    │    │         └── c:11 = 'foo'
      │    │    │    └── filters
      │    │    │         ├── column2:6 = b:10
      │    │    │         └── column3:7 = 'foo'
      │    │    └── projections
      │    │         └── 10 [as=b_new:13]
      │    └── projections
      │         ├── CASE WHEN a:9 IS NULL THEN column1:5 ELSE a:9 END [as=upsert_a:14]
      │         ├── CASE WHEN a:9 IS NULL THEN column2:6 ELSE b_new:13 END [as=upsert_b:15]
      │         └── CASE WHEN a:9 IS NULL THEN column3:7 ELSE c:11 END [as=upsert_c:16]
      └── projections
           ├── upsert_c:16 = 'foo' [as=partial_index_put1:17]
           ├── c:11 = 'foo' [as=partial_index_del1:18]
           ├── upsert_c:16 = 'bar' [as=partial_index_put2:19]
           └── c:11 = 'bar' [as=partial_index_del2:20]

# Do not error with "column reference is ambiguous" when table column names
# match synthesized column names.
build
INSERT INTO ambig VALUES (1, 2)
ON CONFLICT (partial_index_put1) WHERE partial_index_put1 > 0 AND partial_index_del1 > 0
DO UPDATE SET partial_index_put1 = 10, partial_index_del1 = 20
----
upsert ambig
 ├── columns: <none>
 ├── arbiter indexes: secondary
 ├── canary column: rowid:11
 ├── fetch columns: ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11
 ├── insert-mapping:
 │    ├── column1:5 => ambig.partial_index_put1:1
 │    ├── column2:6 => ambig.partial_index_del1:2
 │    └── column7:7 => rowid:3
 ├── update-mapping:
 │    ├── upsert_partial_index_put1:15 => ambig.partial_index_put1:1
 │    └── upsert_partial_index_del1:16 => ambig.partial_index_del1:2
 ├── partial index put columns: partial_index_put1:18 partial_index_put2:20
 ├── partial index del columns: partial_index_del1:19 partial_index_del2:21
 └── project
      ├── columns: partial_index_put1:18!null partial_index_del1:19 partial_index_put2:20!null partial_index_del2:21 column1:5!null column2:6!null column7:7 ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11 crdb_internal_mvcc_timestamp:12 partial_index_put1_new:13!null partial_index_del1_new:14!null upsert_partial_index_put1:15!null upsert_partial_index_del1:16!null upsert_rowid:17
      ├── project
      │    ├── columns: upsert_partial_index_put1:15!null upsert_partial_index_del1:16!null upsert_rowid:17 column1:5!null column2:6!null column7:7 ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11 crdb_internal_mvcc_timestamp:12 partial_index_put1_new:13!null partial_index_del1_new:14!null
      │    ├── project
      │    │    ├── columns: partial_index_put1_new:13!null partial_index_del1_new:14!null column1:5!null column2:6!null column7:7 ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11 crdb_internal_mvcc_timestamp:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11 crdb_internal_mvcc_timestamp:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column1:5!null column2:6!null column7:7
      │    │    │    │    └── ensure-upsert-distinct-on
      │    │    │    │         ├── columns: column1:5!null column2:6!null column7:7 upsert_partial_index_distinct1:8
      │    │    │    │         ├── grouping columns: column1:5!null upsert_partial_index_distinct1:8
      │    │    │    │         ├── project
      │    │    │    │         │    ├── columns: upsert_partial_index_distinct1:8 column1:5!null column2:6!null column7:7
      │    │    │    │         │    ├── project
      │    │    │    │         │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │         │    │    ├── values
      │    │    │    │         │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │         │    │    │    └── (1, 2)
      │    │    │    │         │    │    └── projections
      │    │    │    │         │    │         └── unique_rowid() [as=column7:7]
      │    │    │    │         │    └── projections
      │    │    │    │         │         └── (column1:5 > 0) OR NULL::BOOL [as=upsert_partial_index_distinct1:8]
      │    │    │    │         └── aggregations
      │    │    │    │              ├── first-agg [as=column2:6]
      │    │    │    │              │    └── column2:6
      │    │    │    │              └── first-agg [as=column7:7]
      │    │    │    │                   └── column7:7
      │    │    │    ├── select
      │    │    │    │    ├── columns: ambig.partial_index_put1:9!null ambig.partial_index_del1:10 rowid:11!null crdb_internal_mvcc_timestamp:12
      │    │    │    │    ├── scan ambig
      │    │    │    │    │    ├── columns: ambig.partial_index_put1:9 ambig.partial_index_del1:10 rowid:11!null crdb_internal_mvcc_timestamp:12
      │    │    │    │    │    └── partial index predicates
      │    │    │    │    │         ├── secondary: filters
      │    │    │    │    │         │    └── ambig.partial_index_put1:9 > 0
      │    │    │    │    │         └── secondary: filters
      │    │    │    │    │              └── ambig.partial_index_del1:10 > 0
      │    │    │    │    └── filters
      │    │    │    │         └── ambig.partial_index_put1:9 > 0
      │    │    │    └── filters
      │    │    │         ├── column1:5 = ambig.partial_index_put1:9
      │    │    │         └── column1:5 > 0
      │    │    └── projections
      │    │         ├── 10 [as=partial_index_put1_new:13]
      │    │         └── 20 [as=partial_index_del1_new:14]
      │    └── projections
      │         ├── CASE WHEN rowid:11 IS NULL THEN column1:5 ELSE partial_index_put1_new:13 END [as=upsert_partial_index_put1:15]
      │         ├── CASE WHEN rowid:11 IS NULL THEN column2:6 ELSE partial_index_del1_new:14 END [as=upsert_partial_index_del1:16]
      │         └── CASE WHEN rowid:11 IS NULL THEN column7:7 ELSE rowid:11 END [as=upsert_rowid:17]
      └── projections
           ├── upsert_partial_index_put1:15 > 0 [as=partial_index_put1:18]
           ├── ambig.partial_index_put1:9 > 0 [as=partial_index_del1:19]
           ├── upsert_partial_index_del1:16 > 0 [as=partial_index_put2:20]
           └── ambig.partial_index_del1:10 > 0 [as=partial_index_del2:21]
