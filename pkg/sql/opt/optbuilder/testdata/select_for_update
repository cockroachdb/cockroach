exec-ddl
CREATE TABLE t (a INT PRIMARY KEY, b INT)
----

exec-ddl
CREATE TABLE u (a INT PRIMARY KEY, c INT)
----

exec-ddl
CREATE VIEW v AS SELECT a FROM t
----

# ------------------------------------------------------------------------------
# Basic tests.
# ------------------------------------------------------------------------------

build
SELECT * FROM t FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR NO KEY UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-no-key-update

build
SELECT * FROM t FOR SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-share

build
SELECT * FROM t FOR KEY SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-key-share

build
SELECT * FROM t FOR KEY SHARE FOR SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-share

build
SELECT * FROM t FOR KEY SHARE FOR SHARE FOR NO KEY UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-no-key-update

build
SELECT * FROM t FOR KEY SHARE FOR SHARE FOR NO KEY UPDATE FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR UPDATE OF t
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR UPDATE OF t2
----
scan t
 └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with table aliases.
# ------------------------------------------------------------------------------

build
SELECT * FROM t AS t2 FOR UPDATE
----
scan t2
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t AS t2 FOR UPDATE OF t
----
scan t2
 └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM t AS t2 FOR UPDATE OF t2
----
scan t2
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

# ------------------------------------------------------------------------------
# Tests with numeric table references.
# Cockroach numeric references start after 53 for user tables.
# ------------------------------------------------------------------------------

build
SELECT * FROM [53 AS t] FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM [53 AS t] FOR UPDATE OF t
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM [53 AS t] FOR UPDATE OF t2
----
scan t
 └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with views.
# ------------------------------------------------------------------------------

build
SELECT * FROM v FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v FOR UPDATE OF v
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v FOR UPDATE OF v2
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM v FOR UPDATE OF t
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with aliased views.
# ------------------------------------------------------------------------------

build
SELECT * FROM v AS v2 FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v AS v2 FOR UPDATE OF v
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM v AS v2 FOR UPDATE OF v2
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

# ------------------------------------------------------------------------------
# Tests with subqueries.
# 
# Row-level locking clauses only apply to subqueries in the FROM clause of a
# SELECT statement. They don't apply to subqueries in the projection or in
# the filter.
# ------------------------------------------------------------------------------

build
SELECT * FROM (SELECT a FROM t) FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM (SELECT a FROM t FOR UPDATE)
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM (SELECT a FROM t FOR NO KEY UPDATE) FOR KEY SHARE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-no-key-update

build
SELECT * FROM (SELECT a FROM t FOR KEY SHARE) FOR NO KEY UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-no-key-update

# TODO(nvanbenschoten): To match Postgres perfectly, this would throw an error.
# It's not clear that it's worth going out of our way to mirror that behavior.
build
SELECT * FROM (SELECT a FROM t) FOR UPDATE OF t
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM (SELECT a FROM t FOR UPDATE OF t)
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM (SELECT a FROM t) AS r FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM (SELECT a FROM t FOR UPDATE) AS r
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM (SELECT a FROM t) AS r FOR UPDATE OF t
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM (SELECT a FROM t FOR UPDATE OF t) AS r
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT (SELECT a FROM t) FOR UPDATE
----
project
 ├── columns: a:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: t.a:1(int!null)
                └── project
                     ├── columns: t.a:1(int!null)
                     └── scan t
                          └── columns: t.a:1(int!null) b:2(int)

build
SELECT (SELECT a FROM t FOR UPDATE)
----
project
 ├── columns: a:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: t.a:1(int!null)
                └── project
                     ├── columns: t.a:1(int!null)
                     └── scan t
                          ├── columns: t.a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT (SELECT a FROM t) FOR UPDATE OF t
----
project
 ├── columns: a:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: t.a:1(int!null)
                └── project
                     ├── columns: t.a:1(int!null)
                     └── scan t
                          └── columns: t.a:1(int!null) b:2(int)

build
SELECT (SELECT a FROM t FOR UPDATE OF t)
----
project
 ├── columns: a:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: t.a:1(int!null)
                └── project
                     ├── columns: t.a:1(int!null)
                     └── scan t
                          ├── columns: t.a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT (SELECT a FROM t) AS r FOR UPDATE
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          └── columns: a:1(int!null) b:2(int)

build
SELECT (SELECT a FROM t FOR UPDATE) AS r
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT (SELECT a FROM t) AS r FOR UPDATE OF t
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          └── columns: a:1(int!null) b:2(int)

build
SELECT (SELECT a FROM t FOR UPDATE OF t) AS r
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT * FROM t WHERE a IN (SELECT a FROM t) FOR UPDATE
----
select
 ├── columns: a:1(int!null) b:2(int)
 ├── scan t
 │    ├── columns: a:1(int!null) b:2(int)
 │    └── locking: for-update
 └── filters
      └── any: eq [type=bool]
           ├── project
           │    ├── columns: a:3(int!null)
           │    └── scan t
           │         └── columns: a:3(int!null) b:4(int)
           └── variable: a [type=int]

build
SELECT * FROM t WHERE a IN (SELECT a FROM t FOR UPDATE)
----
select
 ├── columns: a:1(int!null) b:2(int)
 ├── scan t
 │    └── columns: a:1(int!null) b:2(int)
 └── filters
      └── any: eq [type=bool]
           ├── project
           │    ├── columns: a:3(int!null)
           │    └── scan t
           │         ├── columns: a:3(int!null) b:4(int)
           │         └── locking: for-update
           └── variable: a [type=int]

build
SELECT * FROM t WHERE a IN (SELECT a FROM t) FOR UPDATE OF t
----
select
 ├── columns: a:1(int!null) b:2(int)
 ├── scan t
 │    ├── columns: a:1(int!null) b:2(int)
 │    └── locking: for-update
 └── filters
      └── any: eq [type=bool]
           ├── project
           │    ├── columns: a:3(int!null)
           │    └── scan t
           │         └── columns: a:3(int!null) b:4(int)
           └── variable: a [type=int]

build
SELECT * FROM t WHERE a IN (SELECT a FROM t FOR UPDATE OF t)
----
select
 ├── columns: a:1(int!null) b:2(int)
 ├── scan t
 │    └── columns: a:1(int!null) b:2(int)
 └── filters
      └── any: eq [type=bool]
           ├── project
           │    ├── columns: a:3(int!null)
           │    └── scan t
           │         ├── columns: a:3(int!null) b:4(int)
           │         └── locking: for-update
           └── variable: a [type=int]

# ------------------------------------------------------------------------------
# Tests with common-table expressions.
#
# Unlike with subqueries, row-level locking clauses do not apply to WITH queries
# referenced by the primary query. To achieve row locking within a WITH query, a
# locking clause should be specified within the WITH query.
# ------------------------------------------------------------------------------

build
SELECT * FROM [SELECT a FROM t] FOR UPDATE
----
with &1
 ├── columns: a:3(int!null)
 ├── project
 │    ├── columns: t.a:1(int!null)
 │    └── scan t
 │         └── columns: t.a:1(int!null) b:2(int)
 └── with-scan &1
      ├── columns: a:3(int!null)
      └── mapping:
           └──  t.a:1(int) => a:3(int)

build
WITH cte AS (SELECT a FROM t) SELECT * FROM cte FOR UPDATE
----
with &1 (cte)
 ├── columns: a:3(int!null)
 ├── project
 │    ├── columns: t.a:1(int!null)
 │    └── scan t
 │         └── columns: t.a:1(int!null) b:2(int)
 └── with-scan &1 (cte)
      ├── columns: a:3(int!null)
      └── mapping:
           └──  t.a:1(int) => a:3(int)

build
SELECT * FROM [SELECT a FROM t FOR UPDATE]
----
with &1
 ├── columns: a:3(int!null)
 ├── project
 │    ├── columns: t.a:1(int!null)
 │    └── scan t
 │         ├── columns: t.a:1(int!null) b:2(int)
 │         └── locking: for-update
 └── with-scan &1
      ├── columns: a:3(int!null)
      └── mapping:
           └──  t.a:1(int) => a:3(int)

build
WITH cte AS (SELECT a FROM t FOR UPDATE) SELECT * FROM cte
----
with &1 (cte)
 ├── columns: a:3(int!null)
 ├── project
 │    ├── columns: t.a:1(int!null)
 │    └── scan t
 │         ├── columns: t.a:1(int!null) b:2(int)
 │         └── locking: for-update
 └── with-scan &1 (cte)
      ├── columns: a:3(int!null)
      └── mapping:
           └──  t.a:1(int) => a:3(int)

# ------------------------------------------------------------------------------
# Tests with joins.
# ------------------------------------------------------------------------------

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    └── columns: u.a:3(int!null) c:4(int)
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    └── columns: t.a:1(int!null) b:2(int)
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t, u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t FOR SHARE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-share
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t2 FOR SHARE OF u2
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    └── columns: t.a:1(int!null) b:2(int)
      ├── scan u
      │    └── columns: u.a:3(int!null) c:4(int)
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t AS t2 JOIN u AS u2 USING (a) FOR UPDATE OF t2 FOR SHARE OF u2
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t2.a:1(int!null) b:2(int) u2.a:3(int!null) c:4(int)
      ├── scan t2
      │    ├── columns: t2.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u2
      │    ├── columns: u2.a:3(int!null) c:4(int)
      │    └── locking: for-share
      └── filters
           └── eq [type=bool]
                ├── variable: t2.a [type=int]
                └── variable: u2.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR KEY SHARE FOR UPDATE
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR KEY SHARE FOR NO KEY UPDATE OF t
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-no-key-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-key-share
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR SHARE FOR NO KEY UPDATE OF t FOR UPDATE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-no-key-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

# ------------------------------------------------------------------------------
# Tests with virtual tables.
# ------------------------------------------------------------------------------

build
SELECT * FROM information_schema.columns FOR UPDATE
----
error (42601): FOR UPDATE not allowed with virtual tables
