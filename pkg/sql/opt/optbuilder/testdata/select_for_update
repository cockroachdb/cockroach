exec-ddl
CREATE TABLE t (a INT PRIMARY KEY, b INT)
----

exec-ddl
CREATE TABLE u (a INT PRIMARY KEY, c INT)
----

exec-ddl
CREATE VIEW v AS SELECT a FROM t
----

# ------------------------------------------------------------------------------
# Basic tests.
# ------------------------------------------------------------------------------

build
SELECT * FROM t FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR NO KEY UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-no-key-update

build
SELECT * FROM t FOR SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-share

build
SELECT * FROM t FOR KEY SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-key-share

build
SELECT * FROM t FOR KEY SHARE FOR SHARE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-share

build
SELECT * FROM t FOR KEY SHARE FOR SHARE FOR NO KEY UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-no-key-update

build
SELECT * FROM t FOR KEY SHARE FOR SHARE FOR NO KEY UPDATE FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR UPDATE OF t
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t FOR UPDATE OF t2
----
scan t
 └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with table aliases.
# ------------------------------------------------------------------------------

build
SELECT * FROM t AS t2 FOR UPDATE
----
scan t2
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM t AS t2 FOR UPDATE OF t
----
scan t2
 └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM t AS t2 FOR UPDATE OF t2
----
scan t2
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

# ------------------------------------------------------------------------------
# Tests with numeric table references.
# Cockroach numeric references start after 53 for user tables.
# ------------------------------------------------------------------------------

build
SELECT * FROM [53 AS t] FOR UPDATE
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM [53 AS t] FOR UPDATE OF t
----
scan t
 ├── columns: a:1(int!null) b:2(int)
 └── locking: for-update

build
SELECT * FROM [53 AS t] FOR UPDATE OF t2
----
scan t
 └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with views.
# ------------------------------------------------------------------------------

build
SELECT * FROM v FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v FOR UPDATE OF v
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v FOR UPDATE OF v2
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

# ------------------------------------------------------------------------------
# Tests with aliased views.
# ------------------------------------------------------------------------------

build
SELECT * FROM v AS v2 FOR UPDATE
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

build
SELECT * FROM v AS v2 FOR UPDATE OF v
----
project
 ├── columns: a:1(int!null)
 └── scan t
      └── columns: a:1(int!null) b:2(int)

build
SELECT * FROM v AS v2 FOR UPDATE OF v2
----
project
 ├── columns: a:1(int!null)
 └── scan t
      ├── columns: a:1(int!null) b:2(int)
      └── locking: for-update

# ------------------------------------------------------------------------------
# Tests with subqueries.
# ------------------------------------------------------------------------------

build
SELECT (SELECT a FROM t) AS r FOR UPDATE
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT (SELECT a FROM t FOR UPDATE) AS r
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

# TODO(nvanbenschoten): To match Postgres perfectly, this would throw an error.
# It's not clear that it's worth going out of our way to mirror that behavior.
build
SELECT (SELECT a FROM t) AS r FOR UPDATE OF t
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

build
SELECT (SELECT a FROM t FOR UPDATE OF t) AS r
----
project
 ├── columns: r:3(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: a:1(int!null)
                └── project
                     ├── columns: a:1(int!null)
                     └── scan t
                          ├── columns: a:1(int!null) b:2(int)
                          └── locking: for-update

# ------------------------------------------------------------------------------
# Tests with joins.
# ------------------------------------------------------------------------------

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    └── columns: u.a:3(int!null) c:4(int)
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    └── columns: t.a:1(int!null) b:2(int)
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t, u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t FOR SHARE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-share
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR UPDATE OF t2 FOR SHARE OF u2
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    └── columns: t.a:1(int!null) b:2(int)
      ├── scan u
      │    └── columns: u.a:3(int!null) c:4(int)
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t AS t2 JOIN u AS u2 USING (a) FOR UPDATE OF t2 FOR SHARE OF u2
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t2.a:1(int!null) b:2(int) u2.a:3(int!null) c:4(int)
      ├── scan t2
      │    ├── columns: t2.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u2
      │    ├── columns: u2.a:3(int!null) c:4(int)
      │    └── locking: for-share
      └── filters
           └── eq [type=bool]
                ├── variable: t2.a [type=int]
                └── variable: u2.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR KEY SHARE FOR UPDATE
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR KEY SHARE FOR NO KEY UPDATE OF t
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-no-key-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-key-share
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

build
SELECT * FROM t JOIN u USING (a) FOR SHARE FOR NO KEY UPDATE OF t FOR UPDATE OF u
----
project
 ├── columns: a:1(int!null) b:2(int) c:4(int)
 └── inner-join (hash)
      ├── columns: t.a:1(int!null) b:2(int) u.a:3(int!null) c:4(int)
      ├── scan t
      │    ├── columns: t.a:1(int!null) b:2(int)
      │    └── locking: for-no-key-update
      ├── scan u
      │    ├── columns: u.a:3(int!null) c:4(int)
      │    └── locking: for-update
      └── filters
           └── eq [type=bool]
                ├── variable: t.a [type=int]
                └── variable: u.a [type=int]

# ------------------------------------------------------------------------------
# Tests with virtual tables.
# ------------------------------------------------------------------------------

build
SELECT * FROM information_schema.columns FOR UPDATE
----
error (42601): FOR UPDATE not allowed with virtual tables
