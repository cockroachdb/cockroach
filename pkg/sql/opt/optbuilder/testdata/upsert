exec-ddl
CREATE TABLE abc (
    a INT NOT NULL,
    b INT DEFAULT (10),
    c INT AS (b + 1) STORED,
    UNIQUE(a),
    UNIQUE(b, c)
)
----

exec-ddl
CREATE TABLE xyz (
    x INT PRIMARY KEY,
    y INT,
    z INT,
    UNIQUE (y, z),
    UNIQUE (z, y),
    INDEX (y DESC)
)
----

exec-ddl
CREATE TABLE uv (
    u INT,
    v INT,
    PRIMARY KEY (u, v)
)
----

exec-ddl
CREATE TABLE noindex (
    x INT PRIMARY KEY,
    y INT,
    z INT
)
----

exec-ddl
CREATE TABLE mutation (
    m INT PRIMARY KEY,
    n INT,
    "o:write-only" INT DEFAULT(10),
    "p:write-only" INT AS (o + n) STORED,
    "q:delete-only" INT AS (m * p) STORED,
    CHECK (m > 0)
)
----

exec-ddl
CREATE TABLE checks (
    a INT PRIMARY KEY CHECK (a > 0),
    b INT,
    c INT,
    d INT AS (c + 1) STORED,
    CHECK (b < d)
)
----

exec-ddl
CREATE TABLE decimals (
    a DECIMAL(10,0) PRIMARY KEY CHECK (round(a) = a),
    b DECIMAL(5,1)[] CHECK (b[0] > 1),
    c DECIMAL(10,1) DEFAULT (1.23),
    d DECIMAL(10,1) AS (a+c) STORED
)
----

# ------------------------------------------------------------------------------
# Basic tests.
# ------------------------------------------------------------------------------

# Set single column, single column conflict.
build
INSERT INTO abc (a, b)
SELECT x, y FROM xyz
ON CONFLICT (a) DO
UPDATE SET a=5
----
upsert abc
 ├── columns: <none>
 ├── canary column: 13
 ├── fetch columns: a:10 b:11 c:12 rowid:13
 ├── insert-mapping:
 │    ├──  x:5 => a:1
 │    ├──  y:6 => b:2
 │    ├──  column9:9 => c:3
 │    └──  column8:8 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_a:16 => a:1
 │    └──  upsert_c:18 => c:3
 └── project
      ├── columns: upsert_a:16!null upsert_b:17 upsert_c:18 upsert_rowid:19 x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13 column14:14!null column15:15
      ├── project
      │    ├── columns: column15:15 x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13 column14:14!null
      │    ├── project
      │    │    ├── columns: column14:14!null x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13
      │    │    │    ├── project
      │    │    │    │    ├── columns: column9:9 x:5!null y:6 column8:8
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column8:8 x:5!null y:6
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: x:5!null y:6
      │    │    │    │    │    │    └── scan xyz
      │    │    │    │    │    │         └── columns: x:5!null y:6 z:7
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── unique_rowid()
      │    │    │    │    └── projections
      │    │    │    │         └── y + 1
      │    │    │    ├── scan abc
      │    │    │    │    ├── columns: a:10!null b:11 c:12 rowid:13!null
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── c:12
      │    │    │    │              └── b + 1
      │    │    │    └── filters
      │    │    │         └── x = a
      │    │    └── projections
      │    │         └── const: 5 [projected as column14:14]
      │    └── projections
      │         └── b + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN x ELSE column14 END
           ├── CASE WHEN rowid IS NULL THEN y ELSE b END
           ├── CASE WHEN rowid IS NULL THEN column9 ELSE column15 END
           └── CASE WHEN rowid IS NULL THEN column8 ELSE rowid END

# Set all columns, multi-column conflict.
build
INSERT INTO abc (a, b, rowid)
SELECT x, y, z FROM xyz
ON CONFLICT (b, c) DO
UPDATE SET a=1, b=2, rowid=3
RETURNING *
----
project
 ├── columns: a:1!null b:2 c:3
 └── upsert abc
      ├── columns: a:1!null b:2 c:3 rowid:4!null
      ├── canary column: 12
      ├── fetch columns: a:9 b:10 c:11 rowid:12
      ├── insert-mapping:
      │    ├──  x:5 => a:1
      │    ├──  y:6 => b:2
      │    ├──  column8:8 => c:3
      │    └──  z:7 => rowid:4
      ├── update-mapping:
      │    ├──  upsert_a:17 => a:1
      │    ├──  upsert_b:18 => b:2
      │    ├──  upsert_c:19 => c:3
      │    └──  upsert_rowid:20 => rowid:4
      ├── return-mapping:
      │    ├──  upsert_a:17 => a:1
      │    ├──  upsert_b:18 => b:2
      │    ├──  upsert_c:19 => c:3
      │    └──  upsert_rowid:20 => rowid:4
      └── project
           ├── columns: upsert_a:17!null upsert_b:18 upsert_c:19 upsert_rowid:20 x:5!null y:6 z:7 column8:8 a:9 b:10 c:11 rowid:12 column13:13!null column14:14!null column15:15!null column16:16!null
           ├── project
           │    ├── columns: column16:16!null x:5!null y:6 z:7 column8:8 a:9 b:10 c:11 rowid:12 column13:13!null column14:14!null column15:15!null
           │    ├── project
           │    │    ├── columns: column13:13!null column14:14!null column15:15!null x:5!null y:6 z:7 column8:8 a:9 b:10 c:11 rowid:12
           │    │    ├── left-join (hash)
           │    │    │    ├── columns: x:5!null y:6 z:7 column8:8 a:9 b:10 c:11 rowid:12
           │    │    │    ├── project
           │    │    │    │    ├── columns: column8:8 x:5!null y:6 z:7
           │    │    │    │    ├── scan xyz
           │    │    │    │    │    └── columns: x:5!null y:6 z:7
           │    │    │    │    └── projections
           │    │    │    │         └── y + 1
           │    │    │    ├── scan abc
           │    │    │    │    ├── columns: a:9!null b:10 c:11 rowid:12!null
           │    │    │    │    └── computed column expressions
           │    │    │    │         └── c:11
           │    │    │    │              └── b + 1
           │    │    │    └── filters
           │    │    │         ├── y = b
           │    │    │         └── column8 = c
           │    │    └── projections
           │    │         ├── const: 1 [projected as column13:13]
           │    │         ├── const: 2 [projected as column14:14]
           │    │         └── const: 3 [projected as column15:15]
           │    └── projections
           │         └── column14 + 1
           └── projections
                ├── CASE WHEN rowid IS NULL THEN x ELSE column13 END
                ├── CASE WHEN rowid IS NULL THEN y ELSE column14 END
                ├── CASE WHEN rowid IS NULL THEN column8 ELSE column16 END
                └── CASE WHEN rowid IS NULL THEN z ELSE column15 END

# UPDATE + WHERE clause.
build
INSERT INTO abc
SELECT x, y FROM xyz
ON CONFLICT (a) DO
UPDATE SET b=10
WHERE abc.a>0
----
upsert abc
 ├── columns: <none>
 ├── canary column: 13
 ├── fetch columns: a:10 b:11 c:12 rowid:13
 ├── insert-mapping:
 │    ├──  x:5 => a:1
 │    ├──  y:6 => b:2
 │    ├──  column9:9 => c:3
 │    └──  column8:8 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_b:17 => b:2
 │    └──  upsert_c:18 => c:3
 └── project
      ├── columns: upsert_a:16 upsert_b:17 upsert_c:18 upsert_rowid:19 x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13 column14:14!null column15:15!null
      ├── project
      │    ├── columns: column15:15!null x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13 column14:14!null
      │    ├── project
      │    │    ├── columns: column14:14!null x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13
      │    │    ├── select
      │    │    │    ├── columns: x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13
      │    │    │    ├── left-join (hash)
      │    │    │    │    ├── columns: x:5!null y:6 column8:8 column9:9 a:10 b:11 c:12 rowid:13
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column9:9 x:5!null y:6 column8:8
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: column8:8 x:5!null y:6
      │    │    │    │    │    │    ├── project
      │    │    │    │    │    │    │    ├── columns: x:5!null y:6
      │    │    │    │    │    │    │    └── scan xyz
      │    │    │    │    │    │    │         └── columns: x:5!null y:6 z:7
      │    │    │    │    │    │    └── projections
      │    │    │    │    │    │         └── unique_rowid()
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── y + 1
      │    │    │    │    ├── scan abc
      │    │    │    │    │    ├── columns: a:10!null b:11 c:12 rowid:13!null
      │    │    │    │    │    └── computed column expressions
      │    │    │    │    │         └── c:12
      │    │    │    │    │              └── b + 1
      │    │    │    │    └── filters
      │    │    │    │         └── x = a
      │    │    │    └── filters
      │    │    │         └── (rowid IS NULL) OR (a > 0)
      │    │    └── projections
      │    │         └── const: 10 [projected as column14:14]
      │    └── projections
      │         └── column14 + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN x ELSE a END
           ├── CASE WHEN rowid IS NULL THEN y ELSE column14 END
           ├── CASE WHEN rowid IS NULL THEN column9 ELSE column15 END
           └── CASE WHEN rowid IS NULL THEN column8 ELSE rowid END

# Use RETURNING INSERT..ON CONFLICT as a FROM clause.
build
SELECT *
FROM [INSERT INTO abc (a, b) VALUES (1,2), (3,4) ON CONFLICT (a) DO UPDATE SET b=1 RETURNING *]
ORDER BY a, b DESC
----
sort
 ├── columns: a:19!null b:20!null c:21!null
 ├── ordering: +19,-20
 └── with &1
      ├── columns: a:19!null b:20!null c:21!null
      ├── project
      │    ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null
      │    └── upsert abc
      │         ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null rowid:4!null
      │         ├── canary column: 12
      │         ├── fetch columns: abc.a:9 abc.b:10 abc.c:11 rowid:12
      │         ├── insert-mapping:
      │         │    ├──  column1:5 => abc.a:1
      │         │    ├──  column2:6 => abc.b:2
      │         │    ├──  column8:8 => abc.c:3
      │         │    └──  column7:7 => rowid:4
      │         ├── update-mapping:
      │         │    ├──  upsert_b:16 => abc.b:2
      │         │    └──  upsert_c:17 => abc.c:3
      │         ├── return-mapping:
      │         │    ├──  upsert_a:15 => abc.a:1
      │         │    ├──  upsert_b:16 => abc.b:2
      │         │    ├──  upsert_c:17 => abc.c:3
      │         │    └──  upsert_rowid:18 => rowid:4
      │         └── project
      │              ├── columns: upsert_a:15 upsert_b:16!null upsert_c:17!null upsert_rowid:18 column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12 column13:13!null column14:14!null
      │              ├── project
      │              │    ├── columns: column14:14!null column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12 column13:13!null
      │              │    ├── project
      │              │    │    ├── columns: column13:13!null column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12
      │              │    │    ├── left-join (hash)
      │              │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12
      │              │    │    │    ├── project
      │              │    │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
      │              │    │    │    │    ├── project
      │              │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │              │    │    │    │    │    ├── values
      │              │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │              │    │    │    │    │    │    ├── (1, 2)
      │              │    │    │    │    │    │    └── (3, 4)
      │              │    │    │    │    │    └── projections
      │              │    │    │    │    │         └── unique_rowid()
      │              │    │    │    │    └── projections
      │              │    │    │    │         └── column2 + 1
      │              │    │    │    ├── scan abc
      │              │    │    │    │    ├── columns: abc.a:9!null abc.b:10 abc.c:11 rowid:12!null
      │              │    │    │    │    └── computed column expressions
      │              │    │    │    │         └── abc.c:11
      │              │    │    │    │              └── abc.b + 1
      │              │    │    │    └── filters
      │              │    │    │         └── column1 = abc.a
      │              │    │    └── projections
      │              │    │         └── const: 1 [projected as column13:13]
      │              │    └── projections
      │              │         └── column13 + 1
      │              └── projections
      │                   ├── CASE WHEN rowid IS NULL THEN column1 ELSE abc.a END
      │                   ├── CASE WHEN rowid IS NULL THEN column2 ELSE column13 END
      │                   ├── CASE WHEN rowid IS NULL THEN column8 ELSE column14 END
      │                   └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END
      └── with-scan &1
           ├── columns: a:19!null b:20!null c:21!null
           └── mapping:
                ├──  abc.a:1 => a:19
                ├──  abc.b:2 => b:20
                └──  abc.c:3 => c:21

# Use table alias.
build
INSERT INTO abc AS tab (a, b)
VALUES (1, 2)
ON CONFLICT (a) DO
UPDATE SET a=tab.a*excluded.a
----
upsert tab
 ├── columns: <none>
 ├── canary column: 12
 ├── fetch columns: a:9 b:10 c:11 rowid:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column8:8 => c:3
 │    └──  column7:7 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_a:15 => a:1
 │    └──  upsert_c:17 => c:3
 └── project
      ├── columns: upsert_a:15 upsert_b:16 upsert_c:17 upsert_rowid:18 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13 column14:14
      ├── project
      │    ├── columns: column14:14 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13
      │    ├── project
      │    │    ├── columns: column13:13 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── unique_rowid()
      │    │    │    │    └── projections
      │    │    │    │         └── column2 + 1
      │    │    │    ├── scan tab
      │    │    │    │    ├── columns: a:9!null b:10 c:11 rowid:12!null
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── c:11
      │    │    │    │              └── b + 1
      │    │    │    └── filters
      │    │    │         └── column1 = a
      │    │    └── projections
      │    │         └── a * column1
      │    └── projections
      │         └── b + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN column1 ELSE column13 END
           ├── CASE WHEN rowid IS NULL THEN column2 ELSE b END
           ├── CASE WHEN rowid IS NULL THEN column8 ELSE column14 END
           └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END

# Conflict columns are in different order than index key columns.
build
INSERT INTO abc (a, b)
VALUES (1, 2)
ON CONFLICT (c, b) DO
UPDATE SET a=5
----
upsert abc
 ├── columns: <none>
 ├── canary column: 12
 ├── fetch columns: a:9 b:10 c:11 rowid:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column8:8 => c:3
 │    └──  column7:7 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_a:15 => a:1
 │    └──  upsert_c:17 => c:3
 └── project
      ├── columns: upsert_a:15!null upsert_b:16 upsert_c:17 upsert_rowid:18 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13!null column14:14
      ├── project
      │    ├── columns: column14:14 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13!null
      │    ├── project
      │    │    ├── columns: column13:13!null column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── unique_rowid()
      │    │    │    │    └── projections
      │    │    │    │         └── column2 + 1
      │    │    │    ├── scan abc
      │    │    │    │    ├── columns: a:9!null b:10 c:11 rowid:12!null
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── c:11
      │    │    │    │              └── b + 1
      │    │    │    └── filters
      │    │    │         ├── column2 = b
      │    │    │         └── column8 = c
      │    │    └── projections
      │    │         └── const: 5 [projected as column13:13]
      │    └── projections
      │         └── b + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN column1 ELSE column13 END
           ├── CASE WHEN rowid IS NULL THEN column2 ELSE b END
           ├── CASE WHEN rowid IS NULL THEN column8 ELSE column14 END
           └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END

# Conflict columns don't match unique index (too few columns).
build
INSERT INTO abc (a, b)
VALUES (1, 2)
ON CONFLICT (b) DO
UPDATE SET a=5
----
error (42P10): there is no unique or exclusion constraint matching the ON CONFLICT specification

# Conflict columns don't match unique index (too many columns).
build
INSERT INTO abc (a, b)
VALUES (1, 2)
ON CONFLICT (a, b) DO
UPDATE SET a=5
----
error (42P10): there is no unique or exclusion constraint matching the ON CONFLICT specification

# Conflict column not found.
build
INSERT INTO abc (a, b)
VALUES (1, 2)
ON CONFLICT (a, unknown) DO
UPDATE SET a=5
----
error (42703): column "unknown" does not exist

# ------------------------------------------------------------------------------
# Test DO NOTHING.
# ------------------------------------------------------------------------------

# No conflict columns specified (all non-duplicate indexes must be checked).
build
INSERT INTO xyz
VALUES (1, 2, 3), (4, 5, 6)
ON CONFLICT DO NOTHING
----
insert xyz
 ├── columns: <none>
 ├── insert-mapping:
 │    ├──  column1:4 => x:1
 │    ├──  column2:5 => y:2
 │    └──  column3:6 => z:3
 └── project
      ├── columns: column1:4!null column2:5!null column3:6!null
      └── select
           ├── columns: column1:4!null column2:5!null column3:6!null x:13 y:14 z:15
           ├── left-join (hash)
           │    ├── columns: column1:4!null column2:5!null column3:6!null x:13 y:14 z:15
           │    ├── project
           │    │    ├── columns: column1:4!null column2:5!null column3:6!null
           │    │    └── select
           │    │         ├── columns: column1:4!null column2:5!null column3:6!null x:10 y:11 z:12
           │    │         ├── left-join (hash)
           │    │         │    ├── columns: column1:4!null column2:5!null column3:6!null x:10 y:11 z:12
           │    │         │    ├── project
           │    │         │    │    ├── columns: column1:4!null column2:5!null column3:6!null
           │    │         │    │    └── select
           │    │         │    │         ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
           │    │         │    │         ├── left-join (hash)
           │    │         │    │         │    ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
           │    │         │    │         │    ├── values
           │    │         │    │         │    │    ├── columns: column1:4!null column2:5!null column3:6!null
           │    │         │    │         │    │    ├── (1, 2, 3)
           │    │         │    │         │    │    └── (4, 5, 6)
           │    │         │    │         │    ├── scan xyz
           │    │         │    │         │    │    └── columns: x:7!null y:8 z:9
           │    │         │    │         │    └── filters
           │    │         │    │         │         └── column1 = x
           │    │         │    │         └── filters
           │    │         │    │              └── x IS NULL
           │    │         │    ├── scan xyz
           │    │         │    │    └── columns: x:10!null y:11 z:12
           │    │         │    └── filters
           │    │         │         ├── column2 = y
           │    │         │         └── column3 = z
           │    │         └── filters
           │    │              └── x IS NULL
           │    ├── scan xyz
           │    │    └── columns: x:13!null y:14 z:15
           │    └── filters
           │         ├── column3 = z
           │         └── column2 = y
           └── filters
                └── x IS NULL

# Conflict columns are explicitly specified.
build
INSERT INTO xyz
VALUES (1, 2, 3), (4, 5, 6)
ON CONFLICT (y, z) DO NOTHING
----
insert xyz
 ├── columns: <none>
 ├── insert-mapping:
 │    ├──  column1:4 => x:1
 │    ├──  column2:5 => y:2
 │    └──  column3:6 => z:3
 └── project
      ├── columns: column1:4!null column2:5!null column3:6!null
      └── select
           ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
           ├── left-join (hash)
           │    ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
           │    ├── values
           │    │    ├── columns: column1:4!null column2:5!null column3:6!null
           │    │    ├── (1, 2, 3)
           │    │    └── (4, 5, 6)
           │    ├── scan xyz
           │    │    └── columns: x:7!null y:8 z:9
           │    └── filters
           │         ├── column2 = y
           │         └── column3 = z
           └── filters
                └── x IS NULL

# ------------------------------------------------------------------------------
# Test excluded columns.
# ------------------------------------------------------------------------------

build
INSERT INTO xyz
VALUES (1, 2, 3), (-1, -1, -1)
ON CONFLICT (z, y) DO
UPDATE SET x=excluded.x+1, y=excluded.y*xyz.y, z=excluded.x-excluded.z
WHERE excluded.y>xyz.y
RETURNING xyz.x*2, y+z
----
project
 ├── columns: "?column?":16!null "?column?":17
 ├── upsert xyz
 │    ├── columns: x:1!null y:2 z:3!null
 │    ├── canary column: 7
 │    ├── fetch columns: x:7 y:8 z:9
 │    ├── insert-mapping:
 │    │    ├──  column1:4 => x:1
 │    │    ├──  column2:5 => y:2
 │    │    └──  column3:6 => z:3
 │    ├── update-mapping:
 │    │    ├──  upsert_x:13 => x:1
 │    │    ├──  upsert_y:14 => y:2
 │    │    └──  upsert_z:15 => z:3
 │    ├── return-mapping:
 │    │    ├──  upsert_x:13 => x:1
 │    │    ├──  upsert_y:14 => y:2
 │    │    └──  upsert_z:15 => z:3
 │    └── project
 │         ├── columns: upsert_x:13!null upsert_y:14 upsert_z:15!null column1:4!null column2:5!null column3:6!null x:7 y:8 z:9 column10:10!null column11:11 column12:12!null
 │         ├── project
 │         │    ├── columns: column10:10!null column11:11 column12:12!null column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
 │         │    ├── select
 │         │    │    ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
 │         │    │    ├── left-join (hash)
 │         │    │    │    ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
 │         │    │    │    ├── values
 │         │    │    │    │    ├── columns: column1:4!null column2:5!null column3:6!null
 │         │    │    │    │    ├── (1, 2, 3)
 │         │    │    │    │    └── (-1, -1, -1)
 │         │    │    │    ├── scan xyz
 │         │    │    │    │    └── columns: x:7!null y:8 z:9
 │         │    │    │    └── filters
 │         │    │    │         ├── column2 = y
 │         │    │    │         └── column3 = z
 │         │    │    └── filters
 │         │    │         └── (x IS NULL) OR (column2 > y)
 │         │    └── projections
 │         │         ├── column1 + 1
 │         │         ├── column2 * y
 │         │         └── column1 - column3
 │         └── projections
 │              ├── CASE WHEN x IS NULL THEN column1 ELSE column10 END
 │              ├── CASE WHEN x IS NULL THEN column2 ELSE column11 END
 │              └── CASE WHEN x IS NULL THEN column3 ELSE column12 END
 └── projections
      ├── x * 2
      └── y + z

# Try to use excluded in RETURNING.
build
INSERT INTO xyz
VALUES (1, 2, 3)
ON CONFLICT (x) DO
UPDATE SET x=1
RETURNING excluded.x
----
error (42P01): no data source matches prefix: excluded

# Referencing column without "excluded" or "xyz" prefix is not allowed.
build
INSERT INTO xyz
VALUES (1, 2, 3)
ON CONFLICT (x) DO
UPDATE SET x=x+1
----
error (42702): column reference "x" is ambiguous (candidates: excluded.x, xyz.x)

# ------------------------------------------------------------------------------
# Test UPDATE SET expressions.
# ------------------------------------------------------------------------------

# Subquery.
build
INSERT INTO abc
VALUES (1, 2)
ON CONFLICT (a) DO
UPDATE SET (b, a)=(SELECT x, y+excluded.b FROM xyz WHERE x=excluded.a)
----
upsert abc
 ├── columns: <none>
 ├── canary column: 12
 ├── fetch columns: a:9 b:10 c:11 rowid:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column8:8 => c:3
 │    └──  column7:7 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_a:18 => a:1
 │    ├──  upsert_b:19 => b:2
 │    └──  upsert_c:20 => c:3
 └── project
      ├── columns: upsert_a:18 upsert_b:19 upsert_c:20 upsert_rowid:21 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 x:13 "?column?":16 column17:17
      ├── project
      │    ├── columns: column17:17 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 x:13 "?column?":16
      │    ├── left-join-apply
      │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 x:13 "?column?":16
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── unique_rowid()
      │    │    │    │    └── projections
      │    │    │    │         └── column2 + 1
      │    │    │    ├── scan abc
      │    │    │    │    ├── columns: a:9!null b:10 c:11 rowid:12!null
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── c:11
      │    │    │    │              └── b + 1
      │    │    │    └── filters
      │    │    │         └── column1 = a
      │    │    ├── max1-row
      │    │    │    ├── columns: x:13!null "?column?":16
      │    │    │    └── project
      │    │    │         ├── columns: "?column?":16 x:13!null
      │    │    │         ├── select
      │    │    │         │    ├── columns: x:13!null y:14 z:15
      │    │    │         │    ├── scan xyz
      │    │    │         │    │    └── columns: x:13!null y:14 z:15
      │    │    │         │    └── filters
      │    │    │         │         └── x = column1
      │    │    │         └── projections
      │    │    │              └── y + column2
      │    │    └── filters (true)
      │    └── projections
      │         └── x + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN column1 ELSE ?column? END
           ├── CASE WHEN rowid IS NULL THEN column2 ELSE x END
           ├── CASE WHEN rowid IS NULL THEN column8 ELSE column17 END
           └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END

# Default expressions.
build
INSERT INTO abc
VALUES (1, 2)
ON CONFLICT (a) DO
UPDATE SET a=DEFAULT, b=DEFAULT
----
upsert abc
 ├── columns: <none>
 ├── canary column: 12
 ├── fetch columns: a:9 b:10 c:11 rowid:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column8:8 => c:3
 │    └──  column7:7 => rowid:4
 ├── update-mapping:
 │    ├──  upsert_a:16 => a:1
 │    ├──  upsert_b:17 => b:2
 │    └──  upsert_c:18 => c:3
 └── project
      ├── columns: upsert_a:16 upsert_b:17!null upsert_c:18!null upsert_rowid:19 column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13 column14:14!null column15:15!null
      ├── project
      │    ├── columns: column15:15!null column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12 column13:13 column14:14!null
      │    ├── project
      │    │    ├── columns: column13:13 column14:14!null column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null a:9 b:10 c:11 rowid:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── unique_rowid()
      │    │    │    │    └── projections
      │    │    │    │         └── column2 + 1
      │    │    │    ├── scan abc
      │    │    │    │    ├── columns: a:9!null b:10 c:11 rowid:12!null
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── c:11
      │    │    │    │              └── b + 1
      │    │    │    └── filters
      │    │    │         └── column1 = a
      │    │    └── projections
      │    │         ├── NULL::INT8
      │    │         └── const: 10 [projected as column14:14]
      │    └── projections
      │         └── column14 + 1
      └── projections
           ├── CASE WHEN rowid IS NULL THEN column1 ELSE column13 END
           ├── CASE WHEN rowid IS NULL THEN column2 ELSE column14 END
           ├── CASE WHEN rowid IS NULL THEN column8 ELSE column15 END
           └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END

# ------------------------------------------------------------------------------
# Test mutation columns.
# ------------------------------------------------------------------------------

build
INSERT INTO mutation (m, n)
VALUES (1, 2)
ON CONFLICT (m) DO
UPDATE SET m=mutation.m+1
----
upsert mutation
 ├── columns: <none>
 ├── canary column: 10
 ├── fetch columns: m:10 n:11 o:12 p:13 q:14
 ├── insert-mapping:
 │    ├──  column1:6 => m:1
 │    ├──  column2:7 => n:2
 │    ├──  column8:8 => o:3
 │    └──  column9:9 => p:4
 ├── update-mapping:
 │    ├──  upsert_m:17 => m:1
 │    └──  upsert_p:20 => p:4
 ├── check columns: check1:21
 └── project
      ├── columns: check1:21 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15 column16:16 upsert_m:17 upsert_n:18 upsert_o:19 upsert_p:20
      ├── project
      │    ├── columns: upsert_m:17 upsert_n:18 upsert_o:19 upsert_p:20 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15 column16:16
      │    ├── project
      │    │    ├── columns: column16:16 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15
      │    │    ├── project
      │    │    │    ├── columns: column15:15 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    │    ├── left-join (hash)
      │    │    │    │    ├── columns: column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column9:9!null column1:6!null column2:7!null column8:8!null
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: column8:8!null column1:6!null column2:7!null
      │    │    │    │    │    │    ├── values
      │    │    │    │    │    │    │    ├── columns: column1:6!null column2:7!null
      │    │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    │    └── projections
      │    │    │    │    │    │         └── const: 10 [projected as column8:8]
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── column8 + column2
      │    │    │    │    ├── scan mutation
      │    │    │    │    │    ├── columns: m:10!null n:11 o:12 p:13 q:14
      │    │    │    │    │    └── check constraint expressions
      │    │    │    │    │         └── m > 0
      │    │    │    │    └── filters
      │    │    │    │         └── column1 = m
      │    │    │    └── projections
      │    │    │         └── m + 1
      │    │    └── projections
      │    │         └── o + n
      │    └── projections
      │         ├── CASE WHEN m IS NULL THEN column1 ELSE column15 END
      │         ├── CASE WHEN m IS NULL THEN column2 ELSE n END
      │         ├── CASE WHEN m IS NULL THEN column8 ELSE o END
      │         └── CASE WHEN m IS NULL THEN column9 ELSE column16 END
      └── projections
           └── upsert_m > 0

# ------------------------------------------------------------------------------
# Test UPSERT.
# ------------------------------------------------------------------------------

# Single column primary key.
build
UPSERT INTO xyz VALUES (1)
----
upsert xyz
 ├── columns: <none>
 ├── canary column: 6
 ├── fetch columns: x:6 y:7 z:8
 ├── insert-mapping:
 │    ├──  column1:4 => x:1
 │    ├──  column5:5 => y:2
 │    └──  column5:5 => z:3
 ├── update-mapping:
 │    ├──  column5:5 => y:2
 │    └──  column5:5 => z:3
 └── project
      ├── columns: upsert_x:9 column1:4!null column5:5 x:6 y:7 z:8
      ├── left-join (hash)
      │    ├── columns: column1:4!null column5:5 x:6 y:7 z:8
      │    ├── project
      │    │    ├── columns: column5:5 column1:4!null
      │    │    ├── values
      │    │    │    ├── columns: column1:4!null
      │    │    │    └── (1,)
      │    │    └── projections
      │    │         └── NULL::INT8
      │    ├── scan xyz
      │    │    └── columns: x:6!null y:7 z:8
      │    └── filters
      │         └── column1 = x
      └── projections
           └── CASE WHEN x IS NULL THEN column1 ELSE x END

# Test multi-column primary key that contains all columns in table.
build
UPSERT INTO uv VALUES (1, 2) RETURNING *
----
upsert uv
 ├── columns: u:1!null v:2!null
 ├── upsert-mapping:
 │    ├──  column1:3 => u:1
 │    └──  column2:4 => v:2
 └── values
      ├── columns: column1:3!null column2:4!null
      └── (1, 2)

# Use returning UPSERT as a FROM expression.
build
SELECT * FROM [UPSERT INTO abc VALUES (1, 2) RETURNING *]
----
with &1
 ├── columns: a:14!null b:15!null c:16!null
 ├── project
 │    ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null
 │    └── upsert abc
 │         ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null rowid:4!null
 │         ├── canary column: 12
 │         ├── fetch columns: abc.a:9 abc.b:10 abc.c:11 rowid:12
 │         ├── insert-mapping:
 │         │    ├──  column1:5 => abc.a:1
 │         │    ├──  column2:6 => abc.b:2
 │         │    ├──  column8:8 => abc.c:3
 │         │    └──  column7:7 => rowid:4
 │         ├── update-mapping:
 │         │    ├──  column1:5 => abc.a:1
 │         │    ├──  column2:6 => abc.b:2
 │         │    └──  column8:8 => abc.c:3
 │         ├── return-mapping:
 │         │    ├──  column1:5 => abc.a:1
 │         │    ├──  column2:6 => abc.b:2
 │         │    ├──  column8:8 => abc.c:3
 │         │    └──  upsert_rowid:13 => rowid:4
 │         └── project
 │              ├── columns: upsert_rowid:13 column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12
 │              ├── left-join (hash)
 │              │    ├── columns: column1:5!null column2:6!null column7:7 column8:8!null abc.a:9 abc.b:10 abc.c:11 rowid:12
 │              │    ├── project
 │              │    │    ├── columns: column8:8!null column1:5!null column2:6!null column7:7
 │              │    │    ├── project
 │              │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
 │              │    │    │    ├── values
 │              │    │    │    │    ├── columns: column1:5!null column2:6!null
 │              │    │    │    │    └── (1, 2)
 │              │    │    │    └── projections
 │              │    │    │         └── unique_rowid()
 │              │    │    └── projections
 │              │    │         └── column2 + 1
 │              │    ├── scan abc
 │              │    │    ├── columns: abc.a:9!null abc.b:10 abc.c:11 rowid:12!null
 │              │    │    └── computed column expressions
 │              │    │         └── abc.c:11
 │              │    │              └── abc.b + 1
 │              │    └── filters
 │              │         └── column7 = rowid
 │              └── projections
 │                   └── CASE WHEN rowid IS NULL THEN column7 ELSE rowid END
 └── with-scan &1
      ├── columns: a:14!null b:15!null c:16!null
      └── mapping:
           ├──  abc.a:1 => a:14
           ├──  abc.b:2 => b:15
           └──  abc.c:3 => c:16

# Use explicitly specified column names with secondary indexes present. Existing
# values of other columns need to be fetched to delete existing index rows.
build
UPSERT INTO xyz (z, x, y) VALUES (1, 2, 3)
----
upsert xyz
 ├── columns: <none>
 ├── canary column: 7
 ├── fetch columns: x:7 y:8 z:9
 ├── insert-mapping:
 │    ├──  column2:5 => x:1
 │    ├──  column3:6 => y:2
 │    └──  column1:4 => z:3
 ├── update-mapping:
 │    ├──  column3:6 => y:2
 │    └──  column1:4 => z:3
 └── project
      ├── columns: upsert_x:10 column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
      ├── left-join (hash)
      │    ├── columns: column1:4!null column2:5!null column3:6!null x:7 y:8 z:9
      │    ├── values
      │    │    ├── columns: column1:4!null column2:5!null column3:6!null
      │    │    └── (1, 2, 3)
      │    ├── scan xyz
      │    │    └── columns: x:7!null y:8 z:9
      │    └── filters
      │         └── column2 = x
      └── projections
           └── CASE WHEN x IS NULL THEN column2 ELSE x END

# Use explicitly specified column names with no secondary indexes present.
# Upsert implemented with blind Puts is possible.
build
UPSERT INTO noindex (x, y, z) VALUES (1, 2, 3)
----
upsert noindex
 ├── columns: <none>
 ├── upsert-mapping:
 │    ├──  column1:4 => x:1
 │    ├──  column2:5 => y:2
 │    └──  column3:6 => z:3
 └── values
      ├── columns: column1:4!null column2:5!null column3:6!null
      └── (1, 2, 3)

# Use subset of explicitly specified column names with no secondary indexes
# present. Existing values of other columns need to be fetched to provide
# update values for unspecified columns.
build
UPSERT INTO checks (a, b, c) VALUES (1, 2, 3)
----
upsert checks
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: a:9 b:10 c:11 d:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column3:7 => c:3
 │    └──  column8:8 => d:4
 ├── update-mapping:
 │    ├──  column2:6 => b:2
 │    ├──  column3:7 => c:3
 │    └──  column8:8 => d:4
 ├── check columns: check1:14 check2:15
 └── project
      ├── columns: check1:14!null check2:15 column1:5!null column2:6!null column3:7!null column8:8!null a:9 b:10 c:11 d:12 upsert_a:13
      ├── project
      │    ├── columns: upsert_a:13 column1:5!null column2:6!null column3:7!null column8:8!null a:9 b:10 c:11 d:12
      │    ├── left-join (hash)
      │    │    ├── columns: column1:5!null column2:6!null column3:7!null column8:8!null a:9 b:10 c:11 d:12
      │    │    ├── project
      │    │    │    ├── columns: column8:8!null column1:5!null column2:6!null column3:7!null
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
      │    │    │    │    └── (1, 2, 3)
      │    │    │    └── projections
      │    │    │         └── column3 + 1
      │    │    ├── scan checks
      │    │    │    ├── columns: a:9!null b:10 c:11 d:12
      │    │    │    ├── check constraint expressions
      │    │    │    │    ├── b < d
      │    │    │    │    └── a > 0
      │    │    │    └── computed column expressions
      │    │    │         └── d:12
      │    │    │              └── c + 1
      │    │    └── filters
      │    │         └── column1 = a
      │    └── projections
      │         └── CASE WHEN a IS NULL THEN column1 ELSE a END
      └── projections
           ├── column2 < column8
           └── upsert_a > 0

# Don't directly update mutation columns. However, computed columns do need to
# be updated. Use explicit target columns.
build
UPSERT INTO mutation (m, n) VALUES (1, 2)
----
upsert mutation
 ├── columns: <none>
 ├── canary column: 10
 ├── fetch columns: m:10 n:11 o:12 p:13 q:14
 ├── insert-mapping:
 │    ├──  column1:6 => m:1
 │    ├──  column2:7 => n:2
 │    ├──  column8:8 => o:3
 │    └──  column9:9 => p:4
 ├── update-mapping:
 │    ├──  column2:7 => n:2
 │    └──  upsert_p:18 => p:4
 ├── check columns: check1:19
 └── project
      ├── columns: check1:19 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15 upsert_m:16 upsert_o:17 upsert_p:18
      ├── project
      │    ├── columns: upsert_m:16 upsert_o:17 upsert_p:18 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15
      │    ├── project
      │    │    ├── columns: column15:15 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    │    ├── project
      │    │    │    │    ├── columns: column9:9!null column1:6!null column2:7!null column8:8!null
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column8:8!null column1:6!null column2:7!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:6!null column2:7!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── const: 10 [projected as column8:8]
      │    │    │    │    └── projections
      │    │    │    │         └── column8 + column2
      │    │    │    ├── scan mutation
      │    │    │    │    ├── columns: m:10!null n:11 o:12 p:13 q:14
      │    │    │    │    └── check constraint expressions
      │    │    │    │         └── m > 0
      │    │    │    └── filters
      │    │    │         └── column1 = m
      │    │    └── projections
      │    │         └── o + column2
      │    └── projections
      │         ├── CASE WHEN m IS NULL THEN column1 ELSE m END
      │         ├── CASE WHEN m IS NULL THEN column8 ELSE o END
      │         └── CASE WHEN m IS NULL THEN column9 ELSE column15 END
      └── projections
           └── upsert_m > 0

# Don't directly update mutation columns. However, computed columns do need to
# be updated. Use implicit target columns.
build
UPSERT INTO mutation VALUES (1, 2)
----
upsert mutation
 ├── columns: <none>
 ├── canary column: 10
 ├── fetch columns: m:10 n:11 o:12 p:13 q:14
 ├── insert-mapping:
 │    ├──  column1:6 => m:1
 │    ├──  column2:7 => n:2
 │    ├──  column8:8 => o:3
 │    └──  column9:9 => p:4
 ├── update-mapping:
 │    ├──  column2:7 => n:2
 │    └──  upsert_p:18 => p:4
 ├── check columns: check1:19
 └── project
      ├── columns: check1:19 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15 upsert_m:16 upsert_o:17 upsert_p:18
      ├── project
      │    ├── columns: upsert_m:16 upsert_o:17 upsert_p:18 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14 column15:15
      │    ├── project
      │    │    ├── columns: column15:15 column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:6!null column2:7!null column8:8!null column9:9!null m:10 n:11 o:12 p:13 q:14
      │    │    │    ├── project
      │    │    │    │    ├── columns: column9:9!null column1:6!null column2:7!null column8:8!null
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column8:8!null column1:6!null column2:7!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:6!null column2:7!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── const: 10 [projected as column8:8]
      │    │    │    │    └── projections
      │    │    │    │         └── column8 + column2
      │    │    │    ├── scan mutation
      │    │    │    │    ├── columns: m:10!null n:11 o:12 p:13 q:14
      │    │    │    │    └── check constraint expressions
      │    │    │    │         └── m > 0
      │    │    │    └── filters
      │    │    │         └── column1 = m
      │    │    └── projections
      │    │         └── o + column2
      │    └── projections
      │         ├── CASE WHEN m IS NULL THEN column1 ELSE m END
      │         ├── CASE WHEN m IS NULL THEN column8 ELSE o END
      │         └── CASE WHEN m IS NULL THEN column9 ELSE column15 END
      └── projections
           └── upsert_m > 0

# Use unknown name in upsert column list.
build
UPSERT INTO xyz (x, unknown) VALUES (1)
----
error (42703): column "unknown" does not exist

# ------------------------------------------------------------------------------
# Test check constraints.
# ------------------------------------------------------------------------------

# INSERT..ON CONFLICT
build
INSERT INTO checks (a, b) VALUES (1, 2) ON CONFLICT (a) DO UPDATE SET b=3, c=4
----
upsert checks
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: a:9 b:10 c:11 d:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column7:7 => c:3
 │    └──  column8:8 => d:4
 ├── update-mapping:
 │    ├──  upsert_b:17 => b:2
 │    ├──  upsert_c:18 => c:3
 │    └──  upsert_d:19 => d:4
 ├── check columns: check1:20 check2:21
 └── project
      ├── columns: check1:20 check2:21 column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12 column13:13!null column14:14!null column15:15!null upsert_a:16 upsert_b:17!null upsert_c:18 upsert_d:19
      ├── project
      │    ├── columns: upsert_a:16 upsert_b:17!null upsert_c:18 upsert_d:19 column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12 column13:13!null column14:14!null column15:15!null
      │    ├── project
      │    │    ├── columns: column15:15!null column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12 column13:13!null column14:14!null
      │    │    ├── project
      │    │    │    ├── columns: column13:13!null column14:14!null column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │    │    │    ├── left-join (hash)
      │    │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column8:8 column1:5!null column2:6!null column7:7
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    │    ├── values
      │    │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    │    └── projections
      │    │    │    │    │    │         └── NULL::INT8
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── column7 + 1
      │    │    │    │    ├── scan checks
      │    │    │    │    │    ├── columns: a:9!null b:10 c:11 d:12
      │    │    │    │    │    ├── check constraint expressions
      │    │    │    │    │    │    ├── b < d
      │    │    │    │    │    │    └── a > 0
      │    │    │    │    │    └── computed column expressions
      │    │    │    │    │         └── d:12
      │    │    │    │    │              └── c + 1
      │    │    │    │    └── filters
      │    │    │    │         └── column1 = a
      │    │    │    └── projections
      │    │    │         ├── const: 3 [projected as column13:13]
      │    │    │         └── const: 4 [projected as column14:14]
      │    │    └── projections
      │    │         └── column14 + 1
      │    └── projections
      │         ├── CASE WHEN a IS NULL THEN column1 ELSE a END
      │         ├── CASE WHEN a IS NULL THEN column2 ELSE column13 END
      │         ├── CASE WHEN a IS NULL THEN column7 ELSE column14 END
      │         └── CASE WHEN a IS NULL THEN column8 ELSE column15 END
      └── projections
           ├── upsert_b < upsert_d
           └── upsert_a > 0

# INSERT..ON CONFLICT DO NOTHING
build
INSERT INTO checks (a, b) VALUES (1, 2) ON CONFLICT (a) DO NOTHING
----
insert checks
 ├── columns: <none>
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column7:7 => c:3
 │    └──  column8:8 => d:4
 ├── check columns: check1:13 check2:14
 └── project
      ├── columns: check1:13 check2:14!null column1:5!null column2:6!null column7:7 column8:8
      ├── project
      │    ├── columns: column1:5!null column2:6!null column7:7 column8:8
      │    └── select
      │         ├── columns: column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │         ├── left-join (hash)
      │         │    ├── columns: column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │         │    ├── project
      │         │    │    ├── columns: column8:8 column1:5!null column2:6!null column7:7
      │         │    │    ├── project
      │         │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │         │    │    │    ├── values
      │         │    │    │    │    ├── columns: column1:5!null column2:6!null
      │         │    │    │    │    └── (1, 2)
      │         │    │    │    └── projections
      │         │    │    │         └── NULL::INT8
      │         │    │    └── projections
      │         │    │         └── column7 + 1
      │         │    ├── scan checks
      │         │    │    ├── columns: a:9!null b:10 c:11 d:12
      │         │    │    ├── check constraint expressions
      │         │    │    │    ├── b < d
      │         │    │    │    └── a > 0
      │         │    │    └── computed column expressions
      │         │    │         └── d:12
      │         │    │              └── c + 1
      │         │    └── filters
      │         │         └── column1 = a
      │         └── filters
      │              └── a IS NULL
      └── projections
           ├── column2 < column8
           └── column1 > 0

# UPSERT
build
UPSERT INTO checks (a, b) VALUES (1, 2)
----
upsert checks
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: a:9 b:10 c:11 d:12
 ├── insert-mapping:
 │    ├──  column1:5 => a:1
 │    ├──  column2:6 => b:2
 │    ├──  column7:7 => c:3
 │    └──  column8:8 => d:4
 ├── update-mapping:
 │    ├──  column2:6 => b:2
 │    └──  upsert_d:16 => d:4
 ├── check columns: check1:17 check2:18
 └── project
      ├── columns: check1:17 check2:18 column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12 column13:13 upsert_a:14 upsert_c:15 upsert_d:16
      ├── project
      │    ├── columns: upsert_a:14 upsert_c:15 upsert_d:16 column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12 column13:13
      │    ├── project
      │    │    ├── columns: column13:13 column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: column1:5!null column2:6!null column7:7 column8:8 a:9 b:10 c:11 d:12
      │    │    │    ├── project
      │    │    │    │    ├── columns: column8:8 column1:5!null column2:6!null column7:7
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── columns: column1:5!null column2:6!null
      │    │    │    │    │    │    └── (1, 2)
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── NULL::INT8
      │    │    │    │    └── projections
      │    │    │    │         └── column7 + 1
      │    │    │    ├── scan checks
      │    │    │    │    ├── columns: a:9!null b:10 c:11 d:12
      │    │    │    │    ├── check constraint expressions
      │    │    │    │    │    ├── b < d
      │    │    │    │    │    └── a > 0
      │    │    │    │    └── computed column expressions
      │    │    │    │         └── d:12
      │    │    │    │              └── c + 1
      │    │    │    └── filters
      │    │    │         └── column1 = a
      │    │    └── projections
      │    │         └── c + 1
      │    └── projections
      │         ├── CASE WHEN a IS NULL THEN column1 ELSE a END
      │         ├── CASE WHEN a IS NULL THEN column7 ELSE c END
      │         └── CASE WHEN a IS NULL THEN column8 ELSE column13 END
      └── projections
           ├── column2 < upsert_d
           └── upsert_a > 0

# Use subqueries and excluded.
build
INSERT INTO checks
SELECT a, b FROM abc
ON CONFLICT (a) DO UPDATE SET a=excluded.a, b=(SELECT x FROM xyz WHERE x=checks.a)
----
upsert checks
 ├── columns: <none>
 ├── canary column: 11
 ├── fetch columns: checks.a:11 checks.b:12 checks.c:13 d:14
 ├── insert-mapping:
 │    ├──  abc.a:5 => checks.a:1
 │    ├──  abc.b:6 => checks.b:2
 │    ├──  column9:9 => checks.c:3
 │    └──  column10:10 => d:4
 ├── update-mapping:
 │    ├──  abc.a:5 => checks.a:1
 │    ├──  upsert_b:20 => checks.b:2
 │    └──  upsert_d:22 => d:4
 ├── check columns: check1:23 check2:24
 └── project
      ├── columns: check1:23 check2:24!null abc.a:5!null abc.b:6 column9:9 column10:10 checks.a:11 checks.b:12 checks.c:13 d:14 column18:18 column19:19 upsert_b:20 upsert_c:21 upsert_d:22
      ├── project
      │    ├── columns: upsert_b:20 upsert_c:21 upsert_d:22 abc.a:5!null abc.b:6 column9:9 column10:10 checks.a:11 checks.b:12 checks.c:13 d:14 column18:18 column19:19
      │    ├── project
      │    │    ├── columns: column19:19 abc.a:5!null abc.b:6 column9:9 column10:10 checks.a:11 checks.b:12 checks.c:13 d:14 column18:18
      │    │    ├── project
      │    │    │    ├── columns: column18:18 abc.a:5!null abc.b:6 column9:9 column10:10 checks.a:11 checks.b:12 checks.c:13 d:14
      │    │    │    ├── left-join (hash)
      │    │    │    │    ├── columns: abc.a:5!null abc.b:6 column9:9 column10:10 checks.a:11 checks.b:12 checks.c:13 d:14
      │    │    │    │    ├── project
      │    │    │    │    │    ├── columns: column10:10 abc.a:5!null abc.b:6 column9:9
      │    │    │    │    │    ├── project
      │    │    │    │    │    │    ├── columns: column9:9 abc.a:5!null abc.b:6
      │    │    │    │    │    │    ├── project
      │    │    │    │    │    │    │    ├── columns: abc.a:5!null abc.b:6
      │    │    │    │    │    │    │    └── scan abc
      │    │    │    │    │    │    │         ├── columns: abc.a:5!null abc.b:6 abc.c:7 rowid:8!null
      │    │    │    │    │    │    │         └── computed column expressions
      │    │    │    │    │    │    │              └── abc.c:7
      │    │    │    │    │    │    │                   └── abc.b + 1
      │    │    │    │    │    │    └── projections
      │    │    │    │    │    │         └── NULL::INT8
      │    │    │    │    │    └── projections
      │    │    │    │    │         └── column9 + 1
      │    │    │    │    ├── scan checks
      │    │    │    │    │    ├── columns: checks.a:11!null checks.b:12 checks.c:13 d:14
      │    │    │    │    │    ├── check constraint expressions
      │    │    │    │    │    │    ├── checks.b < d
      │    │    │    │    │    │    └── checks.a > 0
      │    │    │    │    │    └── computed column expressions
      │    │    │    │    │         └── d:14
      │    │    │    │    │              └── checks.c + 1
      │    │    │    │    └── filters
      │    │    │    │         └── abc.a = checks.a
      │    │    │    └── projections
      │    │    │         └── subquery [projected as column18:18]
      │    │    │              └── max1-row
      │    │    │                   ├── columns: x:15!null
      │    │    │                   └── project
      │    │    │                        ├── columns: x:15!null
      │    │    │                        └── select
      │    │    │                             ├── columns: x:15!null y:16 z:17
      │    │    │                             ├── scan xyz
      │    │    │                             │    └── columns: x:15!null y:16 z:17
      │    │    │                             └── filters
      │    │    │                                  └── x = checks.a
      │    │    └── projections
      │    │         └── checks.c + 1
      │    └── projections
      │         ├── CASE WHEN checks.a IS NULL THEN abc.b ELSE column18 END
      │         ├── CASE WHEN checks.a IS NULL THEN column9 ELSE checks.c END
      │         └── CASE WHEN checks.a IS NULL THEN column10 ELSE column19 END
      └── projections
           ├── upsert_b < upsert_d
           └── abc.a > 0

# ------------------------------------------------------------------------------
# Test decimal column truncation.
# ------------------------------------------------------------------------------

# Fast UPSERT case.
opt
UPSERT INTO decimals (a, b) VALUES (1.1, ARRAY[0.95])
----
upsert decimals
 ├── columns: <none>
 ├── canary column: 13
 ├── fetch columns: decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
 ├── insert-mapping:
 │    ├──  a:8 => decimals.a:1
 │    ├──  b:9 => decimals.b:2
 │    ├──  c:10 => decimals.c:3
 │    └──  d:12 => decimals.d:4
 ├── update-mapping:
 │    ├──  b:9 => decimals.b:2
 │    └──  upsert_d:21 => decimals.d:4
 ├── check columns: check1:22 check2:23
 └── project
      ├── columns: check1:22 check2:23 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16 upsert_d:21
      ├── project
      │    ├── columns: upsert_a:19 upsert_d:21 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    ├── left-join (lookup decimals)
      │    │    ├── columns: a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    │    ├── key columns: [8] = [13]
      │    │    ├── lookup columns are key
      │    │    ├── project
      │    │    │    ├── columns: d:12 a:8 b:9 c:10
      │    │    │    ├── values
      │    │    │    │    ├── columns: a:8 b:9 c:10
      │    │    │    │    └── (crdb_internal.round_decimal_values(1.1, 0), crdb_internal.round_decimal_values(ARRAY[0.95], 1), crdb_internal.round_decimal_values(1.23, 1))
      │    │    │    └── projections
      │    │    │         └── crdb_internal.round_decimal_values(a + c, 1)
      │    │    └── filters (true)
      │    └── projections
      │         ├── CASE WHEN decimals.a IS NULL THEN a ELSE decimals.a END
      │         └── CASE WHEN decimals.a IS NULL THEN d ELSE crdb_internal.round_decimal_values(decimals.a + decimals.c, 1) END
      └── projections
           ├── upsert_a = round(upsert_a)
           └── b[0] > 1

# Regular UPSERT case.
opt
UPSERT INTO decimals (a) VALUES (1.1)
----
upsert decimals
 ├── columns: <none>
 ├── canary column: 13
 ├── fetch columns: decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
 ├── insert-mapping:
 │    ├──  a:8 => decimals.a:1
 │    ├──  b:9 => decimals.b:2
 │    ├──  c:10 => decimals.c:3
 │    └──  d:12 => decimals.d:4
 ├── update-mapping:
 │    └──  upsert_d:22 => decimals.d:4
 ├── check columns: check1:23 check2:24
 └── project
      ├── columns: check1:23 check2:24 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16 upsert_d:22
      ├── project
      │    ├── columns: upsert_a:19 upsert_b:20 upsert_d:22 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    ├── left-join (lookup decimals)
      │    │    ├── columns: a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    │    ├── key columns: [8] = [13]
      │    │    ├── lookup columns are key
      │    │    ├── project
      │    │    │    ├── columns: d:12 a:8 b:9 c:10
      │    │    │    ├── values
      │    │    │    │    ├── columns: a:8 b:9 c:10
      │    │    │    │    └── (crdb_internal.round_decimal_values(1.1, 0), crdb_internal.round_decimal_values(CAST(NULL AS DECIMAL(5,1)[]), 1), crdb_internal.round_decimal_values(1.23, 1))
      │    │    │    └── projections
      │    │    │         └── crdb_internal.round_decimal_values(a + c, 1)
      │    │    └── filters (true)
      │    └── projections
      │         ├── CASE WHEN decimals.a IS NULL THEN a ELSE decimals.a END
      │         ├── CASE WHEN decimals.a IS NULL THEN b ELSE decimals.b END
      │         └── CASE WHEN decimals.a IS NULL THEN d ELSE crdb_internal.round_decimal_values(decimals.a + decimals.c, 1) END
      └── projections
           ├── upsert_a = round(upsert_a)
           └── upsert_b[0] > 1

# INSERT...ON CONFLICT case.
opt
INSERT INTO decimals (a, b) VALUES (1.1, ARRAY[0.95])
ON CONFLICT (a)
DO UPDATE SET b=ARRAY[0.99]
----
upsert decimals
 ├── columns: <none>
 ├── canary column: 13
 ├── fetch columns: decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
 ├── insert-mapping:
 │    ├──  a:8 => decimals.a:1
 │    ├──  b:9 => decimals.b:2
 │    ├──  c:10 => decimals.c:3
 │    └──  d:12 => decimals.d:4
 ├── update-mapping:
 │    ├──  upsert_b:22 => decimals.b:2
 │    └──  upsert_d:24 => decimals.d:4
 ├── check columns: check1:25 check2:26
 └── project
      ├── columns: check1:25 check2:26 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16 upsert_b:22 upsert_d:24
      ├── project
      │    ├── columns: upsert_a:21 upsert_b:22 upsert_d:24 a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    ├── left-join (lookup decimals)
      │    │    ├── columns: a:8 b:9 c:10 d:12 decimals.a:13 decimals.b:14 decimals.c:15 decimals.d:16
      │    │    ├── key columns: [8] = [13]
      │    │    ├── lookup columns are key
      │    │    ├── project
      │    │    │    ├── columns: d:12 a:8 b:9 c:10
      │    │    │    ├── values
      │    │    │    │    ├── columns: a:8 b:9 c:10
      │    │    │    │    └── (crdb_internal.round_decimal_values(1.1, 0), crdb_internal.round_decimal_values(ARRAY[0.95], 1), crdb_internal.round_decimal_values(1.23, 1))
      │    │    │    └── projections
      │    │    │         └── crdb_internal.round_decimal_values(a + c, 1)
      │    │    └── filters (true)
      │    └── projections
      │         ├── CASE WHEN decimals.a IS NULL THEN a ELSE decimals.a END
      │         ├── CASE WHEN decimals.a IS NULL THEN b ELSE crdb_internal.round_decimal_values(ARRAY[0.99], 1) END
      │         └── CASE WHEN decimals.a IS NULL THEN d ELSE crdb_internal.round_decimal_values(decimals.a + decimals.c, 1) END
      └── projections
           ├── upsert_a = round(upsert_a)
           └── upsert_b[0] > 1
