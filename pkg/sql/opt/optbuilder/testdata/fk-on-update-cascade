exec-ddl
CREATE TABLE parent (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE child (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p) ON UPDATE CASCADE)
----

build-cascades
UPDATE parent SET p = p * 10 WHERE p > 1
----
root
 ├── update parent
 │    ├── columns: <none>
 │    ├── fetch columns: p:3
 │    ├── update-mapping:
 │    │    └── p_new:5 => p:1
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk_p_ref_parent
 │    └── project
 │         ├── columns: p_new:5!null p:3!null crdb_internal_mvcc_timestamp:4
 │         ├── select
 │         │    ├── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    ├── scan parent
 │         │    │    └── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    └── filters
 │         │         └── p:3 > 1
 │         └── projections
 │              └── p:3 * 10 [as=p_new:5]
 └── cascade
      └── update child
           ├── columns: <none>
           ├── fetch columns: c:9 child.p:10
           ├── update-mapping:
           │    └── p_new:13 => child.p:7
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:9!null child.p:10!null p:12!null p_new:13!null
           │    ├── scan child
           │    │    └── columns: c:9!null child.p:10!null
           │    ├── select
           │    │    ├── columns: p:12!null p_new:13!null
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:12!null p_new:13!null
           │    │    │    └── mapping:
           │    │    │         ├──  parent.p:3 => p:12
           │    │    │         └──  p_new:5 => p_new:13
           │    │    └── filters
           │    │         └── p:12 IS DISTINCT FROM p_new:13
           │    └── filters
           │         └── child.p:10 = p:12
           └── f-k-checks
                └── f-k-checks-item: child(p) -> parent(p)
                     └── anti-join (hash)
                          ├── columns: p:14!null
                          ├── with-scan &2
                          │    ├── columns: p:14!null
                          │    └── mapping:
                          │         └──  p_new:13 => p:14
                          ├── scan parent
                          │    └── columns: parent.p:15!null
                          └── filters
                               └── p:14 = parent.p:15

exec-ddl
CREATE TABLE parent_multi (
  pk INT PRIMARY KEY,
  p INT, q INT,
  UNIQUE (p, q),
  FAMILY (pk),
  FAMILY (p),
  FAMILY (q)
)
----

exec-ddl
CREATE TABLE child_multi (
  c INT PRIMARY KEY,
  p INT, q INT,
  UNIQUE (c, q),
  CONSTRAINT fk FOREIGN KEY (p, q) REFERENCES parent_multi(p, q) ON UPDATE CASCADE 
)
----

build-cascades
UPDATE parent_multi SET p = p * 10, q = q + 1 WHERE pk > 1
----
root
 ├── update parent_multi
 │    ├── columns: <none>
 │    ├── fetch columns: pk:5 p:6 q:7
 │    ├── update-mapping:
 │    │    ├── p_new:9 => p:2
 │    │    └── q_new:10 => q:3
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: p_new:9 q_new:10 pk:5!null p:6 q:7 crdb_internal_mvcc_timestamp:8
 │         ├── select
 │         │    ├── columns: pk:5!null p:6 q:7 crdb_internal_mvcc_timestamp:8
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:5!null p:6 q:7 crdb_internal_mvcc_timestamp:8
 │         │    └── filters
 │         │         └── pk:5 > 1
 │         └── projections
 │              ├── p:6 * 10 [as=p_new:9]
 │              └── q:7 + 1 [as=q_new:10]
 └── cascade
      └── update child_multi
           ├── columns: <none>
           ├── fetch columns: c:15 child_multi.p:16 child_multi.q:17
           ├── update-mapping:
           │    ├── p_new:21 => child_multi.p:12
           │    └── q_new:22 => child_multi.q:13
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:15!null child_multi.p:16!null child_multi.q:17!null p:19!null q:20!null p_new:21 q_new:22
           │    ├── scan child_multi
           │    │    └── columns: c:15!null child_multi.p:16 child_multi.q:17
           │    ├── select
           │    │    ├── columns: p:19 q:20 p_new:21 q_new:22
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:19 q:20 p_new:21 q_new:22
           │    │    │    └── mapping:
           │    │    │         ├──  parent_multi.p:6 => p:19
           │    │    │         ├──  parent_multi.q:7 => q:20
           │    │    │         ├──  p_new:9 => p_new:21
           │    │    │         └──  q_new:10 => q_new:22
           │    │    └── filters
           │    │         └── (p:19 IS DISTINCT FROM p_new:21) OR (q:20 IS DISTINCT FROM q_new:22)
           │    └── filters
           │         ├── child_multi.p:16 = p:19
           │         └── child_multi.q:17 = q:20
           └── f-k-checks
                └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
                     └── anti-join (hash)
                          ├── columns: p:23!null q:24!null
                          ├── select
                          │    ├── columns: p:23!null q:24!null
                          │    ├── with-scan &2
                          │    │    ├── columns: p:23 q:24
                          │    │    └── mapping:
                          │    │         ├──  p_new:21 => p:23
                          │    │         └──  q_new:22 => q:24
                          │    └── filters
                          │         ├── p:23 IS NOT NULL
                          │         └── q:24 IS NOT NULL
                          ├── scan parent_multi
                          │    └── columns: parent_multi.p:26 parent_multi.q:27
                          └── filters
                               ├── p:23 = parent_multi.p:26
                               └── q:24 = parent_multi.q:27

# Update only one of the two FK columns. The "before" and "after" values of q
# come from the same column in the mutation input.
build-cascades
UPDATE parent_multi SET p = p * 10 WHERE p > 1
----
root
 ├── update parent_multi
 │    ├── columns: <none>
 │    ├── fetch columns: pk:5 p:6 q:7
 │    ├── update-mapping:
 │    │    └── p_new:9 => p:2
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: p_new:9!null pk:5!null p:6!null q:7 crdb_internal_mvcc_timestamp:8
 │         ├── select
 │         │    ├── columns: pk:5!null p:6!null q:7 crdb_internal_mvcc_timestamp:8
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:5!null p:6 q:7 crdb_internal_mvcc_timestamp:8
 │         │    └── filters
 │         │         └── p:6 > 1
 │         └── projections
 │              └── p:6 * 10 [as=p_new:9]
 └── cascade
      └── update child_multi
           ├── columns: <none>
           ├── fetch columns: c:14 child_multi.p:15 child_multi.q:16
           ├── update-mapping:
           │    ├── p_new:20 => child_multi.p:11
           │    └── q:21 => child_multi.q:12
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:14!null child_multi.p:15!null child_multi.q:16!null p:18!null q:19!null p_new:20!null q:21
           │    ├── scan child_multi
           │    │    └── columns: c:14!null child_multi.p:15 child_multi.q:16
           │    ├── select
           │    │    ├── columns: p:18!null q:19 p_new:20!null q:21
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:18!null q:19 p_new:20!null q:21
           │    │    │    └── mapping:
           │    │    │         ├──  parent_multi.p:6 => p:18
           │    │    │         ├──  parent_multi.q:7 => q:19
           │    │    │         ├──  p_new:9 => p_new:20
           │    │    │         └──  parent_multi.q:7 => q:21
           │    │    └── filters
           │    │         └── (p:18 IS DISTINCT FROM p_new:20) OR (q:19 IS DISTINCT FROM q:21)
           │    └── filters
           │         ├── child_multi.p:15 = p:18
           │         └── child_multi.q:16 = q:19
           └── f-k-checks
                └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
                     └── anti-join (hash)
                          ├── columns: p:22!null q:23!null
                          ├── select
                          │    ├── columns: p:22!null q:23!null
                          │    ├── with-scan &2
                          │    │    ├── columns: p:22!null q:23
                          │    │    └── mapping:
                          │    │         ├──  p_new:20 => p:22
                          │    │         └──  q:21 => q:23
                          │    └── filters
                          │         └── q:23 IS NOT NULL
                          ├── scan parent_multi
                          │    └── columns: parent_multi.p:25 parent_multi.q:26
                          └── filters
                               ├── p:22 = parent_multi.p:25
                               └── q:23 = parent_multi.q:26

build-cascades
UPSERT INTO parent_multi VALUES (1, 10, 10), (2, 20, 20)
----
root
 ├── upsert parent_multi
 │    ├── columns: <none>
 │    ├── arbiter indexes: primary
 │    ├── canary column: pk:8
 │    ├── fetch columns: pk:8 p:9 q:10
 │    ├── insert-mapping:
 │    │    ├── column1:5 => pk:1
 │    │    ├── column2:6 => p:2
 │    │    └── column3:7 => q:3
 │    ├── update-mapping:
 │    │    ├── column2:6 => p:2
 │    │    └── column3:7 => q:3
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: upsert_pk:12 column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         ├── left-join (hash)
 │         │    ├── columns: column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    ├── ensure-upsert-distinct-on
 │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    ├── grouping columns: column1:5!null
 │         │    │    ├── values
 │         │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    │    ├── (1, 10, 10)
 │         │    │    │    └── (2, 20, 20)
 │         │    │    └── aggregations
 │         │    │         ├── first-agg [as=column2:6]
 │         │    │         │    └── column2:6
 │         │    │         └── first-agg [as=column3:7]
 │         │    │              └── column3:7
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:8!null p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    └── filters
 │         │         └── column1:5 = pk:8
 │         └── projections
 │              └── CASE WHEN pk:8 IS NULL THEN column1:5 ELSE pk:8 END [as=upsert_pk:12]
 └── cascade
      └── update child_multi
           ├── columns: <none>
           ├── fetch columns: c:17 child_multi.p:18 child_multi.q:19
           ├── update-mapping:
           │    ├── column2:23 => child_multi.p:14
           │    └── column3:24 => child_multi.q:15
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:17!null child_multi.p:18!null child_multi.q:19!null p:21!null q:22!null column2:23!null column3:24!null
           │    ├── scan child_multi
           │    │    └── columns: c:17!null child_multi.p:18 child_multi.q:19
           │    ├── select
           │    │    ├── columns: p:21 q:22 column2:23!null column3:24!null
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:21 q:22 column2:23!null column3:24!null
           │    │    │    └── mapping:
           │    │    │         ├──  parent_multi.p:9 => p:21
           │    │    │         ├──  parent_multi.q:10 => q:22
           │    │    │         ├──  column2:6 => column2:23
           │    │    │         └──  column3:7 => column3:24
           │    │    └── filters
           │    │         └── (p:21 IS DISTINCT FROM column2:23) OR (q:22 IS DISTINCT FROM column3:24)
           │    └── filters
           │         ├── child_multi.p:18 = p:21
           │         └── child_multi.q:19 = q:22
           └── f-k-checks
                └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
                     └── anti-join (hash)
                          ├── columns: p:25!null q:26!null
                          ├── with-scan &2
                          │    ├── columns: p:25!null q:26!null
                          │    └── mapping:
                          │         ├──  column2:23 => p:25
                          │         └──  column3:24 => q:26
                          ├── scan parent_multi
                          │    └── columns: parent_multi.p:28 parent_multi.q:29
                          └── filters
                               ├── p:25 = parent_multi.p:28
                               └── q:26 = parent_multi.q:29

# Upsert that only touches one of the FK columns.
build-cascades
UPSERT INTO parent_multi(pk, p) VALUES (1, 10), (2, 20)
----
root
 ├── upsert parent_multi
 │    ├── columns: <none>
 │    ├── arbiter indexes: primary
 │    ├── canary column: pk:8
 │    ├── fetch columns: pk:8 p:9 q:10
 │    ├── insert-mapping:
 │    │    ├── column1:5 => pk:1
 │    │    ├── column2:6 => p:2
 │    │    └── column7:7 => q:3
 │    ├── update-mapping:
 │    │    └── column2:6 => p:2
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: upsert_pk:12 upsert_q:13 column1:5!null column2:6!null column7:7 pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         ├── left-join (hash)
 │         │    ├── columns: column1:5!null column2:6!null column7:7 pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    ├── ensure-upsert-distinct-on
 │         │    │    ├── columns: column1:5!null column2:6!null column7:7
 │         │    │    ├── grouping columns: column1:5!null
 │         │    │    ├── project
 │         │    │    │    ├── columns: column7:7 column1:5!null column2:6!null
 │         │    │    │    ├── values
 │         │    │    │    │    ├── columns: column1:5!null column2:6!null
 │         │    │    │    │    ├── (1, 10)
 │         │    │    │    │    └── (2, 20)
 │         │    │    │    └── projections
 │         │    │    │         └── NULL::INT8 [as=column7:7]
 │         │    │    └── aggregations
 │         │    │         ├── first-agg [as=column2:6]
 │         │    │         │    └── column2:6
 │         │    │         └── first-agg [as=column7:7]
 │         │    │              └── column7:7
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:8!null p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    └── filters
 │         │         └── column1:5 = pk:8
 │         └── projections
 │              ├── CASE WHEN pk:8 IS NULL THEN column1:5 ELSE pk:8 END [as=upsert_pk:12]
 │              └── CASE WHEN pk:8 IS NULL THEN column7:7 ELSE q:10 END [as=upsert_q:13]
 └── cascade
      └── update child_multi
           ├── columns: <none>
           ├── fetch columns: c:18 child_multi.p:19 child_multi.q:20
           ├── update-mapping:
           │    ├── column2:24 => child_multi.p:15
           │    └── q:25 => child_multi.q:16
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:18!null child_multi.p:19!null child_multi.q:20!null p:22!null q:23!null column2:24!null q:25
           │    ├── scan child_multi
           │    │    └── columns: c:18!null child_multi.p:19 child_multi.q:20
           │    ├── select
           │    │    ├── columns: p:22 q:23 column2:24!null q:25
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:22 q:23 column2:24!null q:25
           │    │    │    └── mapping:
           │    │    │         ├──  parent_multi.p:9 => p:22
           │    │    │         ├──  parent_multi.q:10 => q:23
           │    │    │         ├──  column2:6 => column2:24
           │    │    │         └──  parent_multi.q:10 => q:25
           │    │    └── filters
           │    │         └── (p:22 IS DISTINCT FROM column2:24) OR (q:23 IS DISTINCT FROM q:25)
           │    └── filters
           │         ├── child_multi.p:19 = p:22
           │         └── child_multi.q:20 = q:23
           └── f-k-checks
                └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
                     └── anti-join (hash)
                          ├── columns: p:26!null q:27!null
                          ├── select
                          │    ├── columns: p:26!null q:27!null
                          │    ├── with-scan &2
                          │    │    ├── columns: p:26!null q:27
                          │    │    └── mapping:
                          │    │         ├──  column2:24 => p:26
                          │    │         └──  q:25 => q:27
                          │    └── filters
                          │         └── q:27 IS NOT NULL
                          ├── scan parent_multi
                          │    └── columns: parent_multi.p:29 parent_multi.q:30
                          └── filters
                               ├── p:26 = parent_multi.p:29
                               └── q:27 = parent_multi.q:30

build-cascades
INSERT INTO parent_multi VALUES (1, 10, 10), (2, 20, 20) ON CONFLICT (p,q) DO UPDATE SET p = 100
----
root
 ├── upsert parent_multi
 │    ├── columns: <none>
 │    ├── arbiter indexes: secondary
 │    ├── canary column: pk:8
 │    ├── fetch columns: pk:8 p:9 q:10
 │    ├── insert-mapping:
 │    │    ├── column1:5 => pk:1
 │    │    ├── column2:6 => p:2
 │    │    └── column3:7 => q:3
 │    ├── update-mapping:
 │    │    └── upsert_p:14 => p:2
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: upsert_pk:13 upsert_p:14!null upsert_q:15 column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11 p_new:12!null
 │         ├── project
 │         │    ├── columns: p_new:12!null column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    ├── left-join (hash)
 │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    │    ├── ensure-upsert-distinct-on
 │         │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    │    ├── grouping columns: column2:6!null column3:7!null
 │         │    │    │    ├── values
 │         │    │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    │    │    ├── (1, 10, 10)
 │         │    │    │    │    └── (2, 20, 20)
 │         │    │    │    └── aggregations
 │         │    │    │         └── first-agg [as=column1:5]
 │         │    │    │              └── column1:5
 │         │    │    ├── scan parent_multi
 │         │    │    │    └── columns: pk:8!null p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    │    └── filters
 │         │    │         ├── column2:6 = p:9
 │         │    │         └── column3:7 = q:10
 │         │    └── projections
 │         │         └── 100 [as=p_new:12]
 │         └── projections
 │              ├── CASE WHEN pk:8 IS NULL THEN column1:5 ELSE pk:8 END [as=upsert_pk:13]
 │              ├── CASE WHEN pk:8 IS NULL THEN column2:6 ELSE p_new:12 END [as=upsert_p:14]
 │              └── CASE WHEN pk:8 IS NULL THEN column3:7 ELSE q:10 END [as=upsert_q:15]
 └── cascade
      └── update child_multi
           ├── columns: <none>
           ├── fetch columns: c:20 child_multi.p:21 child_multi.q:22
           ├── update-mapping:
           │    ├── upsert_p:26 => child_multi.p:17
           │    └── q:27 => child_multi.q:18
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:20!null child_multi.p:21!null child_multi.q:22!null p:24!null q:25!null upsert_p:26!null q:27
           │    ├── scan child_multi
           │    │    └── columns: c:20!null child_multi.p:21 child_multi.q:22
           │    ├── select
           │    │    ├── columns: p:24 q:25 upsert_p:26!null q:27
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:24 q:25 upsert_p:26!null q:27
           │    │    │    └── mapping:
           │    │    │         ├──  parent_multi.p:9 => p:24
           │    │    │         ├──  parent_multi.q:10 => q:25
           │    │    │         ├──  upsert_p:14 => upsert_p:26
           │    │    │         └──  parent_multi.q:10 => q:27
           │    │    └── filters
           │    │         └── (p:24 IS DISTINCT FROM upsert_p:26) OR (q:25 IS DISTINCT FROM q:27)
           │    └── filters
           │         ├── child_multi.p:21 = p:24
           │         └── child_multi.q:22 = q:25
           └── f-k-checks
                └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
                     └── anti-join (hash)
                          ├── columns: p:28!null q:29!null
                          ├── select
                          │    ├── columns: p:28!null q:29!null
                          │    ├── with-scan &2
                          │    │    ├── columns: p:28!null q:29
                          │    │    └── mapping:
                          │    │         ├──  upsert_p:26 => p:28
                          │    │         └──  q:27 => q:29
                          │    └── filters
                          │         └── q:29 IS NOT NULL
                          ├── scan parent_multi
                          │    └── columns: parent_multi.p:31 parent_multi.q:32
                          └── filters
                               ├── p:28 = parent_multi.p:31
                               └── q:29 = parent_multi.q:32

# Test a two-level cascade.
exec-ddl
CREATE TABLE grandchild (
  g INT PRIMARY KEY,
  c INT, q INT,
  CONSTRAINT fk2 FOREIGN KEY (c, q) REFERENCES child_multi(c, q) ON UPDATE CASCADE
)
----

build-cascades
UPDATE parent_multi SET q = q * 10 WHERE p > 1
----
root
 ├── update parent_multi
 │    ├── columns: <none>
 │    ├── fetch columns: pk:5 p:6 q:7
 │    ├── update-mapping:
 │    │    └── q_new:9 => q:3
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: q_new:9 pk:5!null p:6!null q:7 crdb_internal_mvcc_timestamp:8
 │         ├── select
 │         │    ├── columns: pk:5!null p:6!null q:7 crdb_internal_mvcc_timestamp:8
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:5!null p:6 q:7 crdb_internal_mvcc_timestamp:8
 │         │    └── filters
 │         │         └── p:6 > 1
 │         └── projections
 │              └── q:7 * 10 [as=q_new:9]
 └── cascade
      ├── update child_multi
      │    ├── columns: <none>
      │    ├── fetch columns: c:14 child_multi.p:15 child_multi.q:16
      │    ├── update-mapping:
      │    │    ├── p:20 => child_multi.p:11
      │    │    └── q_new:21 => child_multi.q:12
      │    ├── input binding: &2
      │    ├── cascades
      │    │    └── fk2
      │    ├── inner-join (hash)
      │    │    ├── columns: c:14!null child_multi.p:15!null child_multi.q:16!null p:18!null q:19!null p:20!null q_new:21
      │    │    ├── scan child_multi
      │    │    │    └── columns: c:14!null child_multi.p:15 child_multi.q:16
      │    │    ├── select
      │    │    │    ├── columns: p:18!null q:19 p:20!null q_new:21
      │    │    │    ├── with-scan &1
      │    │    │    │    ├── columns: p:18!null q:19 p:20!null q_new:21
      │    │    │    │    └── mapping:
      │    │    │    │         ├──  parent_multi.p:6 => p:18
      │    │    │    │         ├──  parent_multi.q:7 => q:19
      │    │    │    │         ├──  parent_multi.p:6 => p:20
      │    │    │    │         └──  q_new:9 => q_new:21
      │    │    │    └── filters
      │    │    │         └── (p:18 IS DISTINCT FROM p:20) OR (q:19 IS DISTINCT FROM q_new:21)
      │    │    └── filters
      │    │         ├── child_multi.p:15 = p:18
      │    │         └── child_multi.q:16 = q:19
      │    └── f-k-checks
      │         └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
      │              └── anti-join (hash)
      │                   ├── columns: p:22!null q:23!null
      │                   ├── select
      │                   │    ├── columns: p:22!null q:23!null
      │                   │    ├── with-scan &2
      │                   │    │    ├── columns: p:22!null q:23
      │                   │    │    └── mapping:
      │                   │    │         ├──  p:20 => p:22
      │                   │    │         └──  q_new:21 => q:23
      │                   │    └── filters
      │                   │         └── q:23 IS NOT NULL
      │                   ├── scan parent_multi
      │                   │    └── columns: parent_multi.p:25 parent_multi.q:26
      │                   └── filters
      │                        ├── p:22 = parent_multi.p:25
      │                        └── q:23 = parent_multi.q:26
      └── cascade
           └── update grandchild
                ├── columns: <none>
                ├── fetch columns: g:32 grandchild.c:33 grandchild.q:34
                ├── update-mapping:
                │    ├── c:38 => grandchild.c:29
                │    └── q_new:39 => grandchild.q:30
                ├── input binding: &3
                ├── inner-join (hash)
                │    ├── columns: g:32!null grandchild.c:33!null grandchild.q:34!null c:36!null q:37!null c:38!null q_new:39
                │    ├── scan grandchild
                │    │    └── columns: g:32!null grandchild.c:33 grandchild.q:34
                │    ├── select
                │    │    ├── columns: c:36!null q:37!null c:38!null q_new:39
                │    │    ├── with-scan &2
                │    │    │    ├── columns: c:36!null q:37!null c:38!null q_new:39
                │    │    │    └── mapping:
                │    │    │         ├──  child_multi.c:14 => c:36
                │    │    │         ├──  child_multi.q:16 => q:37
                │    │    │         ├──  child_multi.c:14 => c:38
                │    │    │         └──  q_new:21 => q_new:39
                │    │    └── filters
                │    │         └── (c:36 IS DISTINCT FROM c:38) OR (q:37 IS DISTINCT FROM q_new:39)
                │    └── filters
                │         ├── grandchild.c:33 = c:36
                │         └── grandchild.q:34 = q:37
                └── f-k-checks
                     └── f-k-checks-item: grandchild(c,q) -> child_multi(c,q)
                          └── anti-join (hash)
                               ├── columns: c:40!null q:41!null
                               ├── select
                               │    ├── columns: c:40!null q:41!null
                               │    ├── with-scan &3
                               │    │    ├── columns: c:40!null q:41
                               │    │    └── mapping:
                               │    │         ├──  c:38 => c:40
                               │    │         └──  q_new:39 => q:41
                               │    └── filters
                               │         └── q:41 IS NOT NULL
                               ├── scan child_multi
                               │    └── columns: child_multi.c:42!null child_multi.q:44
                               └── filters
                                    ├── c:40 = child_multi.c:42
                                    └── q:41 = child_multi.q:44

build-cascades
UPSERT INTO parent_multi VALUES (1, 10, 10), (2, 20, 20)
----
root
 ├── upsert parent_multi
 │    ├── columns: <none>
 │    ├── arbiter indexes: primary
 │    ├── canary column: pk:8
 │    ├── fetch columns: pk:8 p:9 q:10
 │    ├── insert-mapping:
 │    │    ├── column1:5 => pk:1
 │    │    ├── column2:6 => p:2
 │    │    └── column3:7 => q:3
 │    ├── update-mapping:
 │    │    ├── column2:6 => p:2
 │    │    └── column3:7 => q:3
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: upsert_pk:12 column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         ├── left-join (hash)
 │         │    ├── columns: column1:5!null column2:6!null column3:7!null pk:8 p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    ├── ensure-upsert-distinct-on
 │         │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    ├── grouping columns: column1:5!null
 │         │    │    ├── values
 │         │    │    │    ├── columns: column1:5!null column2:6!null column3:7!null
 │         │    │    │    ├── (1, 10, 10)
 │         │    │    │    └── (2, 20, 20)
 │         │    │    └── aggregations
 │         │    │         ├── first-agg [as=column2:6]
 │         │    │         │    └── column2:6
 │         │    │         └── first-agg [as=column3:7]
 │         │    │              └── column3:7
 │         │    ├── scan parent_multi
 │         │    │    └── columns: pk:8!null p:9 q:10 crdb_internal_mvcc_timestamp:11
 │         │    └── filters
 │         │         └── column1:5 = pk:8
 │         └── projections
 │              └── CASE WHEN pk:8 IS NULL THEN column1:5 ELSE pk:8 END [as=upsert_pk:12]
 └── cascade
      ├── update child_multi
      │    ├── columns: <none>
      │    ├── fetch columns: c:17 child_multi.p:18 child_multi.q:19
      │    ├── update-mapping:
      │    │    ├── column2:23 => child_multi.p:14
      │    │    └── column3:24 => child_multi.q:15
      │    ├── input binding: &2
      │    ├── cascades
      │    │    └── fk2
      │    ├── inner-join (hash)
      │    │    ├── columns: c:17!null child_multi.p:18!null child_multi.q:19!null p:21!null q:22!null column2:23!null column3:24!null
      │    │    ├── scan child_multi
      │    │    │    └── columns: c:17!null child_multi.p:18 child_multi.q:19
      │    │    ├── select
      │    │    │    ├── columns: p:21 q:22 column2:23!null column3:24!null
      │    │    │    ├── with-scan &1
      │    │    │    │    ├── columns: p:21 q:22 column2:23!null column3:24!null
      │    │    │    │    └── mapping:
      │    │    │    │         ├──  parent_multi.p:9 => p:21
      │    │    │    │         ├──  parent_multi.q:10 => q:22
      │    │    │    │         ├──  column2:6 => column2:23
      │    │    │    │         └──  column3:7 => column3:24
      │    │    │    └── filters
      │    │    │         └── (p:21 IS DISTINCT FROM column2:23) OR (q:22 IS DISTINCT FROM column3:24)
      │    │    └── filters
      │    │         ├── child_multi.p:18 = p:21
      │    │         └── child_multi.q:19 = q:22
      │    └── f-k-checks
      │         └── f-k-checks-item: child_multi(p,q) -> parent_multi(p,q)
      │              └── anti-join (hash)
      │                   ├── columns: p:25!null q:26!null
      │                   ├── with-scan &2
      │                   │    ├── columns: p:25!null q:26!null
      │                   │    └── mapping:
      │                   │         ├──  column2:23 => p:25
      │                   │         └──  column3:24 => q:26
      │                   ├── scan parent_multi
      │                   │    └── columns: parent_multi.p:28 parent_multi.q:29
      │                   └── filters
      │                        ├── p:25 = parent_multi.p:28
      │                        └── q:26 = parent_multi.q:29
      └── cascade
           └── update grandchild
                ├── columns: <none>
                ├── fetch columns: g:35 grandchild.c:36 grandchild.q:37
                ├── update-mapping:
                │    ├── c:41 => grandchild.c:32
                │    └── column3:42 => grandchild.q:33
                ├── input binding: &3
                ├── inner-join (hash)
                │    ├── columns: g:35!null grandchild.c:36!null grandchild.q:37!null c:39!null q:40!null c:41!null column3:42!null
                │    ├── scan grandchild
                │    │    └── columns: g:35!null grandchild.c:36 grandchild.q:37
                │    ├── select
                │    │    ├── columns: c:39!null q:40!null c:41!null column3:42!null
                │    │    ├── with-scan &2
                │    │    │    ├── columns: c:39!null q:40!null c:41!null column3:42!null
                │    │    │    └── mapping:
                │    │    │         ├──  child_multi.c:17 => c:39
                │    │    │         ├──  child_multi.q:19 => q:40
                │    │    │         ├──  child_multi.c:17 => c:41
                │    │    │         └──  column3:24 => column3:42
                │    │    └── filters
                │    │         └── (c:39 IS DISTINCT FROM c:41) OR (q:40 IS DISTINCT FROM column3:42)
                │    └── filters
                │         ├── grandchild.c:36 = c:39
                │         └── grandchild.q:37 = q:40
                └── f-k-checks
                     └── f-k-checks-item: grandchild(c,q) -> child_multi(c,q)
                          └── anti-join (hash)
                               ├── columns: c:43!null q:44!null
                               ├── with-scan &3
                               │    ├── columns: c:43!null q:44!null
                               │    └── mapping:
                               │         ├──  c:41 => c:43
                               │         └──  column3:42 => q:44
                               ├── scan child_multi
                               │    └── columns: child_multi.c:45!null child_multi.q:47
                               └── filters
                                    ├── c:43 = child_multi.c:45
                                    └── q:44 = child_multi.q:47

# Test a cascade to a child with a partial index.
exec-ddl
CREATE TABLE parent_partial (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE child_partial (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_partial(p) ON UPDATE CASCADE,
  i INT,
  INDEX (p) WHERE i > 0,
  INDEX (i) WHERE p > 0
)
----

build-cascades
UPDATE parent_partial SET p = p * 10 WHERE p > 1
----
root
 ├── update parent_partial
 │    ├── columns: <none>
 │    ├── fetch columns: p:3
 │    ├── update-mapping:
 │    │    └── p_new:5 => p:1
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk_p_ref_parent_partial
 │    └── project
 │         ├── columns: p_new:5!null p:3!null crdb_internal_mvcc_timestamp:4
 │         ├── select
 │         │    ├── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    ├── scan parent_partial
 │         │    │    └── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    └── filters
 │         │         └── p:3 > 1
 │         └── projections
 │              └── p:3 * 10 [as=p_new:5]
 └── cascade
      └── update child_partial
           ├── columns: <none>
           ├── fetch columns: c:10 child_partial.p:11 i:12
           ├── update-mapping:
           │    └── p_new:15 => child_partial.p:7
           ├── partial index put columns: partial_index_put1:16 partial_index_put2:17
           ├── partial index del columns: partial_index_put1:16 partial_index_del2:18
           ├── input binding: &2
           ├── project
           │    ├── columns: partial_index_put1:16 partial_index_put2:17!null partial_index_del2:18!null c:10!null child_partial.p:11!null i:12 p:14!null p_new:15!null
           │    ├── inner-join (hash)
           │    │    ├── columns: c:10!null child_partial.p:11!null i:12 p:14!null p_new:15!null
           │    │    ├── scan child_partial
           │    │    │    ├── columns: c:10!null child_partial.p:11 i:12
           │    │    │    └── partial index predicates
           │    │    │         ├── secondary: filters
           │    │    │         │    └── i:12 > 0
           │    │    │         └── secondary: filters
           │    │    │              └── child_partial.p:11 > 0
           │    │    ├── select
           │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    ├── with-scan &1
           │    │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    │    └── mapping:
           │    │    │    │         ├──  parent_partial.p:3 => p:14
           │    │    │    │         └──  p_new:5 => p_new:15
           │    │    │    └── filters
           │    │    │         └── p:14 IS DISTINCT FROM p_new:15
           │    │    └── filters
           │    │         └── child_partial.p:11 = p:14
           │    └── projections
           │         ├── i:12 > 0 [as=partial_index_put1:16]
           │         ├── p_new:15 > 0 [as=partial_index_put2:17]
           │         └── child_partial.p:11 > 0 [as=partial_index_del2:18]
           └── f-k-checks
                └── f-k-checks-item: child_partial(p) -> parent_partial(p)
                     └── anti-join (hash)
                          ├── columns: p:19!null
                          ├── with-scan &2
                          │    ├── columns: p:19!null
                          │    └── mapping:
                          │         └──  p_new:15 => p:19
                          ├── scan parent_partial
                          │    └── columns: parent_partial.p:20!null
                          └── filters
                               └── p:19 = parent_partial.p:20

# Test a cascade to a child with a partial index with an ambiguous name.
exec-ddl
CREATE TABLE parent_partial_ambig (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE child_partial_ambig (
  c INT PRIMARY KEY,
  p_new INT REFERENCES parent_partial_ambig(p) ON UPDATE CASCADE,
  i INT,
  INDEX (i) WHERE p_new > 0
)
----

build-cascades
UPDATE parent_partial_ambig SET p = p * 10 WHERE p > 1
----
root
 ├── update parent_partial_ambig
 │    ├── columns: <none>
 │    ├── fetch columns: p:3
 │    ├── update-mapping:
 │    │    └── p_new:5 => p:1
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk_p_new_ref_parent_partial_ambig
 │    └── project
 │         ├── columns: p_new:5!null p:3!null crdb_internal_mvcc_timestamp:4
 │         ├── select
 │         │    ├── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    ├── scan parent_partial_ambig
 │         │    │    └── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    └── filters
 │         │         └── p:3 > 1
 │         └── projections
 │              └── p:3 * 10 [as=p_new:5]
 └── cascade
      └── update child_partial_ambig
           ├── columns: <none>
           ├── fetch columns: c:10 child_partial_ambig.p_new:11 i:12
           ├── update-mapping:
           │    └── p_new:15 => child_partial_ambig.p_new:7
           ├── partial index put columns: partial_index_put1:16
           ├── partial index del columns: partial_index_del1:17
           ├── input binding: &2
           ├── project
           │    ├── columns: partial_index_put1:16!null partial_index_del1:17!null c:10!null child_partial_ambig.p_new:11!null i:12 p:14!null p_new:15!null
           │    ├── inner-join (hash)
           │    │    ├── columns: c:10!null child_partial_ambig.p_new:11!null i:12 p:14!null p_new:15!null
           │    │    ├── scan child_partial_ambig
           │    │    │    ├── columns: c:10!null child_partial_ambig.p_new:11 i:12
           │    │    │    └── partial index predicates
           │    │    │         └── secondary: filters
           │    │    │              └── child_partial_ambig.p_new:11 > 0
           │    │    ├── select
           │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    ├── with-scan &1
           │    │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    │    └── mapping:
           │    │    │    │         ├──  parent_partial_ambig.p:3 => p:14
           │    │    │    │         └──  p_new:5 => p_new:15
           │    │    │    └── filters
           │    │    │         └── p:14 IS DISTINCT FROM p_new:15
           │    │    └── filters
           │    │         └── child_partial_ambig.p_new:11 = p:14
           │    └── projections
           │         ├── p_new:15 > 0 [as=partial_index_put1:16]
           │         └── child_partial_ambig.p_new:11 > 0 [as=partial_index_del1:17]
           └── f-k-checks
                └── f-k-checks-item: child_partial_ambig(p_new) -> parent_partial_ambig(p)
                     └── anti-join (hash)
                          ├── columns: p_new:18!null
                          ├── with-scan &2
                          │    ├── columns: p_new:18!null
                          │    └── mapping:
                          │         └──  p_new:15 => p_new:18
                          ├── scan parent_partial_ambig
                          │    └── columns: parent_partial_ambig.p:19!null
                          └── filters
                               └── p_new:18 = parent_partial_ambig.p:19

# Test an UPSERT that cascades to a child with a partial index.
exec-ddl
CREATE TABLE parent_multi_partial (
  pk INT PRIMARY KEY,
  p INT, q INT,
  UNIQUE (p, q),
  FAMILY (pk),
  FAMILY (p),
  FAMILY (q)
)
----

exec-ddl
CREATE TABLE child_multi_partial (
  c INT PRIMARY KEY,
  p INT, q INT,
  i INT,
  UNIQUE (c, q),
  INDEX (p, q) WHERE i > 0,
  INDEX (i) WHERE p > 0 AND q > 0,
  CONSTRAINT fk FOREIGN KEY (p, q) REFERENCES parent_multi_partial(p, q) ON UPDATE CASCADE
)
----

build-cascades
UPSERT INTO parent_multi_partial VALUES (1), (2)
----
root
 ├── upsert parent_multi_partial
 │    ├── columns: <none>
 │    ├── arbiter indexes: primary
 │    ├── canary column: pk:7
 │    ├── fetch columns: pk:7 p:8 q:9
 │    ├── insert-mapping:
 │    │    ├── column1:5 => pk:1
 │    │    ├── column6:6 => p:2
 │    │    └── column6:6 => q:3
 │    ├── update-mapping:
 │    │    ├── column6:6 => p:2
 │    │    └── column6:6 => q:3
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk
 │    └── project
 │         ├── columns: upsert_pk:11 column1:5!null column6:6 pk:7 p:8 q:9 crdb_internal_mvcc_timestamp:10
 │         ├── left-join (hash)
 │         │    ├── columns: column1:5!null column6:6 pk:7 p:8 q:9 crdb_internal_mvcc_timestamp:10
 │         │    ├── ensure-upsert-distinct-on
 │         │    │    ├── columns: column1:5!null column6:6
 │         │    │    ├── grouping columns: column1:5!null
 │         │    │    ├── project
 │         │    │    │    ├── columns: column6:6 column1:5!null
 │         │    │    │    ├── values
 │         │    │    │    │    ├── columns: column1:5!null
 │         │    │    │    │    ├── (1,)
 │         │    │    │    │    └── (2,)
 │         │    │    │    └── projections
 │         │    │    │         └── NULL::INT8 [as=column6:6]
 │         │    │    └── aggregations
 │         │    │         └── first-agg [as=column6:6]
 │         │    │              └── column6:6
 │         │    ├── scan parent_multi_partial
 │         │    │    └── columns: pk:7!null p:8 q:9 crdb_internal_mvcc_timestamp:10
 │         │    └── filters
 │         │         └── column1:5 = pk:7
 │         └── projections
 │              └── CASE WHEN pk:7 IS NULL THEN column1:5 ELSE pk:7 END [as=upsert_pk:11]
 └── cascade
      └── update child_multi_partial
           ├── columns: <none>
           ├── fetch columns: c:17 child_multi_partial.p:18 child_multi_partial.q:19 i:20
           ├── update-mapping:
           │    ├── column6:24 => child_multi_partial.p:13
           │    └── column6:25 => child_multi_partial.q:14
           ├── partial index put columns: partial_index_put1:26 partial_index_put2:27
           ├── partial index del columns: partial_index_put1:26 partial_index_del2:28
           ├── input binding: &2
           ├── project
           │    ├── columns: partial_index_put1:26 partial_index_put2:27 partial_index_del2:28!null c:17!null child_multi_partial.p:18!null child_multi_partial.q:19!null i:20 p:22!null q:23!null column6:24 column6:25
           │    ├── inner-join (hash)
           │    │    ├── columns: c:17!null child_multi_partial.p:18!null child_multi_partial.q:19!null i:20 p:22!null q:23!null column6:24 column6:25
           │    │    ├── scan child_multi_partial
           │    │    │    ├── columns: c:17!null child_multi_partial.p:18 child_multi_partial.q:19 i:20
           │    │    │    └── partial index predicates
           │    │    │         ├── secondary: filters
           │    │    │         │    └── i:20 > 0
           │    │    │         └── secondary: filters
           │    │    │              └── (child_multi_partial.p:18 > 0) AND (child_multi_partial.q:19 > 0)
           │    │    ├── select
           │    │    │    ├── columns: p:22 q:23 column6:24 column6:25
           │    │    │    ├── with-scan &1
           │    │    │    │    ├── columns: p:22 q:23 column6:24 column6:25
           │    │    │    │    └── mapping:
           │    │    │    │         ├──  parent_multi_partial.p:8 => p:22
           │    │    │    │         ├──  parent_multi_partial.q:9 => q:23
           │    │    │    │         ├──  column6:6 => column6:24
           │    │    │    │         └──  column6:6 => column6:25
           │    │    │    └── filters
           │    │    │         └── (p:22 IS DISTINCT FROM column6:24) OR (q:23 IS DISTINCT FROM column6:25)
           │    │    └── filters
           │    │         ├── child_multi_partial.p:18 = p:22
           │    │         └── child_multi_partial.q:19 = q:23
           │    └── projections
           │         ├── i:20 > 0 [as=partial_index_put1:26]
           │         ├── (column6:24 > 0) AND (column6:25 > 0) [as=partial_index_put2:27]
           │         └── (child_multi_partial.p:18 > 0) AND (child_multi_partial.q:19 > 0) [as=partial_index_del2:28]
           └── f-k-checks
                └── f-k-checks-item: child_multi_partial(p,q) -> parent_multi_partial(p,q)
                     └── anti-join (hash)
                          ├── columns: p:29!null q:30!null
                          ├── select
                          │    ├── columns: p:29!null q:30!null
                          │    ├── with-scan &2
                          │    │    ├── columns: p:29 q:30
                          │    │    └── mapping:
                          │    │         ├──  column6:24 => p:29
                          │    │         └──  column6:25 => q:30
                          │    └── filters
                          │         ├── p:29 IS NOT NULL
                          │         └── q:30 IS NOT NULL
                          ├── scan parent_multi_partial
                          │    └── columns: parent_multi_partial.p:32 parent_multi_partial.q:33
                          └── filters
                               ├── p:29 = parent_multi_partial.p:32
                               └── q:30 = parent_multi_partial.q:33

# Regression test for #57148. A check constraint or computed column in a child
# table that references a column with the same name as the parent's synthesized
# update column should not result in an ambiguous column reference error. In
# this test the synthesized update column for the parent is "p" + "_new" =
# "p_new", which is the name of the FK column in the child.
exec-ddl
CREATE TABLE parent_check_ambig (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE child_check_ambig (
  c INT PRIMARY KEY,
  p_new INT REFERENCES parent_check_ambig(p) ON UPDATE CASCADE,
  i INT AS (p_new * 2) STORED,
  CHECK (p_new > 0)
)
----

build-cascades
UPDATE parent_check_ambig SET p = p * 10 WHERE p > 1
----
root
 ├── update parent_check_ambig
 │    ├── columns: <none>
 │    ├── fetch columns: p:3
 │    ├── update-mapping:
 │    │    └── p_new:5 => p:1
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk_p_new_ref_parent_check_ambig
 │    └── project
 │         ├── columns: p_new:5!null p:3!null crdb_internal_mvcc_timestamp:4
 │         ├── select
 │         │    ├── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    ├── scan parent_check_ambig
 │         │    │    └── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    └── filters
 │         │         └── p:3 > 1
 │         └── projections
 │              └── p:3 * 10 [as=p_new:5]
 └── cascade
      └── update child_check_ambig
           ├── columns: <none>
           ├── fetch columns: c:10 child_check_ambig.p_new:11 i:12
           ├── update-mapping:
           │    ├── p_new:15 => child_check_ambig.p_new:7
           │    └── column16:16 => i:8
           ├── check columns: check1:17
           ├── input binding: &2
           ├── project
           │    ├── columns: check1:17!null c:10!null child_check_ambig.p_new:11!null i:12 p:14!null p_new:15!null column16:16!null
           │    ├── project
           │    │    ├── columns: column16:16!null c:10!null child_check_ambig.p_new:11!null i:12 p:14!null p_new:15!null
           │    │    ├── inner-join (hash)
           │    │    │    ├── columns: c:10!null child_check_ambig.p_new:11!null i:12 p:14!null p_new:15!null
           │    │    │    ├── scan child_check_ambig
           │    │    │    │    ├── columns: c:10!null child_check_ambig.p_new:11 i:12
           │    │    │    │    └── computed column expressions
           │    │    │    │         └── i:12
           │    │    │    │              └── child_check_ambig.p_new:11 * 2
           │    │    │    ├── select
           │    │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    │    ├── with-scan &1
           │    │    │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    │    │    └── mapping:
           │    │    │    │    │         ├──  parent_check_ambig.p:3 => p:14
           │    │    │    │    │         └──  p_new:5 => p_new:15
           │    │    │    │    └── filters
           │    │    │    │         └── p:14 IS DISTINCT FROM p_new:15
           │    │    │    └── filters
           │    │    │         └── child_check_ambig.p_new:11 = p:14
           │    │    └── projections
           │    │         └── p_new:15 * 2 [as=column16:16]
           │    └── projections
           │         └── p_new:15 > 0 [as=check1:17]
           └── f-k-checks
                └── f-k-checks-item: child_check_ambig(p_new) -> parent_check_ambig(p)
                     └── anti-join (hash)
                          ├── columns: p_new:18!null
                          ├── with-scan &2
                          │    ├── columns: p_new:18!null
                          │    └── mapping:
                          │         └──  p_new:15 => p_new:18
                          ├── scan parent_check_ambig
                          │    └── columns: parent_check_ambig.p:19!null
                          └── filters
                               └── p_new:18 = parent_check_ambig.p:19

# Test cascade to a child with a virtual column that references the FK.
exec-ddl
CREATE TABLE parent_virt (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE child_virt (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_virt(p) ON UPDATE CASCADE,
  v INT AS (p) VIRTUAL
)
----

build-cascades
UPDATE parent_virt SET p = p * 10 WHERE p > 1
----
root
 ├── update parent_virt
 │    ├── columns: <none>
 │    ├── fetch columns: p:3
 │    ├── update-mapping:
 │    │    └── p_new:5 => p:1
 │    ├── input binding: &1
 │    ├── cascades
 │    │    └── fk_p_ref_parent_virt
 │    └── project
 │         ├── columns: p_new:5!null p:3!null crdb_internal_mvcc_timestamp:4
 │         ├── select
 │         │    ├── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    ├── scan parent_virt
 │         │    │    └── columns: p:3!null crdb_internal_mvcc_timestamp:4
 │         │    └── filters
 │         │         └── p:3 > 1
 │         └── projections
 │              └── p:3 * 10 [as=p_new:5]
 └── cascade
      └── update child_virt
           ├── columns: <none>
           ├── fetch columns: c:10 child_virt.p:11 v:12
           ├── update-mapping:
           │    ├── p_new:15 => child_virt.p:7
           │    └── p_new:15 => v:8
           ├── input binding: &2
           ├── inner-join (hash)
           │    ├── columns: c:10!null child_virt.p:11!null v:12 p:14!null p_new:15!null
           │    ├── project
           │    │    ├── columns: v:12 c:10!null child_virt.p:11
           │    │    ├── scan child_virt
           │    │    │    ├── columns: c:10!null child_virt.p:11
           │    │    │    └── computed column expressions
           │    │    │         └── v:12
           │    │    │              └── child_virt.p:11
           │    │    └── projections
           │    │         └── child_virt.p:11 [as=v:12]
           │    ├── select
           │    │    ├── columns: p:14!null p_new:15!null
           │    │    ├── with-scan &1
           │    │    │    ├── columns: p:14!null p_new:15!null
           │    │    │    └── mapping:
           │    │    │         ├──  parent_virt.p:3 => p:14
           │    │    │         └──  p_new:5 => p_new:15
           │    │    └── filters
           │    │         └── p:14 IS DISTINCT FROM p_new:15
           │    └── filters
           │         └── child_virt.p:11 = p:14
           └── f-k-checks
                └── f-k-checks-item: child_virt(p) -> parent_virt(p)
                     └── anti-join (hash)
                          ├── columns: p:16!null
                          ├── with-scan &2
                          │    ├── columns: p:16!null
                          │    └── mapping:
                          │         └──  p_new:15 => p:16
                          ├── scan parent_virt
                          │    └── columns: parent_virt.p:17!null
                          └── filters
                               └── p:16 = parent_virt.p:17
