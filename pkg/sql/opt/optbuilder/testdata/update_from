exec-ddl
CREATE TABLE abc (a int primary key, b int, c int)
----

exec-ddl
CREATE TABLE new_abc (a int, b int, c int)
----

# Test a self join.
opt
UPDATE abc SET b = other.b + 1, c = other.c + 1 FROM abc AS other WHERE abc.a = other.a
----
update abc
 ├── columns: <none>
 ├── fetch columns: abc.a:4(int) abc.b:5(int) abc.c:6(int)
 ├── update-mapping:
 │    ├──  column10:10 => abc.b:2
 │    └──  column11:11 => abc.c:3
 └── project
      ├── columns: column10:10(int) column11:11(int) abc.a:4(int!null) abc.b:5(int) abc.c:6(int) other.a:7(int!null) other.b:8(int) other.c:9(int)
      ├── inner-join (merge)
      │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) other.a:7(int!null) other.b:8(int) other.c:9(int)
      │    ├── left ordering: +4
      │    ├── right ordering: +7
      │    ├── scan abc
      │    │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int)
      │    │    └── ordering: +4
      │    ├── scan other
      │    │    ├── columns: other.a:7(int!null) other.b:8(int) other.c:9(int)
      │    │    └── ordering: +7
      │    └── filters (true)
      └── projections
           ├── plus [type=int]
           │    ├── variable: other.b [type=int]
           │    └── const: 1 [type=int]
           └── plus [type=int]
                ├── variable: other.c [type=int]
                └── const: 1 [type=int]

# Test when Update uses multiple tables.
opt
UPDATE abc SET b = other.b, c = other.c FROM new_abc AS other WHERE abc.a = other.a
----
update abc
 ├── columns: <none>
 ├── fetch columns: abc.a:4(int) abc.b:5(int) abc.c:6(int)
 ├── update-mapping:
 │    ├──  other.b:8 => abc.b:2
 │    └──  other.c:9 => abc.c:3
 └── distinct-on
      ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) other.a:7(int) other.b:8(int) other.c:9(int)
      ├── grouping columns: abc.a:4(int!null)
      ├── inner-join (hash)
      │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) other.a:7(int!null) other.b:8(int) other.c:9(int)
      │    ├── scan abc
      │    │    └── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int)
      │    ├── scan other
      │    │    └── columns: other.a:7(int) other.b:8(int) other.c:9(int)
      │    └── filters
      │         └── eq [type=bool]
      │              ├── variable: abc.a [type=int]
      │              └── variable: other.a [type=int]
      └── aggregations
           ├── first-agg [type=int]
           │    └── variable: abc.b [type=int]
           ├── first-agg [type=int]
           │    └── variable: abc.c [type=int]
           ├── first-agg [type=int]
           │    └── variable: other.a [type=int]
           ├── first-agg [type=int]
           │    └── variable: other.b [type=int]
           └── first-agg [type=int]
                └── variable: other.c [type=int]

# Check if UPDATE FROM works well with RETURNING expressions that reference the FROM tables.
opt
UPDATE abc SET b = old.b + 1, c = old.c + 2 FROM abc AS old WHERE abc.a = old.a RETURNING abc.a, abc.b AS new_b, old.b as old_b, abc.c as new_c, old.c as old_c
----
project
 ├── columns: a:1(int!null) new_b:2(int) old_b:8(int) new_c:3(int) old_c:9(int)
 └── update abc
      ├── columns: abc.a:1(int!null) abc.b:2(int) abc.c:3(int) old.a:7(int) old.b:8(int) old.c:9(int)
      ├── fetch columns: abc.a:4(int) abc.b:5(int) abc.c:6(int)
      ├── update-mapping:
      │    ├──  column10:10 => abc.b:2
      │    └──  column11:11 => abc.c:3
      └── project
           ├── columns: column10:10(int) column11:11(int) abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
           ├── inner-join (merge)
           │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
           │    ├── left ordering: +4
           │    ├── right ordering: +7
           │    ├── scan abc
           │    │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int)
           │    │    └── ordering: +4
           │    ├── scan old
           │    │    ├── columns: old.a:7(int!null) old.b:8(int) old.c:9(int)
           │    │    └── ordering: +7
           │    └── filters (true)
           └── projections
                ├── plus [type=int]
                │    ├── variable: old.b [type=int]
                │    └── const: 1 [type=int]
                └── plus [type=int]
                     ├── variable: old.c [type=int]
                     └── const: 2 [type=int]

# Check if RETURNING * returns everything
opt
UPDATE abc SET b = old.b + 1, c = old.c + 2 FROM abc AS old WHERE abc.a = old.a RETURNING *
----
update abc
 ├── columns: a:1(int!null) b:2(int) c:3(int) a:7(int) b:8(int) c:9(int)
 ├── fetch columns: abc.a:4(int) abc.b:5(int) abc.c:6(int)
 ├── update-mapping:
 │    ├──  column10:10 => abc.b:2
 │    └──  column11:11 => abc.c:3
 └── project
      ├── columns: column10:10(int) column11:11(int) abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
      ├── inner-join (merge)
      │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
      │    ├── left ordering: +4
      │    ├── right ordering: +7
      │    ├── scan abc
      │    │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int)
      │    │    └── ordering: +4
      │    ├── scan old
      │    │    ├── columns: old.a:7(int!null) old.b:8(int) old.c:9(int)
      │    │    └── ordering: +7
      │    └── filters (true)
      └── projections
           ├── plus [type=int]
           │    ├── variable: old.b [type=int]
           │    └── const: 1 [type=int]
           └── plus [type=int]
                ├── variable: old.c [type=int]
                └── const: 2 [type=int]

# Check if the joins are optimized (check if the filters are pushed down).
opt
UPDATE abc SET b = old.b + 1, c = old.c + 2 FROM abc AS old WHERE abc.a = old.a AND abc.a = 2
----
update abc
 ├── columns: <none>
 ├── fetch columns: abc.a:4(int) abc.b:5(int) abc.c:6(int)
 ├── update-mapping:
 │    ├──  column10:10 => abc.b:2
 │    └──  column11:11 => abc.c:3
 └── project
      ├── columns: column10:10(int) column11:11(int) abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
      ├── inner-join (merge)
      │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int) old.a:7(int!null) old.b:8(int) old.c:9(int)
      │    ├── left ordering: +4
      │    ├── right ordering: +7
      │    ├── scan abc
      │    │    ├── columns: abc.a:4(int!null) abc.b:5(int) abc.c:6(int)
      │    │    └── constraint: /4: [/2 - /2]
      │    ├── scan old
      │    │    ├── columns: old.a:7(int!null) old.b:8(int) old.c:9(int)
      │    │    └── constraint: /7: [/2 - /2]
      │    └── filters (true)
      └── projections
           ├── plus [type=int]
           │    ├── variable: old.b [type=int]
           │    └── const: 1 [type=int]
           └── plus [type=int]
                ├── variable: old.c [type=int]
                └── const: 2 [type=int]
