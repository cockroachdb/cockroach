# tests adapted from logictest -- aggregate

exec-ddl
CREATE TABLE kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----
TABLE kv
 ├── k int not null
 ├── v int
 ├── w int
 ├── s string
 └── INDEX primary
      └── k int not null

build
SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1),
  VARIANCE(1), BOOL_AND(true), BOOL_OR(false), XOR_AGG(b'\x01') FROM kv
----
group-by
 ├── columns: column6:6(int) column7:7(int) column8:8(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column17:17(bool) column19:19(bytes)
 ├── project
 │    ├── columns: column5:5(int!null) column14:14(bool!null) column16:16(bool!null) column18:18(bytes!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── const: 1 [type=int]
 │         ├── true [type=bool]
 │         ├── false [type=bool]
 │         └── const: '\x01' [type=bytes]
 └── aggregations
      ├── min [type=int]
      │    └── variable: column5 [type=int]
      ├── max [type=int]
      │    └── variable: column5 [type=int]
      ├── count [type=int]
      │    └── variable: column5 [type=int]
      ├── sum-int [type=int]
      │    └── variable: column5 [type=int]
      ├── avg [type=decimal]
      │    └── variable: column5 [type=int]
      ├── sum [type=decimal]
      │    └── variable: column5 [type=int]
      ├── std-dev [type=decimal]
      │    └── variable: column5 [type=int]
      ├── variance [type=decimal]
      │    └── variable: column5 [type=int]
      ├── bool-and [type=bool]
      │    └── variable: column14 [type=bool]
      ├── bool-or [type=bool]
      │    └── variable: column16 [type=bool]
      └── xor-agg [type=bytes]
           └── variable: column18 [type=bytes]

build
SELECT MIN(v), MAX(v), COUNT(v), SUM_INT(1), AVG(v), SUM(v), STDDEV(v),
  VARIANCE(v), BOOL_AND(v = 1), BOOL_AND(v = 1), XOR_AGG(s::bytes) FROM kv
----
project
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column15:15(bool) column17:17(bytes)
 └── group-by
      ├── columns: column5:5(int) column6:6(int) column7:7(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column17:17(bytes)
      ├── project
      │    ├── columns: column8:8(int!null) column14:14(bool) column16:16(bytes) kv.v:2(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── const: 1 [type=int]
      │         ├── eq [type=bool]
      │         │    ├── variable: kv.v [type=int]
      │         │    └── const: 1 [type=int]
      │         └── cast: bytes [type=bytes]
      │              └── variable: kv.s [type=string]
      └── aggregations
           ├── min [type=int]
           │    └── variable: kv.v [type=int]
           ├── max [type=int]
           │    └── variable: kv.v [type=int]
           ├── count [type=int]
           │    └── variable: kv.v [type=int]
           ├── sum-int [type=int]
           │    └── variable: column8 [type=int]
           ├── avg [type=decimal]
           │    └── variable: kv.v [type=int]
           ├── sum [type=decimal]
           │    └── variable: kv.v [type=int]
           ├── std-dev [type=decimal]
           │    └── variable: kv.v [type=int]
           ├── variance [type=decimal]
           │    └── variable: kv.v [type=int]
           ├── bool-and [type=bool]
           │    └── variable: column14 [type=bool]
           └── xor-agg [type=bytes]
                └── variable: column16 [type=bytes]

build
SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1),
  VARIANCE(1)::float, BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
project
 ├── columns: column2:2(int) column3:3(int) column4:4(int) column5:5(int) column7:7(float) column8:8(decimal) column9:9(decimal) column11:11(float) column13:13(bool) column14:14(bool) column17:17(string)
 ├── group-by
 │    ├── columns: column2:2(int) column3:3(int) column4:4(int) column5:5(int) column6:6(decimal) column8:8(decimal) column9:9(decimal) column10:10(decimal) column13:13(bool) column14:14(bool) column16:16(bytes)
 │    ├── project
 │    │    ├── columns: column1:1(int!null) column12:12(bool!null) column15:15(bytes!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple{}]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         ├── true [type=bool]
 │    │         └── const: '\x01' [type=bytes]
 │    └── aggregations
 │         ├── min [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── count [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── max [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── sum-int [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── sum [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── std-dev [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── variance [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── bool-and [type=bool]
 │         │    └── variable: column12 [type=bool]
 │         ├── bool-or [type=bool]
 │         │    └── variable: column12 [type=bool]
 │         └── xor-agg [type=bytes]
 │              └── variable: column15 [type=bytes]
 └── projections
      ├── cast: float [type=float]
      │    └── variable: column6 [type=decimal]
      ├── cast: float [type=float]
      │    └── variable: column10 [type=decimal]
      └── function: to_hex [type=string]
           └── variable: column16 [type=bytes]

build
SELECT ARRAY_AGG(1) FROM kv
----
group-by
 ├── columns: column6:6(int[])
 ├── project
 │    ├── columns: column5:5(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: column5 [type=int]

build
SELECT JSON_AGG(v) FROM kv
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.v:2(int)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      └── json-agg [type=jsonb]
           └── variable: kv.v [type=int]

build
SELECT JSONB_AGG(1)
----
group-by
 ├── columns: column2:2(jsonb)
 ├── project
 │    ├── columns: column1:1(int!null)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── jsonb-agg [type=jsonb]
           └── variable: column1 [type=int]

# Even with no aggregate functions, grouping occurs in the presence of GROUP BY.
build
SELECT 1 FROM kv GROUP BY v
----
project
 ├── columns: column5:5(int!null)
 ├── group-by
 │    ├── columns: kv.v:2(int)
 │    ├── grouping columns: kv.v:2(int)
 │    └── project
 │         ├── columns: kv.v:2(int)
 │         └── scan kv
 │              └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── projections
      └── const: 1 [type=int]

# This should ideally return {NULL}, but this is a pathological case, and
# Postgres has the same behavior, so it's sufficient for now.
build
SELECT ARRAY_AGG(NULL)
----
error: ambiguous call: array_agg(unknown), candidates are:
array_agg(int) -> int[]
array_agg(float) -> float[]
array_agg(decimal) -> decimal[]
array_agg(string) -> string[]
array_agg(bytes) -> bytes[]
array_agg(date) -> date[]
array_agg(time) -> time[]
array_agg(timetz) -> timetz[]
array_agg(timestamp) -> timestamp[]
array_agg(timestamptz) -> timestamptz[]
array_agg(interval) -> interval[]
array_agg(uuid) -> uuid[]
array_agg(inet) -> inet[]
array_agg(oid) -> oid[]
array_agg(bool) -> bool[]

# With an explicit cast, this works as expected.
build
SELECT ARRAY_AGG(NULL::TEXT)
----
group-by
 ├── columns: column2:2(string[])
 ├── project
 │    ├── columns: column1:1(string)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── cast: string [type=string]
 │              └── null [type=unknown]
 └── aggregations
      └── array-agg [type=string[]]
           └── variable: column1 [type=string]

build
SELECT (SELECT COALESCE(MAX(1), 0) FROM kv)
----
project
 ├── columns: column8:8(int)
 ├── values
 │    └── tuple [type=tuple{}]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: column7:7(int)
                └── project
                     ├── columns: column7:7(int)
                     ├── group-by
                     │    ├── columns: column6:6(int)
                     │    ├── project
                     │    │    ├── columns: column5:5(int!null)
                     │    │    ├── scan kv
                     │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
                     │    │    └── projections
                     │    │         └── const: 1 [type=int]
                     │    └── aggregations
                     │         └── max [type=int]
                     │              └── variable: column5 [type=int]
                     └── projections
                          └── coalesce [type=int]
                               ├── variable: column6 [type=int]
                               └── const: 0 [type=int]

build
SELECT COUNT(*), k FROM kv
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*) FROM kv GROUP BY s < 5
----
error: unsupported comparison operator: <string> < <int>

build
SELECT COUNT(*), k FROM kv GROUP BY k
----
project
 ├── columns: column5:5(int) k:1(int!null)
 └── group-by
      ├── columns: kv.k:1(int!null) column5:5(int)
      ├── grouping columns: kv.k:1(int!null)
      ├── project
      │    ├── columns: kv.k:1(int!null)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

# GROUP BY specified using column index works.
build
SELECT COUNT(*), k FROM kv GROUP BY 2
----
project
 ├── columns: column5:5(int) k:1(int!null)
 └── group-by
      ├── columns: kv.k:1(int!null) column5:5(int)
      ├── grouping columns: kv.k:1(int!null)
      ├── project
      │    ├── columns: kv.k:1(int!null)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT * FROM kv GROUP BY v, COUNT(w)
----
error: aggregate functions are not allowed in GROUP BY

build
SELECT COUNT(w) FROM kv GROUP BY 1
----
error: aggregate functions are not allowed in GROUP BY

build
SELECT SUM(v) FROM kv GROUP BY k LIMIT SUM(v)
----
error: aggregate functions are not allowed in LIMIT

build
SELECT SUM(v) FROM kv GROUP BY k LIMIT 1 OFFSET SUM(v)
----
error: aggregate functions are not allowed in OFFSET

build
VALUES (99, COUNT(1))
----
error: aggregate functions are not allowed in VALUES

build
SELECT COUNT(*), k FROM kv GROUP BY 5
----
error: GROUP BY position 5 is not in select list

build
SELECT COUNT(*), k FROM kv GROUP BY 0
----
error: GROUP BY position 0 is not in select list

build
SELECT 1 GROUP BY 'a'
----
error: non-integer constant in GROUP BY: 'a'

# Qualifying a name in the SELECT, the GROUP BY, both or neither should not affect validation.
build
SELECT COUNT(*), kv.s FROM kv GROUP BY s
----
project
 ├── columns: column5:5(int) s:4(string)
 └── group-by
      ├── columns: kv.s:4(string) column5:5(int)
      ├── grouping columns: kv.s:4(string)
      ├── project
      │    ├── columns: kv.s:4(string)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT COUNT(*), s FROM kv GROUP BY kv.s
----
project
 ├── columns: column5:5(int) s:4(string)
 └── group-by
      ├── columns: kv.s:4(string) column5:5(int)
      ├── grouping columns: kv.s:4(string)
      ├── project
      │    ├── columns: kv.s:4(string)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT COUNT(*), kv.s FROM kv GROUP BY kv.s
----
project
 ├── columns: column5:5(int) s:4(string)
 └── group-by
      ├── columns: kv.s:4(string) column5:5(int)
      ├── grouping columns: kv.s:4(string)
      ├── project
      │    ├── columns: kv.s:4(string)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT COUNT(*), s FROM kv GROUP BY s
----
project
 ├── columns: column5:5(int) s:4(string)
 └── group-by
      ├── columns: kv.s:4(string) column5:5(int)
      ├── grouping columns: kv.s:4(string)
      ├── project
      │    ├── columns: kv.s:4(string)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

# Grouping by more than one column works.
build
SELECT v, COUNT(*), w FROM kv GROUP BY v, w
----
project
 ├── columns: v:2(int) column5:5(int) w:3(int)
 └── group-by
      ├── columns: kv.v:2(int) kv.w:3(int) column5:5(int)
      ├── grouping columns: kv.v:2(int) kv.w:3(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.w:3(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

# Grouping by more than one column using column numbers works.
build
SELECT v, COUNT(*), w FROM kv GROUP BY 1, 3
----
project
 ├── columns: v:2(int) column5:5(int) w:3(int)
 └── group-by
      ├── columns: kv.v:2(int) kv.w:3(int) column5:5(int)
      ├── grouping columns: kv.v:2(int) kv.w:3(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.w:3(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

# Selecting and grouping on a function expression works.
build
SELECT COUNT(*), UPPER(s) FROM kv GROUP BY UPPER(s)
----
project
 ├── columns: column6:6(int) column5:5(string)
 └── group-by
      ├── columns: column5:5(string) column6:6(int)
      ├── grouping columns: column5:5(string)
      ├── project
      │    ├── columns: column5:5(string)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── function: upper [type=string]
      │              └── variable: kv.s [type=string]
      └── aggregations
           └── count-rows [type=int]

# Selecting and grouping on a constant works.
build
SELECT COUNT(*) FROM kv GROUP BY 1+2
----
project
 ├── columns: column6:6(int)
 └── group-by
      ├── columns: column5:5(int!null) column6:6(int)
      ├── grouping columns: column5:5(int!null)
      ├── project
      │    ├── columns: column5:5(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── const: 3 [type=int]
      └── aggregations
           └── count-rows [type=int]

build
SELECT COUNT(*) FROM kv GROUP BY length('abc')
----
project
 ├── columns: column6:6(int)
 └── group-by
      ├── columns: column5:5(int) column6:6(int)
      ├── grouping columns: column5:5(int)
      ├── project
      │    ├── columns: column5:5(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── function: length [type=int]
      │              └── const: 'abc' [type=string]
      └── aggregations
           └── count-rows [type=int]

# Selecting a function of something which is grouped works.
build
SELECT COUNT(*), UPPER(s) FROM kv GROUP BY s
----
project
 ├── columns: column5:5(int) column6:6(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    └── scan kv
 │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── aggregations
 │         └── count-rows [type=int]
 └── projections
      └── function: upper [type=string]
           └── variable: kv.s [type=string]

# Selecting a value that is not grouped, even if a function of it it, does not work.
build
SELECT COUNT(*), s FROM kv GROUP BY UPPER(s)
----
error: column "kv.s" must appear in the GROUP BY clause or be used in an aggregate function

# Selecting and grouping on a more complex expression works.
build
SELECT COUNT(*), k+v FROM kv GROUP BY k+v
----
project
 ├── columns: column6:6(int) column5:5(int)
 └── group-by
      ├── columns: column5:5(int) column6:6(int)
      ├── grouping columns: column5:5(int)
      ├── project
      │    ├── columns: column5:5(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── plus [type=int]
      │              ├── variable: kv.k [type=int]
      │              └── variable: kv.v [type=int]
      └── aggregations
           └── count-rows [type=int]


# Selecting a more complex expression, made up of things which are each grouped, works.
build
SELECT COUNT(*), k+v FROM kv GROUP BY k, v
----
project
 ├── columns: column5:5(int) column6:6(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) column5:5(int)
 │    ├── grouping columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    └── scan kv
 │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── aggregations
 │         └── count-rows [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: kv.k [type=int]
           └── variable: kv.v [type=int]

# TODO(rytaft): don't qualify the column name in the error message differently
# than it was qualified in the query.
build
SELECT COUNT(*), k+v FROM kv GROUP BY k
----
error: column "kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), k+v FROM kv GROUP BY v
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), v/(k+v) FROM kv GROUP BY k+v
----
error: column "kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k FROM kv WHERE AVG(k) > 1
----
error: aggregate functions are not allowed in WHERE

build
SELECT MAX(AVG(k)) FROM kv
----
error: aggregate functions are not allowed in the argument of max()

# Test case from #2761.
build
SELECT count(kv.k) AS count_1, kv.v + kv.w AS lx FROM kv GROUP BY kv.v + kv.w
----
project
 ├── columns: count_1:6(int) lx:5(int)
 └── group-by
      ├── columns: column5:5(int) count_1:6(int)
      ├── grouping columns: column5:5(int)
      ├── project
      │    ├── columns: column5:5(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── plus [type=int]
      │              ├── variable: kv.v [type=int]
      │              └── variable: kv.w [type=int]
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT COUNT(*)
----
group-by
 ├── columns: column1:1(int)
 ├── values
 │    └── tuple [type=tuple{}]
 └── aggregations
      └── count-rows [type=int]

build
SELECT COUNT(k) from kv
----
group-by
 ├── columns: column5:5(int)
 ├── project
 │    ├── columns: kv.k:1(int!null)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      └── count [type=int]
           └── variable: kv.k [type=int]

build
SELECT COUNT(1)
----
group-by
 ├── columns: column2:2(int)
 ├── project
 │    ├── columns: column1:1(int!null)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: column1 [type=int]

build
SELECT COUNT(1) from kv
----
group-by
 ├── columns: column6:6(int)
 ├── project
 │    ├── columns: column5:5(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: column5 [type=int]

build
SELECT COUNT(k, v) FROM kv
----
error: unknown signature: count(int, int)

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k) DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v-COUNT(k)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +6
 └── project
      ├── columns: column6:6(int) kv.v:2(int) column5:5(int)
      ├── group-by
      │    ├── columns: kv.v:2(int) column5:5(int)
      │    ├── grouping columns: kv.v:2(int)
      │    ├── project
      │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    │    └── scan kv
      │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── aggregations
      │         └── count [type=int]
      │              └── variable: kv.k [type=int]
      └── projections
           └── minus [type=int]
                ├── variable: kv.v [type=int]
                └── variable: column5 [type=int]

build
SELECT v FROM kv GROUP BY v ORDER BY SUM(k)
----
sort
 ├── columns: v:2(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(decimal)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── sum [type=decimal]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY 1 DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT COUNT(*), COUNT(k), COUNT(kv.v) FROM kv
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      ├── count-rows [type=int]
      ├── count [type=int]
      │    └── variable: kv.k [type=int]
      └── count [type=int]
           └── variable: kv.v [type=int]

build
SELECT COUNT(kv.*) FROM kv
----
group-by
 ├── columns: column6:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int, int, int, string})
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int, int, int, string}]
 │              ├── variable: kv.k [type=int]
 │              ├── variable: kv.v [type=int]
 │              ├── variable: kv.w [type=int]
 │              └── variable: kv.s [type=string]
 └── aggregations
      └── count [type=int]
           └── variable: column5 [type=tuple{int, int, int, string}]

build
SELECT COUNT((k, v)) FROM kv LIMIT 1
----
limit
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT COUNT((k, v)) FROM kv OFFSET 1
----
offset
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT COUNT(k)+COUNT(kv.v) FROM kv
----
project
 ├── columns: column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    └── scan kv
 │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── aggregations
 │         ├── count [type=int]
 │         │    └── variable: kv.k [type=int]
 │         └── count [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: column5 [type=int]
           └── variable: column6 [type=int]

build
SELECT COUNT(NULL::int), COUNT((NULL, NULL))
----
group-by
 ├── columns: column2:2(int) column4:4(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(tuple{unknown, unknown})
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── null [type=unknown]
 │         └── tuple [type=tuple{unknown, unknown}]
 │              ├── null [type=unknown]
 │              └── null [type=unknown]
 └── aggregations
      ├── count [type=int]
      │    └── variable: column1 [type=int]
      └── count [type=int]
           └── variable: column3 [type=tuple{unknown, unknown}]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM kv
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column8:8(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      ├── min [type=int]
      │    └── variable: kv.k [type=int]
      ├── max [type=int]
      │    └── variable: kv.k [type=int]
      ├── min [type=int]
      │    └── variable: kv.v [type=int]
      └── max [type=int]
           └── variable: kv.v [type=int]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM kv WHERE k > 8
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column8:8(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    └── select
 │         ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── gt [type=bool]
 │              ├── variable: kv.k [type=int]
 │              └── const: 8 [type=int]
 └── aggregations
      ├── min [type=int]
      │    └── variable: kv.k [type=int]
      ├── max [type=int]
      │    └── variable: kv.k [type=int]
      ├── min [type=int]
      │    └── variable: kv.v [type=int]
      └── max [type=int]
           └── variable: kv.v [type=int]

build
SELECT ARRAY_AGG(k), ARRAY_AGG(s) FROM (SELECT k, s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(int[]) column6:6(string[])
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.s:4(string)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      ├── array-agg [type=int[]]
      │    └── variable: kv.k [type=int]
      └── array-agg [type=string[]]
           └── variable: kv.s [type=string]

build
SELECT array_agg(s) FROM kv WHERE s IS NULL
----
group-by
 ├── columns: column5:5(string[])
 ├── project
 │    ├── columns: kv.s:4(string)
 │    └── select
 │         ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── is [type=bool]
 │              ├── variable: kv.s [type=string]
 │              └── null [type=unknown]
 └── aggregations
      └── array-agg [type=string[]]
           └── variable: kv.s [type=string]

build
SELECT AVG(k), AVG(v), SUM(k), SUM(v) FROM kv
----
group-by
 ├── columns: column5:5(decimal) column6:6(decimal) column7:7(decimal) column8:8(decimal)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      ├── avg [type=decimal]
      │    └── variable: kv.k [type=int]
      ├── avg [type=decimal]
      │    └── variable: kv.v [type=int]
      ├── sum [type=decimal]
      │    └── variable: kv.k [type=int]
      └── sum [type=decimal]
           └── variable: kv.v [type=int]

build
SELECT AVG(k::decimal), AVG(v::decimal), SUM(k::decimal), SUM(v::decimal) FROM kv
----
group-by
 ├── columns: column6:6(decimal) column8:8(decimal) column9:9(decimal) column10:10(decimal)
 ├── project
 │    ├── columns: column5:5(decimal) column7:7(decimal)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── cast: decimal [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── cast: decimal [type=decimal]
 │              └── variable: kv.v [type=int]
 └── aggregations
      ├── avg [type=decimal]
      │    └── variable: column5 [type=decimal]
      ├── avg [type=decimal]
      │    └── variable: column7 [type=decimal]
      ├── sum [type=decimal]
      │    └── variable: column5 [type=decimal]
      └── sum [type=decimal]
           └── variable: column7 [type=decimal]

build
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(decimal) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    └── scan kv
 │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── max [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: column5 [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: decimal [type=decimal]
                └── variable: column6 [type=int]

build
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv WHERE w*2 = k
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(decimal) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    └── select
 │    │         ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │         ├── scan kv
 │    │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │         └── eq [type=bool]
 │    │              ├── mult [type=int]
 │    │              │    ├── variable: kv.w [type=int]
 │    │              │    └── const: 2 [type=int]
 │    │              └── variable: kv.k [type=int]
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── max [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: column5 [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: decimal [type=decimal]
                └── variable: column6 [type=int]

exec-ddl
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----
TABLE abc
 ├── a string not null
 ├── b float
 ├── c bool
 ├── d decimal
 └── INDEX primary
      └── a string not null

build
SELECT MIN(a), MIN(b), MIN(c), MIN(d) FROM abc
----
group-by
 ├── columns: column5:5(string) column6:6(float) column7:7(bool) column8:8(decimal)
 ├── scan abc
 │    └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 └── aggregations
      ├── min [type=string]
      │    └── variable: abc.a [type=string]
      ├── min [type=float]
      │    └── variable: abc.b [type=float]
      ├── min [type=bool]
      │    └── variable: abc.c [type=bool]
      └── min [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT MAX(a), MAX(b), MAX(c), MAX(d) FROM abc
----
group-by
 ├── columns: column5:5(string) column6:6(float) column7:7(bool) column8:8(decimal)
 ├── scan abc
 │    └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 └── aggregations
      ├── max [type=string]
      │    └── variable: abc.a [type=string]
      ├── max [type=float]
      │    └── variable: abc.b [type=float]
      ├── max [type=bool]
      │    └── variable: abc.c [type=bool]
      └── max [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT AVG(b), SUM(b), AVG(d), SUM(d) FROM abc
----
group-by
 ├── columns: column5:5(float) column6:6(float) column7:7(decimal) column8:8(decimal)
 ├── project
 │    ├── columns: abc.b:2(float) abc.d:4(decimal)
 │    └── scan abc
 │         └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 └── aggregations
      ├── avg [type=float]
      │    └── variable: abc.b [type=float]
      ├── sum [type=float]
      │    └── variable: abc.b [type=float]
      ├── avg [type=decimal]
      │    └── variable: abc.d [type=decimal]
      └── sum [type=decimal]
           └── variable: abc.d [type=decimal]

# Verify summing of intervals
exec-ddl
CREATE TABLE intervals (
  a INTERVAL PRIMARY KEY
)
----
TABLE intervals
 ├── a interval not null
 └── INDEX primary
      └── a interval not null

build
SELECT SUM(a) FROM intervals
----
group-by
 ├── columns: column2:2(interval)
 ├── scan intervals
 │    └── columns: intervals.a:1(interval!null)
 └── aggregations
      └── sum [type=interval]
           └── variable: intervals.a [type=interval]

build
SELECT AVG(a) FROM abc
----
error: unknown signature: avg(string)

build
SELECT AVG(c) FROM abc
----
error: unknown signature: avg(bool)

build
SELECT AVG((a,c)) FROM abc
----
error: unknown signature: avg(tuple{string, bool})

build
SELECT SUM(a) FROM abc
----
error: unknown signature: sum(string)

build
SELECT SUM(c) FROM abc
----
error: unknown signature: sum(bool)

build
SELECT SUM((a,c)) FROM abc
----
error: unknown signature: sum(tuple{string, bool})

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)
----
TABLE xyz
 ├── x int not null
 ├── y int
 ├── z float
 ├── INDEX primary
 │    └── x int not null
 ├── INDEX xy
 │    ├── x int not null
 │    └── y int
 └── INDEX zyx
      ├── z float
      ├── y int
      └── x int not null

build
SELECT MIN(x) FROM xyz
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── scan xyz
 │         └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 └── aggregations
      └── min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MIN(x) FROM xyz WHERE x in (0, 4, 7)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── in [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── tuple [type=tuple{int, int, int}]
 │                   ├── const: 0 [type=int]
 │                   ├── const: 4 [type=int]
 │                   └── const: 7 [type=int]
 └── aggregations
      └── min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM xyz
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── scan xyz
 │         └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 └── aggregations
      └── max [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(y) FROM xyz WHERE x = 1
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.y:2(int)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── const: 1 [type=int]
 └── aggregations
      └── max [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(y) FROM xyz WHERE x = 7
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.y:2(int)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── const: 7 [type=int]
 └── aggregations
      └── min [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(x) FROM xyz WHERE (y, z) = (2, 3.0)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── tuple [type=tuple{int, float}]
 │              │    ├── variable: xyz.y [type=int]
 │              │    └── variable: xyz.z [type=float]
 │              └── tuple [type=tuple{int, float}]
 │                   ├── const: 2 [type=int]
 │                   └── const: 3.0 [type=float]
 └── aggregations
      └── min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM xyz WHERE (z, y) = (3.0, 2)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── tuple [type=tuple{float, int}]
 │              │    ├── variable: xyz.z [type=float]
 │              │    └── variable: xyz.y [type=int]
 │              └── tuple [type=tuple{float, int}]
 │                   ├── const: 3.0 [type=float]
 │                   └── const: 2 [type=int]
 └── aggregations
      └── max [type=int]
           └── variable: xyz.x [type=int]


# VARIANCE/STDDEV

build
SELECT VARIANCE(x), VARIANCE(y::decimal), round(VARIANCE(z), 14) FROM xyz
----
project
 ├── columns: column4:4(decimal) column6:6(decimal) column8:8(float)
 ├── group-by
 │    ├── columns: column4:4(decimal) column6:6(decimal) column7:7(float)
 │    ├── project
 │    │    ├── columns: column5:5(decimal) xyz.x:1(int!null) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── projections
 │    │         └── cast: decimal [type=decimal]
 │    │              └── variable: xyz.y [type=int]
 │    └── aggregations
 │         ├── variance [type=decimal]
 │         │    └── variable: xyz.x [type=int]
 │         ├── variance [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── variance [type=float]
 │              └── variable: xyz.z [type=float]
 └── projections
      └── function: round [type=float]
           ├── variable: column7 [type=float]
           └── const: 14 [type=int]

build
SELECT VARIANCE(x) FROM xyz WHERE x = 10
----
group-by
 ├── columns: column4:4(decimal)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── const: 10 [type=int]
 └── aggregations
      └── variance [type=decimal]
           └── variable: xyz.x [type=int]

build
SELECT STDDEV(x), STDDEV(y::decimal), round(STDDEV(z), 14) FROM xyz
----
project
 ├── columns: column4:4(decimal) column6:6(decimal) column8:8(float)
 ├── group-by
 │    ├── columns: column4:4(decimal) column6:6(decimal) column7:7(float)
 │    ├── project
 │    │    ├── columns: column5:5(decimal) xyz.x:1(int!null) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── projections
 │    │         └── cast: decimal [type=decimal]
 │    │              └── variable: xyz.y [type=int]
 │    └── aggregations
 │         ├── std-dev [type=decimal]
 │         │    └── variable: xyz.x [type=int]
 │         ├── std-dev [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── std-dev [type=float]
 │              └── variable: xyz.z [type=float]
 └── projections
      └── function: round [type=float]
           ├── variable: column7 [type=float]
           └── const: 14 [type=int]

build
SELECT STDDEV(x) FROM xyz WHERE x = 1
----
group-by
 ├── columns: column4:4(decimal)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    └── select
 │         ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         ├── scan xyz
 │         │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │         └── eq [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── const: 1 [type=int]
 └── aggregations
      └── std-dev [type=decimal]
           └── variable: xyz.x [type=int]

build
SELECT AVG(1::int)::float, AVG(2::float)::float, AVG(3::decimal)::float
----
project
 ├── columns: column3:3(float) column6:6(float) column9:9(float)
 ├── group-by
 │    ├── columns: column2:2(decimal) column5:5(float) column8:8(decimal)
 │    ├── project
 │    │    ├── columns: column1:1(int) column4:4(float) column7:7(decimal)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple{}]
 │    │    └── projections
 │    │         ├── cast: int [type=int]
 │    │         │    └── const: 1 [type=int]
 │    │         ├── cast: float [type=float]
 │    │         │    └── const: 2.0 [type=float]
 │    │         └── cast: decimal [type=decimal]
 │    │              └── const: 3 [type=decimal]
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── avg [type=float]
 │         │    └── variable: column4 [type=float]
 │         └── avg [type=decimal]
 │              └── variable: column7 [type=decimal]
 └── projections
      ├── cast: float [type=float]
      │    └── variable: column2 [type=decimal]
      ├── cast: float [type=float]
      │    └── variable: column5 [type=float]
      └── cast: float [type=float]
           └── variable: column8 [type=decimal]

build
SELECT COUNT(2::int), COUNT(3::float), COUNT(4::decimal)
----
group-by
 ├── columns: column2:2(int) column4:4(int) column6:6(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 2 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 3.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 4 [type=decimal]
 └── aggregations
      ├── count [type=int]
      │    └── variable: column1 [type=int]
      ├── count [type=int]
      │    └── variable: column3 [type=float]
      └── count [type=int]
           └── variable: column5 [type=decimal]

build
SELECT SUM(1::int), SUM(2::float), SUM(3::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 2.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 3 [type=decimal]
 └── aggregations
      ├── sum [type=decimal]
      │    └── variable: column1 [type=int]
      ├── sum [type=float]
      │    └── variable: column3 [type=float]
      └── sum [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT VARIANCE(1::int), VARIANCE(1::float), VARIANCE(1::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── variance [type=decimal]
      │    └── variable: column1 [type=int]
      ├── variance [type=float]
      │    └── variable: column3 [type=float]
      └── variance [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT STDDEV(1::int), STDDEV(1::float), STDDEV(1::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── std-dev [type=decimal]
      │    └── variable: column1 [type=int]
      ├── std-dev [type=float]
      │    └── variable: column3 [type=float]
      └── std-dev [type=decimal]
           └── variable: column5 [type=decimal]

# Ensure subqueries don't trigger aggregation.
build
SELECT x > (SELECT avg(0)) FROM xyz LIMIT 1
----
limit
 ├── columns: column6:6(bool)
 ├── project
 │    ├── columns: column6:6(bool)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── subquery [type=decimal]
 │                   └── max1-row
 │                        ├── columns: column5:5(decimal)
 │                        └── group-by
 │                             ├── columns: column5:5(decimal)
 │                             ├── project
 │                             │    ├── columns: column4:4(int!null)
 │                             │    ├── values
 │                             │    │    └── tuple [type=tuple{}]
 │                             │    └── projections
 │                             │         └── const: 0 [type=int]
 │                             └── aggregations
 │                                  └── avg [type=decimal]
 │                                       └── variable: column4 [type=int]
 └── const: 1 [type=int]

build
SELECT x > (SELECT avg(y) FROM xyz) FROM xyz LIMIT 1
----
limit
 ├── columns: column8:8(bool)
 ├── project
 │    ├── columns: column8:8(bool)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── subquery [type=decimal]
 │                   └── max1-row
 │                        ├── columns: column7:7(decimal)
 │                        └── group-by
 │                             ├── columns: column7:7(decimal)
 │                             ├── project
 │                             │    ├── columns: xyz.y:5(int)
 │                             │    └── scan xyz
 │                             │         └── columns: xyz.x:4(int!null) xyz.y:5(int) xyz.z:6(float)
 │                             └── aggregations
 │                                  └── avg [type=decimal]
 │                                       └── variable: xyz.y [type=int]
 └── const: 1 [type=int]

exec-ddl
CREATE TABLE bools (b BOOL)
----
TABLE bools
 ├── b bool
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT BOOL_AND(b), BOOL_OR(b) FROM bools
----
group-by
 ├── columns: column3:3(bool) column4:4(bool)
 ├── project
 │    ├── columns: bools.b:1(bool)
 │    └── scan bools
 │         └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 └── aggregations
      ├── bool-and [type=bool]
      │    └── variable: bools.b [type=bool]
      └── bool-or [type=bool]
           └── variable: bools.b [type=bool]


# Tests with * inside GROUP BY.
build
SELECT 1 FROM kv GROUP BY kv.*;
----
project
 ├── columns: column5:5(int!null)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    ├── grouping columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── projections
      └── const: 1 [type=int]

exec-ddl
CREATE TABLE xor_bytes (a bytes, b int, c int)
----
TABLE xor_bytes
 ├── a bytes
 ├── b int
 ├── c int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT TO_HEX(XOR_AGG(a)), XOR_AGG(c) FROM xor_bytes
----
project
 ├── columns: column6:6(string) column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(bytes) column7:7(int)
 │    ├── project
 │    │    ├── columns: xor_bytes.a:1(bytes) xor_bytes.c:3(int)
 │    │    └── scan xor_bytes
 │    │         └── columns: xor_bytes.a:1(bytes) xor_bytes.b:2(int) xor_bytes.c:3(int) xor_bytes.rowid:4(int!null)
 │    └── aggregations
 │         ├── xor-agg [type=bytes]
 │         │    └── variable: xor_bytes.a [type=bytes]
 │         └── xor-agg [type=int]
 │              └── variable: xor_bytes.c [type=int]
 └── projections
      └── function: to_hex [type=string]
           └── variable: column5 [type=bytes]

build
SELECT TO_HEX(XOR_AGG(a)), b, XOR_AGG(c) FROM xor_bytes GROUP BY b ORDER BY b
----
sort
 ├── columns: column6:6(string) b:2(int) column7:7(int)
 ├── ordering: +2
 └── project
      ├── columns: column6:6(string) xor_bytes.b:2(int) column7:7(int)
      ├── group-by
      │    ├── columns: xor_bytes.b:2(int) column5:5(bytes) column7:7(int)
      │    ├── grouping columns: xor_bytes.b:2(int)
      │    ├── project
      │    │    ├── columns: xor_bytes.a:1(bytes) xor_bytes.b:2(int) xor_bytes.c:3(int)
      │    │    └── scan xor_bytes
      │    │         └── columns: xor_bytes.a:1(bytes) xor_bytes.b:2(int) xor_bytes.c:3(int) xor_bytes.rowid:4(int!null)
      │    └── aggregations
      │         ├── xor-agg [type=bytes]
      │         │    └── variable: xor_bytes.a [type=bytes]
      │         └── xor-agg [type=int]
      │              └── variable: xor_bytes.c [type=int]
      └── projections
           └── function: to_hex [type=string]
                └── variable: column5 [type=bytes]

# At execution time, this query will cause the error:
# "arguments to xor must all be the same length"
build
SELECT XOR_AGG(i) FROM (VALUES (b'\x01'), (b'\x01\x01')) AS a(i)
----
group-by
 ├── columns: column2:2(bytes)
 ├── values
 │    ├── columns: column1:1(bytes)
 │    ├── tuple [type=tuple{bytes}]
 │    │    └── const: '\x01' [type=bytes]
 │    └── tuple [type=tuple{bytes}]
 │         └── const: '\x0101' [type=bytes]
 └── aggregations
      └── xor-agg [type=bytes]
           └── variable: column1 [type=bytes]

build
SELECT MAX(true), MIN(true)
----
group-by
 ├── columns: column2:2(bool) column3:3(bool)
 ├── project
 │    ├── columns: column1:1(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── true [type=bool]
 └── aggregations
      ├── max [type=bool]
      │    └── variable: column1 [type=bool]
      └── min [type=bool]
           └── variable: column1 [type=bool]

build
SELECT CONCAT_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(string)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.s:4(string)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      └── concat-agg [type=string]
           └── variable: kv.s [type=string]

build
SELECT JSON_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.s:4(string)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      └── json-agg [type=jsonb]
           └── variable: kv.s [type=string]

build
SELECT JSONB_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.s:4(string)
 │    └── scan kv
 │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── aggregations
      └── jsonb-agg [type=jsonb]
           └── variable: kv.s [type=string]

exec-ddl
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)
----
TABLE ab
 ├── a int not null
 ├── b int
 └── INDEX primary
      └── a int not null

exec-ddl
CREATE TABLE xy(x STRING, y STRING);
----
TABLE xy
 ├── x string
 ├── y string
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

# Grouping and rendering tuples.
build
SELECT (b, a) FROM ab GROUP BY (b, a)
----
project
 ├── columns: column3:3(tuple{int, int})
 ├── group-by
 │    ├── columns: ab.a:1(int!null) ab.b:2(int)
 │    ├── grouping columns: ab.a:1(int!null) ab.b:2(int)
 │    └── project
 │         ├── columns: ab.a:1(int!null) ab.b:2(int)
 │         └── scan ab
 │              └── columns: ab.a:1(int!null) ab.b:2(int)
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT MIN(y), (b, a)
 FROM ab, xy GROUP BY (x, (a, b))
----
project
 ├── columns: column6:6(string) column7:7(tuple{int, int})
 ├── group-by
 │    ├── columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string) column6:6(string)
 │    ├── grouping columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string)
 │    ├── project
 │    │    ├── columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string) xy.y:4(string)
 │    │    └── inner-join
 │    │         ├── columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string) xy.y:4(string) xy.rowid:5(int!null)
 │    │         ├── scan ab
 │    │         │    └── columns: ab.a:1(int!null) ab.b:2(int)
 │    │         ├── scan xy
 │    │         │    └── columns: xy.x:3(string) xy.y:4(string) xy.rowid:5(int!null)
 │    │         └── true [type=bool]
 │    └── aggregations
 │         └── min [type=string]
 │              └── variable: xy.y [type=string]
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(*) FROM kv GROUP BY v ORDER BY COUNT(*)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT v, COUNT(1) FROM kv GROUP BY v ORDER BY COUNT(1)
----
sort
 ├── columns: v:2(int) column6:6(int)
 ├── ordering: +6
 └── group-by
      ├── columns: kv.v:2(int) column6:6(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: column5:5(int!null) kv.v:2(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── const: 1 [type=int]
      └── aggregations
           └── count [type=int]
                └── variable: column5 [type=int]

build
SELECT (k+v)/(v+w) FROM kv GROUP BY k+v, v+w;
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int) column6:6(int)
 │    └── project
 │         ├── columns: column5:5(int) column6:6(int)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── projections
 │              ├── plus [type=int]
 │              │    ├── variable: kv.k [type=int]
 │              │    └── variable: kv.v [type=int]
 │              └── plus [type=int]
 │                   ├── variable: kv.v [type=int]
 │                   └── variable: kv.w [type=int]
 └── projections
      └── div [type=decimal]
           ├── plus [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.v [type=int]
           └── plus [type=int]
                ├── variable: kv.v [type=int]
                └── variable: kv.w [type=int]

# Check that everything still works with differently qualified names
build fully-qualify-names
SELECT SUM(t.kv.w), t.kv.v FROM t.kv GROUP BY v, kv.k * w
----
project
 ├── columns: column6:6(decimal) v:2(int)
 └── group-by
      ├── columns: t.public.kv.v:2(int) column5:5(int) column6:6(decimal)
      ├── grouping columns: t.public.kv.v:2(int) column5:5(int)
      ├── project
      │    ├── columns: column5:5(int) t.public.kv.v:2(int) t.public.kv.w:3(int)
      │    ├── scan kv
      │    │    └── columns: t.public.kv.k:1(int!null) t.public.kv.v:2(int) t.public.kv.w:3(int) t.public.kv.s:4(string)
      │    └── projections
      │         └── mult [type=int]
      │              ├── variable: t.public.kv.k [type=int]
      │              └── variable: t.public.kv.w [type=int]
      └── aggregations
           └── sum [type=decimal]
                └── variable: t.public.kv.w [type=int]

build fully-qualify-names
SELECT SUM(t.kv.w), LOWER(s), t.kv.v + k * t.kv.w, t.kv.v FROM t.kv GROUP BY v, LOWER(kv.s), kv.k * w
----
project
 ├── columns: column7:7(decimal) column5:5(string) column8:8(int) v:2(int)
 ├── group-by
 │    ├── columns: t.public.kv.v:2(int) column5:5(string) column6:6(int) column7:7(decimal)
 │    ├── grouping columns: t.public.kv.v:2(int) column5:5(string) column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(string) column6:6(int) t.public.kv.v:2(int) t.public.kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: t.public.kv.k:1(int!null) t.public.kv.v:2(int) t.public.kv.w:3(int) t.public.kv.s:4(string)
 │    │    └── projections
 │    │         ├── function: lower [type=string]
 │    │         │    └── variable: t.public.kv.s [type=string]
 │    │         └── mult [type=int]
 │    │              ├── variable: t.public.kv.k [type=int]
 │    │              └── variable: t.public.kv.w [type=int]
 │    └── aggregations
 │         └── sum [type=decimal]
 │              └── variable: t.public.kv.w [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: t.public.kv.v [type=int]
           └── mult [type=int]
                ├── variable: t.public.kv.k [type=int]
                └── variable: t.public.kv.w [type=int]

# Check all the different types of scalar expressions as group by columns
build
SELECT b1.b AND abc.c AND b2.b FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
project
 ├── columns: column10:10(bool)
 ├── group-by
 │    ├── columns: bools.b:3(bool) column9:9(bool)
 │    ├── grouping columns: bools.b:3(bool) column9:9(bool)
 │    └── project
 │         ├── columns: column9:9(bool) bools.b:3(bool)
 │         ├── inner-join
 │         │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    ├── inner-join
 │         │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null)
 │         │    │    ├── scan bools
 │         │    │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │         │    │    ├── scan bools
 │         │    │    │    └── columns: bools.b:3(bool) bools.rowid:4(int!null)
 │         │    │    └── true [type=bool]
 │         │    ├── scan abc
 │         │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    └── true [type=bool]
 │         └── projections
 │              └── and [type=bool]
 │                   ├── variable: bools.b [type=bool]
 │                   └── variable: abc.c [type=bool]
 └── projections
      └── and [type=bool]
           ├── and [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b AND abc.c AND abc.c FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b1.b OR abc.c OR b2.b FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
project
 ├── columns: column10:10(bool)
 ├── group-by
 │    ├── columns: bools.b:3(bool) column9:9(bool)
 │    ├── grouping columns: bools.b:3(bool) column9:9(bool)
 │    └── project
 │         ├── columns: column9:9(bool) bools.b:3(bool)
 │         ├── inner-join
 │         │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    ├── inner-join
 │         │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null)
 │         │    │    ├── scan bools
 │         │    │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │         │    │    ├── scan bools
 │         │    │    │    └── columns: bools.b:3(bool) bools.rowid:4(int!null)
 │         │    │    └── true [type=bool]
 │         │    ├── scan abc
 │         │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    └── true [type=bool]
 │         └── projections
 │              └── or [type=bool]
 │                   ├── variable: bools.b [type=bool]
 │                   └── variable: abc.c [type=bool]
 └── projections
      └── or [type=bool]
           ├── or [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b OR abc.c OR abc.c FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k % w % v FROM kv GROUP BY k % w, v
----
project
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(int)
 │    ├── grouping columns: kv.v:2(int) column5:5(int)
 │    └── project
 │         ├── columns: column5:5(int) kv.v:2(int)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── projections
 │              └── mod [type=int]
 │                   ├── variable: kv.k [type=int]
 │                   └── variable: kv.w [type=int]
 └── projections
      └── mod [type=int]
           ├── mod [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── variable: kv.v [type=int]

build
SELECT CONCAT(CONCAT(s, a), a) FROM kv, abc GROUP BY CONCAT(s, a), a
----
project
 ├── columns: column10:10(string)
 ├── group-by
 │    ├── columns: abc.a:5(string!null) column9:9(string)
 │    ├── grouping columns: abc.a:5(string!null) column9:9(string)
 │    └── project
 │         ├── columns: column9:9(string) abc.a:5(string!null)
 │         ├── inner-join
 │         │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    ├── scan kv
 │         │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         │    ├── scan abc
 │         │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │         │    └── true [type=bool]
 │         └── projections
 │              └── function: concat [type=string]
 │                   ├── variable: kv.s [type=string]
 │                   └── variable: abc.a [type=string]
 └── projections
      └── function: concat [type=string]
           ├── function: concat [type=string]
           │    ├── variable: kv.s [type=string]
           │    └── variable: abc.a [type=string]
           └── variable: abc.a [type=string]

build
SELECT CONCAT(CONCAT(s, a), s) FROM kv, abc GROUP BY CONCAT(s, a), a
----
error: column "kv.s" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k < w AND v != 5 FROM kv GROUP BY k < w, v
----
project
 ├── columns: column6:6(bool)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(bool)
 │    ├── grouping columns: kv.v:2(int) column5:5(bool)
 │    └── project
 │         ├── columns: column5:5(bool) kv.v:2(int)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── projections
 │              └── lt [type=bool]
 │                   ├── variable: kv.k [type=int]
 │                   └── variable: kv.w [type=int]
 └── projections
      └── and [type=bool]
           ├── lt [type=bool]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── ne [type=bool]
                ├── variable: kv.v [type=int]
                └── const: 5 [type=int]

build
SELECT k < w AND k < v FROM kv GROUP BY k < w, v
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

exec-ddl
CREATE TABLE foo (bar JSON, baz JSON)
----
TABLE foo
 ├── bar jsonb
 ├── baz jsonb
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY a.bar @> b.baz, b.baz
----
project
 ├── columns: column8:8(bool)
 ├── group-by
 │    ├── columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: foo.baz:5(jsonb) column7:7(bool)
 │    └── project
 │         ├── columns: column7:7(bool) foo.baz:5(jsonb)
 │         ├── inner-join
 │         │    ├── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null) foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │         │    ├── scan foo
 │         │    │    └── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null)
 │         │    ├── scan foo
 │         │    │    └── columns: foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │         │    └── true [type=bool]
 │         └── projections
 │              └── contains [type=bool]
 │                   ├── variable: foo.bar [type=jsonb]
 │                   └── variable: foo.baz [type=jsonb]
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
error: column "foo.bar" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b.baz <@ a.bar AND b.baz <@ b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
project
 ├── columns: column8:8(bool)
 ├── group-by
 │    ├── columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: foo.baz:5(jsonb) column7:7(bool)
 │    └── project
 │         ├── columns: column7:7(bool) foo.baz:5(jsonb)
 │         ├── inner-join
 │         │    ├── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null) foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │         │    ├── scan foo
 │         │    │    └── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null)
 │         │    ├── scan foo
 │         │    │    └── columns: foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │         │    └── true [type=bool]
 │         └── projections
 │              └── contains [type=bool]
 │                   ├── variable: foo.bar [type=jsonb]
 │                   └── variable: foo.baz [type=jsonb]
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

exec-ddl
CREATE TABLE times (t time PRIMARY KEY)
----
TABLE times
 ├── t time not null
 └── INDEX primary
      └── t time not null

build
SELECT date_trunc('second', a.t) - date_trunc('minute', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
project
 ├── columns: column5:5(interval)
 ├── group-by
 │    ├── columns: column3:3(interval) column4:4(interval)
 │    ├── grouping columns: column3:3(interval) column4:4(interval)
 │    └── project
 │         ├── columns: column3:3(interval) column4:4(interval)
 │         ├── inner-join
 │         │    ├── columns: times.t:1(time!null) times.t:2(time!null)
 │         │    ├── scan times
 │         │    │    └── columns: times.t:1(time!null)
 │         │    ├── scan times
 │         │    │    └── columns: times.t:2(time!null)
 │         │    └── true [type=bool]
 │         └── projections
 │              ├── function: date_trunc [type=interval]
 │              │    ├── const: 'second' [type=string]
 │              │    └── variable: times.t [type=time]
 │              └── function: date_trunc [type=interval]
 │                   ├── const: 'minute' [type=string]
 │                   └── variable: times.t [type=time]
 └── projections
      └── minus [type=interval]
           ├── function: date_trunc [type=interval]
           │    ├── const: 'second' [type=string]
           │    └── variable: times.t [type=time]
           └── function: date_trunc [type=interval]
                ├── const: 'minute' [type=string]
                └── variable: times.t [type=time]

build
SELECT date_trunc('second', a.t) - date_trunc('second', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
error: column "times.t" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY NOT b
----
group-by
 ├── columns: column3:3(bool)
 ├── grouping columns: column3:3(bool)
 └── project
      ├── columns: column3:3(bool)
      ├── scan bools
      │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
      └── projections
           └── not [type=bool]
                └── variable: bools.b [type=bool]

build
SELECT b FROM bools GROUP BY NOT b
----
error: column "bools.b" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY b
----
project
 ├── columns: column3:3(bool)
 ├── group-by
 │    ├── columns: bools.b:1(bool)
 │    ├── grouping columns: bools.b:1(bool)
 │    └── project
 │         ├── columns: bools.b:1(bool)
 │         └── scan bools
 │              └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 └── projections
      └── not [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT +k * (-w) FROM kv GROUP BY +k, -w
----
project
 ├── columns: column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int) column6:6(int)
 │    └── project
 │         ├── columns: column5:5(int) column6:6(int)
 │         ├── scan kv
 │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │         └── projections
 │              ├── variable: kv.k [type=int]
 │              └── unary-minus [type=int]
 │                   └── variable: kv.w [type=int]
 └── projections
      └── mult [type=int]
           ├── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build
SELECT k * (-w) FROM kv GROUP BY +k, -w
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT +k * (-w) FROM kv GROUP BY k, w
----
project
 ├── columns: column5:5(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.w:3(int)
 │    ├── grouping columns: kv.k:1(int!null) kv.w:3(int)
 │    └── project
 │         ├── columns: kv.k:1(int!null) kv.w:3(int)
 │         └── scan kv
 │              └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 └── projections
      └── mult [type=int]
           ├── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build
SELECT 1 + MIN(v*2) FROM kv GROUP BY k+3
----
project
 ├── columns: column8:8(int)
 ├── group-by
 │    ├── columns: column5:5(int) column7:7(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) column6:6(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── const: 3 [type=int]
 │    │         └── mult [type=int]
 │    │              ├── variable: kv.v [type=int]
 │    │              └── const: 2 [type=int]
 │    └── aggregations
 │         └── min [type=int]
 │              └── variable: column6 [type=int]
 └── projections
      └── plus [type=int]
           ├── const: 1 [type=int]
           └── variable: column7 [type=int]

build
SELECT count(*) FROM kv GROUP BY k, k
----
project
 ├── columns: column5:5(int)
 └── group-by
      ├── columns: kv.k:1(int!null) column5:5(int)
      ├── grouping columns: kv.k:1(int!null)
      ├── project
      │    ├── columns: kv.k:1(int!null)
      │    └── scan kv
      │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT COUNT(UPPER(s)) FROM kv GROUP BY UPPER(s)
----
project
 ├── columns: column6:6(int)
 └── group-by
      ├── columns: column5:5(string) column6:6(int)
      ├── grouping columns: column5:5(string)
      ├── project
      │    ├── columns: column5:5(string)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── function: upper [type=string]
      │              └── variable: kv.s [type=string]
      └── aggregations
           └── count [type=int]
                └── variable: column5 [type=string]

build
SELECT SUM(abc.d) FROM kv JOIN abc ON kv.k >= abc.d GROUP BY kv.*
----
project
 ├── columns: column9:9(decimal)
 └── group-by
      ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) column9:9(decimal)
      ├── grouping columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      ├── project
      │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.d:8(decimal)
      │    └── inner-join
      │         ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
      │         ├── scan kv
      │         │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │         ├── scan abc
      │         │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
      │         └── ge [type=bool]
      │              ├── variable: kv.k [type=int]
      │              └── variable: abc.d [type=decimal]
      └── aggregations
           └── sum [type=decimal]
                └── variable: abc.d [type=decimal]

build
SELECT SUM(DISTINCT abc.d) FROM abc
----
error: aggregates with DISTINCT are not supported yet

build
SELECT SUM(abc.d) FILTER (WHERE abc.d > 0) FROM abc
----
error: aggregates with FILTER are not supported yet

# Check that ordering by an alias of an aggregate works.
build
SELECT MAX(k) AS mk FROM kv GROUP BY v ORDER BY mk
----
sort
 ├── columns: mk:5(int)
 ├── ordering: +5
 └── project
      ├── columns: mk:5(int)
      └── group-by
           ├── columns: kv.v:2(int) mk:5(int)
           ├── grouping columns: kv.v:2(int)
           ├── project
           │    ├── columns: kv.k:1(int!null) kv.v:2(int)
           │    └── scan kv
           │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: kv.k [type=int]

build
SELECT MAX(k) AS mk FROM kv GROUP BY v ORDER BY MAX(k)
----
sort
 ├── columns: mk:5(int)
 ├── ordering: +5
 └── project
      ├── columns: mk:5(int)
      └── group-by
           ├── columns: kv.v:2(int) mk:5(int)
           ├── grouping columns: kv.v:2(int)
           ├── project
           │    ├── columns: kv.k:1(int!null) kv.v:2(int)
           │    └── scan kv
           │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: kv.k [type=int]

build
SELECT MAX(k) AS mk1, MAX(k) AS mk2 FROM kv GROUP BY v ORDER BY mk1
----
sort
 ├── columns: mk1:5(int) mk2:5(int)
 ├── ordering: +5
 └── project
      ├── columns: mk1:5(int)
      └── group-by
           ├── columns: kv.v:2(int) mk1:5(int)
           ├── grouping columns: kv.v:2(int)
           ├── project
           │    ├── columns: kv.k:1(int!null) kv.v:2(int)
           │    └── scan kv
           │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: kv.k [type=int]

build
SELECT MAX(k) AS mk1, MAX(k) AS mk2 FROM kv GROUP BY v ORDER BY mk2
----
sort
 ├── columns: mk1:5(int) mk2:5(int)
 ├── ordering: +5
 └── project
      ├── columns: mk1:5(int)
      └── group-by
           ├── columns: kv.v:2(int) mk1:5(int)
           ├── grouping columns: kv.v:2(int)
           ├── project
           │    ├── columns: kv.k:1(int!null) kv.v:2(int)
           │    └── scan kv
           │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: kv.k [type=int]

build
SELECT MAX(k) AS mk1, MAX(k)/5 AS mk2 FROM kv GROUP BY v ORDER BY mk2
----
sort
 ├── columns: mk1:5(int) mk2:6(decimal)
 ├── ordering: +6
 └── project
      ├── columns: mk2:6(decimal) mk1:5(int)
      ├── group-by
      │    ├── columns: kv.v:2(int) mk1:5(int)
      │    ├── grouping columns: kv.v:2(int)
      │    ├── project
      │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
      │    │    └── scan kv
      │    │         └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── aggregations
      │         └── max [type=int]
      │              └── variable: kv.k [type=int]
      └── projections
           └── div [type=decimal]
                ├── variable: mk1 [type=int]
                └── const: 5 [type=int]
