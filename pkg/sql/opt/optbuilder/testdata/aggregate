# tests adapted from logictest -- aggregate

exec-ddl
CREATE TABLE t.kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----
TABLE kv
 ├── k int not null
 ├── v int
 ├── w int
 ├── s string
 └── INDEX primary
      └── k int not null

build
SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1),
  VARIANCE(1), BOOL_AND(true), BOOL_OR(false), XOR_AGG(b'\x01') FROM t.kv
----
group-by
 ├── columns: column6:6(int) column7:7(int) column8:8(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column17:17(bool) column19:19(bytes)
 ├── project
 │    ├── columns: column5:5(int) column14:14(bool) column16:16(bool) column18:18(bytes)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── const: 1 [type=int]
 │         ├── true [type=bool]
 │         ├── false [type=bool]
 │         └── const: '\x01' [type=bytes]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: column5 [type=int]
      ├── function: max [type=int]
      │    └── variable: column5 [type=int]
      ├── function: count [type=int]
      │    └── variable: column5 [type=int]
      ├── function: sum_int [type=int]
      │    └── variable: column5 [type=int]
      ├── function: avg [type=decimal]
      │    └── variable: column5 [type=int]
      ├── function: sum [type=decimal]
      │    └── variable: column5 [type=int]
      ├── function: stddev [type=decimal]
      │    └── variable: column5 [type=int]
      ├── function: variance [type=decimal]
      │    └── variable: column5 [type=int]
      ├── function: bool_and [type=bool]
      │    └── variable: column14 [type=bool]
      ├── function: bool_or [type=bool]
      │    └── variable: column16 [type=bool]
      └── function: xor_agg [type=bytes]
           └── variable: column18 [type=bytes]

build
SELECT MIN(v), MAX(v), COUNT(v), SUM_INT(1), AVG(v), SUM(v), STDDEV(v),
  VARIANCE(v), BOOL_AND(v = 1), BOOL_AND(v = 1), XOR_AGG(s::bytes) FROM kv
----
project
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column15:15(bool) column17:17(bytes)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int) column7:7(int) column9:9(int) column10:10(decimal) column11:11(decimal) column12:12(decimal) column13:13(decimal) column15:15(bool) column17:17(bytes)
 │    ├── project
 │    │    ├── columns: kv.v:2(int) column8:8(int) column14:14(bool) column16:16(bytes)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── const: 1 [type=int]
 │    │         ├── eq [type=bool]
 │    │         │    ├── variable: kv.v [type=int]
 │    │         │    └── const: 1 [type=int]
 │    │         └── cast: bytes [type=bytes]
 │    │              └── variable: kv.s [type=string]
 │    └── aggregations
 │         ├── function: min [type=int]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: max [type=int]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: count [type=int]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: sum_int [type=int]
 │         │    └── variable: column8 [type=int]
 │         ├── function: avg [type=decimal]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: sum [type=decimal]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: stddev [type=decimal]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: variance [type=decimal]
 │         │    └── variable: kv.v [type=int]
 │         ├── function: bool_and [type=bool]
 │         │    └── variable: column14 [type=bool]
 │         └── function: xor_agg [type=bytes]
 │              └── variable: column16 [type=bytes]
 └── projections
      ├── variable: column5 [type=int]
      ├── variable: column6 [type=int]
      ├── variable: column7 [type=int]
      ├── variable: column9 [type=int]
      ├── variable: column10 [type=decimal]
      ├── variable: column11 [type=decimal]
      ├── variable: column12 [type=decimal]
      ├── variable: column13 [type=decimal]
      ├── variable: column15 [type=bool]
      └── variable: column17 [type=bytes]

build
SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1),
  VARIANCE(1)::float, BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
project
 ├── columns: column2:2(int) column3:3(int) column4:4(int) column5:5(int) column7:7(float) column8:8(decimal) column9:9(decimal) column11:11(float) column13:13(bool) column14:14(bool) column17:17(string)
 ├── group-by
 │    ├── columns: column2:2(int) column3:3(int) column4:4(int) column5:5(int) column6:6(decimal) column8:8(decimal) column9:9(decimal) column10:10(decimal) column13:13(bool) column14:14(bool) column16:16(bytes)
 │    ├── project
 │    │    ├── columns: column1:1(int) column12:12(bool) column15:15(bytes)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple{}]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         ├── true [type=bool]
 │    │         └── const: '\x01' [type=bytes]
 │    └── aggregations
 │         ├── function: min [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── function: count [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── function: max [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── function: sum_int [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── function: avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── function: sum [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── function: stddev [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── function: variance [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── function: bool_and [type=bool]
 │         │    └── variable: column12 [type=bool]
 │         ├── function: bool_or [type=bool]
 │         │    └── variable: column12 [type=bool]
 │         └── function: xor_agg [type=bytes]
 │              └── variable: column15 [type=bytes]
 └── projections
      ├── variable: column2 [type=int]
      ├── variable: column3 [type=int]
      ├── variable: column4 [type=int]
      ├── variable: column5 [type=int]
      ├── cast: float [type=float]
      │    └── variable: column6 [type=decimal]
      ├── variable: column8 [type=decimal]
      ├── variable: column9 [type=decimal]
      ├── cast: float [type=float]
      │    └── variable: column10 [type=decimal]
      ├── variable: column13 [type=bool]
      ├── variable: column14 [type=bool]
      └── function: to_hex [type=string]
           └── variable: column16 [type=bytes]

build
SELECT ARRAY_AGG(1) FROM t.kv
----
group-by
 ├── columns: column6:6(int[])
 ├── project
 │    ├── columns: column5:5(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: array_agg [type=int[]]
           └── variable: column5 [type=int]

build
SELECT JSON_AGG(v) FROM t.kv
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.v:2(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── variable: kv.v [type=int]
 └── aggregations
      └── function: json_agg [type=jsonb]
           └── variable: kv.v [type=int]

build
SELECT JSONB_AGG(1)
----
group-by
 ├── columns: column2:2(jsonb)
 ├── project
 │    ├── columns: column1:1(int)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: jsonb_agg [type=jsonb]
           └── variable: column1 [type=int]

# Even with no aggregate functions, grouping occurs in the presence of GROUP BY.
build
SELECT 1 FROM t.kv GROUP BY v
----
project
 ├── columns: column5:5(int)
 ├── group-by
 │    ├── columns: kv.v:2(int)
 │    ├── grouping columns: kv.v:2(int)
 │    ├── project
 │    │    ├── columns: kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── const: 1 [type=int]

# This should ideally return {NULL}, but this is a pathological case, and
# Postgres has the same behavior, so it's sufficient for now.
build
SELECT ARRAY_AGG(NULL)
----
error: ambiguous call: array_agg(unknown), candidates are:
array_agg(int) -> int[]
array_agg(float) -> float[]
array_agg(decimal) -> decimal[]
array_agg(string) -> string[]
array_agg(bytes) -> bytes[]
array_agg(date) -> date[]
array_agg(time) -> time[]
array_agg(timestamp) -> timestamp[]
array_agg(timestamptz) -> timestamptz[]
array_agg(interval) -> interval[]
array_agg(uuid) -> uuid[]
array_agg(inet) -> inet[]
array_agg(oid) -> oid[]
array_agg(bool) -> bool[]

# With an explicit cast, this works as expected.
build
SELECT ARRAY_AGG(NULL::TEXT)
----
group-by
 ├── columns: column2:2(string[])
 ├── project
 │    ├── columns: column1:1(string)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── cast: string [type=string]
 │              └── null [type=unknown]
 └── aggregations
      └── function: array_agg [type=string[]]
           └── variable: column1 [type=string]

build
SELECT (SELECT COALESCE(MAX(1), 0) FROM kv)
----
project
 ├── columns: column8:8(int)
 ├── values
 │    └── tuple [type=tuple{}]
 └── projections
      └── subquery [type=int]
           ├── max1-row
           │    ├── columns: column7:7(int)
           │    └── project
           │         ├── columns: column7:7(int)
           │         ├── group-by
           │         │    ├── columns: column6:6(int)
           │         │    ├── project
           │         │    │    ├── columns: column5:5(int)
           │         │    │    ├── scan kv
           │         │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
           │         │    │    └── projections
           │         │    │         └── const: 1 [type=int]
           │         │    └── aggregations
           │         │         └── function: max [type=int]
           │         │              └── variable: column5 [type=int]
           │         └── projections
           │              └── coalesce [type=int]
           │                   ├── variable: column6 [type=int]
           │                   └── const: 0 [type=int]
           └── variable: column7 [type=int]

build
SELECT COUNT(*), k FROM t.kv
----
error: column "t.kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*) FROM t.kv GROUP BY s < 5
----
error: unsupported comparison operator: <string> < <int>

build
SELECT COUNT(*), k FROM t.kv GROUP BY k
----
project
 ├── columns: column5:5(int) k:1(int!null)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) column5:5(int)
 │    ├── grouping columns: kv.k:1(int!null)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.k [type=int]

# GROUP BY specified using column index works.
build
SELECT COUNT(*), k FROM t.kv GROUP BY 2
----
project
 ├── columns: column5:5(int) k:1(int!null)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) column5:5(int)
 │    ├── grouping columns: kv.k:1(int!null)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.k [type=int]

build
SELECT * FROM kv GROUP BY v, COUNT(w)
----
error: aggregate functions are not allowed in GROUP BY

build
SELECT COUNT(w) FROM kv GROUP BY 1
----
error: aggregate functions are not allowed in GROUP BY

build
SELECT SUM(v) FROM kv GROUP BY k LIMIT SUM(v)
----
error: aggregate functions are not allowed in LIMIT

build
SELECT SUM(v) FROM kv GROUP BY k LIMIT 1 OFFSET SUM(v)
----
error: aggregate functions are not allowed in OFFSET

build
VALUES (99, COUNT(1))
----
error: aggregate functions are not allowed in VALUES

build
SELECT COUNT(*), k FROM t.kv GROUP BY 5
----
error: GROUP BY position 5 is not in select list

build
SELECT COUNT(*), k FROM t.kv GROUP BY 0
----
error: GROUP BY position 0 is not in select list

build
SELECT 1 GROUP BY 'a'
----
error: non-integer constant in GROUP BY: 'a'

# Qualifying a name in the SELECT, the GROUP BY, both or neither should not affect validation.
build
SELECT COUNT(*), kv.s FROM t.kv GROUP BY s
----
project
 ├── columns: column5:5(int) s:4(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), s FROM t.kv GROUP BY kv.s
----
project
 ├── columns: column5:5(int) s:4(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), kv.s FROM t.kv GROUP BY kv.s
----
project
 ├── columns: column5:5(int) s:4(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), s FROM t.kv GROUP BY s
----
project
 ├── columns: column5:5(int) s:4(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

# Grouping by more than one column works.
build
SELECT v, COUNT(*), w FROM t.kv GROUP BY v, w
----
project
 ├── columns: v:2(int) column5:5(int) w:3(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) kv.w:3(int) column5:5(int)
 │    ├── grouping columns: kv.v:2(int) kv.w:3(int)
 │    ├── project
 │    │    ├── columns: kv.v:2(int) kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: kv.v [type=int]
      ├── variable: column5 [type=int]
      └── variable: kv.w [type=int]

# Grouping by more than one column using column numbers works.
build
SELECT v, COUNT(*), w FROM t.kv GROUP BY 1, 3
----
project
 ├── columns: v:2(int) column5:5(int) w:3(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) kv.w:3(int) column5:5(int)
 │    ├── grouping columns: kv.v:2(int) kv.w:3(int)
 │    ├── project
 │    │    ├── columns: kv.v:2(int) kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: kv.v [type=int]
      ├── variable: column5 [type=int]
      └── variable: kv.w [type=int]

# Selecting and grouping on a function expression works.
build
SELECT COUNT(*), UPPER(s) FROM t.kv GROUP BY UPPER(s)
----
project
 ├── columns: column6:6(int) column5:5(string)
 ├── group-by
 │    ├── columns: column5:5(string) column6:6(int)
 │    ├── grouping columns: column5:5(string)
 │    ├── project
 │    │    ├── columns: column5:5(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── function: upper [type=string]
 │    │              └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column6 [type=int]
      └── variable: column5 [type=string]

# Selecting and grouping on a constant works.
build
SELECT COUNT(*) FROM t.kv GROUP BY 1+2
----
project
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── const: 3 [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      └── variable: column6 [type=int]

build
SELECT COUNT(*) FROM t.kv GROUP BY length('abc')
----
project
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── function: length [type=int]
 │    │              └── const: 'abc' [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      └── variable: column6 [type=int]

# Selecting a function of something which is grouped works.
build
SELECT COUNT(*), UPPER(s) FROM t.kv GROUP BY s
----
project
 ├── columns: column5:5(int) column6:6(string)
 ├── group-by
 │    ├── columns: kv.s:4(string) column5:5(int)
 │    ├── grouping columns: kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── function: upper [type=string]
           └── variable: kv.s [type=string]

# Selecting a value that is not grouped, even if a function of it it, does not work.
build
SELECT COUNT(*), s FROM t.kv GROUP BY UPPER(s)
----
error: column "t.kv.s" must appear in the GROUP BY clause or be used in an aggregate function

# Selecting and grouping on a more complex expression works.
build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k+v
----
project
 ├── columns: column6:6(int) column5:5(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── plus [type=int]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column6 [type=int]
      └── variable: column5 [type=int]


# Selecting a more complex expression, made up of things which are each grouped, works.
build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k, v
----
project
 ├── columns: column5:5(int) column6:6(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) column5:5(int)
 │    ├── grouping columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── plus [type=int]
           ├── variable: kv.k [type=int]
           └── variable: kv.v [type=int]

# TODO(rytaft): don't qualify the column name in the error message differently
# than it was qualified in the query.
build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k
----
error: column "t.kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), k+v FROM t.kv GROUP BY v
----
error: column "t.kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), v/(k+v) FROM t.kv GROUP BY k+v
----
error: column "t.kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k FROM t.kv WHERE AVG(k) > 1
----
error: aggregate functions are not allowed in WHERE

build
SELECT MAX(AVG(k)) FROM t.kv
----
error: aggregate functions are not allowed in the argument of max()

# Test case from #2761.
build
SELECT count(kv.k) AS count_1, kv.v + kv.w AS lx FROM t.kv GROUP BY kv.v + kv.w
----
project
 ├── columns: count_1:6(int) lx:5(int)
 ├── group-by
 │    ├── columns: column5:5(int) count_1:6(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) kv.k:1(int!null)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.v [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count [type=int]
 │              └── variable: kv.k [type=int]
 └── projections
      ├── variable: count_1 [type=int]
      └── variable: column5 [type=int]

build
SELECT COUNT(*)
----
group-by
 ├── columns: column1:1(int)
 ├── values
 │    └── tuple [type=tuple{}]
 └── aggregations
      └── function: count_rows [type=int]

build
SELECT COUNT(k) from t.kv
----
group-by
 ├── columns: column5:5(int)
 ├── project
 │    ├── columns: kv.k:1(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── variable: kv.k [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: kv.k [type=int]

build
SELECT COUNT(1)
----
group-by
 ├── columns: column2:2(int)
 ├── project
 │    ├── columns: column1:1(int)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: column1 [type=int]

build
SELECT COUNT(1) from t.kv
----
group-by
 ├── columns: column6:6(int)
 ├── project
 │    ├── columns: column5:5(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: column5 [type=int]

build
SELECT COUNT(k, v) FROM t.kv
----
error: unknown signature: count(int, int)

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k) DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v-COUNT(k)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +6
 └── project
      ├── columns: kv.v:2(int) column5:5(int) column6:6(int)
      ├── group-by
      │    ├── columns: kv.v:2(int) column5:5(int)
      │    ├── grouping columns: kv.v:2(int)
      │    ├── project
      │    │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    │    ├── scan kv
      │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    │    └── projections
      │    │         ├── variable: kv.v [type=int]
      │    │         └── variable: kv.k [type=int]
      │    └── aggregations
      │         └── function: count [type=int]
      │              └── variable: kv.k [type=int]
      └── projections
           ├── variable: kv.v [type=int]
           ├── variable: column5 [type=int]
           └── minus [type=int]
                ├── variable: kv.v [type=int]
                └── variable: column5 [type=int]

build
SELECT v FROM kv GROUP BY v ORDER BY SUM(k)
----
sort
 ├── columns: v:2(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(decimal)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: sum [type=decimal]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY 1 DESC
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: kv.k [type=int]

build
SELECT COUNT(*), COUNT(k), COUNT(kv.v) FROM t.kv
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: count_rows [type=int]
      ├── function: count [type=int]
      │    └── variable: kv.k [type=int]
      └── function: count [type=int]
           └── variable: kv.v [type=int]

build
SELECT COUNT(kv.*) FROM t.kv
----
group-by
 ├── columns: column6:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int, int, int, string})
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int, int, int, string}]
 │              ├── variable: kv.k [type=int]
 │              ├── variable: kv.v [type=int]
 │              ├── variable: kv.w [type=int]
 │              └── variable: kv.s [type=string]
 └── aggregations
      └── function: count [type=int]
           └── variable: column5 [type=tuple{int, int, int, string}]

build
SELECT COUNT((k, v)) FROM t.kv LIMIT 1
----
limit
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT COUNT((k, v)) FROM t.kv OFFSET 1
----
offset
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT COUNT(k)+COUNT(kv.v) FROM t.kv
----
project
 ├── columns: column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         ├── function: count [type=int]
 │         │    └── variable: kv.k [type=int]
 │         └── function: count [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: column5 [type=int]
           └── variable: column6 [type=int]

build
SELECT COUNT(NULL::int), COUNT((NULL, NULL))
----
group-by
 ├── columns: column2:2(int) column4:4(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(tuple{unknown, unknown})
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── null [type=unknown]
 │         └── tuple [type=tuple{unknown, unknown}]
 │              ├── null [type=unknown]
 │              └── null [type=unknown]
 └── aggregations
      ├── function: count [type=int]
      │    └── variable: column1 [type=int]
      └── function: count [type=int]
           └── variable: column3 [type=tuple{unknown, unknown}]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM t.kv
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column8:8(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: max [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: min [type=int]
      │    └── variable: kv.v [type=int]
      └── function: max [type=int]
           └── variable: kv.v [type=int]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM t.kv WHERE k > 8
----
group-by
 ├── columns: column5:5(int) column6:6(int) column7:7(int) column8:8(int)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── select
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── gt [type=bool]
 │    │         ├── variable: kv.k [type=int]
 │    │         └── const: 8 [type=int]
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: max [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: min [type=int]
      │    └── variable: kv.v [type=int]
      └── function: max [type=int]
           └── variable: kv.v [type=int]

build
SELECT ARRAY_AGG(k), ARRAY_AGG(s) FROM (SELECT k, s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(int[]) column6:6(string[])
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.s:4(string)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.s [type=string]
 └── aggregations
      ├── function: array_agg [type=int[]]
      │    └── variable: kv.k [type=int]
      └── function: array_agg [type=string[]]
           └── variable: kv.s [type=string]

build
SELECT array_agg(s) FROM t.kv WHERE s IS NULL
----
group-by
 ├── columns: column5:5(string[])
 ├── project
 │    ├── columns: kv.s:4(string)
 │    ├── select
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── is [type=bool]
 │    │         ├── variable: kv.s [type=string]
 │    │         └── null [type=unknown]
 │    └── projections
 │         └── variable: kv.s [type=string]
 └── aggregations
      └── function: array_agg [type=string[]]
           └── variable: kv.s [type=string]

build
SELECT AVG(k), AVG(v), SUM(k), SUM(v) FROM t.kv
----
group-by
 ├── columns: column5:5(decimal) column6:6(decimal) column7:7(decimal) column8:8(decimal)
 ├── project
 │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: avg [type=decimal]
      │    └── variable: kv.k [type=int]
      ├── function: avg [type=decimal]
      │    └── variable: kv.v [type=int]
      ├── function: sum [type=decimal]
      │    └── variable: kv.k [type=int]
      └── function: sum [type=decimal]
           └── variable: kv.v [type=int]

build
SELECT AVG(k::decimal), AVG(v::decimal), SUM(k::decimal), SUM(v::decimal) FROM kv
----
group-by
 ├── columns: column6:6(decimal) column8:8(decimal) column9:9(decimal) column10:10(decimal)
 ├── project
 │    ├── columns: column5:5(decimal) column7:7(decimal)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── cast: decimal [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── cast: decimal [type=decimal]
 │              └── variable: kv.v [type=int]
 └── aggregations
      ├── function: avg [type=decimal]
      │    └── variable: column5 [type=decimal]
      ├── function: avg [type=decimal]
      │    └── variable: column7 [type=decimal]
      ├── function: sum [type=decimal]
      │    └── variable: column5 [type=decimal]
      └── function: sum [type=decimal]
           └── variable: column7 [type=decimal]

build
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(decimal) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         ├── function: avg [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── function: max [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: column5 [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: decimal [type=decimal]
                └── variable: column6 [type=int]

build
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv WHERE w*2 = k
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(decimal) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int)
 │    │    ├── select
 │    │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    │    ├── scan kv
 │    │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    │    └── eq [type=bool]
 │    │    │         ├── mult [type=int]
 │    │    │         │    ├── variable: kv.w [type=int]
 │    │    │         │    └── const: 2 [type=int]
 │    │    │         └── variable: kv.k [type=int]
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         ├── function: avg [type=decimal]
 │         │    └── variable: kv.k [type=int]
 │         └── function: max [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: column5 [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: decimal [type=decimal]
                └── variable: column6 [type=int]

exec-ddl
CREATE TABLE t.abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----
TABLE abc
 ├── a string not null
 ├── b float
 ├── c bool
 ├── d decimal
 └── INDEX primary
      └── a string not null

build
SELECT MIN(a), MIN(b), MIN(c), MIN(d) FROM t.abc
----
group-by
 ├── columns: column5:5(string) column6:6(float) column7:7(bool) column8:8(decimal)
 ├── scan abc
 │    └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 └── aggregations
      ├── function: min [type=string]
      │    └── variable: abc.a [type=string]
      ├── function: min [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: min [type=bool]
      │    └── variable: abc.c [type=bool]
      └── function: min [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT MAX(a), MAX(b), MAX(c), MAX(d) FROM t.abc
----
group-by
 ├── columns: column5:5(string) column6:6(float) column7:7(bool) column8:8(decimal)
 ├── scan abc
 │    └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 └── aggregations
      ├── function: max [type=string]
      │    └── variable: abc.a [type=string]
      ├── function: max [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: max [type=bool]
      │    └── variable: abc.c [type=bool]
      └── function: max [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT AVG(b), SUM(b), AVG(d), SUM(d) FROM t.abc
----
group-by
 ├── columns: column5:5(float) column6:6(float) column7:7(decimal) column8:8(decimal)
 ├── project
 │    ├── columns: abc.b:2(float) abc.d:4(decimal)
 │    ├── scan abc
 │    │    └── columns: abc.a:1(string!null) abc.b:2(float) abc.c:3(bool) abc.d:4(decimal)
 │    └── projections
 │         ├── variable: abc.b [type=float]
 │         └── variable: abc.d [type=decimal]
 └── aggregations
      ├── function: avg [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: sum [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: avg [type=decimal]
      │    └── variable: abc.d [type=decimal]
      └── function: sum [type=decimal]
           └── variable: abc.d [type=decimal]

# Verify summing of intervals
exec-ddl
CREATE TABLE t.intervals (
  a INTERVAL PRIMARY KEY
)
----
TABLE intervals
 ├── a interval not null
 └── INDEX primary
      └── a interval not null

build
SELECT SUM(a) FROM t.intervals
----
group-by
 ├── columns: column2:2(interval)
 ├── scan intervals
 │    └── columns: intervals.a:1(interval!null)
 └── aggregations
      └── function: sum [type=interval]
           └── variable: intervals.a [type=interval]

build
SELECT AVG(a) FROM t.abc
----
error: unknown signature: avg(string)

build
SELECT AVG(c) FROM t.abc
----
error: unknown signature: avg(bool)

build
SELECT AVG((a,c)) FROM t.abc
----
error: unknown signature: avg(tuple{string, bool})

build
SELECT SUM(a) FROM t.abc
----
error: unknown signature: sum(string)

build
SELECT SUM(c) FROM t.abc
----
error: unknown signature: sum(bool)

build
SELECT SUM((a,c)) FROM t.abc
----
error: unknown signature: sum(tuple{string, bool})

exec-ddl
CREATE TABLE t.xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)
----
TABLE xyz
 ├── x int not null
 ├── y int
 ├── z float
 ├── INDEX primary
 │    └── x int not null
 ├── INDEX xy
 │    ├── x int not null
 │    └── y int
 └── INDEX zyx
      ├── z float
      ├── y int
      └── x int not null

build
SELECT MIN(x) FROM t.xyz
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MIN(x) FROM t.xyz WHERE x in (0, 4, 7)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── in [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── tuple [type=tuple{int, int, int}]
 │    │              ├── const: 0 [type=int]
 │    │              ├── const: 4 [type=int]
 │    │              └── const: 7 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM t.xyz
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(y) FROM t.xyz WHERE x = 1
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.y:2(int)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 1 [type=int]
 │    └── projections
 │         └── variable: xyz.y [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(y) FROM t.xyz WHERE x = 7
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.y:2(int)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 7 [type=int]
 │    └── projections
 │         └── variable: xyz.y [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(x) FROM t.xyz WHERE (y, z) = (2, 3.0)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── tuple [type=tuple{int, float}]
 │    │         │    ├── variable: xyz.y [type=int]
 │    │         │    └── variable: xyz.z [type=float]
 │    │         └── tuple [type=tuple{int, float}]
 │    │              ├── const: 2 [type=int]
 │    │              └── const: 3.0 [type=float]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM t.xyz WHERE (z, y) = (3.0, 2)
----
group-by
 ├── columns: column4:4(int)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── tuple [type=tuple{float, int}]
 │    │         │    ├── variable: xyz.z [type=float]
 │    │         │    └── variable: xyz.y [type=int]
 │    │         └── tuple [type=tuple{float, int}]
 │    │              ├── const: 3.0 [type=float]
 │    │              └── const: 2 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.x [type=int]


# VARIANCE/STDDEV

build
SELECT VARIANCE(x), VARIANCE(y::decimal), round(VARIANCE(z), 14) FROM xyz
----
project
 ├── columns: column4:4(decimal) column6:6(decimal) column8:8(float)
 ├── group-by
 │    ├── columns: column4:4(decimal) column6:6(decimal) column7:7(float)
 │    ├── project
 │    │    ├── columns: xyz.x:1(int!null) column5:5(decimal) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── projections
 │    │         ├── variable: xyz.x [type=int]
 │    │         ├── cast: decimal [type=decimal]
 │    │         │    └── variable: xyz.y [type=int]
 │    │         └── variable: xyz.z [type=float]
 │    └── aggregations
 │         ├── function: variance [type=decimal]
 │         │    └── variable: xyz.x [type=int]
 │         ├── function: variance [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── function: variance [type=float]
 │              └── variable: xyz.z [type=float]
 └── projections
      ├── variable: column4 [type=decimal]
      ├── variable: column6 [type=decimal]
      └── function: round [type=float]
           ├── variable: column7 [type=float]
           └── const: 14 [type=int]

build
SELECT VARIANCE(x) FROM t.xyz WHERE x = 10
----
group-by
 ├── columns: column4:4(decimal)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 10 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: variance [type=decimal]
           └── variable: xyz.x [type=int]

build
SELECT STDDEV(x), STDDEV(y::decimal), round(STDDEV(z), 14) FROM xyz
----
project
 ├── columns: column4:4(decimal) column6:6(decimal) column8:8(float)
 ├── group-by
 │    ├── columns: column4:4(decimal) column6:6(decimal) column7:7(float)
 │    ├── project
 │    │    ├── columns: xyz.x:1(int!null) column5:5(decimal) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── projections
 │    │         ├── variable: xyz.x [type=int]
 │    │         ├── cast: decimal [type=decimal]
 │    │         │    └── variable: xyz.y [type=int]
 │    │         └── variable: xyz.z [type=float]
 │    └── aggregations
 │         ├── function: stddev [type=decimal]
 │         │    └── variable: xyz.x [type=int]
 │         ├── function: stddev [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── function: stddev [type=float]
 │              └── variable: xyz.z [type=float]
 └── projections
      ├── variable: column4 [type=decimal]
      ├── variable: column6 [type=decimal]
      └── function: round [type=float]
           ├── variable: column7 [type=float]
           └── const: 14 [type=int]

build
SELECT STDDEV(x) FROM t.xyz WHERE x = 1
----
group-by
 ├── columns: column4:4(decimal)
 ├── project
 │    ├── columns: xyz.x:1(int!null)
 │    ├── select
 │    │    ├── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 1 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: stddev [type=decimal]
           └── variable: xyz.x [type=int]

build
SELECT AVG(1::int)::float, AVG(2::float)::float, AVG(3::decimal)::float
----
project
 ├── columns: column3:3(float) column6:6(float) column9:9(float)
 ├── group-by
 │    ├── columns: column2:2(decimal) column5:5(float) column8:8(decimal)
 │    ├── project
 │    │    ├── columns: column1:1(int) column4:4(float) column7:7(decimal)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple{}]
 │    │    └── projections
 │    │         ├── cast: int [type=int]
 │    │         │    └── const: 1 [type=int]
 │    │         ├── cast: float [type=float]
 │    │         │    └── const: 2.0 [type=float]
 │    │         └── cast: decimal [type=decimal]
 │    │              └── const: 3 [type=decimal]
 │    └── aggregations
 │         ├── function: avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── function: avg [type=float]
 │         │    └── variable: column4 [type=float]
 │         └── function: avg [type=decimal]
 │              └── variable: column7 [type=decimal]
 └── projections
      ├── cast: float [type=float]
      │    └── variable: column2 [type=decimal]
      ├── cast: float [type=float]
      │    └── variable: column5 [type=float]
      └── cast: float [type=float]
           └── variable: column8 [type=decimal]

build
SELECT COUNT(2::int), COUNT(3::float), COUNT(4::decimal)
----
group-by
 ├── columns: column2:2(int) column4:4(int) column6:6(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 2 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 3.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 4 [type=decimal]
 └── aggregations
      ├── function: count [type=int]
      │    └── variable: column1 [type=int]
      ├── function: count [type=int]
      │    └── variable: column3 [type=float]
      └── function: count [type=int]
           └── variable: column5 [type=decimal]

build
SELECT SUM(1::int), SUM(2::float), SUM(3::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 2.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 3 [type=decimal]
 └── aggregations
      ├── function: sum [type=decimal]
      │    └── variable: column1 [type=int]
      ├── function: sum [type=float]
      │    └── variable: column3 [type=float]
      └── function: sum [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT VARIANCE(1::int), VARIANCE(1::float), VARIANCE(1::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── function: variance [type=decimal]
      │    └── variable: column1 [type=int]
      ├── function: variance [type=float]
      │    └── variable: column3 [type=float]
      └── function: variance [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT STDDEV(1::int), STDDEV(1::float), STDDEV(1::decimal)
----
group-by
 ├── columns: column2:2(decimal) column4:4(float) column6:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         ├── cast: int [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: float [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: decimal [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── function: stddev [type=decimal]
      │    └── variable: column1 [type=int]
      ├── function: stddev [type=float]
      │    └── variable: column3 [type=float]
      └── function: stddev [type=decimal]
           └── variable: column5 [type=decimal]

# Ensure subqueries don't trigger aggregation.
build
SELECT x > (SELECT avg(0)) FROM xyz LIMIT 1
----
limit
 ├── columns: column6:6(bool)
 ├── project
 │    ├── columns: column6:6(bool)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── subquery [type=decimal]
 │                   ├── max1-row
 │                   │    ├── columns: column5:5(decimal)
 │                   │    └── group-by
 │                   │         ├── columns: column5:5(decimal)
 │                   │         ├── project
 │                   │         │    ├── columns: column4:4(int)
 │                   │         │    ├── values
 │                   │         │    │    └── tuple [type=tuple{}]
 │                   │         │    └── projections
 │                   │         │         └── const: 0 [type=int]
 │                   │         └── aggregations
 │                   │              └── function: avg [type=decimal]
 │                   │                   └── variable: column4 [type=int]
 │                   └── variable: column5 [type=decimal]
 └── const: 1 [type=int]

build
SELECT x > (SELECT avg(y) FROM xyz) FROM xyz LIMIT 1
----
limit
 ├── columns: column8:8(bool)
 ├── project
 │    ├── columns: column8:8(bool)
 │    ├── scan xyz
 │    │    └── columns: xyz.x:1(int!null) xyz.y:2(int) xyz.z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: xyz.x [type=int]
 │              └── subquery [type=decimal]
 │                   ├── max1-row
 │                   │    ├── columns: column7:7(decimal)
 │                   │    └── group-by
 │                   │         ├── columns: column7:7(decimal)
 │                   │         ├── project
 │                   │         │    ├── columns: xyz.y:5(int)
 │                   │         │    ├── scan xyz
 │                   │         │    │    └── columns: xyz.x:4(int!null) xyz.y:5(int) xyz.z:6(float)
 │                   │         │    └── projections
 │                   │         │         └── variable: xyz.y [type=int]
 │                   │         └── aggregations
 │                   │              └── function: avg [type=decimal]
 │                   │                   └── variable: xyz.y [type=int]
 │                   └── variable: column7 [type=decimal]
 └── const: 1 [type=int]

exec-ddl
CREATE TABLE t.bools (b BOOL)
----
TABLE bools
 ├── b bool
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT BOOL_AND(b), BOOL_OR(b) FROM t.bools
----
group-by
 ├── columns: column3:3(bool) column4:4(bool)
 ├── project
 │    ├── columns: bools.b:1(bool)
 │    ├── scan bools
 │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │    └── projections
 │         └── variable: bools.b [type=bool]
 └── aggregations
      ├── function: bool_and [type=bool]
      │    └── variable: bools.b [type=bool]
      └── function: bool_or [type=bool]
           └── variable: bools.b [type=bool]


# Tests with * inside GROUP BY.
build
SELECT 1 FROM t.kv GROUP BY kv.*;
----
project
 ├── columns: column5:5(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    ├── grouping columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── aggregations
 └── projections
      └── const: 1 [type=int]

exec-ddl
CREATE TABLE t.xor_bytes (a bytes, b int, c int)
----
TABLE xor_bytes
 ├── a bytes
 ├── b int
 ├── c int
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT TO_HEX(XOR_AGG(a)), XOR_AGG(c) FROM t.xor_bytes
----
project
 ├── columns: column6:6(string) column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(bytes) column7:7(int)
 │    ├── project
 │    │    ├── columns: xor_bytes.a:1(bytes) xor_bytes.c:3(int)
 │    │    ├── scan xor_bytes
 │    │    │    └── columns: xor_bytes.a:1(bytes) xor_bytes.b:2(int) xor_bytes.c:3(int) xor_bytes.rowid:4(int!null)
 │    │    └── projections
 │    │         ├── variable: xor_bytes.a [type=bytes]
 │    │         └── variable: xor_bytes.c [type=int]
 │    └── aggregations
 │         ├── function: xor_agg [type=bytes]
 │         │    └── variable: xor_bytes.a [type=bytes]
 │         └── function: xor_agg [type=int]
 │              └── variable: xor_bytes.c [type=int]
 └── projections
      ├── function: to_hex [type=string]
      │    └── variable: column5 [type=bytes]
      └── variable: column7 [type=int]

build
SELECT TO_HEX(XOR_AGG(a)), b, XOR_AGG(c) FROM xor_bytes GROUP BY b ORDER BY b
----
sort
 ├── columns: column6:6(string) b:2(int) column7:7(int)
 ├── ordering: +2
 └── project
      ├── columns: column6:6(string) xor_bytes.b:2(int) column7:7(int)
      ├── group-by
      │    ├── columns: xor_bytes.b:2(int) column5:5(bytes) column7:7(int)
      │    ├── grouping columns: xor_bytes.b:2(int)
      │    ├── project
      │    │    ├── columns: xor_bytes.b:2(int) xor_bytes.a:1(bytes) xor_bytes.c:3(int)
      │    │    ├── scan xor_bytes
      │    │    │    └── columns: xor_bytes.a:1(bytes) xor_bytes.b:2(int) xor_bytes.c:3(int) xor_bytes.rowid:4(int!null)
      │    │    └── projections
      │    │         ├── variable: xor_bytes.b [type=int]
      │    │         ├── variable: xor_bytes.a [type=bytes]
      │    │         └── variable: xor_bytes.c [type=int]
      │    └── aggregations
      │         ├── function: xor_agg [type=bytes]
      │         │    └── variable: xor_bytes.a [type=bytes]
      │         └── function: xor_agg [type=int]
      │              └── variable: xor_bytes.c [type=int]
      └── projections
           ├── function: to_hex [type=string]
           │    └── variable: column5 [type=bytes]
           ├── variable: xor_bytes.b [type=int]
           └── variable: column7 [type=int]

# At execution time, this query will cause the error:
# "arguments to xor must all be the same length"
build
SELECT XOR_AGG(i) FROM (VALUES (b'\x01'), (b'\x01\x01')) AS a(i)
----
group-by
 ├── columns: column2:2(bytes)
 ├── values
 │    ├── columns: column1:1(bytes)
 │    ├── tuple [type=tuple{bytes}]
 │    │    └── const: '\x01' [type=bytes]
 │    └── tuple [type=tuple{bytes}]
 │         └── const: '\x0101' [type=bytes]
 └── aggregations
      └── function: xor_agg [type=bytes]
           └── variable: column1 [type=bytes]

build
SELECT MAX(true), MIN(true)
----
group-by
 ├── columns: column2:2(bool) column3:3(bool)
 ├── project
 │    ├── columns: column1:1(bool)
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── true [type=bool]
 └── aggregations
      ├── function: max [type=bool]
      │    └── variable: column1 [type=bool]
      └── function: min [type=bool]
           └── variable: column1 [type=bool]

build
SELECT CONCAT_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(string)
 ├── project
 │    ├── columns: kv.s:4(string) kv.k:1(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.s [type=string]
 │         └── variable: kv.k [type=int]
 └── aggregations
      └── function: concat_agg [type=string]
           └── variable: kv.s [type=string]

build
SELECT JSON_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.s:4(string) kv.k:1(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.s [type=string]
 │         └── variable: kv.k [type=int]
 └── aggregations
      └── function: json_agg [type=jsonb]
           └── variable: kv.s [type=string]

build
SELECT JSONB_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group-by
 ├── columns: column5:5(jsonb)
 ├── project
 │    ├── columns: kv.s:4(string) kv.k:1(int!null)
 │    ├── scan kv
 │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    └── projections
 │         ├── variable: kv.s [type=string]
 │         └── variable: kv.k [type=int]
 └── aggregations
      └── function: jsonb_agg [type=jsonb]
           └── variable: kv.s [type=string]

exec-ddl
CREATE TABLE t.ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)
----
TABLE ab
 ├── a int not null
 ├── b int
 └── INDEX primary
      └── a int not null

exec-ddl
CREATE TABLE t.xy(x STRING, y STRING);
----
TABLE xy
 ├── x string
 ├── y string
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

# Grouping and rendering tuples.
build
SELECT (b, a) FROM t.ab GROUP BY (b, a)
----
project
 ├── columns: column3:3(tuple{int, int})
 ├── group-by
 │    ├── columns: ab.a:1(int!null) ab.b:2(int)
 │    ├── grouping columns: ab.a:1(int!null) ab.b:2(int)
 │    ├── project
 │    │    ├── columns: ab.b:2(int) ab.a:1(int!null)
 │    │    ├── scan ab
 │    │    │    └── columns: ab.a:1(int!null) ab.b:2(int)
 │    │    └── projections
 │    │         ├── variable: ab.b [type=int]
 │    │         └── variable: ab.a [type=int]
 │    └── aggregations
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT MIN(y), (b, a)
 FROM t.ab, t.xy GROUP BY (x, (a, b))
----
project
 ├── columns: column6:6(string) column7:7(tuple{int, int})
 ├── group-by
 │    ├── columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string) column6:6(string)
 │    ├── grouping columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string)
 │    ├── project
 │    │    ├── columns: xy.x:3(string) ab.a:1(int!null) ab.b:2(int) xy.y:4(string)
 │    │    ├── inner-join
 │    │    │    ├── columns: ab.a:1(int!null) ab.b:2(int) xy.x:3(string) xy.y:4(string) xy.rowid:5(int!null)
 │    │    │    ├── scan ab
 │    │    │    │    └── columns: ab.a:1(int!null) ab.b:2(int)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: xy.x:3(string) xy.y:4(string) xy.rowid:5(int!null)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── variable: xy.x [type=string]
 │    │         ├── variable: ab.a [type=int]
 │    │         ├── variable: ab.b [type=int]
 │    │         └── variable: xy.y [type=string]
 │    └── aggregations
 │         └── function: min [type=string]
 │              └── variable: xy.y [type=string]
 └── projections
      ├── variable: column6 [type=string]
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) kv.k:1(int!null)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── variable: kv.k [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: kv.k [type=int]

build
SELECT v, COUNT(*) FROM kv GROUP BY v ORDER BY COUNT(*)
----
sort
 ├── columns: v:2(int) column5:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: kv.v:2(int) column5:5(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         └── variable: kv.v [type=int]
      └── aggregations
           └── function: count_rows [type=int]

build
SELECT v, COUNT(1) FROM kv GROUP BY v ORDER BY COUNT(1)
----
sort
 ├── columns: v:2(int) column6:6(int)
 ├── ordering: +6
 └── group-by
      ├── columns: kv.v:2(int) column6:6(int)
      ├── grouping columns: kv.v:2(int)
      ├── project
      │    ├── columns: kv.v:2(int) column5:5(int)
      │    ├── scan kv
      │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
      │    └── projections
      │         ├── variable: kv.v [type=int]
      │         └── const: 1 [type=int]
      └── aggregations
           └── function: count [type=int]
                └── variable: column5 [type=int]

build
SELECT (k+v)/(v+w) FROM t.kv GROUP BY k+v, v+w;
----
project
 ├── columns: column7:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int) column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) column6:6(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.v [type=int]
 │    │         └── plus [type=int]
 │    │              ├── variable: kv.v [type=int]
 │    │              └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── div [type=decimal]
           ├── plus [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.v [type=int]
           └── plus [type=int]
                ├── variable: kv.v [type=int]
                └── variable: kv.w [type=int]

# Check that everything still works with differently qualified names
build
SELECT SUM(t.kv.w), t.kv.v FROM t.kv GROUP BY v, kv.k * w
----
project
 ├── columns: column6:6(decimal) v:2(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(int) column6:6(decimal)
 │    ├── grouping columns: kv.v:2(int) column5:5(int)
 │    ├── project
 │    │    ├── columns: kv.v:2(int) column5:5(int) kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── mult [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: sum [type=decimal]
 │              └── variable: kv.w [type=int]
 └── projections
      ├── variable: column6 [type=decimal]
      └── variable: kv.v [type=int]

build
SELECT SUM(t.kv.w), LOWER(s), t.kv.v + k * t.kv.w, t.kv.v FROM t.kv GROUP BY v, LOWER(kv.s), kv.k * w
----
project
 ├── columns: column7:7(decimal) column5:5(string) column8:8(int) v:2(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(string) column6:6(int) column7:7(decimal)
 │    ├── grouping columns: kv.v:2(int) column5:5(string) column6:6(int)
 │    ├── project
 │    │    ├── columns: kv.v:2(int) column5:5(string) column6:6(int) kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── function: lower [type=string]
 │    │         │    └── variable: kv.s [type=string]
 │    │         ├── mult [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: sum [type=decimal]
 │              └── variable: kv.w [type=int]
 └── projections
      ├── variable: column7 [type=decimal]
      ├── variable: column5 [type=string]
      ├── plus [type=int]
      │    ├── variable: kv.v [type=int]
      │    └── mult [type=int]
      │         ├── variable: kv.k [type=int]
      │         └── variable: kv.w [type=int]
      └── variable: kv.v [type=int]

# Check all the different types of scalar expressions as group by columns
build
SELECT b1.b AND abc.c AND b2.b FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
project
 ├── columns: column10:10(bool)
 ├── group-by
 │    ├── columns: bools.b:3(bool) column9:9(bool)
 │    ├── grouping columns: bools.b:3(bool) column9:9(bool)
 │    ├── project
 │    │    ├── columns: column9:9(bool) bools.b:3(bool)
 │    │    ├── inner-join
 │    │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    ├── inner-join
 │    │    │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null)
 │    │    │    │    ├── scan bools
 │    │    │    │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │    │    │    │    ├── scan bools
 │    │    │    │    │    └── columns: bools.b:3(bool) bools.rowid:4(int!null)
 │    │    │    │    └── true [type=bool]
 │    │    │    ├── scan abc
 │    │    │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── and [type=bool]
 │    │         │    ├── variable: bools.b [type=bool]
 │    │         │    └── variable: abc.c [type=bool]
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── and [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b AND abc.c AND abc.c FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b1.b OR abc.c OR b2.b FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
project
 ├── columns: column10:10(bool)
 ├── group-by
 │    ├── columns: bools.b:3(bool) column9:9(bool)
 │    ├── grouping columns: bools.b:3(bool) column9:9(bool)
 │    ├── project
 │    │    ├── columns: column9:9(bool) bools.b:3(bool)
 │    │    ├── inner-join
 │    │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    ├── inner-join
 │    │    │    │    ├── columns: bools.b:1(bool) bools.rowid:2(int!null) bools.b:3(bool) bools.rowid:4(int!null)
 │    │    │    │    ├── scan bools
 │    │    │    │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │    │    │    │    ├── scan bools
 │    │    │    │    │    └── columns: bools.b:3(bool) bools.rowid:4(int!null)
 │    │    │    │    └── true [type=bool]
 │    │    │    ├── scan abc
 │    │    │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── or [type=bool]
 │    │         │    ├── variable: bools.b [type=bool]
 │    │         │    └── variable: abc.c [type=bool]
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── or [type=bool]
           ├── or [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b OR abc.c OR abc.c FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k % w % v FROM kv GROUP BY k % w, v
----
project
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(int)
 │    ├── grouping columns: kv.v:2(int) column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── mod [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── mod [type=int]
           ├── mod [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── variable: kv.v [type=int]

build
SELECT CONCAT(CONCAT(s, a), a) FROM kv, abc GROUP BY CONCAT(s, a), a
----
project
 ├── columns: column10:10(string)
 ├── group-by
 │    ├── columns: abc.a:5(string!null) column9:9(string)
 │    ├── grouping columns: abc.a:5(string!null) column9:9(string)
 │    ├── project
 │    │    ├── columns: column9:9(string) abc.a:5(string!null)
 │    │    ├── inner-join
 │    │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    ├── scan kv
 │    │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    │    ├── scan abc
 │    │    │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── function: concat [type=string]
 │    │         │    ├── variable: kv.s [type=string]
 │    │         │    └── variable: abc.a [type=string]
 │    │         └── variable: abc.a [type=string]
 │    └── aggregations
 └── projections
      └── function: concat [type=string]
           ├── function: concat [type=string]
           │    ├── variable: kv.s [type=string]
           │    └── variable: abc.a [type=string]
           └── variable: abc.a [type=string]

build
SELECT CONCAT(CONCAT(s, a), s) FROM kv, abc GROUP BY CONCAT(s, a), a
----
error: column "kv.s" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k < w AND v != 5 FROM kv GROUP BY k < w, v
----
project
 ├── columns: column6:6(bool)
 ├── group-by
 │    ├── columns: kv.v:2(int) column5:5(bool)
 │    ├── grouping columns: kv.v:2(int) column5:5(bool)
 │    ├── project
 │    │    ├── columns: column5:5(bool) kv.v:2(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── lt [type=bool]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── lt [type=bool]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── ne [type=bool]
                ├── variable: kv.v [type=int]
                └── const: 5 [type=int]

build
SELECT k < w AND k < v FROM kv GROUP BY k < w, v
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

exec-ddl
CREATE TABLE foo (bar JSON, baz JSON)
----
TABLE foo
 ├── bar jsonb
 ├── baz jsonb
 ├── rowid int not null (hidden)
 └── INDEX primary
      └── rowid int not null (hidden)

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY a.bar @> b.baz, b.baz
----
project
 ├── columns: column8:8(bool)
 ├── group-by
 │    ├── columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── project
 │    │    ├── columns: column7:7(bool) foo.baz:5(jsonb)
 │    │    ├── inner-join
 │    │    │    ├── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null) foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │    │    │    ├── scan foo
 │    │    │    │    └── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null)
 │    │    │    ├── scan foo
 │    │    │    │    └── columns: foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── contains [type=bool]
 │    │         │    ├── variable: foo.bar [type=jsonb]
 │    │         │    └── variable: foo.baz [type=jsonb]
 │    │         └── variable: foo.baz [type=jsonb]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
error: column "foo.bar" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b.baz <@ a.bar AND b.baz <@ b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
project
 ├── columns: column8:8(bool)
 ├── group-by
 │    ├── columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: foo.baz:5(jsonb) column7:7(bool)
 │    ├── project
 │    │    ├── columns: column7:7(bool) foo.baz:5(jsonb)
 │    │    ├── inner-join
 │    │    │    ├── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null) foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │    │    │    ├── scan foo
 │    │    │    │    └── columns: foo.bar:1(jsonb) foo.baz:2(jsonb) foo.rowid:3(int!null)
 │    │    │    ├── scan foo
 │    │    │    │    └── columns: foo.bar:4(jsonb) foo.baz:5(jsonb) foo.rowid:6(int!null)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── contains [type=bool]
 │    │         │    ├── variable: foo.bar [type=jsonb]
 │    │         │    └── variable: foo.baz [type=jsonb]
 │    │         └── variable: foo.baz [type=jsonb]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

exec-ddl
CREATE TABLE times (t time PRIMARY KEY)
----
TABLE times
 ├── t time not null
 └── INDEX primary
      └── t time not null

build
SELECT date_trunc('second', a.t) - date_trunc('minute', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
project
 ├── columns: column5:5(interval)
 ├── group-by
 │    ├── columns: column3:3(interval) column4:4(interval)
 │    ├── grouping columns: column3:3(interval) column4:4(interval)
 │    ├── project
 │    │    ├── columns: column3:3(interval) column4:4(interval)
 │    │    ├── inner-join
 │    │    │    ├── columns: times.t:1(time!null) times.t:2(time!null)
 │    │    │    ├── scan times
 │    │    │    │    └── columns: times.t:1(time!null)
 │    │    │    ├── scan times
 │    │    │    │    └── columns: times.t:2(time!null)
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── function: date_trunc [type=interval]
 │    │         │    ├── const: 'second' [type=string]
 │    │         │    └── variable: times.t [type=time]
 │    │         └── function: date_trunc [type=interval]
 │    │              ├── const: 'minute' [type=string]
 │    │              └── variable: times.t [type=time]
 │    └── aggregations
 └── projections
      └── minus [type=interval]
           ├── function: date_trunc [type=interval]
           │    ├── const: 'second' [type=string]
           │    └── variable: times.t [type=time]
           └── function: date_trunc [type=interval]
                ├── const: 'minute' [type=string]
                └── variable: times.t [type=time]

build
SELECT date_trunc('second', a.t) - date_trunc('second', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
error: column "times.t" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY NOT b
----
group-by
 ├── columns: column3:3(bool)
 ├── grouping columns: column3:3(bool)
 ├── project
 │    ├── columns: column3:3(bool)
 │    ├── scan bools
 │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │    └── projections
 │         └── not [type=bool]
 │              └── variable: bools.b [type=bool]
 └── aggregations

build
SELECT b FROM bools GROUP BY NOT b
----
error: column "bools.b" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY b
----
project
 ├── columns: column3:3(bool)
 ├── group-by
 │    ├── columns: bools.b:1(bool)
 │    ├── grouping columns: bools.b:1(bool)
 │    ├── project
 │    │    ├── columns: bools.b:1(bool)
 │    │    ├── scan bools
 │    │    │    └── columns: bools.b:1(bool) bools.rowid:2(int!null)
 │    │    └── projections
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── not [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT +k * (-w) FROM kv GROUP BY +k, -w
----
project
 ├── columns: column7:7(int)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int) column6:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) column6:6(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── unary-minus [type=int]
 │    │              └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── mult [type=int]
           ├── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build
SELECT k * (-w) FROM kv GROUP BY +k, -w
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT +k * (-w) FROM kv GROUP BY k, w
----
project
 ├── columns: column5:5(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.w:3(int)
 │    ├── grouping columns: kv.k:1(int!null) kv.w:3(int)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.w:3(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── mult [type=int]
           ├── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build 
SELECT 1 + MIN(v*2) FROM kv GROUP BY k+3
----
project
 ├── columns: column8:8(int)
 ├── group-by
 │    ├── columns: column5:5(int) column7:7(int)
 │    ├── grouping columns: column5:5(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) column6:6(int)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── const: 3 [type=int]
 │    │         └── mult [type=int]
 │    │              ├── variable: kv.v [type=int]
 │    │              └── const: 2 [type=int]
 │    └── aggregations
 │         └── function: min [type=int]
 │              └── variable: column6 [type=int]
 └── projections
      └── plus [type=int]
           ├── const: 1 [type=int]
           └── variable: column7 [type=int]

build
SELECT count(*) FROM kv GROUP BY k, k
----
project
 ├── columns: column5:5(int)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) column5:5(int)
 │    ├── grouping columns: kv.k:1(int!null)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      └── variable: column5 [type=int]

build
SELECT COUNT(UPPER(s)) FROM t.kv GROUP BY UPPER(s)
----
project
 ├── columns: column6:6(int)
 ├── group-by
 │    ├── columns: column5:5(string) column6:6(int)
 │    ├── grouping columns: column5:5(string)
 │    ├── project
 │    │    ├── columns: column5:5(string)
 │    │    ├── scan kv
 │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         └── function: upper [type=string]
 │    │              └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count [type=int]
 │              └── variable: column5 [type=string]
 └── projections
      └── variable: column6 [type=int]

build
SELECT SUM(abc.d) FROM t.kv JOIN t.abc ON kv.k >= abc.d GROUP BY kv.*
----
project
 ├── columns: column9:9(decimal)
 ├── group-by
 │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) column9:9(decimal)
 │    ├── grouping columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    ├── project
 │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.d:8(decimal)
 │    │    ├── inner-join
 │    │    │    ├── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string) abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    ├── scan kv
 │    │    │    │    └── columns: kv.k:1(int!null) kv.v:2(int) kv.w:3(int) kv.s:4(string)
 │    │    │    ├── scan abc
 │    │    │    │    └── columns: abc.a:5(string!null) abc.b:6(float) abc.c:7(bool) abc.d:8(decimal)
 │    │    │    └── ge [type=bool]
 │    │    │         ├── variable: kv.k [type=int]
 │    │    │         └── variable: abc.d [type=decimal]
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── variable: kv.w [type=int]
 │    │         ├── variable: kv.s [type=string]
 │    │         └── variable: abc.d [type=decimal]
 │    └── aggregations
 │         └── function: sum [type=decimal]
 │              └── variable: abc.d [type=decimal]
 └── projections
      └── variable: column9 [type=decimal]
