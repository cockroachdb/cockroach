# tests adapted from logictest -- aggregate

exec-ddl
CREATE TABLE t.kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----
table kv
  k int NOT NULL
  v int NULL
  w int NULL
  s string NULL

build
SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1),
  VARIANCE(1), BOOL_AND(true), BOOL_AND(false), XOR_AGG(b'\x01') FROM t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5 column6:int:null:6 column7:int:null:7 column8:int:null:8 column9:decimal:null:9 column10:decimal:null:10 column11:decimal:null:11 column12:decimal:null:12 column13:bool:null:13 column14:bool:null:14 column15:bytes:null:15
 ├── project
 │    ├── columns: column16:int:null:16 column17:int:null:17 column18:int:null:18 column19:int:null:19 column20:int:null:20 column21:int:null:21 column22:int:null:22 column23:int:null:23 column24:bool:null:24 column25:bool:null:25 column26:bytes:null:26
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── const: 1 [type=int]
 │         ├── true [type=bool]
 │         ├── false [type=bool]
 │         └── const: '\x01' [type=bytes]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: column16 [type=int]
      ├── function: max [type=int]
      │    └── variable: column17 [type=int]
      ├── function: count [type=int]
      │    └── variable: column18 [type=int]
      ├── function: sum_int [type=int]
      │    └── variable: column19 [type=int]
      ├── function: avg [type=decimal]
      │    └── variable: column20 [type=int]
      ├── function: sum [type=decimal]
      │    └── variable: column21 [type=int]
      ├── function: stddev [type=decimal]
      │    └── variable: column22 [type=int]
      ├── function: variance [type=decimal]
      │    └── variable: column23 [type=int]
      ├── function: bool_and [type=bool]
      │    └── variable: column24 [type=bool]
      ├── function: bool_and [type=bool]
      │    └── variable: column25 [type=bool]
      └── function: xor_agg [type=bytes]
           └── variable: column26 [type=bytes]

build
SELECT ARRAY_AGG(1) FROM t.kv
----
group-by
 ├── aggregation columns: column5:int[]:null:5
 ├── project
 │    ├── columns: column6:int:null:6
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: array_agg [type=int[]]
           └── variable: column6 [type=int]

build
SELECT JSON_AGG(v) FROM t.kv
----
group-by
 ├── aggregation columns: column5:jsonb:null:5
 ├── project
 │    ├── columns: kv.v:int:null:2
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         └── variable: kv.v [type=int]
 └── aggregations
      └── function: json_agg [type=jsonb]
           └── variable: kv.v [type=int]

build
SELECT JSONB_AGG(1)
----
group-by
 ├── aggregation columns: column1:jsonb:null:1
 ├── project
 │    ├── columns: column2:int:null:2
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: jsonb_agg [type=jsonb]
           └── variable: column2 [type=int]

# Even with no aggregate functions, grouping occurs in the presence of GROUP BY.
build
SELECT 1 FROM t.kv GROUP BY v
----
project
 ├── columns: column5:int:null:5
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2
 │    ├── project
 │    │    ├── columns: kv.v:int:null:2
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── const: 1 [type=int]

build
SELECT COUNT(*), k FROM t.kv
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*) FROM t.kv GROUP BY s < 5
----
error: unsupported comparison operator: <string> < <int>

build
SELECT COUNT(*), k FROM t.kv GROUP BY k
----
project
 ├── columns: column5:int:null:5 kv.k:int:null:1
 ├── group-by
 │    ├── grouping columns: kv.k:int:null:1
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.k:int:1
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.k [type=int]

# GROUP BY specified using column index works.
build
SELECT COUNT(*), k FROM t.kv GROUP BY 2
----
project
 ├── columns: column5:int:null:5 kv.k:int:null:1
 ├── group-by
 │    ├── grouping columns: kv.k:int:null:1
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.k:int:1
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.k [type=int]

build
SELECT COUNT(*), k FROM t.kv GROUP BY 5
----
error: GROUP BY position 5 is not in select list

build
SELECT COUNT(*), k FROM t.kv GROUP BY 0
----
error: GROUP BY position 0 is not in select list

build
SELECT 1 GROUP BY 'a'
----
error: non-integer constant in GROUP BY: 'a'

# Qualifying a name in the SELECT, the GROUP BY, both or neither should not affect validation.
build
SELECT COUNT(*), kv.s FROM t.kv GROUP BY s
----
project
 ├── columns: column5:int:null:5 kv.s:string:null:4
 ├── group-by
 │    ├── grouping columns: kv.s:string:null:4
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), s FROM t.kv GROUP BY kv.s
----
project
 ├── columns: column5:int:null:5 kv.s:string:null:4
 ├── group-by
 │    ├── grouping columns: kv.s:string:null:4
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), kv.s FROM t.kv GROUP BY kv.s
----
project
 ├── columns: column5:int:null:5 kv.s:string:null:4
 ├── group-by
 │    ├── grouping columns: kv.s:string:null:4
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

build
SELECT COUNT(*), s FROM t.kv GROUP BY s
----
project
 ├── columns: column5:int:null:5 kv.s:string:null:4
 ├── group-by
 │    ├── grouping columns: kv.s:string:null:4
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── variable: kv.s [type=string]

# Grouping by more than one column works.
build
SELECT v, COUNT(*), w FROM t.kv GROUP BY v, w
----
project
 ├── columns: kv.v:int:null:2 column5:int:null:5 kv.w:int:null:3
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 kv.w:int:null:3
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.v:int:null:2 kv.w:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: kv.v [type=int]
      ├── variable: column5 [type=int]
      └── variable: kv.w [type=int]

# Grouping by more than one column using column numbers works.
build
SELECT v, COUNT(*), w FROM t.kv GROUP BY 1, 3
----
project
 ├── columns: kv.v:int:null:2 column5:int:null:5 kv.w:int:null:3
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 kv.w:int:null:3
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.v:int:null:2 kv.w:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: kv.v [type=int]
      ├── variable: column5 [type=int]
      └── variable: kv.w [type=int]

# Selecting and grouping on a function expression works.
build
SELECT COUNT(*), UPPER(s) FROM t.kv GROUP BY UPPER(s)
----
project
 ├── columns: column6:int:null:6 column5:string:null:5
 ├── group-by
 │    ├── grouping columns: column5:string:null:5
 │    ├── aggregation columns: column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:string:null:5
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── function: upper [type=string]
 │    │              └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column6 [type=int]
      └── variable: column5 [type=string]

# Selecting and grouping on a constant works.
build
SELECT COUNT(*) FROM t.kv GROUP BY 1+2
----
project
 ├── columns: column6:int:null:6
 ├── group-by
 │    ├── grouping columns: column5:int:null:5
 │    ├── aggregation columns: column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── const: 3 [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      └── variable: column6 [type=int]

build
SELECT COUNT(*) FROM t.kv GROUP BY length('abc')
----
project
 ├── columns: column6:int:null:6
 ├── group-by
 │    ├── grouping columns: column5:int:null:5
 │    ├── aggregation columns: column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── function: length [type=int]
 │    │              └── const: 'abc' [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      └── variable: column6 [type=int]

# Selecting a function of something which is grouped works.
build
SELECT COUNT(*), UPPER(s) FROM t.kv GROUP BY s
----
project
 ├── columns: column5:int:null:5 column6:string:null:6
 ├── group-by
 │    ├── grouping columns: kv.s:string:null:4
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── variable: kv.s [type=string]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── function: upper [type=string]
           └── variable: kv.s [type=string]

# Selecting a value that is not grouped, even if a function of it it, does not work.
build
SELECT COUNT(*), s FROM t.kv GROUP BY UPPER(s)
----
error: column "kv.s" must appear in the GROUP BY clause or be used in an aggregate function

# Selecting and grouping on a more complex expression works.
build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k+v
----
project
 ├── columns: column6:int:null:6 column5:int:null:5
 ├── group-by
 │    ├── grouping columns: column5:int:null:5
 │    ├── aggregation columns: column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         └── plus [type=int]
 │    │              ├── variable: kv.k [type=int]
 │    │              └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column6 [type=int]
      └── variable: column5 [type=int]


# Selecting a more complex expression, made up of things which are each grouped, works.
build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k, v
----
project
 ├── columns: column5:int:null:5 column6:int:null:6
 ├── group-by
 │    ├── grouping columns: kv.k:int:null:1 kv.v:int:null:2
 │    ├── aggregation columns: column5:int:null:5
 │    ├── project
 │    │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         └── function: count_rows [type=int]
 └── projections
      ├── variable: column5 [type=int]
      └── plus [type=int]
           ├── variable: kv.k [type=int]
           └── variable: kv.v [type=int]

build
SELECT COUNT(*), k+v FROM t.kv GROUP BY k
----
error: column "kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), k+v FROM t.kv GROUP BY v
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT COUNT(*), v/(k+v) FROM t.kv GROUP BY k+v
----
error: column "kv.v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k FROM t.kv WHERE AVG(k) > 1
----
error: aggregate function is not allowed in this context

build
SELECT MAX(AVG(k)) FROM t.kv
----
error: aggregate function cannot be nested within another aggregate function

# Test case from #2761.
build
SELECT count(kv.k) AS count_1, kv.v + kv.w AS lx FROM t.kv GROUP BY kv.v + kv.w
----
project
 ├── columns: count_1:int:null:6 column5:int:null:5
 ├── group-by
 │    ├── grouping columns: column5:int:null:5
 │    ├── aggregation columns: count_1:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5 kv.k:int:1
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.v [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.k [type=int]
 │    └── aggregations
 │         └── function: count [type=int]
 │              └── variable: kv.k [type=int]
 └── projections
      ├── variable: count_1 [type=int]
      └── variable: column5 [type=int]

build
SELECT COUNT(*)
----
group-by
 ├── aggregation columns: column1:int:null:1
 ├── values
 │    └── tuple [type=tuple{}]
 └── aggregations
      └── function: count_rows [type=int]

build
SELECT COUNT(k) from t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5
 ├── project
 │    ├── columns: kv.k:int:1
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         └── variable: kv.k [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: kv.k [type=int]

build
SELECT COUNT(1)
----
group-by
 ├── aggregation columns: column1:int:null:1
 ├── project
 │    ├── columns: column2:int:null:2
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: column2 [type=int]

build
SELECT COUNT(1) from t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5
 ├── project
 │    ├── columns: column6:int:null:6
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: column6 [type=int]

build
SELECT COUNT(k, v) FROM t.kv
----
error: unknown signature: count(int, int)

build
SELECT COUNT(*), COUNT(k), COUNT(kv.v) FROM t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5 column6:int:null:6 column7:int:null:7
 ├── project
 │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: count_rows [type=int]
      ├── function: count [type=int]
      │    └── variable: kv.k [type=int]
      └── function: count [type=int]
           └── variable: kv.v [type=int]

# TODO(rytaft): This should work once we add support for the AllColumnSelector.
build
SELECT COUNT(kv.*) FROM t.kv
----
error: count(): cannot use "kv.*" in this context

build
SELECT COUNT((k, v)) FROM t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5
 ├── project
 │    ├── columns: column6:tuple{int, int}:null:6
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         └── tuple [type=tuple{int, int}]
 │              ├── variable: kv.k [type=int]
 │              └── variable: kv.v [type=int]
 └── aggregations
      └── function: count [type=int]
           └── variable: column6 [type=tuple{int, int}]

build
SELECT COUNT(k)+COUNT(kv.v) FROM t.kv
----
project
 ├── columns: column7:int:null:7
 ├── group-by
 │    ├── aggregation columns: column5:int:null:5 column6:int:null:6
 │    ├── project
 │    │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 │         ├── function: count [type=int]
 │         │    └── variable: kv.k [type=int]
 │         └── function: count [type=int]
 │              └── variable: kv.v [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: column5 [type=int]
           └── variable: column6 [type=int]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM t.kv
----
group-by
 ├── aggregation columns: column5:int:null:5 column6:int:null:6 column7:int:null:7 column8:int:null:8
 ├── project
 │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: max [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: min [type=int]
      │    └── variable: kv.v [type=int]
      └── function: max [type=int]
           └── variable: kv.v [type=int]

build
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM t.kv WHERE k > 8
----
group-by
 ├── aggregation columns: column5:int:null:5 column6:int:null:6 column7:int:null:7 column8:int:null:8
 ├── project
 │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    ├── select
 │    │    ├── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── gt [type=bool]
 │    │         ├── variable: kv.k [type=int]
 │    │         └── const: 8 [type=int]
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: min [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: max [type=int]
      │    └── variable: kv.k [type=int]
      ├── function: min [type=int]
      │    └── variable: kv.v [type=int]
      └── function: max [type=int]
           └── variable: kv.v [type=int]

build
SELECT array_agg(s) FROM t.kv WHERE s IS NULL
----
group-by
 ├── aggregation columns: column5:string[]:null:5
 ├── project
 │    ├── columns: kv.s:string:null:4
 │    ├── select
 │    │    ├── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── is [type=bool]
 │    │         ├── variable: kv.s [type=string]
 │    │         └── const: NULL [type=NULL]
 │    └── projections
 │         └── variable: kv.s [type=string]
 └── aggregations
      └── function: array_agg [type=string[]]
           └── variable: kv.s [type=string]

build
SELECT AVG(k), AVG(v), SUM(k), SUM(v) FROM t.kv
----
group-by
 ├── aggregation columns: column5:decimal:null:5 column6:decimal:null:6 column7:decimal:null:7 column8:decimal:null:8
 ├── project
 │    ├── columns: kv.k:int:1 kv.v:int:null:2
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── projections
 │         ├── variable: kv.k [type=int]
 │         └── variable: kv.v [type=int]
 └── aggregations
      ├── function: avg [type=decimal]
      │    └── variable: kv.k [type=int]
      ├── function: avg [type=decimal]
      │    └── variable: kv.v [type=int]
      ├── function: sum [type=decimal]
      │    └── variable: kv.k [type=int]
      └── function: sum [type=decimal]
           └── variable: kv.v [type=int]

exec-ddl
CREATE TABLE t.abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----
table abc
  a string NOT NULL
  b float NULL
  c bool NULL
  d decimal NULL

build
SELECT MIN(a), MIN(b), MIN(c), MIN(d) FROM t.abc
----
group-by
 ├── aggregation columns: column5:string:null:5 column6:float:null:6 column7:bool:null:7 column8:decimal:null:8
 ├── scan
 │    └── columns: abc.a:string:1 abc.b:float:null:2 abc.c:bool:null:3 abc.d:decimal:null:4
 └── aggregations
      ├── function: min [type=string]
      │    └── variable: abc.a [type=string]
      ├── function: min [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: min [type=bool]
      │    └── variable: abc.c [type=bool]
      └── function: min [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT MAX(a), MAX(b), MAX(c), MAX(d) FROM t.abc
----
group-by
 ├── aggregation columns: column5:string:null:5 column6:float:null:6 column7:bool:null:7 column8:decimal:null:8
 ├── scan
 │    └── columns: abc.a:string:1 abc.b:float:null:2 abc.c:bool:null:3 abc.d:decimal:null:4
 └── aggregations
      ├── function: max [type=string]
      │    └── variable: abc.a [type=string]
      ├── function: max [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: max [type=bool]
      │    └── variable: abc.c [type=bool]
      └── function: max [type=decimal]
           └── variable: abc.d [type=decimal]

build
SELECT AVG(b), SUM(b), AVG(d), SUM(d) FROM t.abc
----
group-by
 ├── aggregation columns: column5:float:null:5 column6:float:null:6 column7:decimal:null:7 column8:decimal:null:8
 ├── project
 │    ├── columns: abc.b:float:null:2 abc.d:decimal:null:4
 │    ├── scan
 │    │    └── columns: abc.a:string:1 abc.b:float:null:2 abc.c:bool:null:3 abc.d:decimal:null:4
 │    └── projections
 │         ├── variable: abc.b [type=float]
 │         └── variable: abc.d [type=decimal]
 └── aggregations
      ├── function: avg [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: sum [type=float]
      │    └── variable: abc.b [type=float]
      ├── function: avg [type=decimal]
      │    └── variable: abc.d [type=decimal]
      └── function: sum [type=decimal]
           └── variable: abc.d [type=decimal]

# Verify summing of intervals
exec-ddl
CREATE TABLE t.intervals (
  a INTERVAL PRIMARY KEY
)
----
table intervals
  a interval NOT NULL

build
SELECT SUM(a) FROM t.intervals
----
group-by
 ├── aggregation columns: column2:interval:null:2
 ├── scan
 │    └── columns: intervals.a:interval:1
 └── aggregations
      └── function: sum [type=interval]
           └── variable: intervals.a [type=interval]

build
SELECT AVG(a) FROM t.abc
----
error: unknown signature: avg(string)

build
SELECT AVG(c) FROM t.abc
----
error: unknown signature: avg(bool)

build
SELECT AVG((a,c)) FROM t.abc
----
error: unknown signature: avg(tuple{string, bool})

build
SELECT SUM(a) FROM t.abc
----
error: unknown signature: sum(string)

build
SELECT SUM(c) FROM t.abc
----
error: unknown signature: sum(bool)

build
SELECT SUM((a,c)) FROM t.abc
----
error: unknown signature: sum(tuple{string, bool})

exec-ddl
CREATE TABLE t.xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)
----
table xyz
  x int NOT NULL
  y int NULL
  z float NULL

build
SELECT MIN(x) FROM t.xyz
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── scan
 │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MIN(x) FROM t.xyz WHERE x in (0, 4, 7)
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── in [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── tuple [type=tuple{int, int, int}]
 │    │              ├── const: 0 [type=int]
 │    │              ├── const: 4 [type=int]
 │    │              └── const: 7 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM t.xyz
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── scan
 │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(y) FROM t.xyz WHERE x = 1
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.y:int:null:2
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 1 [type=int]
 │    └── projections
 │         └── variable: xyz.y [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(y) FROM t.xyz WHERE x = 7
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.y:int:null:2
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 7 [type=int]
 │    └── projections
 │         └── variable: xyz.y [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.y [type=int]

build
SELECT MIN(x) FROM t.xyz WHERE (y, z) = (2, 3.0)
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── tuple [type=tuple{int, float}]
 │    │         │    ├── variable: xyz.y [type=int]
 │    │         │    └── variable: xyz.z [type=float]
 │    │         └── tuple [type=tuple{int, float}]
 │    │              ├── const: 2 [type=int]
 │    │              └── const: 3.0 [type=float]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: min [type=int]
           └── variable: xyz.x [type=int]

build
SELECT MAX(x) FROM t.xyz WHERE (z, y) = (3.0, 2)
----
group-by
 ├── aggregation columns: column4:int:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── tuple [type=tuple{float, int}]
 │    │         │    ├── variable: xyz.z [type=float]
 │    │         │    └── variable: xyz.y [type=int]
 │    │         └── tuple [type=tuple{float, int}]
 │    │              ├── const: 3.0 [type=float]
 │    │              └── const: 2 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: max [type=int]
           └── variable: xyz.x [type=int]


# VARIANCE/STDDEV

build
SELECT VARIANCE(x) FROM t.xyz WHERE x = 10
----
group-by
 ├── aggregation columns: column4:decimal:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 10 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: variance [type=decimal]
           └── variable: xyz.x [type=int]

build
SELECT STDDEV(x) FROM t.xyz WHERE x = 1
----
group-by
 ├── aggregation columns: column4:decimal:null:4
 ├── project
 │    ├── columns: xyz.x:int:1
 │    ├── select
 │    │    ├── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    ├── scan
 │    │    │    └── columns: xyz.x:int:1 xyz.y:int:null:2 xyz.z:float:null:3
 │    │    └── eq [type=bool]
 │    │         ├── variable: xyz.x [type=int]
 │    │         └── const: 1 [type=int]
 │    └── projections
 │         └── variable: xyz.x [type=int]
 └── aggregations
      └── function: stddev [type=decimal]
           └── variable: xyz.x [type=int]

exec-ddl
CREATE TABLE t.bools (b BOOL)
----
table bools
  b bool NULL
  rowid int NOT NULL (hidden)

build
SELECT BOOL_AND(b), BOOL_OR(b) FROM t.bools
----
group-by
 ├── aggregation columns: column3:bool:null:3 column4:bool:null:4
 ├── project
 │    ├── columns: bools.b:bool:null:1
 │    ├── scan
 │    │    └── columns: bools.b:bool:null:1 bools.rowid:int:2
 │    └── projections
 │         └── variable: bools.b [type=bool]
 └── aggregations
      ├── function: bool_and [type=bool]
      │    └── variable: bools.b [type=bool]
      └── function: bool_or [type=bool]
           └── variable: bools.b [type=bool]


# Tests with * inside GROUP BY.
build
SELECT 1 FROM t.kv GROUP BY kv.*;
----
project
 ├── columns: column5:int:null:5
 ├── group-by
 │    ├── grouping columns: kv.k:int:null:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    ├── scan
 │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    └── aggregations
 └── projections
      └── const: 1 [type=int]

exec-ddl
CREATE TABLE t.xor_bytes (a bytes, b int, c int)
----
table xor_bytes
  a bytes NULL
  b int NULL
  c int NULL
  rowid int NOT NULL (hidden)

build
SELECT TO_HEX(XOR_AGG(a)), XOR_AGG(c) FROM t.xor_bytes
----
project
 ├── columns: column6:string:null:6 column7:int:null:7
 ├── group-by
 │    ├── aggregation columns: column5:bytes:null:5 column7:int:null:7
 │    ├── project
 │    │    ├── columns: xor_bytes.a:bytes:null:1 xor_bytes.c:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: xor_bytes.a:bytes:null:1 xor_bytes.b:int:null:2 xor_bytes.c:int:null:3 xor_bytes.rowid:int:4
 │    │    └── projections
 │    │         ├── variable: xor_bytes.a [type=bytes]
 │    │         └── variable: xor_bytes.c [type=int]
 │    └── aggregations
 │         ├── function: xor_agg [type=bytes]
 │         │    └── variable: xor_bytes.a [type=bytes]
 │         └── function: xor_agg [type=int]
 │              └── variable: xor_bytes.c [type=int]
 └── projections
      ├── function: to_hex [type=string]
      │    └── variable: column5 [type=bytes]
      └── variable: column7 [type=int]

build
SELECT MAX(true), MIN(true)
----
group-by
 ├── aggregation columns: column1:bool:null:1 column2:bool:null:2
 ├── project
 │    ├── columns: column3:bool:null:3
 │    ├── values
 │    │    └── tuple [type=tuple{}]
 │    └── projections
 │         └── true [type=bool]
 └── aggregations
      ├── function: max [type=bool]
      │    └── variable: column3 [type=bool]
      └── function: min [type=bool]
           └── variable: column3 [type=bool]

exec-ddl
CREATE TABLE t.ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)
----
table ab
  a int NOT NULL
  b int NULL

exec-ddl
CREATE TABLE t.xy(x STRING, y STRING);
----
table xy
  x string NULL
  y string NULL
  rowid int NOT NULL (hidden)

# Grouping and rendering tuples.
build
SELECT (b, a) FROM t.ab GROUP BY (b, a)
----
project
 ├── columns: column3:tuple{int, int}:null:3
 ├── group-by
 │    ├── grouping columns: ab.a:int:null:1 ab.b:int:null:2
 │    ├── project
 │    │    ├── columns: ab.b:int:null:2 ab.a:int:1
 │    │    ├── scan
 │    │    │    └── columns: ab.a:int:1 ab.b:int:null:2
 │    │    └── projections
 │    │         ├── variable: ab.b [type=int]
 │    │         └── variable: ab.a [type=int]
 │    └── aggregations
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT MIN(y), (b, a)
 FROM t.ab, t.xy GROUP BY (x, (a, b))
----
project
 ├── columns: column6:string:null:6 column7:tuple{int, int}:null:7
 ├── group-by
 │    ├── grouping columns: ab.a:int:null:1 ab.b:int:null:2 xy.x:string:null:3
 │    ├── aggregation columns: column6:string:null:6
 │    ├── project
 │    │    ├── columns: xy.x:string:null:3 ab.a:int:1 ab.b:int:null:2 xy.y:string:null:4
 │    │    ├── inner-join
 │    │    │    ├── columns: ab.a:int:1 ab.b:int:null:2 xy.x:string:null:3 xy.y:string:null:4 xy.rowid:int:5
 │    │    │    ├── scan
 │    │    │    │    └── columns: ab.a:int:1 ab.b:int:null:2
 │    │    │    ├── scan
 │    │    │    │    └── columns: xy.x:string:null:3 xy.y:string:null:4 xy.rowid:int:5
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── variable: xy.x [type=string]
 │    │         ├── variable: ab.a [type=int]
 │    │         ├── variable: ab.b [type=int]
 │    │         └── variable: xy.y [type=string]
 │    └── aggregations
 │         └── function: min [type=string]
 │              └── variable: xy.y [type=string]
 └── projections
      ├── variable: column6 [type=string]
      └── tuple [type=tuple{int, int}]
           ├── variable: ab.b [type=int]
           └── variable: ab.a [type=int]

build
SELECT (k+v)/(v+w) FROM t.kv GROUP BY k+v, v+w;
----
project
 ├── columns: column7:decimal:null:7
 ├── group-by
 │    ├── grouping columns: column5:int:null:5 column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5 column6:int:null:6
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.v [type=int]
 │    │         └── plus [type=int]
 │    │              ├── variable: kv.v [type=int]
 │    │              └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── div [type=decimal]
           ├── plus [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.v [type=int]
           └── plus [type=int]
                ├── variable: kv.v [type=int]
                └── variable: kv.w [type=int]

# Check that everything still works with differently qualified names
build
SELECT SUM(t.kv.w), t.kv.v FROM t.kv GROUP BY v, kv.k * w
----
project
 ├── columns: column6:decimal:null:6 kv.v:int:null:2
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 column5:int:null:5
 │    ├── aggregation columns: column6:decimal:null:6
 │    ├── project
 │    │    ├── columns: kv.v:int:null:2 column5:int:null:5 kv.w:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── mult [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: sum [type=decimal]
 │              └── variable: kv.w [type=int]
 └── projections
      ├── variable: column6 [type=decimal]
      └── variable: kv.v [type=int]

build
SELECT SUM(t.kv.w), LOWER(s), t.kv.v + k * t.kv.w, t.kv.v FROM t.kv GROUP BY v, LOWER(kv.s), kv.k * w
----
project
 ├── columns: column7:decimal:null:7 column5:string:null:5 column8:int:null:8 kv.v:int:null:2
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 column5:string:null:5 column6:int:null:6
 │    ├── aggregation columns: column7:decimal:null:7
 │    ├── project
 │    │    ├── columns: kv.v:int:null:2 column5:string:null:5 column6:int:null:6 kv.w:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.v [type=int]
 │    │         ├── function: lower [type=string]
 │    │         │    └── variable: kv.s [type=string]
 │    │         ├── mult [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 │         └── function: sum [type=decimal]
 │              └── variable: kv.w [type=int]
 └── projections
      ├── variable: column7 [type=decimal]
      ├── variable: column5 [type=string]
      ├── plus [type=int]
      │    ├── variable: kv.v [type=int]
      │    └── mult [type=int]
      │         ├── variable: kv.k [type=int]
      │         └── variable: kv.w [type=int]
      └── variable: kv.v [type=int]

# Check all the different types of scalar expressions as group by columns
build
SELECT b1.b AND abc.c AND b2.b FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
project
 ├── columns: column10:bool:null:10
 ├── group-by
 │    ├── grouping columns: bools.b:bool:null:3 column9:bool:null:9
 │    ├── project
 │    │    ├── columns: column9:bool:null:9 bools.b:bool:null:3
 │    │    ├── inner-join
 │    │    │    ├── columns: bools.b:bool:null:1 bools.rowid:int:2 bools.b:bool:null:3 bools.rowid:int:4 abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    ├── inner-join
 │    │    │    │    ├── columns: bools.b:bool:null:1 bools.rowid:int:2 bools.b:bool:null:3 bools.rowid:int:4
 │    │    │    │    ├── scan
 │    │    │    │    │    └── columns: bools.b:bool:null:1 bools.rowid:int:2
 │    │    │    │    ├── scan
 │    │    │    │    │    └── columns: bools.b:bool:null:3 bools.rowid:int:4
 │    │    │    │    └── true [type=bool]
 │    │    │    ├── scan
 │    │    │    │    └── columns: abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── and [type=bool]
 │    │         │    ├── variable: bools.b [type=bool]
 │    │         │    └── variable: abc.c [type=bool]
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── and [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b AND abc.c AND abc.c FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b1.b OR abc.c OR b2.b FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
project
 ├── columns: column10:bool:null:10
 ├── group-by
 │    ├── grouping columns: bools.b:bool:null:3 column9:bool:null:9
 │    ├── project
 │    │    ├── columns: column9:bool:null:9 bools.b:bool:null:3
 │    │    ├── inner-join
 │    │    │    ├── columns: bools.b:bool:null:1 bools.rowid:int:2 bools.b:bool:null:3 bools.rowid:int:4 abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    ├── inner-join
 │    │    │    │    ├── columns: bools.b:bool:null:1 bools.rowid:int:2 bools.b:bool:null:3 bools.rowid:int:4
 │    │    │    │    ├── scan
 │    │    │    │    │    └── columns: bools.b:bool:null:1 bools.rowid:int:2
 │    │    │    │    ├── scan
 │    │    │    │    │    └── columns: bools.b:bool:null:3 bools.rowid:int:4
 │    │    │    │    └── true [type=bool]
 │    │    │    ├── scan
 │    │    │    │    └── columns: abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── or [type=bool]
 │    │         │    ├── variable: bools.b [type=bool]
 │    │         │    └── variable: abc.c [type=bool]
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── or [type=bool]
           ├── or [type=bool]
           │    ├── variable: bools.b [type=bool]
           │    └── variable: abc.c [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT b1.b OR abc.c OR abc.c FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
error: column "abc.c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k % w % v FROM kv GROUP BY k % w, v
----
project
 ├── columns: column6:int:null:6
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 column5:int:null:5
 │    ├── project
 │    │    ├── columns: column5:int:null:5 kv.v:int:null:2
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── mod [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── mod [type=int]
           ├── mod [type=int]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── variable: kv.v [type=int]

build
SELECT CONCAT(CONCAT(s, a), a) FROM kv, abc GROUP BY CONCAT(s, a), a
----
project
 ├── columns: column10:string:null:10
 ├── group-by
 │    ├── grouping columns: abc.a:string:null:5 column9:string:null:9
 │    ├── project
 │    │    ├── columns: column9:string:null:9 abc.a:string:5
 │    │    ├── inner-join
 │    │    │    ├── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4 abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    ├── scan
 │    │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    │    ├── scan
 │    │    │    │    └── columns: abc.a:string:5 abc.b:float:null:6 abc.c:bool:null:7 abc.d:decimal:null:8
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── function: concat [type=string]
 │    │         │    ├── variable: kv.s [type=string]
 │    │         │    └── variable: abc.a [type=string]
 │    │         └── variable: abc.a [type=string]
 │    └── aggregations
 └── projections
      └── function: concat [type=string]
           ├── function: concat [type=string]
           │    ├── variable: kv.s [type=string]
           │    └── variable: abc.a [type=string]
           └── variable: abc.a [type=string]

build
SELECT CONCAT(CONCAT(s, a), s) FROM kv, abc GROUP BY CONCAT(s, a), a
----
error: column "kv.s" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k < w AND v != 5 FROM kv GROUP BY k < w, v
----
project
 ├── columns: column6:bool:null:6
 ├── group-by
 │    ├── grouping columns: kv.v:int:null:2 column5:bool:null:5
 │    ├── project
 │    │    ├── columns: column5:bool:null:5 kv.v:int:null:2
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── lt [type=bool]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── variable: kv.w [type=int]
 │    │         └── variable: kv.v [type=int]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── lt [type=bool]
           │    ├── variable: kv.k [type=int]
           │    └── variable: kv.w [type=int]
           └── ne [type=bool]
                ├── variable: kv.v [type=int]
                └── const: 5 [type=int]

build
SELECT k < w AND k < v FROM kv GROUP BY k < w, v
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

exec-ddl
CREATE TABLE foo (bar JSON, baz JSON)
----
table foo
  bar jsonb NULL
  baz jsonb NULL
  rowid int NOT NULL (hidden)

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY a.bar @> b.baz, b.baz
----
project
 ├── columns: column8:bool:null:8
 ├── group-by
 │    ├── grouping columns: foo.baz:jsonb:null:5 column7:bool:null:7
 │    ├── project
 │    │    ├── columns: column7:bool:null:7 foo.baz:jsonb:null:5
 │    │    ├── inner-join
 │    │    │    ├── columns: foo.bar:jsonb:null:1 foo.baz:jsonb:null:2 foo.rowid:int:3 foo.bar:jsonb:null:4 foo.baz:jsonb:null:5 foo.rowid:int:6
 │    │    │    ├── scan
 │    │    │    │    └── columns: foo.bar:jsonb:null:1 foo.baz:jsonb:null:2 foo.rowid:int:3
 │    │    │    ├── scan
 │    │    │    │    └── columns: foo.bar:jsonb:null:4 foo.baz:jsonb:null:5 foo.rowid:int:6
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── contains [type=bool]
 │    │         │    ├── variable: foo.bar [type=jsonb]
 │    │         │    └── variable: foo.baz [type=jsonb]
 │    │         └── variable: foo.baz [type=jsonb]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
error: column "foo.bar" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b.baz <@ a.bar AND b.baz <@ b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
project
 ├── columns: column8:bool:null:8
 ├── group-by
 │    ├── grouping columns: foo.baz:jsonb:null:5 column7:bool:null:7
 │    ├── project
 │    │    ├── columns: column7:bool:null:7 foo.baz:jsonb:null:5
 │    │    ├── inner-join
 │    │    │    ├── columns: foo.bar:jsonb:null:1 foo.baz:jsonb:null:2 foo.rowid:int:3 foo.bar:jsonb:null:4 foo.baz:jsonb:null:5 foo.rowid:int:6
 │    │    │    ├── scan
 │    │    │    │    └── columns: foo.bar:jsonb:null:1 foo.baz:jsonb:null:2 foo.rowid:int:3
 │    │    │    ├── scan
 │    │    │    │    └── columns: foo.bar:jsonb:null:4 foo.baz:jsonb:null:5 foo.rowid:int:6
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── contains [type=bool]
 │    │         │    ├── variable: foo.bar [type=jsonb]
 │    │         │    └── variable: foo.baz [type=jsonb]
 │    │         └── variable: foo.baz [type=jsonb]
 │    └── aggregations
 └── projections
      └── and [type=bool]
           ├── contains [type=bool]
           │    ├── variable: foo.bar [type=jsonb]
           │    └── variable: foo.baz [type=jsonb]
           └── contains [type=bool]
                ├── variable: foo.baz [type=jsonb]
                └── variable: foo.baz [type=jsonb]

exec-ddl
CREATE TABLE times (t time PRIMARY KEY)
----
table times
  t time NOT NULL

build
SELECT date_trunc('second', a.t) - date_trunc('minute', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
project
 ├── columns: column5:interval:null:5
 ├── group-by
 │    ├── grouping columns: column3:interval:null:3 column4:interval:null:4
 │    ├── project
 │    │    ├── columns: column3:interval:null:3 column4:interval:null:4
 │    │    ├── inner-join
 │    │    │    ├── columns: times.t:time:1 times.t:time:2
 │    │    │    ├── scan
 │    │    │    │    └── columns: times.t:time:1
 │    │    │    ├── scan
 │    │    │    │    └── columns: times.t:time:2
 │    │    │    └── true [type=bool]
 │    │    └── projections
 │    │         ├── function: date_trunc [type=interval]
 │    │         │    ├── const: 'second' [type=string]
 │    │         │    └── variable: times.t [type=time]
 │    │         └── function: date_trunc [type=interval]
 │    │              ├── const: 'minute' [type=string]
 │    │              └── variable: times.t [type=time]
 │    └── aggregations
 └── projections
      └── minus [type=interval]
           ├── function: date_trunc [type=interval]
           │    ├── const: 'second' [type=string]
           │    └── variable: times.t [type=time]
           └── function: date_trunc [type=interval]
                ├── const: 'minute' [type=string]
                └── variable: times.t [type=time]

build
SELECT date_trunc('second', a.t) - date_trunc('second', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
error: column "times.t" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY NOT b
----
group-by
 ├── grouping columns: column3:bool:null:3
 ├── project
 │    ├── columns: column3:bool:null:3
 │    ├── scan
 │    │    └── columns: bools.b:bool:null:1 bools.rowid:int:2
 │    └── projections
 │         └── not [type=bool]
 │              └── variable: bools.b [type=bool]
 └── aggregations

build
SELECT b FROM bools GROUP BY NOT b
----
error: column "bools.b" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b FROM bools GROUP BY b
----
project
 ├── columns: column3:bool:null:3
 ├── group-by
 │    ├── grouping columns: bools.b:bool:null:1
 │    ├── project
 │    │    ├── columns: bools.b:bool:null:1
 │    │    ├── scan
 │    │    │    └── columns: bools.b:bool:null:1 bools.rowid:int:2
 │    │    └── projections
 │    │         └── variable: bools.b [type=bool]
 │    └── aggregations
 └── projections
      └── not [type=bool]
           └── variable: bools.b [type=bool]

build
SELECT +k * (-w) FROM kv GROUP BY +k, -w
----
project
 ├── columns: column7:int:null:7
 ├── group-by
 │    ├── grouping columns: column5:int:null:5 column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5 column6:int:null:6
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── unary-plus [type=int]
 │    │         │    └── variable: kv.k [type=int]
 │    │         └── unary-minus [type=int]
 │    │              └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── mult [type=int]
           ├── unary-plus [type=int]
           │    └── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build
SELECT k * (-w) FROM kv GROUP BY +k, -w
----
error: column "kv.k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT +k * (-w) FROM kv GROUP BY k, w
----
project
 ├── columns: column5:int:null:5
 ├── group-by
 │    ├── grouping columns: kv.k:int:null:1 kv.w:int:null:3
 │    ├── project
 │    │    ├── columns: kv.k:int:1 kv.w:int:null:3
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── variable: kv.k [type=int]
 │    │         └── variable: kv.w [type=int]
 │    └── aggregations
 └── projections
      └── mult [type=int]
           ├── unary-plus [type=int]
           │    └── variable: kv.k [type=int]
           └── unary-minus [type=int]
                └── variable: kv.w [type=int]

build 
SELECT 1 + MIN(v*2) FROM kv GROUP BY k+3
----
project
 ├── columns: column7:int:null:7
 ├── group-by
 │    ├── grouping columns: column5:int:null:5
 │    ├── aggregation columns: column6:int:null:6
 │    ├── project
 │    │    ├── columns: column5:int:null:5 column8:int:null:8
 │    │    ├── scan
 │    │    │    └── columns: kv.k:int:1 kv.v:int:null:2 kv.w:int:null:3 kv.s:string:null:4
 │    │    └── projections
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: kv.k [type=int]
 │    │         │    └── const: 3 [type=int]
 │    │         └── mult [type=int]
 │    │              ├── variable: kv.v [type=int]
 │    │              └── const: 2 [type=int]
 │    └── aggregations
 │         └── function: min [type=int]
 │              └── variable: column8 [type=int]
 └── projections
      └── plus [type=int]
           ├── const: 1 [type=int]
           └── variable: column6 [type=int]
