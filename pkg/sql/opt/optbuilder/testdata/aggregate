# tests adapted from logictest -- aggregate

exec-ddl
CREATE TABLE kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----

exec-ddl
CREATE TABLE abxy (
  a INT,
  b INT,
  x INT,
  y INT,
  PRIMARY KEY(a,b)
)
----

build
SELECT min(1), max(1), count(1), sum_int(1), avg(1), sum(1), stddev(1),
  variance(1), bool_and(true), bool_or(false), xor_agg(b'\x01') FROM kv
----
scalar-group-by
 ├── columns: min:6(int) max:7(int) count:8(int) sum_int:9(int) avg:10(decimal) sum:11(decimal) stddev:12(decimal) variance:13(decimal) bool_and:15(bool) bool_or:17(bool) xor_agg:19(bytes)
 ├── project
 │    ├── columns: column5:5(int!null) column14:14(bool!null) column16:16(bool!null) column18:18(bytes!null)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         ├── const: 1 [type=int]
 │         ├── true [type=bool]
 │         ├── false [type=bool]
 │         └── const: '\x01' [type=bytes]
 └── aggregations
      ├── min [type=int]
      │    └── variable: column5 [type=int]
      ├── max [type=int]
      │    └── variable: column5 [type=int]
      ├── count [type=int]
      │    └── variable: column5 [type=int]
      ├── sum-int [type=int]
      │    └── variable: column5 [type=int]
      ├── avg [type=decimal]
      │    └── variable: column5 [type=int]
      ├── sum [type=decimal]
      │    └── variable: column5 [type=int]
      ├── std-dev [type=decimal]
      │    └── variable: column5 [type=int]
      ├── variance [type=decimal]
      │    └── variable: column5 [type=int]
      ├── bool-and [type=bool]
      │    └── variable: column14 [type=bool]
      ├── bool-or [type=bool]
      │    └── variable: column16 [type=bool]
      └── xor-agg [type=bytes]
           └── variable: column18 [type=bytes]

build
SELECT min(v), max(v), count(v), sum_int(1), avg(v), sum(v), stddev(v),
  variance(v), bool_and(v = 1), bool_and(v = 1), xor_agg(s::bytes) FROM kv
----
scalar-group-by
 ├── columns: min:5(int) max:6(int) count:7(int) sum_int:9(int) avg:10(decimal) sum:11(decimal) stddev:12(decimal) variance:13(decimal) bool_and:15(bool) bool_and:15(bool) xor_agg:17(bytes)
 ├── project
 │    ├── columns: column8:8(int!null) column14:14(bool) column16:16(bytes) v:2(int)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         ├── const: 1 [type=int]
 │         ├── eq [type=bool]
 │         │    ├── variable: v [type=int]
 │         │    └── const: 1 [type=int]
 │         └── cast: BYTES [type=bytes]
 │              └── variable: s [type=string]
 └── aggregations
      ├── min [type=int]
      │    └── variable: v [type=int]
      ├── max [type=int]
      │    └── variable: v [type=int]
      ├── count [type=int]
      │    └── variable: v [type=int]
      ├── sum-int [type=int]
      │    └── variable: column8 [type=int]
      ├── avg [type=decimal]
      │    └── variable: v [type=int]
      ├── sum [type=decimal]
      │    └── variable: v [type=int]
      ├── std-dev [type=decimal]
      │    └── variable: v [type=int]
      ├── variance [type=decimal]
      │    └── variable: v [type=int]
      ├── bool-and [type=bool]
      │    └── variable: column14 [type=bool]
      └── xor-agg [type=bytes]
           └── variable: column16 [type=bytes]

build
SELECT min(1, 2)
----
error (42883): unknown signature: min(int, int)

build
SELECT min(1), count(1), max(1), sum_int(1), avg(1)::float, sum(1), stddev(1),
  variance(1)::float, bool_and(true), bool_or(true), to_hex(xor_agg(b'\x01'))
----
project
 ├── columns: min:2(int) count:3(int) max:4(int) sum_int:5(int) avg:15(float) sum:7(decimal) stddev:8(decimal) variance:16(float) bool_and:11(bool) bool_or:12(bool) to_hex:17(string)
 ├── scalar-group-by
 │    ├── columns: min:2(int) count:3(int) max:4(int) sum_int:5(int) avg:6(decimal) sum:7(decimal) stddev:8(decimal) variance:9(decimal) bool_and:11(bool) bool_or:12(bool) xor_agg:14(bytes)
 │    ├── project
 │    │    ├── columns: column1:1(int!null) column10:10(bool!null) column13:13(bytes!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         ├── true [type=bool]
 │    │         └── const: '\x01' [type=bytes]
 │    └── aggregations
 │         ├── min [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── count [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── max [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── sum-int [type=int]
 │         │    └── variable: column1 [type=int]
 │         ├── avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── sum [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── std-dev [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── variance [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── bool-and [type=bool]
 │         │    └── variable: column10 [type=bool]
 │         ├── bool-or [type=bool]
 │         │    └── variable: column10 [type=bool]
 │         └── xor-agg [type=bytes]
 │              └── variable: column13 [type=bytes]
 └── projections
      ├── cast: FLOAT8 [type=float]
      │    └── variable: avg [type=decimal]
      ├── cast: FLOAT8 [type=float]
      │    └── variable: variance [type=decimal]
      └── function: to_hex [type=string]
           └── variable: xor_agg [type=bytes]

build
SELECT array_agg(1) FROM kv
----
scalar-group-by
 ├── columns: array_agg:6(int[])
 ├── project
 │    ├── columns: column5:5(int!null)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: column5 [type=int]

build
SELECT json_agg(v) FROM kv
----
scalar-group-by
 ├── columns: json_agg:5(jsonb)
 ├── project
 │    ├── columns: v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── json-agg [type=jsonb]
           └── variable: v [type=int]

build
SELECT jsonb_agg(1)
----
scalar-group-by
 ├── columns: jsonb_agg:2(jsonb)
 ├── project
 │    ├── columns: column1:1(int!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── jsonb-agg [type=jsonb]
           └── variable: column1 [type=int]

# Even with no aggregate functions, grouping occurs in the presence of GROUP BY.
build
SELECT 1 r FROM kv GROUP BY v
----
project
 ├── columns: r:5(int!null)
 ├── group-by
 │    ├── columns: v:2(int)
 │    ├── grouping columns: v:2(int)
 │    └── project
 │         ├── columns: v:2(int)
 │         └── scan kv
 │              └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── projections
      └── const: 1 [type=int]

# This should ideally return {NULL}, but this is a pathological case, and
# Postgres has the same behavior, so it's sufficient for now.
build
SELECT array_agg(NULL)
----
error (42725): ambiguous call: array_agg(unknown), candidates are:
array_agg(int) -> int[]
array_agg(float) -> float[]
array_agg(decimal) -> decimal[]
array_agg(date) -> date[]
array_agg(timestamp) -> timestamp[]
array_agg(interval) -> interval[]
array_agg(string) -> string[]
array_agg(bytes) -> bytes[]
array_agg(timestamptz) -> timestamptz[]
array_agg(oid) -> oid[]
array_agg(uuid) -> uuid[]
array_agg(inet) -> inet[]
array_agg(time) -> time[]
array_agg(varbit) -> varbit[]
array_agg(bool) -> bool[]

# With an explicit cast, this works as expected.
build
SELECT array_agg(NULL::TEXT)
----
scalar-group-by
 ├── columns: array_agg:2(string[])
 ├── project
 │    ├── columns: column1:1(string)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── cast: STRING [type=string]
 │              └── null [type=unknown]
 └── aggregations
      └── array-agg [type=string[]]
           └── variable: column1 [type=string]

build
SELECT (SELECT COALESCE(max(1), 0) FROM kv)
----
project
 ├── columns: coalesce:8(int)
 ├── values
 │    └── tuple [type=tuple]
 └── projections
      └── subquery [type=int]
           └── max1-row
                ├── columns: coalesce:7(int)
                └── project
                     ├── columns: coalesce:7(int)
                     ├── scalar-group-by
                     │    ├── columns: max:6(int)
                     │    ├── project
                     │    │    ├── columns: column5:5(int!null)
                     │    │    ├── scan kv
                     │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
                     │    │    └── projections
                     │    │         └── const: 1 [type=int]
                     │    └── aggregations
                     │         └── max [type=int]
                     │              └── variable: column5 [type=int]
                     └── projections
                          └── coalesce [type=int]
                               ├── variable: max [type=int]
                               └── const: 0 [type=int]

build
SELECT count(*), k FROM kv
----
error (42803): column "k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT count(*) FROM kv GROUP BY s < 5
----
error (22023): unsupported comparison operator: <string> < <int>

build
SELECT count(*), k FROM kv GROUP BY k
----
group-by
 ├── columns: count:5(int) k:1(int!null)
 ├── grouping columns: k:1(int!null)
 ├── project
 │    ├── columns: k:1(int!null)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

# GROUP BY specified using column index works.
build
SELECT count(*), k FROM kv GROUP BY 2
----
group-by
 ├── columns: count:5(int) k:1(int!null)
 ├── grouping columns: k:1(int!null)
 ├── project
 │    ├── columns: k:1(int!null)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

build
SELECT * FROM kv GROUP BY v, count(w)
----
error (42803): count(): aggregate functions are not allowed in GROUP BY

build
SELECT count(w) FROM kv GROUP BY 1
----
error (42803): count(): aggregate functions are not allowed in GROUP BY

build
SELECT sum(v) FROM kv GROUP BY k LIMIT sum(v)
----
error (42703): column "v" does not exist

build
SELECT sum(v) FROM kv GROUP BY k LIMIT 1 OFFSET sum(v)
----
error (42703): column "v" does not exist

build
VALUES (99, count(1))
----
error (42803): count(): aggregate functions are not allowed in VALUES

build
SELECT count(*), k FROM kv GROUP BY 5
----
error (42P10): GROUP BY position 5 is not in select list

build
SELECT count(*), k FROM kv GROUP BY 0
----
error (42P10): GROUP BY position 0 is not in select list

build
SELECT 1 GROUP BY 'a'
----
error (42601): non-integer constant in GROUP BY: 'a'

# Qualifying a name in the SELECT, the GROUP BY, both or neither should not affect validation.
build
SELECT count(*), kv.s FROM kv GROUP BY s
----
group-by
 ├── columns: count:5(int) s:4(string)
 ├── grouping columns: s:4(string)
 ├── project
 │    ├── columns: s:4(string)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

build
SELECT count(*), s FROM kv GROUP BY kv.s
----
group-by
 ├── columns: count:5(int) s:4(string)
 ├── grouping columns: s:4(string)
 ├── project
 │    ├── columns: s:4(string)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

build
SELECT count(*), kv.s FROM kv GROUP BY kv.s
----
group-by
 ├── columns: count:5(int) s:4(string)
 ├── grouping columns: s:4(string)
 ├── project
 │    ├── columns: s:4(string)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

build
SELECT count(*), s FROM kv GROUP BY s
----
group-by
 ├── columns: count:5(int) s:4(string)
 ├── grouping columns: s:4(string)
 ├── project
 │    ├── columns: s:4(string)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

# Grouping by more than one column works.
build
SELECT v, count(*), w FROM kv GROUP BY v, w
----
group-by
 ├── columns: v:2(int) count:5(int) w:3(int)
 ├── grouping columns: v:2(int) w:3(int)
 ├── project
 │    ├── columns: v:2(int) w:3(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

# Grouping by more than one column using column numbers works.
build
SELECT v, count(*), w FROM kv GROUP BY 1, 3
----
group-by
 ├── columns: v:2(int) count:5(int) w:3(int)
 ├── grouping columns: v:2(int) w:3(int)
 ├── project
 │    ├── columns: v:2(int) w:3(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count-rows [type=int]

# Selecting and grouping on a function expression works.
build
SELECT count(*), upper(s) FROM kv GROUP BY upper(s)
----
group-by
 ├── columns: count:5(int) upper:6(string)
 ├── grouping columns: column6:6(string)
 ├── project
 │    ├── columns: column6:6(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── function: upper [type=string]
 │              └── variable: s [type=string]
 └── aggregations
      └── count-rows [type=int]

# Selecting and grouping on a constant works.
build
SELECT count(*) FROM kv GROUP BY 1+2
----
project
 ├── columns: count:5(int)
 └── group-by
      ├── columns: count_rows:5(int) column6:6(int!null)
      ├── grouping columns: column6:6(int!null)
      ├── project
      │    ├── columns: column6:6(int!null)
      │    ├── scan kv
      │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── projections
      │         └── const: 3 [type=int]
      └── aggregations
           └── count-rows [type=int]

build
SELECT count(*) FROM kv GROUP BY length('abc')
----
project
 ├── columns: count:5(int)
 └── group-by
      ├── columns: count_rows:5(int) column6:6(int)
      ├── grouping columns: column6:6(int)
      ├── project
      │    ├── columns: column6:6(int)
      │    ├── scan kv
      │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── projections
      │         └── function: length [type=int]
      │              └── const: 'abc' [type=string]
      └── aggregations
           └── count-rows [type=int]

# Selecting a function of something which is grouped works.
build
SELECT count(*), upper(s) FROM kv GROUP BY s
----
project
 ├── columns: count:5(int) upper:6(string)
 ├── group-by
 │    ├── columns: s:4(string) count_rows:5(int)
 │    ├── grouping columns: s:4(string)
 │    ├── project
 │    │    ├── columns: s:4(string)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         └── count-rows [type=int]
 └── projections
      └── function: upper [type=string]
           └── variable: s [type=string]

# Selecting a value that is not grouped, even if a function of it it, does not work.
build
SELECT count(*), s FROM kv GROUP BY upper(s)
----
error (42803): column "s" must appear in the GROUP BY clause or be used in an aggregate function

# Selecting and grouping on a more complex expression works.
build
SELECT count(*), k+v AS r FROM kv GROUP BY k+v
----
group-by
 ├── columns: count:5(int) r:6(int)
 ├── grouping columns: column6:6(int)
 ├── project
 │    ├── columns: column6:6(int)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── plus [type=int]
 │              ├── variable: k [type=int]
 │              └── variable: v [type=int]
 └── aggregations
      └── count-rows [type=int]


# Selecting a more complex expression, made up of things which are each grouped, works.
build
SELECT count(*), k+v AS r FROM kv GROUP BY k, v
----
project
 ├── columns: count:5(int) r:6(int)
 ├── group-by
 │    ├── columns: k:1(int!null) v:2(int) count_rows:5(int)
 │    ├── grouping columns: k:1(int!null) v:2(int)
 │    ├── project
 │    │    ├── columns: k:1(int!null) v:2(int)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         └── count-rows [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: k [type=int]
           └── variable: v [type=int]

build
SELECT count(*), k+v FROM kv GROUP BY v
----
error (42803): column "k" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT count(*), v/(k+v) FROM kv GROUP BY k+v
----
error (42803): column "v" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k FROM kv WHERE avg(k) > 1
----
error (42803): avg(): aggregate functions are not allowed in WHERE

build
SELECT max(avg(k)) FROM kv
----
error (42803): max(): avg(): aggregate function calls cannot be nested

# Test case from #2761.
build
SELECT count(kv.k) AS count_1, kv.v + kv.w AS lx FROM kv GROUP BY kv.v + kv.w
----
group-by
 ├── columns: count_1:5(int) lx:6(int)
 ├── grouping columns: column6:6(int)
 ├── project
 │    ├── columns: column6:6(int) k:1(int!null)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── plus [type=int]
 │              ├── variable: v [type=int]
 │              └── variable: w [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: k [type=int]

build
SELECT count(*)
----
scalar-group-by
 ├── columns: count:1(int)
 ├── values
 │    └── tuple [type=tuple]
 └── aggregations
      └── count-rows [type=int]

build
SELECT count(k) from kv
----
scalar-group-by
 ├── columns: count:5(int)
 ├── project
 │    ├── columns: k:1(int!null)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── count [type=int]
           └── variable: k [type=int]

build
SELECT count(1)
----
scalar-group-by
 ├── columns: count:2(int)
 ├── project
 │    ├── columns: column1:1(int!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: column1 [type=int]

build
SELECT count(1) from kv
----
scalar-group-by
 ├── columns: count:6(int)
 ├── project
 │    ├── columns: column5:5(int!null)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── const: 1 [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: column5 [type=int]

build
SELECT count(k, v) FROM kv
----
error (42883): unknown signature: count(int, int)

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY v
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: +2
 └── group-by
      ├── columns: v:2(int) count:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: k [type=int]

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY v DESC
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: v:2(int) count:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: k [type=int]

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY count(k) DESC
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: -5
 └── group-by
      ├── columns: v:2(int) count:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: k [type=int]

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY v-count(k)
----
sort
 ├── columns: v:2(int) count:5(int)  [hidden: column6:6(int)]
 ├── ordering: +6
 └── project
      ├── columns: column6:6(int) v:2(int) count:5(int)
      ├── group-by
      │    ├── columns: v:2(int) count:5(int)
      │    ├── grouping columns: v:2(int)
      │    ├── project
      │    │    ├── columns: k:1(int!null) v:2(int)
      │    │    └── scan kv
      │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── aggregations
      │         └── count [type=int]
      │              └── variable: k [type=int]
      └── projections
           └── minus [type=int]
                ├── variable: v [type=int]
                └── variable: count [type=int]

build
SELECT v FROM kv GROUP BY v ORDER BY sum(k)
----
sort
 ├── columns: v:2(int)  [hidden: sum:5(decimal)]
 ├── ordering: +5
 └── group-by
      ├── columns: v:2(int) sum:5(decimal)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── sum [type=decimal]
                └── variable: k [type=int]

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY 1 DESC
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: -2
 └── group-by
      ├── columns: v:2(int) count:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: k [type=int]

build
SELECT count(*), count(k), count(kv.v) FROM kv
----
scalar-group-by
 ├── columns: count:5(int) count:6(int) count:7(int)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      ├── count-rows [type=int]
      ├── count [type=int]
      │    └── variable: k [type=int]
      └── count [type=int]
           └── variable: v [type=int]

build
SELECT count(kv.*) FROM kv
----
scalar-group-by
 ├── columns: count:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int AS k, int AS v, int AS w, string AS s})
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int AS k, int AS v, int AS w, string AS s}]
 │              ├── variable: k [type=int]
 │              ├── variable: v [type=int]
 │              ├── variable: w [type=int]
 │              └── variable: s [type=string]
 └── aggregations
      └── count [type=int]
           └── variable: column5 [type=tuple{int AS k, int AS v, int AS w, string AS s}]

build
SELECT count(DISTINCT k), count(DISTINCT v), count(DISTINCT (v)) FROM kv
----
scalar-group-by
 ├── columns: count:5(int) count:6(int) count:6(int)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      ├── count [type=int]
      │    └── agg-distinct [type=int]
      │         └── variable: k [type=int]
      └── count [type=int]
           └── agg-distinct [type=int]
                └── variable: v [type=int]

build
SELECT upper(s), count(DISTINCT k), count(DISTINCT v), count(DISTINCT (v)) FROM kv GROUP BY upper(s)
----
group-by
 ├── columns: upper:7(string) count:5(int) count:6(int) count:6(int)
 ├── grouping columns: column7:7(string)
 ├── project
 │    ├── columns: column7:7(string) k:1(int!null) v:2(int)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── function: upper [type=string]
 │              └── variable: s [type=string]
 └── aggregations
      ├── count [type=int]
      │    └── agg-distinct [type=int]
      │         └── variable: k [type=int]
      └── count [type=int]
           └── agg-distinct [type=int]
                └── variable: v [type=int]

build
SELECT count((k, v)) FROM kv
----
scalar-group-by
 ├── columns: count:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int, int})
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int, int}]
 │              ├── variable: k [type=int]
 │              └── variable: v [type=int]
 └── aggregations
      └── count [type=int]
           └── variable: column5 [type=tuple{int, int}]

build
SELECT count(DISTINCT (k, v)) FROM kv
----
scalar-group-by
 ├── columns: count:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int, int})
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int, int}]
 │              ├── variable: k [type=int]
 │              └── variable: v [type=int]
 └── aggregations
      └── count [type=int]
           └── agg-distinct [type=tuple{int, int}]
                └── variable: column5 [type=tuple{int, int}]

build
SELECT count(DISTINCT (k, (v))) FROM kv
----
scalar-group-by
 ├── columns: count:6(int)
 ├── project
 │    ├── columns: column5:5(tuple{int, int})
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── tuple [type=tuple{int, int}]
 │              ├── variable: k [type=int]
 │              └── variable: v [type=int]
 └── aggregations
      └── count [type=int]
           └── agg-distinct [type=tuple{int, int}]
                └── variable: column5 [type=tuple{int, int}]

build
SELECT count(*) FROM kv a, kv b
----
scalar-group-by
 ├── columns: count:9(int)
 ├── project
 │    └── inner-join (hash)
 │         ├── columns: a.k:1(int!null) a.v:2(int) a.w:3(int) a.s:4(string) b.k:5(int!null) b.v:6(int) b.w:7(int) b.s:8(string)
 │         ├── scan a
 │         │    └── columns: a.k:1(int!null) a.v:2(int) a.w:3(int) a.s:4(string)
 │         ├── scan b
 │         │    └── columns: b.k:5(int!null) b.v:6(int) b.w:7(int) b.s:8(string)
 │         └── filters (true)
 └── aggregations
      └── count-rows [type=int]

build
SELECT count((k, v)) FROM kv LIMIT 1
----
limit
 ├── columns: count:6(int)
 ├── scalar-group-by
 │    ├── columns: count:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: k [type=int]
 │    │              └── variable: v [type=int]
 │    └── aggregations
 │         └── count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT count((k, v)) FROM kv OFFSET 1
----
offset
 ├── columns: count:6(int)
 ├── scalar-group-by
 │    ├── columns: count:6(int)
 │    ├── project
 │    │    ├── columns: column5:5(tuple{int, int})
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    └── projections
 │    │         └── tuple [type=tuple{int, int}]
 │    │              ├── variable: k [type=int]
 │    │              └── variable: v [type=int]
 │    └── aggregations
 │         └── count [type=int]
 │              └── variable: column5 [type=tuple{int, int}]
 └── const: 1 [type=int]

build
SELECT count(k)+count(kv.v) AS r FROM kv
----
project
 ├── columns: r:7(int)
 ├── scalar-group-by
 │    ├── columns: count:5(int) count:6(int)
 │    ├── project
 │    │    ├── columns: k:1(int!null) v:2(int)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         ├── count [type=int]
 │         │    └── variable: k [type=int]
 │         └── count [type=int]
 │              └── variable: v [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: count [type=int]
           └── variable: count [type=int]

build
SELECT count(NULL::int), count((NULL, NULL))
----
scalar-group-by
 ├── columns: count:2(int) count:4(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(tuple{unknown, unknown})
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── cast: INT8 [type=int]
 │         │    └── null [type=unknown]
 │         └── tuple [type=tuple{unknown, unknown}]
 │              ├── null [type=unknown]
 │              └── null [type=unknown]
 └── aggregations
      ├── count [type=int]
      │    └── variable: column1 [type=int]
      └── count [type=int]
           └── variable: column3 [type=tuple{unknown, unknown}]

build
SELECT min(k), max(k), min(v), max(v) FROM kv
----
scalar-group-by
 ├── columns: min:5(int) max:6(int) min:7(int) max:8(int)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      ├── min [type=int]
      │    └── variable: k [type=int]
      ├── max [type=int]
      │    └── variable: k [type=int]
      ├── min [type=int]
      │    └── variable: v [type=int]
      └── max [type=int]
           └── variable: v [type=int]

build
SELECT min(k), max(k), min(v), max(v) FROM kv WHERE k > 8
----
scalar-group-by
 ├── columns: min:5(int) max:6(int) min:7(int) max:8(int)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── select
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── filters
 │              └── gt [type=bool]
 │                   ├── variable: k [type=int]
 │                   └── const: 8 [type=int]
 └── aggregations
      ├── min [type=int]
      │    └── variable: k [type=int]
      ├── max [type=int]
      │    └── variable: k [type=int]
      ├── min [type=int]
      │    └── variable: v [type=int]
      └── max [type=int]
           └── variable: v [type=int]

build
SELECT array_agg(k), array_agg(s) FROM (SELECT k, s FROM kv ORDER BY k)
----
scalar-group-by
 ├── columns: array_agg:5(int[]) array_agg:6(string[])
 ├── internal-ordering: +1
 ├── project
 │    ├── columns: k:1(int!null) s:4(string)
 │    ├── ordering: +1
 │    └── scan kv
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── ordering: +1
 └── aggregations
      ├── array-agg [type=int[]]
      │    └── variable: k [type=int]
      └── array-agg [type=string[]]
           └── variable: s [type=string]

build
SELECT array_agg(k) FROM (SELECT k FROM kv ORDER BY s)
----
scalar-group-by
 ├── columns: array_agg:5(int[])
 ├── internal-ordering: +4
 ├── sort
 │    ├── columns: k:1(int!null) s:4(string)
 │    ├── ordering: +4
 │    └── project
 │         ├── columns: k:1(int!null) s:4(string)
 │         └── scan kv
 │              └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: k [type=int]

build
SELECT max(k) FROM (SELECT k FROM kv ORDER BY s)
----
scalar-group-by
 ├── columns: max:5(int)
 ├── project
 │    ├── columns: k:1(int!null)
 │    └── project
 │         ├── columns: k:1(int!null) s:4(string)
 │         └── scan kv
 │              └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      └── max [type=int]
           └── variable: k [type=int]


build
SELECT array_agg(k) || 1 FROM (SELECT k FROM kv ORDER BY s)
----
project
 ├── columns: "?column?":6(int[])
 ├── scalar-group-by
 │    ├── columns: array_agg:5(int[])
 │    ├── internal-ordering: +4
 │    ├── sort
 │    │    ├── columns: k:1(int!null) s:4(string)
 │    │    ├── ordering: +4
 │    │    └── project
 │    │         ├── columns: k:1(int!null) s:4(string)
 │    │         └── scan kv
 │    │              └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         └── array-agg [type=int[]]
 │              └── variable: k [type=int]
 └── projections
      └── concat [type=int[]]
           ├── variable: array_agg [type=int[]]
           └── const: 1 [type=int]

build
SELECT array_agg(s) FROM kv WHERE s IS NULL
----
scalar-group-by
 ├── columns: array_agg:5(string[])
 ├── project
 │    ├── columns: s:4(string)
 │    └── select
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── filters
 │              └── is [type=bool]
 │                   ├── variable: s [type=string]
 │                   └── null [type=unknown]
 └── aggregations
      └── array-agg [type=string[]]
           └── variable: s [type=string]

build
SELECT avg(k), avg(v), sum(k), sum(v) FROM kv
----
scalar-group-by
 ├── columns: avg:5(decimal) avg:6(decimal) sum:7(decimal) sum:8(decimal)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      ├── avg [type=decimal]
      │    └── variable: k [type=int]
      ├── avg [type=decimal]
      │    └── variable: v [type=int]
      ├── sum [type=decimal]
      │    └── variable: k [type=int]
      └── sum [type=decimal]
           └── variable: v [type=int]

build
SELECT avg(k::decimal), avg(v::decimal), sum(k::decimal), sum(v::decimal) FROM kv
----
scalar-group-by
 ├── columns: avg:6(decimal) avg:8(decimal) sum:9(decimal) sum:10(decimal)
 ├── project
 │    ├── columns: column5:5(decimal) column7:7(decimal)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         ├── cast: DECIMAL [type=decimal]
 │         │    └── variable: k [type=int]
 │         └── cast: DECIMAL [type=decimal]
 │              └── variable: v [type=int]
 └── aggregations
      ├── avg [type=decimal]
      │    └── variable: column5 [type=decimal]
      ├── avg [type=decimal]
      │    └── variable: column7 [type=decimal]
      ├── sum [type=decimal]
      │    └── variable: column5 [type=decimal]
      └── sum [type=decimal]
           └── variable: column7 [type=decimal]

build
SELECT avg(DISTINCT k), avg(DISTINCT v), sum(DISTINCT k), sum(DISTINCT v) FROM kv
----
scalar-group-by
 ├── columns: avg:5(decimal) avg:6(decimal) sum:7(decimal) sum:8(decimal)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── aggregations
      ├── avg [type=decimal]
      │    └── agg-distinct [type=int]
      │         └── variable: k [type=int]
      ├── avg [type=decimal]
      │    └── agg-distinct [type=int]
      │         └── variable: v [type=int]
      ├── sum [type=decimal]
      │    └── agg-distinct [type=int]
      │         └── variable: k [type=int]
      └── sum [type=decimal]
           └── agg-distinct [type=int]
                └── variable: v [type=int]

build
SELECT avg(k) * 2.0 + max(v)::DECIMAL AS r FROM kv
----
project
 ├── columns: r:7(decimal)
 ├── scalar-group-by
 │    ├── columns: avg:5(decimal) max:6(int)
 │    ├── project
 │    │    ├── columns: k:1(int!null) v:2(int)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: k [type=int]
 │         └── max [type=int]
 │              └── variable: v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: avg [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: DECIMAL [type=decimal]
                └── variable: max [type=int]

build
SELECT avg(k) * 2.0 + max(v)::DECIMAL AS r FROM kv WHERE w*2 = k
----
project
 ├── columns: r:7(decimal)
 ├── scalar-group-by
 │    ├── columns: avg:5(decimal) max:6(int)
 │    ├── project
 │    │    ├── columns: k:1(int!null) v:2(int)
 │    │    └── select
 │    │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │         ├── scan kv
 │    │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │         └── filters
 │    │              └── eq [type=bool]
 │    │                   ├── mult [type=int]
 │    │                   │    ├── variable: w [type=int]
 │    │                   │    └── const: 2 [type=int]
 │    │                   └── variable: k [type=int]
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: k [type=int]
 │         └── max [type=int]
 │              └── variable: v [type=int]
 └── projections
      └── plus [type=decimal]
           ├── mult [type=decimal]
           │    ├── variable: avg [type=decimal]
           │    └── const: 2.0 [type=decimal]
           └── cast: DECIMAL [type=decimal]
                └── variable: max [type=int]

exec-ddl
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----

build
SELECT min(a), min(b), min(c), min(d) FROM abc
----
scalar-group-by
 ├── columns: min:5(string) min:6(float) min:7(bool) min:8(decimal)
 ├── scan abc
 │    └── columns: a:1(char!null) b:2(float) c:3(bool) d:4(decimal)
 └── aggregations
      ├── min [type=char]
      │    └── variable: a [type=char]
      ├── min [type=float]
      │    └── variable: b [type=float]
      ├── min [type=bool]
      │    └── variable: c [type=bool]
      └── min [type=decimal]
           └── variable: d [type=decimal]

build
SELECT max(a), max(b), max(c), max(d) FROM abc
----
scalar-group-by
 ├── columns: max:5(string) max:6(float) max:7(bool) max:8(decimal)
 ├── scan abc
 │    └── columns: a:1(char!null) b:2(float) c:3(bool) d:4(decimal)
 └── aggregations
      ├── max [type=char]
      │    └── variable: a [type=char]
      ├── max [type=float]
      │    └── variable: b [type=float]
      ├── max [type=bool]
      │    └── variable: c [type=bool]
      └── max [type=decimal]
           └── variable: d [type=decimal]

build
SELECT avg(b), sum(b), avg(d), sum(d) FROM abc
----
scalar-group-by
 ├── columns: avg:5(float) sum:6(float) avg:7(decimal) sum:8(decimal)
 ├── project
 │    ├── columns: b:2(float) d:4(decimal)
 │    └── scan abc
 │         └── columns: a:1(char!null) b:2(float) c:3(bool) d:4(decimal)
 └── aggregations
      ├── avg [type=float]
      │    └── variable: b [type=float]
      ├── sum [type=float]
      │    └── variable: b [type=float]
      ├── avg [type=decimal]
      │    └── variable: d [type=decimal]
      └── sum [type=decimal]
           └── variable: d [type=decimal]

# Verify summing of intervals
exec-ddl
CREATE TABLE intervals (
  a INTERVAL PRIMARY KEY
)
----

build
SELECT sum(a) FROM intervals
----
scalar-group-by
 ├── columns: sum:2(interval)
 ├── scan intervals
 │    └── columns: a:1(interval!null)
 └── aggregations
      └── sum [type=interval]
           └── variable: a [type=interval]

build
SELECT avg(a) FROM abc
----
error (42883): unknown signature: avg(char)

build
SELECT avg(c) FROM abc
----
error (42883): unknown signature: avg(bool)

build
SELECT avg((a,c)) FROM abc
----
error (42883): unknown signature: avg(tuple{char, bool})

build
SELECT sum(a) FROM abc
----
error (42883): unknown signature: sum(char)

build
SELECT sum(c) FROM abc
----
error (42883): unknown signature: sum(bool)

build
SELECT sum((a,c)) FROM abc
----
error (42883): unknown signature: sum(tuple{char, bool})

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)
----

build
SELECT min(x) FROM xyz
----
scalar-group-by
 ├── columns: min:4(int)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── scan xyz
 │         └── columns: x:1(int!null) y:2(int) z:3(float)
 └── aggregations
      └── min [type=int]
           └── variable: x [type=int]

build
SELECT min(x) FROM xyz WHERE x in (0, 4, 7)
----
scalar-group-by
 ├── columns: min:4(int)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── in [type=bool]
 │                   ├── variable: x [type=int]
 │                   └── tuple [type=tuple{int, int, int}]
 │                        ├── const: 0 [type=int]
 │                        ├── const: 4 [type=int]
 │                        └── const: 7 [type=int]
 └── aggregations
      └── min [type=int]
           └── variable: x [type=int]

build
SELECT max(x) FROM xyz
----
scalar-group-by
 ├── columns: max:4(int)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── scan xyz
 │         └── columns: x:1(int!null) y:2(int) z:3(float)
 └── aggregations
      └── max [type=int]
           └── variable: x [type=int]

build
SELECT max(y) FROM xyz WHERE x = 1
----
scalar-group-by
 ├── columns: max:4(int)
 ├── project
 │    ├── columns: y:2(int)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── variable: x [type=int]
 │                   └── const: 1 [type=int]
 └── aggregations
      └── max [type=int]
           └── variable: y [type=int]

build
SELECT min(y) FROM xyz WHERE x = 7
----
scalar-group-by
 ├── columns: min:4(int)
 ├── project
 │    ├── columns: y:2(int)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── variable: x [type=int]
 │                   └── const: 7 [type=int]
 └── aggregations
      └── min [type=int]
           └── variable: y [type=int]

build
SELECT min(x) FROM xyz WHERE (y, z) = (2, 3.0)
----
scalar-group-by
 ├── columns: min:4(int)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── tuple [type=tuple{int, float}]
 │                   │    ├── variable: y [type=int]
 │                   │    └── variable: z [type=float]
 │                   └── tuple [type=tuple{int, float}]
 │                        ├── const: 2 [type=int]
 │                        └── const: 3.0 [type=float]
 └── aggregations
      └── min [type=int]
           └── variable: x [type=int]

build
SELECT max(x) FROM xyz WHERE (z, y) = (3.0, 2)
----
scalar-group-by
 ├── columns: max:4(int)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── tuple [type=tuple{float, int}]
 │                   │    ├── variable: z [type=float]
 │                   │    └── variable: y [type=int]
 │                   └── tuple [type=tuple{float, int}]
 │                        ├── const: 3.0 [type=float]
 │                        └── const: 2 [type=int]
 └── aggregations
      └── max [type=int]
           └── variable: x [type=int]


# VARIANCE/STDDEV

build
SELECT variance(x), variance(y::decimal), round(variance(z), 14) FROM xyz
----
project
 ├── columns: variance:4(decimal) variance:6(decimal) round:8(float)
 ├── scalar-group-by
 │    ├── columns: variance:4(decimal) variance:6(decimal) variance:7(float)
 │    ├── project
 │    │    ├── columns: column5:5(decimal) x:1(int!null) z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    │    └── projections
 │    │         └── cast: DECIMAL [type=decimal]
 │    │              └── variable: y [type=int]
 │    └── aggregations
 │         ├── variance [type=decimal]
 │         │    └── variable: x [type=int]
 │         ├── variance [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── variance [type=float]
 │              └── variable: z [type=float]
 └── projections
      └── function: round [type=float]
           ├── variable: variance [type=float]
           └── const: 14 [type=int]

build
SELECT variance(x) FROM xyz WHERE x = 10
----
scalar-group-by
 ├── columns: variance:4(decimal)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── variable: x [type=int]
 │                   └── const: 10 [type=int]
 └── aggregations
      └── variance [type=decimal]
           └── variable: x [type=int]

build
SELECT stddev(x), stddev(y::decimal), round(stddev(z), 14) FROM xyz
----
project
 ├── columns: stddev:4(decimal) stddev:6(decimal) round:8(float)
 ├── scalar-group-by
 │    ├── columns: stddev:4(decimal) stddev:6(decimal) stddev:7(float)
 │    ├── project
 │    │    ├── columns: column5:5(decimal) x:1(int!null) z:3(float)
 │    │    ├── scan xyz
 │    │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    │    └── projections
 │    │         └── cast: DECIMAL [type=decimal]
 │    │              └── variable: y [type=int]
 │    └── aggregations
 │         ├── std-dev [type=decimal]
 │         │    └── variable: x [type=int]
 │         ├── std-dev [type=decimal]
 │         │    └── variable: column5 [type=decimal]
 │         └── std-dev [type=float]
 │              └── variable: z [type=float]
 └── projections
      └── function: round [type=float]
           ├── variable: stddev [type=float]
           └── const: 14 [type=int]

build
SELECT stddev(x) FROM xyz WHERE x = 1
----
scalar-group-by
 ├── columns: stddev:4(decimal)
 ├── project
 │    ├── columns: x:1(int!null)
 │    └── select
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         ├── scan xyz
 │         │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── variable: x [type=int]
 │                   └── const: 1 [type=int]
 └── aggregations
      └── std-dev [type=decimal]
           └── variable: x [type=int]

build
SELECT avg(1::int)::float, avg(2::float)::float, avg(3::decimal)::float
----
project
 ├── columns: avg:7(float) avg:8(float) avg:9(float)
 ├── scalar-group-by
 │    ├── columns: avg:2(decimal) avg:4(float) avg:6(decimal)
 │    ├── project
 │    │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── cast: INT8 [type=int]
 │    │         │    └── const: 1 [type=int]
 │    │         ├── cast: FLOAT8 [type=float]
 │    │         │    └── const: 2.0 [type=float]
 │    │         └── cast: DECIMAL [type=decimal]
 │    │              └── const: 3 [type=decimal]
 │    └── aggregations
 │         ├── avg [type=decimal]
 │         │    └── variable: column1 [type=int]
 │         ├── avg [type=float]
 │         │    └── variable: column3 [type=float]
 │         └── avg [type=decimal]
 │              └── variable: column5 [type=decimal]
 └── projections
      ├── cast: FLOAT8 [type=float]
      │    └── variable: avg [type=decimal]
      ├── cast: FLOAT8 [type=float]
      │    └── variable: avg [type=float]
      └── cast: FLOAT8 [type=float]
           └── variable: avg [type=decimal]

build
SELECT count(2::int), count(3::float), count(4::decimal)
----
scalar-group-by
 ├── columns: count:2(int) count:4(int) count:6(int)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── cast: INT8 [type=int]
 │         │    └── const: 2 [type=int]
 │         ├── cast: FLOAT8 [type=float]
 │         │    └── const: 3.0 [type=float]
 │         └── cast: DECIMAL [type=decimal]
 │              └── const: 4 [type=decimal]
 └── aggregations
      ├── count [type=int]
      │    └── variable: column1 [type=int]
      ├── count [type=int]
      │    └── variable: column3 [type=float]
      └── count [type=int]
           └── variable: column5 [type=decimal]

build
SELECT sum(1::int), sum(2::float), sum(3::decimal)
----
scalar-group-by
 ├── columns: sum:2(decimal) sum:4(float) sum:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── cast: INT8 [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: FLOAT8 [type=float]
 │         │    └── const: 2.0 [type=float]
 │         └── cast: DECIMAL [type=decimal]
 │              └── const: 3 [type=decimal]
 └── aggregations
      ├── sum [type=decimal]
      │    └── variable: column1 [type=int]
      ├── sum [type=float]
      │    └── variable: column3 [type=float]
      └── sum [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT variance(1::int), variance(1::float), variance(1::decimal)
----
scalar-group-by
 ├── columns: variance:2(decimal) variance:4(float) variance:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── cast: INT8 [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: FLOAT8 [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: DECIMAL [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── variance [type=decimal]
      │    └── variable: column1 [type=int]
      ├── variance [type=float]
      │    └── variable: column3 [type=float]
      └── variance [type=decimal]
           └── variable: column5 [type=decimal]

build
SELECT stddev(1::int), stddev(1::float), stddev(1::decimal)
----
scalar-group-by
 ├── columns: stddev:2(decimal) stddev:4(float) stddev:6(decimal)
 ├── project
 │    ├── columns: column1:1(int) column3:3(float) column5:5(decimal)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         ├── cast: INT8 [type=int]
 │         │    └── const: 1 [type=int]
 │         ├── cast: FLOAT8 [type=float]
 │         │    └── const: 1.0 [type=float]
 │         └── cast: DECIMAL [type=decimal]
 │              └── const: 1 [type=decimal]
 └── aggregations
      ├── std-dev [type=decimal]
      │    └── variable: column1 [type=int]
      ├── std-dev [type=float]
      │    └── variable: column3 [type=float]
      └── std-dev [type=decimal]
           └── variable: column5 [type=decimal]

# Ensure subqueries don't trigger aggregation.
build
SELECT x > (SELECT avg(0)) AS r FROM xyz LIMIT 1
----
limit
 ├── columns: r:6(bool)
 ├── project
 │    ├── columns: r:6(bool)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: x [type=int]
 │              └── subquery [type=decimal]
 │                   └── max1-row
 │                        ├── columns: avg:5(decimal)
 │                        └── scalar-group-by
 │                             ├── columns: avg:5(decimal)
 │                             ├── project
 │                             │    ├── columns: column4:4(int!null)
 │                             │    ├── values
 │                             │    │    └── tuple [type=tuple]
 │                             │    └── projections
 │                             │         └── const: 0 [type=int]
 │                             └── aggregations
 │                                  └── avg [type=decimal]
 │                                       └── variable: column4 [type=int]
 └── const: 1 [type=int]

build
SELECT x > (SELECT avg(y) FROM xyz) AS r FROM xyz LIMIT 1
----
limit
 ├── columns: r:8(bool)
 ├── project
 │    ├── columns: r:8(bool)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: x [type=int]
 │              └── subquery [type=decimal]
 │                   └── max1-row
 │                        ├── columns: avg:7(decimal)
 │                        └── scalar-group-by
 │                             ├── columns: avg:7(decimal)
 │                             ├── project
 │                             │    ├── columns: y:5(int)
 │                             │    └── scan xyz
 │                             │         └── columns: x:4(int!null) y:5(int) z:6(float)
 │                             └── aggregations
 │                                  └── avg [type=decimal]
 │                                       └── variable: y [type=int]
 └── const: 1 [type=int]

exec-ddl
CREATE TABLE bools (b BOOL)
----

build
SELECT bool_and(b), bool_or(b) FROM bools
----
scalar-group-by
 ├── columns: bool_and:3(bool) bool_or:4(bool)
 ├── project
 │    ├── columns: b:1(bool)
 │    └── scan bools
 │         └── columns: b:1(bool) rowid:2(int!null)
 └── aggregations
      ├── bool-and [type=bool]
      │    └── variable: b [type=bool]
      └── bool-or [type=bool]
           └── variable: b [type=bool]


# Tests with * inside GROUP BY.
build
SELECT 1 r FROM kv GROUP BY kv.*;
----
project
 ├── columns: r:5(int!null)
 ├── group-by
 │    ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    ├── grouping columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── scan kv
 │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── projections
      └── const: 1 [type=int]

exec-ddl
CREATE TABLE xor_bytes (a bytes, b int, c int)
----

build
SELECT to_hex(xor_agg(a)), xor_agg(c) FROM xor_bytes
----
project
 ├── columns: to_hex:7(string) xor_agg:6(int)
 ├── scalar-group-by
 │    ├── columns: xor_agg:5(bytes) xor_agg:6(int)
 │    ├── project
 │    │    ├── columns: a:1(bytes) c:3(int)
 │    │    └── scan xor_bytes
 │    │         └── columns: a:1(bytes) b:2(int) c:3(int) rowid:4(int!null)
 │    └── aggregations
 │         ├── xor-agg [type=bytes]
 │         │    └── variable: a [type=bytes]
 │         └── xor-agg [type=int]
 │              └── variable: c [type=int]
 └── projections
      └── function: to_hex [type=string]
           └── variable: xor_agg [type=bytes]

build
SELECT to_hex(xor_agg(a)), b, xor_agg(c) FROM xor_bytes GROUP BY b ORDER BY b
----
sort
 ├── columns: to_hex:7(string) b:2(int) xor_agg:6(int)
 ├── ordering: +2
 └── project
      ├── columns: to_hex:7(string) b:2(int) xor_agg:6(int)
      ├── group-by
      │    ├── columns: b:2(int) xor_agg:5(bytes) xor_agg:6(int)
      │    ├── grouping columns: b:2(int)
      │    ├── project
      │    │    ├── columns: a:1(bytes) b:2(int) c:3(int)
      │    │    └── scan xor_bytes
      │    │         └── columns: a:1(bytes) b:2(int) c:3(int) rowid:4(int!null)
      │    └── aggregations
      │         ├── xor-agg [type=bytes]
      │         │    └── variable: a [type=bytes]
      │         └── xor-agg [type=int]
      │              └── variable: c [type=int]
      └── projections
           └── function: to_hex [type=string]
                └── variable: xor_agg [type=bytes]

# At execution time, this query will cause the error:
# "arguments to xor must all be the same length"
build
SELECT xor_agg(i) FROM (VALUES (b'\x01'), (b'\x01\x01')) AS a(i)
----
scalar-group-by
 ├── columns: xor_agg:2(bytes)
 ├── values
 │    ├── columns: column1:1(bytes!null)
 │    ├── tuple [type=tuple{bytes}]
 │    │    └── const: '\x01' [type=bytes]
 │    └── tuple [type=tuple{bytes}]
 │         └── const: '\x0101' [type=bytes]
 └── aggregations
      └── xor-agg [type=bytes]
           └── variable: column1 [type=bytes]

build
SELECT max(true), min(true)
----
scalar-group-by
 ├── columns: max:2(bool) min:3(bool)
 ├── project
 │    ├── columns: column1:1(bool!null)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── projections
 │         └── true [type=bool]
 └── aggregations
      ├── max [type=bool]
      │    └── variable: column1 [type=bool]
      └── min [type=bool]
           └── variable: column1 [type=bool]

build
SELECT concat_agg(s) FROM (SELECT s FROM kv ORDER BY k)
----
scalar-group-by
 ├── columns: concat_agg:5(string)
 ├── internal-ordering: +1
 ├── project
 │    ├── columns: k:1(int!null) s:4(string)
 │    ├── ordering: +1
 │    └── scan kv
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── ordering: +1
 └── aggregations
      └── concat-agg [type=string]
           └── variable: s [type=string]

build
SELECT json_agg(s) FROM (SELECT s FROM kv ORDER BY k)
----
scalar-group-by
 ├── columns: json_agg:5(jsonb)
 ├── internal-ordering: +1
 ├── project
 │    ├── columns: k:1(int!null) s:4(string)
 │    ├── ordering: +1
 │    └── scan kv
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── ordering: +1
 └── aggregations
      └── json-agg [type=jsonb]
           └── variable: s [type=string]

build
SELECT jsonb_agg(s) FROM (SELECT s FROM kv ORDER BY k)
----
scalar-group-by
 ├── columns: jsonb_agg:5(jsonb)
 ├── internal-ordering: +1
 ├── project
 │    ├── columns: k:1(int!null) s:4(string)
 │    ├── ordering: +1
 │    └── scan kv
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── ordering: +1
 └── aggregations
      └── jsonb-agg [type=jsonb]
           └── variable: s [type=string]

exec-ddl
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)
----

exec-ddl
CREATE TABLE xy(x STRING, y STRING);
----

# Grouping and rendering tuples.
build
SELECT (b, a) AS r FROM ab GROUP BY (b, a)
----
project
 ├── columns: r:3(tuple{int, int})
 ├── group-by
 │    ├── columns: a:1(int!null) b:2(int)
 │    ├── grouping columns: a:1(int!null) b:2(int)
 │    └── scan ab
 │         └── columns: a:1(int!null) b:2(int)
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: b [type=int]
           └── variable: a [type=int]

build
SELECT min(y), (b, a) AS r
 FROM ab, xy GROUP BY (x, (a, b))
----
project
 ├── columns: min:6(string) r:7(tuple{int, int})
 ├── group-by
 │    ├── columns: a:1(int!null) b:2(int) x:3(string) min:6(string)
 │    ├── grouping columns: a:1(int!null) b:2(int) x:3(string)
 │    ├── project
 │    │    ├── columns: a:1(int!null) b:2(int) x:3(string) y:4(string)
 │    │    └── inner-join (hash)
 │    │         ├── columns: a:1(int!null) b:2(int) x:3(string) y:4(string) rowid:5(int!null)
 │    │         ├── scan ab
 │    │         │    └── columns: a:1(int!null) b:2(int)
 │    │         ├── scan xy
 │    │         │    └── columns: x:3(string) y:4(string) rowid:5(int!null)
 │    │         └── filters (true)
 │    └── aggregations
 │         └── min [type=string]
 │              └── variable: y [type=string]
 └── projections
      └── tuple [type=tuple{int, int}]
           ├── variable: b [type=int]
           └── variable: a [type=int]

build
SELECT v, count(k) FROM kv GROUP BY v ORDER BY count(k)
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: v:2(int) count:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count [type=int]
                └── variable: k [type=int]

build
SELECT v, count(*) FROM kv GROUP BY v ORDER BY count(*)
----
sort
 ├── columns: v:2(int) count:5(int)
 ├── ordering: +5
 └── group-by
      ├── columns: v:2(int) count_rows:5(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: v:2(int)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT v, count(1) FROM kv GROUP BY v ORDER BY count(1)
----
sort
 ├── columns: v:2(int) count:6(int)
 ├── ordering: +6
 └── group-by
      ├── columns: v:2(int) count:6(int)
      ├── grouping columns: v:2(int)
      ├── project
      │    ├── columns: column5:5(int!null) v:2(int)
      │    ├── scan kv
      │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── projections
      │         └── const: 1 [type=int]
      └── aggregations
           └── count [type=int]
                └── variable: column5 [type=int]

build
SELECT (k+v)/(v+w) AS r FROM kv GROUP BY k+v, v+w;
----
project
 ├── columns: r:7(decimal)
 ├── group-by
 │    ├── columns: column5:5(int) column6:6(int)
 │    ├── grouping columns: column5:5(int) column6:6(int)
 │    └── project
 │         ├── columns: column5:5(int) column6:6(int)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── projections
 │              ├── plus [type=int]
 │              │    ├── variable: k [type=int]
 │              │    └── variable: v [type=int]
 │              └── plus [type=int]
 │                   ├── variable: v [type=int]
 │                   └── variable: w [type=int]
 └── projections
      └── div [type=decimal]
           ├── variable: column5 [type=int]
           └── variable: column6 [type=int]

# Check that everything still works with differently qualified names
build fully-qualify-names
SELECT sum(t.kv.w), t.kv.v FROM t.kv GROUP BY v, kv.k * w
----
project
 ├── columns: sum:5(decimal) v:2(int)
 └── group-by
      ├── columns: t.public.kv.v:2(int) sum:5(decimal) column6:6(int)
      ├── grouping columns: t.public.kv.v:2(int) column6:6(int)
      ├── project
      │    ├── columns: column6:6(int) t.public.kv.v:2(int) t.public.kv.w:3(int)
      │    ├── scan t.public.kv
      │    │    └── columns: t.public.kv.k:1(int!null) t.public.kv.v:2(int) t.public.kv.w:3(int) t.public.kv.s:4(string)
      │    └── projections
      │         └── mult [type=int]
      │              ├── variable: t.public.kv.k [type=int]
      │              └── variable: t.public.kv.w [type=int]
      └── aggregations
           └── sum [type=decimal]
                └── variable: t.public.kv.w [type=int]

build fully-qualify-names
SELECT sum(t.kv.w), lower(s), t.kv.v + k * t.kv.w AS r, t.kv.v FROM t.kv GROUP BY v, lower(kv.s), kv.k * w
----
project
 ├── columns: sum:5(decimal) lower:6(string) r:8(int) v:2(int)
 ├── group-by
 │    ├── columns: t.public.kv.v:2(int) sum:5(decimal) column6:6(string) column7:7(int)
 │    ├── grouping columns: t.public.kv.v:2(int) column6:6(string) column7:7(int)
 │    ├── project
 │    │    ├── columns: column6:6(string) column7:7(int) t.public.kv.v:2(int) t.public.kv.w:3(int)
 │    │    ├── scan t.public.kv
 │    │    │    └── columns: t.public.kv.k:1(int!null) t.public.kv.v:2(int) t.public.kv.w:3(int) t.public.kv.s:4(string)
 │    │    └── projections
 │    │         ├── function: lower [type=string]
 │    │         │    └── variable: t.public.kv.s [type=string]
 │    │         └── mult [type=int]
 │    │              ├── variable: t.public.kv.k [type=int]
 │    │              └── variable: t.public.kv.w [type=int]
 │    └── aggregations
 │         └── sum [type=decimal]
 │              └── variable: t.public.kv.w [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: t.public.kv.v [type=int]
           └── variable: column7 [type=int]

# Check all the different types of scalar expressions as group by columns
build
SELECT b1.b AND abc.c AND b2.b AS r FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
project
 ├── columns: r:10(bool)
 ├── group-by
 │    ├── columns: b2.b:3(bool) column9:9(bool)
 │    ├── grouping columns: b2.b:3(bool) column9:9(bool)
 │    └── project
 │         ├── columns: column9:9(bool) b2.b:3(bool)
 │         ├── inner-join (hash)
 │         │    ├── columns: b1.b:1(bool) b1.rowid:2(int!null) b2.b:3(bool) b2.rowid:4(int!null) a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    ├── scan b1
 │         │    │    └── columns: b1.b:1(bool) b1.rowid:2(int!null)
 │         │    ├── inner-join (hash)
 │         │    │    ├── columns: b2.b:3(bool) b2.rowid:4(int!null) a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    │    ├── scan b2
 │         │    │    │    └── columns: b2.b:3(bool) b2.rowid:4(int!null)
 │         │    │    ├── scan abc
 │         │    │    │    └── columns: a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    │    └── filters (true)
 │         │    └── filters (true)
 │         └── projections
 │              └── and [type=bool]
 │                   ├── variable: b1.b [type=bool]
 │                   └── variable: c [type=bool]
 └── projections
      └── and [type=bool]
           ├── variable: column9 [type=bool]
           └── variable: b2.b [type=bool]

build
SELECT b1.b AND abc.c AND abc.c FROM bools b1, bools b2, abc GROUP BY b1.b AND abc.c, b2.b
----
error (42803): column "c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b1.b OR abc.c OR b2.b AS r FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
project
 ├── columns: r:10(bool)
 ├── group-by
 │    ├── columns: b2.b:3(bool) column9:9(bool)
 │    ├── grouping columns: b2.b:3(bool) column9:9(bool)
 │    └── project
 │         ├── columns: column9:9(bool) b2.b:3(bool)
 │         ├── inner-join (hash)
 │         │    ├── columns: b1.b:1(bool) b1.rowid:2(int!null) b2.b:3(bool) b2.rowid:4(int!null) a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    ├── scan b1
 │         │    │    └── columns: b1.b:1(bool) b1.rowid:2(int!null)
 │         │    ├── inner-join (hash)
 │         │    │    ├── columns: b2.b:3(bool) b2.rowid:4(int!null) a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    │    ├── scan b2
 │         │    │    │    └── columns: b2.b:3(bool) b2.rowid:4(int!null)
 │         │    │    ├── scan abc
 │         │    │    │    └── columns: a:5(char!null) abc.b:6(float) c:7(bool) d:8(decimal)
 │         │    │    └── filters (true)
 │         │    └── filters (true)
 │         └── projections
 │              └── or [type=bool]
 │                   ├── variable: b1.b [type=bool]
 │                   └── variable: c [type=bool]
 └── projections
      └── or [type=bool]
           ├── variable: column9 [type=bool]
           └── variable: b2.b [type=bool]

build
SELECT b1.b OR abc.c OR abc.c FROM bools b1, bools b2, abc GROUP BY b1.b OR abc.c, b2.b
----
error (42803): column "c" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k % w % v AS r FROM kv GROUP BY k % w, v
----
project
 ├── columns: r:6(int)
 ├── group-by
 │    ├── columns: v:2(int) column5:5(int)
 │    ├── grouping columns: v:2(int) column5:5(int)
 │    └── project
 │         ├── columns: column5:5(int) v:2(int)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── projections
 │              └── mod [type=int]
 │                   ├── variable: k [type=int]
 │                   └── variable: w [type=int]
 └── projections
      └── mod [type=int]
           ├── variable: column5 [type=int]
           └── variable: v [type=int]

build
SELECT concat(concat(s, a), a) FROM kv, abc GROUP BY concat(s, a), a
----
project
 ├── columns: concat:10(string)
 ├── group-by
 │    ├── columns: a:5(char!null) column9:9(string)
 │    ├── grouping columns: a:5(char!null) column9:9(string)
 │    └── project
 │         ├── columns: column9:9(string) a:5(char!null)
 │         ├── inner-join (hash)
 │         │    ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) a:5(char!null) b:6(float) c:7(bool) d:8(decimal)
 │         │    ├── scan kv
 │         │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         │    ├── scan abc
 │         │    │    └── columns: a:5(char!null) b:6(float) c:7(bool) d:8(decimal)
 │         │    └── filters (true)
 │         └── projections
 │              └── function: concat [type=string]
 │                   ├── variable: s [type=string]
 │                   └── variable: a [type=char]
 └── projections
      └── function: concat [type=string]
           ├── variable: column9 [type=string]
           └── variable: a [type=char]

build
SELECT concat(concat(s, a), s) FROM kv, abc GROUP BY concat(s, a), a
----
error (42803): column "s" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT k < w AND v != 5 AS r FROM kv GROUP BY k < w, v
----
project
 ├── columns: r:6(bool)
 ├── group-by
 │    ├── columns: v:2(int) column5:5(bool)
 │    ├── grouping columns: v:2(int) column5:5(bool)
 │    └── project
 │         ├── columns: column5:5(bool) v:2(int)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── projections
 │              └── lt [type=bool]
 │                   ├── variable: k [type=int]
 │                   └── variable: w [type=int]
 └── projections
      └── and [type=bool]
           ├── variable: column5 [type=bool]
           └── ne [type=bool]
                ├── variable: v [type=int]
                └── const: 5 [type=int]

build
SELECT k < w AND k < v FROM kv GROUP BY k < w, v
----
error (42803): column "k" must appear in the GROUP BY clause or be used in an aggregate function

exec-ddl
CREATE TABLE foo (bar JSON, baz JSON)
----

build
SELECT a.bar @> b.baz AND b.baz @> b.baz AS r FROM foo AS a, foo AS b GROUP BY a.bar @> b.baz, b.baz
----
project
 ├── columns: r:8(bool)
 ├── group-by
 │    ├── columns: b.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: b.baz:5(jsonb) column7:7(bool)
 │    └── project
 │         ├── columns: column7:7(bool) b.baz:5(jsonb)
 │         ├── inner-join (hash)
 │         │    ├── columns: a.bar:1(jsonb) a.baz:2(jsonb) a.rowid:3(int!null) b.bar:4(jsonb) b.baz:5(jsonb) b.rowid:6(int!null)
 │         │    ├── scan a
 │         │    │    └── columns: a.bar:1(jsonb) a.baz:2(jsonb) a.rowid:3(int!null)
 │         │    ├── scan b
 │         │    │    └── columns: b.bar:4(jsonb) b.baz:5(jsonb) b.rowid:6(int!null)
 │         │    └── filters (true)
 │         └── projections
 │              └── contains [type=bool]
 │                   ├── variable: a.bar [type=jsonb]
 │                   └── variable: b.baz [type=jsonb]
 └── projections
      └── and [type=bool]
           ├── variable: column7 [type=bool]
           └── contains [type=bool]
                ├── variable: b.baz [type=jsonb]
                └── variable: b.baz [type=jsonb]

build
SELECT a.bar @> b.baz AND b.baz @> b.baz FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
error (42803): column "bar" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT b.baz <@ a.bar AND b.baz <@ b.baz AS r FROM foo AS a, foo AS b GROUP BY b.baz <@ a.bar, b.baz
----
project
 ├── columns: r:8(bool)
 ├── group-by
 │    ├── columns: b.baz:5(jsonb) column7:7(bool)
 │    ├── grouping columns: b.baz:5(jsonb) column7:7(bool)
 │    └── project
 │         ├── columns: column7:7(bool) b.baz:5(jsonb)
 │         ├── inner-join (hash)
 │         │    ├── columns: a.bar:1(jsonb) a.baz:2(jsonb) a.rowid:3(int!null) b.bar:4(jsonb) b.baz:5(jsonb) b.rowid:6(int!null)
 │         │    ├── scan a
 │         │    │    └── columns: a.bar:1(jsonb) a.baz:2(jsonb) a.rowid:3(int!null)
 │         │    ├── scan b
 │         │    │    └── columns: b.bar:4(jsonb) b.baz:5(jsonb) b.rowid:6(int!null)
 │         │    └── filters (true)
 │         └── projections
 │              └── contains [type=bool]
 │                   ├── variable: a.bar [type=jsonb]
 │                   └── variable: b.baz [type=jsonb]
 └── projections
      └── and [type=bool]
           ├── variable: column7 [type=bool]
           └── contains [type=bool]
                ├── variable: b.baz [type=jsonb]
                └── variable: b.baz [type=jsonb]

exec-ddl
CREATE TABLE times (t time PRIMARY KEY)
----

build
SELECT date_trunc('second', a.t) - date_trunc('minute', b.t) AS r FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
project
 ├── columns: r:5(interval)
 ├── group-by
 │    ├── columns: column3:3(interval) column4:4(interval)
 │    ├── grouping columns: column3:3(interval) column4:4(interval)
 │    └── project
 │         ├── columns: column3:3(interval) column4:4(interval)
 │         ├── inner-join (hash)
 │         │    ├── columns: a.t:1(time!null) b.t:2(time!null)
 │         │    ├── scan a
 │         │    │    └── columns: a.t:1(time!null)
 │         │    ├── scan b
 │         │    │    └── columns: b.t:2(time!null)
 │         │    └── filters (true)
 │         └── projections
 │              ├── function: date_trunc [type=interval]
 │              │    ├── const: 'second' [type=string]
 │              │    └── variable: a.t [type=time]
 │              └── function: date_trunc [type=interval]
 │                   ├── const: 'minute' [type=string]
 │                   └── variable: b.t [type=time]
 └── projections
      └── minus [type=interval]
           ├── variable: column3 [type=interval]
           └── variable: column4 [type=interval]

build
SELECT date_trunc('second', a.t) - date_trunc('second', b.t) FROM times a, times b
  GROUP BY date_trunc('second', a.t), date_trunc('minute', b.t)
----
error (42803): column "t" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b AS r FROM bools GROUP BY NOT b
----
group-by
 ├── columns: r:3(bool)
 ├── grouping columns: column3:3(bool)
 └── project
      ├── columns: column3:3(bool)
      ├── scan bools
      │    └── columns: b:1(bool) rowid:2(int!null)
      └── projections
           └── not [type=bool]
                └── variable: b [type=bool]

build
SELECT b FROM bools GROUP BY NOT b
----
error (42803): column "b" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT NOT b AS r FROM bools GROUP BY b
----
project
 ├── columns: r:3(bool)
 ├── group-by
 │    ├── columns: b:1(bool)
 │    ├── grouping columns: b:1(bool)
 │    └── project
 │         ├── columns: b:1(bool)
 │         └── scan bools
 │              └── columns: b:1(bool) rowid:2(int!null)
 └── projections
      └── not [type=bool]
           └── variable: b [type=bool]

build
SELECT +k * (-w) AS r FROM kv GROUP BY +k, -w
----
project
 ├── columns: r:6(int)
 ├── group-by
 │    ├── columns: k:1(int!null) column5:5(int)
 │    ├── grouping columns: k:1(int!null) column5:5(int)
 │    └── project
 │         ├── columns: column5:5(int) k:1(int!null)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── projections
 │              └── unary-minus [type=int]
 │                   └── variable: w [type=int]
 └── projections
      └── mult [type=int]
           ├── variable: k [type=int]
           └── variable: column5 [type=int]

build
SELECT k * (-w) FROM kv GROUP BY +k, -w
----
project
 ├── columns: "?column?":6(int)
 ├── group-by
 │    ├── columns: k:1(int!null) column5:5(int)
 │    ├── grouping columns: k:1(int!null) column5:5(int)
 │    └── project
 │         ├── columns: column5:5(int) k:1(int!null)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         └── projections
 │              └── unary-minus [type=int]
 │                   └── variable: w [type=int]
 └── projections
      └── mult [type=int]
           ├── variable: k [type=int]
           └── variable: column5 [type=int]

build
SELECT +k * (-w) AS r FROM kv GROUP BY k, w
----
project
 ├── columns: r:5(int)
 ├── group-by
 │    ├── columns: k:1(int!null) w:3(int)
 │    ├── grouping columns: k:1(int!null) w:3(int)
 │    └── project
 │         ├── columns: k:1(int!null) w:3(int)
 │         └── scan kv
 │              └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 └── projections
      └── mult [type=int]
           ├── variable: k [type=int]
           └── unary-minus [type=int]
                └── variable: w [type=int]

build
SELECT 1 + min(v*2) AS r FROM kv GROUP BY k+3
----
project
 ├── columns: r:8(int)
 ├── group-by
 │    ├── columns: min:6(int) column7:7(int)
 │    ├── grouping columns: column7:7(int)
 │    ├── project
 │    │    ├── columns: column5:5(int) column7:7(int)
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    └── projections
 │    │         ├── mult [type=int]
 │    │         │    ├── variable: v [type=int]
 │    │         │    └── const: 2 [type=int]
 │    │         └── plus [type=int]
 │    │              ├── variable: k [type=int]
 │    │              └── const: 3 [type=int]
 │    └── aggregations
 │         └── min [type=int]
 │              └── variable: column5 [type=int]
 └── projections
      └── plus [type=int]
           ├── const: 1 [type=int]
           └── variable: min [type=int]

build
SELECT count(*) FROM kv GROUP BY k, k
----
project
 ├── columns: count:5(int)
 └── group-by
      ├── columns: k:1(int!null) count_rows:5(int)
      ├── grouping columns: k:1(int!null)
      ├── project
      │    ├── columns: k:1(int!null)
      │    └── scan kv
      │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      └── aggregations
           └── count-rows [type=int]

build
SELECT count(upper(s)) FROM kv GROUP BY upper(s)
----
project
 ├── columns: count:6(int)
 └── group-by
      ├── columns: column5:5(string) count:6(int)
      ├── grouping columns: column5:5(string)
      ├── project
      │    ├── columns: column5:5(string)
      │    ├── scan kv
      │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── projections
      │         └── function: upper [type=string]
      │              └── variable: s [type=string]
      └── aggregations
           └── count [type=int]
                └── variable: column5 [type=string]

build
SELECT sum(abc.d) FROM kv JOIN abc ON kv.k >= abc.d GROUP BY kv.*
----
project
 ├── columns: sum:9(decimal)
 └── group-by
      ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) sum:9(decimal)
      ├── grouping columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      ├── project
      │    ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) d:8(decimal!null)
      │    └── inner-join (hash)
      │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) a:5(char!null) b:6(float) c:7(bool) d:8(decimal!null)
      │         ├── scan kv
      │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │         ├── scan abc
      │         │    └── columns: a:5(char!null) b:6(float) c:7(bool) d:8(decimal)
      │         └── filters
      │              └── ge [type=bool]
      │                   ├── variable: k [type=int]
      │                   └── variable: d [type=decimal]
      └── aggregations
           └── sum [type=decimal]
                └── variable: d [type=decimal]

build
SELECT sum(DISTINCT abc.d) FROM abc
----
scalar-group-by
 ├── columns: sum:5(decimal)
 ├── project
 │    ├── columns: d:4(decimal)
 │    └── scan abc
 │         └── columns: a:1(char!null) b:2(float) c:3(bool) d:4(decimal)
 └── aggregations
      └── sum [type=decimal]
           └── agg-distinct [type=decimal]
                └── variable: d [type=decimal]

# FILTER.

build
SELECT sum(abc.d) FILTER (WHERE abc.d > 0) FROM abc
----
scalar-group-by
 ├── columns: sum:6(decimal)
 ├── project
 │    ├── columns: column5:5(bool) d:4(decimal)
 │    ├── scan abc
 │    │    └── columns: a:1(char!null) b:2(float) c:3(bool) d:4(decimal)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: d [type=decimal]
 │              └── const: 0 [type=decimal]
 └── aggregations
      └── sum [type=decimal]
           └── agg-filter [type=decimal]
                ├── variable: d [type=decimal]
                └── filter
                     └── variable: column5 [type=bool]

# Ensure aggregates with FILTER coexist properly with non-FILTER aggregates.
build
SELECT
    sum(x) FILTER (WHERE y > 0),
    avg(DISTINCT z),
    avg(DISTINCT z) FILTER (WHERE y > 0)
FROM xyz
----
scalar-group-by
 ├── columns: sum:5(decimal) avg:6(float) avg:7(float)
 ├── project
 │    ├── columns: column4:4(bool) x:1(int!null) z:3(float)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: y [type=int]
 │              └── const: 0 [type=int]
 └── aggregations
      ├── sum [type=decimal]
      │    └── agg-filter [type=int]
      │         ├── variable: x [type=int]
      │         └── filter
      │              └── variable: column4 [type=bool]
      ├── avg [type=float]
      │    └── agg-distinct [type=float]
      │         └── variable: z [type=float]
      └── avg [type=float]
           └── agg-filter [type=float]
                ├── agg-distinct [type=float]
                │    └── variable: z [type=float]
                └── filter
                     └── variable: column4 [type=bool]

# Ensure aggregates involving FILTER are deduplicated.
build
SELECT
    avg(DISTINCT x),
    avg(DISTINCT x),
    avg(DISTINCT x) FILTER (WHERE y > 0),
    avg(DISTINCT x) FILTER (WHERE y > 0)
FROM xyz
----
scalar-group-by
 ├── columns: avg:4(decimal) avg:4(decimal) avg:6(decimal) avg:6(decimal)
 ├── project
 │    ├── columns: column5:5(bool) x:1(int!null)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         └── gt [type=bool]
 │              ├── variable: y [type=int]
 │              └── const: 0 [type=int]
 └── aggregations
      ├── avg [type=decimal]
      │    └── agg-distinct [type=int]
      │         └── variable: x [type=int]
      └── avg [type=decimal]
           └── agg-filter [type=int]
                ├── agg-distinct [type=int]
                │    └── variable: x [type=int]
                └── filter
                     └── variable: column5 [type=bool]

build
SELECT
    string_agg(x::string, 'foo') FILTER (WHERE y > 0)
FROM xyz
----
scalar-group-by
 ├── columns: string_agg:7(string)
 ├── project
 │    ├── columns: column4:4(string) column5:5(string!null) column6:6(bool)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         ├── cast: STRING [type=string]
 │         │    └── variable: x [type=int]
 │         ├── const: 'foo' [type=string]
 │         └── gt [type=bool]
 │              ├── variable: y [type=int]
 │              └── const: 0 [type=int]
 └── aggregations
      └── string-agg [type=string]
           ├── agg-filter [type=string]
           │    ├── variable: column4 [type=string]
           │    └── filter
           │         └── variable: column6 [type=bool]
           └── const: 'foo' [type=string]

build
SELECT y, count(*) FILTER (WHERE x > 5) FROM xyz GROUP BY y
----
group-by
 ├── columns: y:2(int) count:6(int)
 ├── grouping columns: y:2(int)
 ├── project
 │    ├── columns: column4:4(bool!null) column5:5(bool) y:2(int)
 │    ├── scan xyz
 │    │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │    └── projections
 │         ├── true [type=bool]
 │         └── gt [type=bool]
 │              ├── variable: x [type=int]
 │              └── const: 5 [type=int]
 └── aggregations
      └── count [type=int]
           └── agg-filter [type=bool]
                ├── variable: column4 [type=bool]
                └── filter
                     └── variable: column5 [type=bool]

build
SELECT y, count(*) FILTER (WHERE count(*) > 5) FROM xyz GROUP BY y
----
error (42803): count_rows(): aggregate functions are not allowed in FILTER


# Check that ordering by an alias of an aggregate works.
build
SELECT max(k) AS mk FROM kv GROUP BY v ORDER BY mk
----
sort
 ├── columns: mk:5(int)
 ├── ordering: +5
 └── project
      ├── columns: max:5(int)
      └── group-by
           ├── columns: v:2(int) max:5(int)
           ├── grouping columns: v:2(int)
           ├── project
           │    ├── columns: k:1(int!null) v:2(int)
           │    └── scan kv
           │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: k [type=int]

build
SELECT max(k) AS mk FROM kv GROUP BY v ORDER BY max(k)
----
sort
 ├── columns: mk:5(int)
 ├── ordering: +5
 └── project
      ├── columns: max:5(int)
      └── group-by
           ├── columns: v:2(int) max:5(int)
           ├── grouping columns: v:2(int)
           ├── project
           │    ├── columns: k:1(int!null) v:2(int)
           │    └── scan kv
           │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: k [type=int]

build
SELECT max(k) AS mk1, max(k) AS mk2 FROM kv GROUP BY v ORDER BY mk1
----
sort
 ├── columns: mk1:5(int) mk2:5(int)
 ├── ordering: +5
 └── project
      ├── columns: max:5(int)
      └── group-by
           ├── columns: v:2(int) max:5(int)
           ├── grouping columns: v:2(int)
           ├── project
           │    ├── columns: k:1(int!null) v:2(int)
           │    └── scan kv
           │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: k [type=int]

build
SELECT max(k) AS mk1, max(k) AS mk2 FROM kv GROUP BY v ORDER BY mk2
----
sort
 ├── columns: mk1:5(int) mk2:5(int)
 ├── ordering: +5
 └── project
      ├── columns: max:5(int)
      └── group-by
           ├── columns: v:2(int) max:5(int)
           ├── grouping columns: v:2(int)
           ├── project
           │    ├── columns: k:1(int!null) v:2(int)
           │    └── scan kv
           │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
           └── aggregations
                └── max [type=int]
                     └── variable: k [type=int]

build
SELECT max(k) AS mk1, max(k)/5 AS mk2 FROM kv GROUP BY v ORDER BY mk2
----
sort
 ├── columns: mk1:5(int) mk2:6(decimal)
 ├── ordering: +6
 └── project
      ├── columns: mk2:6(decimal) max:5(int)
      ├── group-by
      │    ├── columns: v:2(int) max:5(int)
      │    ├── grouping columns: v:2(int)
      │    ├── project
      │    │    ├── columns: k:1(int!null) v:2(int)
      │    │    └── scan kv
      │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── aggregations
      │         └── max [type=int]
      │              └── variable: k [type=int]
      └── projections
           └── div [type=decimal]
                ├── variable: max [type=int]
                └── const: 5 [type=int]

# Grouping columns cannot be reused inside an aggregate input expression
# because the aggregate input expressions and grouping expressions are
# built as part of the same projection. 
build
SELECT max((k+v)/(k-v)) AS r, (k+v)*(k-v) AS s FROM kv GROUP BY k+v, k-v
----
project
 ├── columns: r:6(decimal) s:9(int)
 ├── group-by
 │    ├── columns: max:6(decimal) column7:7(int) column8:8(int)
 │    ├── grouping columns: column7:7(int) column8:8(int)
 │    ├── project
 │    │    ├── columns: column5:5(decimal) column7:7(int) column8:8(int)
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) kv.s:4(string)
 │    │    └── projections
 │    │         ├── div [type=decimal]
 │    │         │    ├── plus [type=int]
 │    │         │    │    ├── variable: k [type=int]
 │    │         │    │    └── variable: v [type=int]
 │    │         │    └── minus [type=int]
 │    │         │         ├── variable: k [type=int]
 │    │         │         └── variable: v [type=int]
 │    │         ├── plus [type=int]
 │    │         │    ├── variable: k [type=int]
 │    │         │    └── variable: v [type=int]
 │    │         └── minus [type=int]
 │    │              ├── variable: k [type=int]
 │    │              └── variable: v [type=int]
 │    └── aggregations
 │         └── max [type=decimal]
 │              └── variable: column5 [type=decimal]
 └── projections
      └── mult [type=int]
           ├── variable: column7 [type=int]
           └── variable: column8 [type=int]

build
SELECT max((k+v)/(k-v)) AS r, (k+v)*(k-v) AS s FROM kv GROUP BY k+v, (k+v)/(k-v), (k+v)*(k-v)
----
project
 ├── columns: r:6(decimal) s:8(int)
 └── group-by
      ├── columns: column5:5(decimal) max:6(decimal) column7:7(int) column8:8(int)
      ├── grouping columns: column5:5(decimal) column7:7(int) column8:8(int)
      ├── project
      │    ├── columns: column5:5(decimal) column7:7(int) column8:8(int)
      │    ├── scan kv
      │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── projections
      │         ├── div [type=decimal]
      │         │    ├── plus [type=int]
      │         │    │    ├── variable: k [type=int]
      │         │    │    └── variable: v [type=int]
      │         │    └── minus [type=int]
      │         │         ├── variable: k [type=int]
      │         │         └── variable: v [type=int]
      │         ├── plus [type=int]
      │         │    ├── variable: k [type=int]
      │         │    └── variable: v [type=int]
      │         └── mult [type=int]
      │              ├── plus [type=int]
      │              │    ├── variable: k [type=int]
      │              │    └── variable: v [type=int]
      │              └── minus [type=int]
      │                   ├── variable: k [type=int]
      │                   └── variable: v [type=int]
      └── aggregations
           └── max [type=decimal]
                └── variable: column5 [type=decimal]

# Tests for string_agg.

build
SELECT string_agg(s, 'separator') FROM kv
----
scalar-group-by
 ├── columns: string_agg:6(string)
 ├── project
 │    ├── columns: column5:5(string!null) s:4(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── const: 'separator' [type=string]
 └── aggregations
      └── string-agg [type=string]
           ├── variable: s [type=string]
           └── const: 'separator' [type=string]

build
SELECT string_agg(s) FROM kv
----
error (42883): unknown signature: string_agg(string)

build
SELECT string_agg(s, 'x', 'y') FROM kv
----
error (42883): unknown signature: string_agg(string, string, string)

build
SELECT string_agg(DISTINCT s, 'separator') FROM kv
----
scalar-group-by
 ├── columns: string_agg:6(string)
 ├── project
 │    ├── columns: column5:5(string!null) s:4(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── const: 'separator' [type=string]
 └── aggregations
      └── string-agg [type=string]
           ├── agg-distinct [type=string]
           │    └── variable: s [type=string]
           └── const: 'separator' [type=string]

build
SELECT max(s), string_agg(s, 'sep1'), string_agg(s, 'sep2'), min(s) FROM kv
----
scalar-group-by
 ├── columns: max:5(string) string_agg:7(string) string_agg:9(string) min:10(string)
 ├── project
 │    ├── columns: column6:6(string!null) column8:8(string!null) s:4(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         ├── const: 'sep1' [type=string]
 │         └── const: 'sep2' [type=string]
 └── aggregations
      ├── max [type=string]
      │    └── variable: s [type=string]
      ├── string-agg [type=string]
      │    ├── variable: s [type=string]
      │    └── const: 'sep1' [type=string]
      ├── string-agg [type=string]
      │    ├── variable: s [type=string]
      │    └── const: 'sep2' [type=string]
      └── min [type=string]
           └── variable: s [type=string]

# The separator must be constant, but it need not be a literal - any constant (as
# determined by tree.IsConst) is valid.
build
SELECT string_agg(s, 'abc' || 'xyz') FROM kv
----
scalar-group-by
 ├── columns: string_agg:6(string)
 ├── project
 │    ├── columns: column5:5(string!null) s:4(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── const: 'abcxyz' [type=string]
 └── aggregations
      └── string-agg [type=string]
           ├── variable: s [type=string]
           └── const: 'abcxyz' [type=string]

build
SELECT string_agg(s, NULL) FROM kv
----
scalar-group-by
 ├── columns: string_agg:6(string)
 ├── project
 │    ├── columns: column5:5(unknown) s:4(string)
 │    ├── scan kv
 │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── projections
 │         └── null [type=unknown]
 └── aggregations
      └── string-agg [type=string]
           ├── variable: s [type=string]
           └── null [type=unknown]

build
SELECT string_agg('foo', s) FROM kv
----
error (0A000): unimplemented: aggregate functions with multiple non-constant expressions are not supported

# Regression test for #26419
build
SELECT 123 r FROM kv ORDER BY max(v)
----
project
 ├── columns: r:6(int!null)  [hidden: max:5(int)]
 ├── ordering: +5
 ├── scalar-group-by
 │    ├── columns: max:5(int)
 │    ├── project
 │    │    ├── columns: v:2(int)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         └── max [type=int]
 │              └── variable: v [type=int]
 └── projections
      └── const: 123 [type=int]

# Check that ordering columns are projected correctly.
build
SELECT array_agg(y) FROM (SELECT * FROM xyz ORDER BY x+y)
----
scalar-group-by
 ├── columns: array_agg:5(int[])
 ├── internal-ordering: +4
 ├── sort
 │    ├── columns: y:2(int) column4:4(int)
 │    ├── ordering: +4
 │    └── project
 │         ├── columns: y:2(int) column4:4(int)
 │         └── project
 │              ├── columns: column4:4(int) x:1(int!null) y:2(int) z:3(float)
 │              ├── scan xyz
 │              │    └── columns: x:1(int!null) y:2(int) z:3(float)
 │              └── projections
 │                   └── plus [type=int]
 │                        ├── variable: x [type=int]
 │                        └── variable: y [type=int]
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: y [type=int]

build
SELECT array_agg(y) FROM (SELECT * FROM xyz ORDER BY x DESC)
----
scalar-group-by
 ├── columns: array_agg:4(int[])
 ├── internal-ordering: -1
 ├── project
 │    ├── columns: x:1(int!null) y:2(int)
 │    ├── ordering: -1
 │    └── scan xyz,rev
 │         ├── columns: x:1(int!null) y:2(int) z:3(float)
 │         └── ordering: -1
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: y [type=int]

# Regression test for #30166.
build
SELECT array_agg(generate_series(1, 2))
----
scalar-group-by
 ├── columns: array_agg:2(int[])
 ├── project-set
 │    ├── columns: generate_series:1(int)
 │    ├── values
 │    │    └── tuple [type=tuple]
 │    └── zip
 │         └── function: generate_series [type=int]
 │              ├── const: 1 [type=int]
 │              └── const: 2 [type=int]
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: generate_series [type=int]

# Regression test for #37317: duplicate column in GROUP BY
build format=show-all
SELECT
*
FROM
(
 SELECT
 x AS firstCol,
 y AS secondCol,
 y AS thirdCol
 FROM xyz
)
GROUP BY
firstCol, secondCol, thirdCol;
----
group-by
 ├── columns: firstcol:1(int!null) secondcol:2(int) thirdcol:2(int)
 ├── grouping columns: t.public.xyz.x:1(int!null) t.public.xyz.y:2(int)
 ├── stats: [rows=991, distinct(1,2)=991, null(1,2)=10]
 ├── cost: 1109.95
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── interesting orderings: (+1,+2)
 └── project
      ├── columns: t.public.xyz.x:1(int!null) t.public.xyz.y:2(int)
      ├── stats: [rows=1000, distinct(1,2)=991, null(1,2)=10]
      ├── cost: 1070.03
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── prune: (1,2)
      ├── interesting orderings: (+1,+2)
      └── scan t.public.xyz
           ├── columns: t.public.xyz.x:1(int!null) t.public.xyz.y:2(int) t.public.xyz.z:3(float)
           ├── stats: [rows=1000, distinct(1,2)=991, null(1,2)=10]
           ├── cost: 1060.02
           ├── key: (1)
           ├── fd: (1)-->(2,3)
           ├── prune: (1-3)
           └── interesting orderings: (+1,+2) (+3,+2,+1)

# Testing ordered aggregations.
exec-ddl
CREATE TABLE tab (col1 int NOT NULL, col2 int NOT NULL, col3 string)
----

build
SELECT array_agg(col1 ORDER BY col1) FROM tab
----
scalar-group-by
 ├── columns: array_agg:5(int[])
 ├── window partition=() ordering=+1
 │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[])
 │    ├── scan tab
 │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: col1 [type=int]
 └── aggregations
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

# Ignore aggregate orderings for non commutative aggregates.
build
SELECT count(col1 ORDER BY col2) FROM tab
----
scalar-group-by
 ├── columns: count:5(int)
 ├── project
 │    ├── columns: col1:1(int!null) col2:2(int!null)
 │    └── scan tab
 │         └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 └── aggregations
      └── count [type=int]
           └── variable: col1 [type=int]

# Multiple ordered aggregations.
build
SELECT array_agg(col1 ORDER BY col1), array_agg(col1 ORDER BY col2) from tab
----
scalar-group-by
 ├── columns: array_agg:5(int[]) array_agg:6(int[])
 ├── window partition=() ordering=+2
 │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[]) array_agg:6(int[])
 │    ├── window partition=() ordering=+1
 │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[])
 │    │    ├── scan tab
 │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    │    └── windows
 │    │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │    │              └── array-agg [type=int[]]
 │    │                   └── variable: col1 [type=int]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: col1 [type=int]
 └── aggregations
      ├── const-agg [type=int[]]
      │    └── variable: array_agg [type=int[]]
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

build
SELECT concat_agg(col3 ORDER BY col1), array_agg(col1) FROM tab
----
scalar-group-by
 ├── columns: concat_agg:5(string) array_agg:6(int[])
 ├── window partition=()
 │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) concat_agg:5(string) array_agg:6(int[])
 │    ├── window partition=() ordering=+1
 │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) concat_agg:5(string)
 │    │    ├── scan tab
 │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    │    └── windows
 │    │         └── windows-item: range from unbounded to unbounded [type=string]
 │    │              └── concat-agg [type=string]
 │    │                   └── variable: col3 [type=string]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: col1 [type=int]
 └── aggregations
      ├── const-agg [type=string]
      │    └── variable: concat_agg [type=string]
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

build
SELECT concat_agg(col3 ORDER BY col1), sum(col1 ORDER BY col2) FROM tab
----
scalar-group-by
 ├── columns: concat_agg:5(string) sum:6(decimal)
 ├── window partition=()
 │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) concat_agg:5(string) sum:6(decimal)
 │    ├── window partition=() ordering=+1
 │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) concat_agg:5(string)
 │    │    ├── scan tab
 │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    │    └── windows
 │    │         └── windows-item: range from unbounded to unbounded [type=string]
 │    │              └── concat-agg [type=string]
 │    │                   └── variable: col3 [type=string]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=decimal]
 │              └── sum [type=decimal]
 │                   └── variable: col1 [type=int]
 └── aggregations
      ├── const-agg [type=string]
      │    └── variable: concat_agg [type=string]
      └── const-agg [type=decimal]
           └── variable: sum [type=decimal]

build
SELECT array_agg(col1 ORDER BY col1) FROM tab GROUP BY col2
----
project
 ├── columns: array_agg:5(int[])
 └── group-by
      ├── columns: col2:2(int!null) array_agg:5(int[])
      ├── grouping columns: col2:2(int!null)
      ├── window partition=(2) ordering=+1
      │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[])
      │    ├── scan tab
      │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    └── windows
      │         └── windows-item: range from unbounded to unbounded [type=int[]]
      │              └── array-agg [type=int[]]
      │                   └── variable: col1 [type=int]
      └── aggregations
           └── const-agg [type=int[]]
                └── variable: array_agg [type=int[]]

build
SELECT array_agg(col1 ORDER BY col1), array_agg(col3 ORDER BY col1) FROM tab GROUP BY col2
----
project
 ├── columns: array_agg:5(int[]) array_agg:6(string[])
 └── group-by
      ├── columns: col2:2(int!null) array_agg:5(int[]) array_agg:6(string[])
      ├── grouping columns: col2:2(int!null)
      ├── window partition=(2) ordering=+1
      │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[]) array_agg:6(string[])
      │    ├── scan tab
      │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    └── windows
      │         ├── windows-item: range from unbounded to unbounded [type=int[]]
      │         │    └── array-agg [type=int[]]
      │         │         └── variable: col1 [type=int]
      │         └── windows-item: range from unbounded to unbounded [type=string[]]
      │              └── array-agg [type=string[]]
      │                   └── variable: col3 [type=string]
      └── aggregations
           ├── const-agg [type=int[]]
           │    └── variable: array_agg [type=int[]]
           └── const-agg [type=string[]]
                └── variable: array_agg [type=string[]]

build
SELECT array_agg(col1 ORDER BY col1), array_agg(col3 ORDER BY col1) FROM tab GROUP BY col2 HAVING col2 > 1
----
project
 ├── columns: array_agg:5(int[]) array_agg:6(string[])
 └── select
      ├── columns: col2:2(int!null) array_agg:5(int[]) array_agg:6(string[])
      ├── group-by
      │    ├── columns: col2:2(int!null) array_agg:5(int[]) array_agg:6(string[])
      │    ├── grouping columns: col2:2(int!null)
      │    ├── window partition=(2) ordering=+1
      │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[]) array_agg:6(string[])
      │    │    ├── scan tab
      │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    │    └── windows
      │    │         ├── windows-item: range from unbounded to unbounded [type=int[]]
      │    │         │    └── array-agg [type=int[]]
      │    │         │         └── variable: col1 [type=int]
      │    │         └── windows-item: range from unbounded to unbounded [type=string[]]
      │    │              └── array-agg [type=string[]]
      │    │                   └── variable: col3 [type=string]
      │    └── aggregations
      │         ├── const-agg [type=int[]]
      │         │    └── variable: array_agg [type=int[]]
      │         └── const-agg [type=string[]]
      │              └── variable: array_agg [type=string[]]
      └── filters
           └── gt [type=bool]
                ├── variable: col2 [type=int]
                └── const: 1 [type=int]

# Add projection on top to ensure the default NULL values are set correctly.
build
SELECT count(DISTINCT col1), count(*), array_agg(col1 ORDER BY col2) FROM tab
----
project
 ├── columns: count:5(int) count:6(int) array_agg:7(int[])
 └── project
      ├── columns: count:5(int) count_rows:6(int) col1:1(int) col2:2(int) col3:3(string) rowid:4(int) array_agg:7(int[])
      ├── scalar-group-by
      │    ├── columns: array_agg:7(int[]) count:8(int) count_rows:9(int)
      │    ├── window partition=() ordering=+2
      │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) count:5(int) count_rows:6(int) array_agg:7(int[])
      │    │    ├── window partition=()
      │    │    │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) count:5(int) count_rows:6(int)
      │    │    │    ├── scan tab
      │    │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    │    │    └── windows
      │    │    │         ├── windows-item: range from unbounded to unbounded [type=int]
      │    │    │         │    └── count [type=int]
      │    │    │         │         └── variable: col1 [type=int]
      │    │    │         └── windows-item: range from unbounded to unbounded [type=int]
      │    │    │              └── count-rows [type=int]
      │    │    └── windows
      │    │         └── windows-item: range from unbounded to unbounded [type=int[]]
      │    │              └── array-agg [type=int[]]
      │    │                   └── variable: col1 [type=int]
      │    └── aggregations
      │         ├── const-agg [type=int]
      │         │    └── variable: count [type=int]
      │         ├── const-agg [type=int]
      │         │    └── variable: count_rows [type=int]
      │         └── const-agg [type=int[]]
      │              └── variable: array_agg [type=int[]]
      └── projections
           ├── case [type=int]
           │    ├── true [type=bool]
           │    ├── when [type=int]
           │    │    ├── is [type=bool]
           │    │    │    ├── variable: count [type=int]
           │    │    │    └── null [type=unknown]
           │    │    └── const: 0 [type=int]
           │    └── variable: count [type=int]
           └── case [type=int]
                ├── true [type=bool]
                ├── when [type=int]
                │    ├── is [type=bool]
                │    │    ├── variable: count_rows [type=int]
                │    │    └── null [type=unknown]
                │    └── const: 0 [type=int]
                └── variable: count_rows [type=int]

# Testing aggregations as window when group by has a projection.
build
SELECT array_agg(col1 ORDER BY col1) FROM tab GROUP BY upper(col3)
----
project
 ├── columns: array_agg:5(int[])
 └── group-by
      ├── columns: array_agg:5(int[]) column6:6(string)
      ├── grouping columns: column6:6(string)
      ├── window partition=(6) ordering=+1
      │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[]) column6:6(string)
      │    ├── project
      │    │    ├── columns: column6:6(string) col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    │    ├── scan tab
      │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    │    └── projections
      │    │         └── function: upper [type=string]
      │    │              └── variable: col3 [type=string]
      │    └── windows
      │         └── windows-item: range from unbounded to unbounded [type=int[]]
      │              └── array-agg [type=int[]]
      │                   └── variable: col1 [type=int]
      └── aggregations
           └── const-agg [type=int[]]
                └── variable: array_agg [type=int[]]

build
SELECT array_agg(col1 ORDER BY col1), upper(col3) FROM tab GROUP BY upper(col3)
----
group-by
 ├── columns: array_agg:5(int[]) upper:6(string)
 ├── grouping columns: column6:6(string)
 ├── window partition=(6) ordering=+1
 │    ├── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null) array_agg:5(int[]) column6:6(string)
 │    ├── project
 │    │    ├── columns: column6:6(string) col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    │    ├── scan tab
 │    │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
 │    │    └── projections
 │    │         └── function: upper [type=string]
 │    │              └── variable: col3 [type=string]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: col1 [type=int]
 └── aggregations
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

build
SELECT array_agg(lower(col3)) FROM tab GROUP BY upper(col3)
----
project
 ├── columns: array_agg:6(string[])
 └── group-by
      ├── columns: array_agg:6(string[]) column7:7(string)
      ├── grouping columns: column7:7(string)
      ├── project
      │    ├── columns: column5:5(string) column7:7(string)
      │    ├── scan tab
      │    │    └── columns: col1:1(int!null) col2:2(int!null) col3:3(string) rowid:4(int!null)
      │    └── projections
      │         ├── function: lower [type=string]
      │         │    └── variable: col3 [type=string]
      │         └── function: upper [type=string]
      │              └── variable: col3 [type=string]
      └── aggregations
           └── array-agg [type=string[]]
                └── variable: column5 [type=string]

build
SELECT array_agg(v+w ORDER BY w) FROM kv
----
scalar-group-by
 ├── columns: array_agg:6(int[])
 ├── window partition=() ordering=+3
 │    ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) column5:5(int) array_agg:6(int[])
 │    ├── project
 │    │    ├── columns: column5:5(int) k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    └── projections
 │    │         └── plus [type=int]
 │    │              ├── variable: v [type=int]
 │    │              └── variable: w [type=int]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: column5 [type=int]
 └── aggregations
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

build
SELECT array_agg(v ORDER BY v+w) FROM kv
----
scalar-group-by
 ├── columns: array_agg:6(int[])
 ├── window partition=() ordering=+5
 │    ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) column5:5(int) array_agg:6(int[])
 │    ├── project
 │    │    ├── columns: column5:5(int) k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    ├── scan kv
 │    │    │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    │    └── projections
 │    │         └── plus [type=int]
 │    │              ├── variable: v [type=int]
 │    │              └── variable: w [type=int]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: v [type=int]
 └── aggregations
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

build
SELECT array_agg(a ORDER BY b) FROM (SELECT 1 AS a, 2 AS b)
----
scalar-group-by
 ├── columns: array_agg:3(int[])
 ├── window partition=() ordering=+2
 │    ├── columns: a:1(int!null) b:2(int!null) array_agg:3(int[])
 │    ├── project
 │    │    ├── columns: a:1(int!null) b:2(int!null)
 │    │    ├── values
 │    │    │    └── tuple [type=tuple]
 │    │    └── projections
 │    │         ├── const: 1 [type=int]
 │    │         └── const: 2 [type=int]
 │    └── windows
 │         └── windows-item: range from unbounded to unbounded [type=int[]]
 │              └── array-agg [type=int[]]
 │                   └── variable: a [type=int]
 └── aggregations
      └── const-agg [type=int[]]
           └── variable: array_agg [type=int[]]

# Regression test for #38551.
build
SELECT * FROM ROWS FROM (count(json_each('[]')))
----
error (0A000): count(): json_each(): generator functions are not allowed in aggregate

# Tests for projecting non-grouping columns when we group by a PK.
build
SELECT v FROM kv GROUP BY k
----
project
 ├── columns: v:2(int)
 └── group-by
      ├── columns: k:1(int!null) v:2(int)
      ├── grouping columns: k:1(int!null) v:2(int)
      └── project
           ├── columns: k:1(int!null) v:2(int)
           └── scan kv
                └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)

# This should be equivalent to the query above.
build
SELECT v FROM kv GROUP BY k, v
----
project
 ├── columns: v:2(int)
 └── group-by
      ├── columns: k:1(int!null) v:2(int)
      ├── grouping columns: k:1(int!null) v:2(int)
      └── project
           ├── columns: k:1(int!null) v:2(int)
           └── scan kv
                └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)

build
SELECT count(*), k+v FROM kv GROUP BY k
----
project
 ├── columns: count:5(int) "?column?":6(int)
 ├── group-by
 │    ├── columns: k:1(int!null) v:2(int) count_rows:5(int)
 │    ├── grouping columns: k:1(int!null) v:2(int)
 │    ├── project
 │    │    ├── columns: k:1(int!null) v:2(int)
 │    │    └── scan kv
 │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │    └── aggregations
 │         └── count-rows [type=int]
 └── projections
      └── plus [type=int]
           ├── variable: k [type=int]
           └── variable: v [type=int]

build
SELECT count(*) FROM kv GROUP BY k HAVING v=1
----
project
 ├── columns: count:5(int)
 └── select
      ├── columns: k:1(int!null) v:2(int!null) count_rows:5(int)
      ├── group-by
      │    ├── columns: k:1(int!null) v:2(int) count_rows:5(int)
      │    ├── grouping columns: k:1(int!null) v:2(int)
      │    ├── project
      │    │    ├── columns: k:1(int!null) v:2(int)
      │    │    └── scan kv
      │    │         └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
      │    └── aggregations
      │         └── count-rows [type=int]
      └── filters
           └── eq [type=bool]
                ├── variable: v [type=int]
                └── const: 1 [type=int]

build
SELECT k, v, count(*) FROM kv JOIN ab ON a=k GROUP BY k
----
group-by
 ├── columns: k:1(int!null) v:2(int) count:7(int)
 ├── grouping columns: k:1(int!null) v:2(int)
 ├── project
 │    ├── columns: k:1(int!null) v:2(int)
 │    └── inner-join (hash)
 │         ├── columns: k:1(int!null) v:2(int) w:3(int) s:4(string) a:5(int!null) b:6(int)
 │         ├── scan kv
 │         │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
 │         ├── scan ab
 │         │    └── columns: a:5(int!null) b:6(int)
 │         └── filters
 │              └── eq [type=bool]
 │                   ├── variable: a [type=int]
 │                   └── variable: k [type=int]
 └── aggregations
      └── count-rows [type=int]

# Not allowed when grouping on a subset of the PK.
build
SELECT x, y FROM abxy GROUP BY a
----
error (42803): column "x" must appear in the GROUP BY clause or be used in an aggregate function

build
SELECT x, y FROM abxy GROUP BY a, b
----
project
 ├── columns: x:3(int) y:4(int)
 └── group-by
      ├── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      ├── grouping columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      └── scan abxy
           └── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)

# The following two should be equivalent to the one above.
build
SELECT x, y FROM abxy GROUP BY x, a, b
----
project
 ├── columns: x:3(int) y:4(int)
 └── group-by
      ├── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      ├── grouping columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      └── scan abxy
           └── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)

build
SELECT x, y FROM abxy GROUP BY x, y, a, b
----
project
 ├── columns: x:3(int) y:4(int)
 └── group-by
      ├── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      ├── grouping columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)
      └── scan abxy
           └── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int)

build
SELECT x, y FROM abxy NATURAL JOIN ab GROUP BY a, b
----
project
 ├── columns: x:3(int) y:4(int)
 └── group-by
      ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
      ├── grouping columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
      └── project
           ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
           └── inner-join (hash)
                ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int) ab.a:5(int!null) ab.b:6(int!null)
                ├── scan abxy
                │    └── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
                ├── scan ab
                │    └── columns: ab.a:5(int!null) ab.b:6(int)
                └── filters
                     ├── eq [type=bool]
                     │    ├── variable: abxy.a [type=int]
                     │    └── variable: ab.a [type=int]
                     └── eq [type=bool]
                          ├── variable: abxy.b [type=int]
                          └── variable: ab.b [type=int]

# Should be equivalent to the one above.
build
SELECT x, y FROM abxy NATURAL JOIN ab GROUP BY a, b, x
----
project
 ├── columns: x:3(int) y:4(int)
 └── group-by
      ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
      ├── grouping columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
      └── project
           ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
           └── inner-join (hash)
                ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int) ab.a:5(int!null) ab.b:6(int!null)
                ├── scan abxy
                │    └── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
                ├── scan ab
                │    └── columns: ab.a:5(int!null) ab.b:6(int)
                └── filters
                     ├── eq [type=bool]
                     │    ├── variable: abxy.a [type=int]
                     │    └── variable: ab.a [type=int]
                     └── eq [type=bool]
                          ├── variable: abxy.b [type=int]
                          └── variable: ab.b [type=int]

build
SELECT abxy.*, ab.* FROM abxy, ab GROUP BY abxy.a, abxy.b, ab.a
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) x:3(int) y:4(int) a:5(int!null) b:6(int)
 ├── grouping columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int) ab.a:5(int!null) ab.b:6(int)
 └── inner-join (hash)
      ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int) ab.a:5(int!null) ab.b:6(int)
      ├── scan abxy
      │    └── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
      ├── scan ab
      │    └── columns: ab.a:5(int!null) ab.b:6(int)
      └── filters (true)

# Not allowed with UNION.
build
SELECT x FROM (SELECT a, b, x FROM abxy UNION SELECT a, b, 1 FROM ab) GROUP BY a,b
----
error (42803): column "x" must appear in the GROUP BY clause or be used in an aggregate function

# Allowed with EXCEPT.
build
SELECT x FROM (SELECT a, b, x FROM abxy EXCEPT SELECT a, b, 1 FROM ab) GROUP BY a,b
----
project
 ├── columns: x:3(int)
 └── group-by
      ├── columns: abxy.a:1(int!null) abxy.b:2(int) x:3(int)
      ├── grouping columns: abxy.a:1(int!null) abxy.b:2(int) x:3(int)
      └── except
           ├── columns: abxy.a:1(int!null) abxy.b:2(int) x:3(int)
           ├── left columns: abxy.a:1(int!null) abxy.b:2(int) x:3(int)
           ├── right columns: ab.a:5(int) ab.b:6(int) "?column?":7(int)
           ├── project
           │    ├── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int)
           │    └── scan abxy
           │         └── columns: abxy.a:1(int!null) abxy.b:2(int!null) x:3(int) y:4(int)
           └── project
                ├── columns: "?column?":7(int!null) ab.a:5(int!null) ab.b:6(int)
                ├── scan ab
                │    └── columns: ab.a:5(int!null) ab.b:6(int)
                └── projections
                     └── const: 1 [type=int]

# Allowed even with outer joins. It's a little subtle why this is correct: the
# PK columns are also non-nullable so any "outer" rows are never in the same
# group with "non-outer" rows.
build
SELECT v, w FROM kv FULL JOIN ab ON k=a GROUP BY k
----
project
 ├── columns: v:2(int) w:3(int)
 └── group-by
      ├── columns: k:1(int) v:2(int) w:3(int)
      ├── grouping columns: k:1(int) v:2(int) w:3(int)
      └── project
           ├── columns: k:1(int) v:2(int) w:3(int)
           └── full-join (hash)
                ├── columns: k:1(int) v:2(int) w:3(int) s:4(string) a:5(int) b:6(int)
                ├── scan kv
                │    └── columns: k:1(int!null) v:2(int) w:3(int) s:4(string)
                ├── scan ab
                │    └── columns: a:5(int!null) b:6(int)
                └── filters
                     └── eq [type=bool]
                          ├── variable: k [type=int]
                          └── variable: a [type=int]
