// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package memo

//go:generate optgen -out expr.og.go exprs ../ops/*.opt

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ExprOrdinal is the ordinal position of an expression within its memo group.
// Each group stores one or more logically equivalent expressions. The 0th
// expression is always the normalized expression for the group.
type ExprOrdinal uint16

const (
	// normExprOrdinal is the ordinal position of the normalized expression in
	// its group.
	normExprOrdinal ExprOrdinal = 0
)

// ExprID uniquely identifies an expression stored in the memo by pairing the
// ID of its group with the ordinal position of the expression within that
// group.
type ExprID struct {
	Group GroupID
	Expr  ExprOrdinal
}

// MakeNormExprID returns the id of the normalized expression for the given
// group.
func MakeNormExprID(group GroupID) ExprID {
	return ExprID{Group: group, Expr: normExprOrdinal}
}

// exprState is opaque storage used to store operator-specific fields in the
// memo expression.
type exprState [opt.MaxOperands]uint32

// Expr is a memoized representation of an expression. Strongly-typed
// specializations of Expr are generated by optgen for each operator (see
// expr.og.go). Each Expr belongs to a memo group, which contains logically
// equivalent expressions. Two expressions are considered logically equivalent
// if they both reduce to an identical normal form after normalizing
// transformations have been applied.
//
// The children of Expr are recursively memoized in the same way as the
// Expr, and are referenced by their memo group. Therefore, the Expr
// is the root of a forest of expressions.
type Expr struct {
	// op is this expression's operator type. Each operator may have additional
	// fields. To access these fields in a strongly-typed way, use the asXXX()
	// generated methods to cast the Expr to the more specialized
	// expression type.
	op opt.Operator

	// state stores operator-specific state. Depending upon the value of the
	// op field, this state will be interpreted in different ways.
	state exprState
}

// Operator returns this memo expression's operator type. Each operator may
// have additional fields. To access these fields in a strongly-typed way, use
// the AsXXX() generated methods to cast the Expr to the more specialized
// expression type.
func (e *Expr) Operator() opt.Operator {
	return e.op
}

// Fingerprint uniquely identifies a memo expression by combining its operator
// type plus its operator fields. It can be used as a map key. If two
// expressions share the same fingerprint, then they are the identical
// expression. If they don't share a fingerprint, then they still may be
// logically equivalent expressions. Since a memo expression is 16 bytes and
// contains no pointers, it can function as its own fingerprint/hash.
type Fingerprint Expr

// Fingerprint returns this memo expression's unique fingerprint.
func (e *Expr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

// opLayout describes the "layout" of each op's children. It contains multiple
// fields:
//
//  - baseCount (bits 0,1):
//      number of children, excluding any list; the children are in
//      state[0] through state[baseCount-1], unless the op is an enforcer.
//
//  - list (bits 2,3):
//      0 if op has no list, otherwise 1 + position of the list in state
//      (specifically Offset=state[list-1] Length=state[list]).
//
//  - priv (bits 4,5):
//      0 if op has no private, otherwise 1 + position of the private in state.
//
// The table of values (opLayoutTable) is generated by optgen.
type opLayout uint8

func (val opLayout) baseCount() uint8 {
	return uint8(val) & 3
}

func (val opLayout) list() uint8 {
	return (uint8(val) >> 2) & 3
}

func (val opLayout) priv() uint8 {
	return (uint8(val) >> 4) & 3
}

func makeOpLayout(baseCount, list, priv uint8) opLayout {
	return opLayout(baseCount | (list << 2) | (priv << 4))
}

// ChildCount returns the number of expressions that are inputs to this parent
// expression.
func (e *Expr) ChildCount() int {
	layout := opLayoutTable[e.op]
	baseCount := layout.baseCount()
	list := layout.list()
	if list == 0 {
		return int(baseCount)
	}
	return int(baseCount) + int(e.state[list])
}

// ChildGroup returns the memo group containing the nth child of this parent
// expression.
func (e *Expr) ChildGroup(mem *Memo, nth int) GroupID {
	layout := opLayoutTable[e.op]
	baseCount := layout.baseCount()
	if nth < int(baseCount) {
		return GroupID(e.state[nth])
	}
	nth -= int(baseCount)
	list := layout.list()
	if list != 0 && nth < int(e.state[list]) {
		listID := ListID{Offset: e.state[list-1], Length: e.state[list]}
		return mem.LookupList(listID)[nth]
	}
	panic("child index out of range")
}

// Private returns the value of this expression's private field, if it has one,
// or nil if not.
func (e *Expr) Private(mem *Memo) interface{} {
	return mem.LookupPrivate(e.privateID())
}

func (e *Expr) privateID() PrivateID {
	priv := opLayoutTable[e.op].priv()
	if priv == 0 {
		return 0
	}
	return PrivateID(e.state[priv-1])
}
