exec-ddl
CREATE TABLE xysd (x INT PRIMARY KEY, y INT, s STRING, d DECIMAL NOT NULL, UNIQUE (s DESC, d))
----

exec-ddl
CREATE TABLE uv (u INT, v INT NOT NULL)
----

exec-ddl
CREATE TABLE mn (m INT PRIMARY KEY, n INT, UNIQUE (n))
----

exec-ddl
CREATE TABLE fk (
    k INT PRIMARY KEY,
    v INT,
    r1 INT NOT NULL REFERENCES xysd(x),
    r2 INT REFERENCES xysd(x)
)
----

exec-ddl
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, b, c))
----

exec-ddl
CREATE TABLE ref (
    r1 INT NOT NULL,
    r2 INT,
    r3 INT NOT NULL,
    FOREIGN KEY (r1, r2, r3) REFERENCES abc(a, b, c)
)
----

# Inner-join.
build
SELECT *, rowid FROM xysd INNER JOIN uv ON x=u
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int!null) v:7(int!null) rowid:8(int!null)
 ├── key: (8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2,6), (8)-->(1-4,6,7), (1)==(6), (6)==(1)
 ├── prune: (1-4,6-8)
 ├── interesting orderings: (+1) (-3,+4,+1) (+8)
 └── inner-join (hash)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int!null) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      ├── key: (8)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (8)-->(6,7,9), (1)==(6), (6)==(1)
      ├── prune: (2-5,7-9)
      ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── scan uv
      │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    ├── key: (8)
      │    ├── fd: (8)-->(6,7,9)
      │    ├── prune: (6-9)
      │    ├── interesting orderings: (+8)
      │    └── unfiltered-cols: (6-9)
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: u:6 [type=int]

# Inner-join-apply.
opt
SELECT (SELECT (VALUES (x), (y))) FROM xysd
----
project
 ├── columns: column1:8(int)
 ├── prune: (8)
 ├── ensure-distinct-on
 │    ├── columns: x:1(int!null) column1:6(int)
 │    ├── grouping columns: x:1(int!null)
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(6)
 │    ├── prune: (6)
 │    ├── inner-join-apply
 │    │    ├── columns: x:1(int!null) y:2(int) column1:6(int)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── prune: (6)
 │    │    ├── interesting orderings: (+1)
 │    │    ├── scan xysd
 │    │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── prune: (1,2)
 │    │    │    └── interesting orderings: (+1)
 │    │    ├── values
 │    │    │    ├── columns: column1:6(int)
 │    │    │    ├── outer: (1,2)
 │    │    │    ├── cardinality: [2 - 2]
 │    │    │    ├── prune: (6)
 │    │    │    ├── tuple [type=tuple{int}]
 │    │    │    │    └── variable: x:1 [type=int]
 │    │    │    └── tuple [type=tuple{int}]
 │    │    │         └── variable: y:2 [type=int]
 │    │    └── filters (true)
 │    └── aggregations
 │         └── const-agg [as=column1:6, type=int, outer=(6)]
 │              └── variable: column1:6 [type=int]
 └── projections
      └── variable: column1:6 [as=column1:8, type=int, outer=(6)]

# Inner-join-apply nested in inner-join-apply with outer column references to
# each parent.
opt disable=TryDecorrelateMax1Row
SELECT * FROM xysd WHERE (SELECT v FROM uv WHERE (SELECT n FROM mn WHERE n=v)=x)=x
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── inner-join-apply
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:7(int!null)
      ├── key: (1)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(7), (7)==(1)
      ├── prune: (2-4)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    ├── prune: (1-4)
      │    └── interesting orderings: (+1) (-3,+4,+1)
      ├── max1-row
      │    ├── columns: v:7(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── outer: (1)
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(7)
      │    └── project
      │         ├── columns: v:7(int!null)
      │         ├── outer: (1)
      │         ├── fd: ()-->(7)
      │         ├── prune: (7)
      │         └── inner-join (hash)
      │              ├── columns: v:7(int!null) n:11(int!null)
      │              ├── outer: (1)
      │              ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │              ├── fd: ()-->(7,11)
      │              ├── interesting orderings: (+11)
      │              ├── scan uv
      │              │    ├── columns: v:7(int!null)
      │              │    ├── prune: (7)
      │              │    └── unfiltered-cols: (6-9)
      │              ├── scan mn
      │              │    ├── columns: n:11(int)
      │              │    ├── lax-key: (11)
      │              │    ├── prune: (11)
      │              │    ├── interesting orderings: (+11)
      │              │    └── unfiltered-cols: (10-12)
      │              └── filters
      │                   ├── eq [type=bool, outer=(7,11), constraints=(/7: (/NULL - ]; /11: (/NULL - ]), fd=(7)==(11), (11)==(7)]
      │                   │    ├── variable: n:11 [type=int]
      │                   │    └── variable: v:7 [type=int]
      │                   └── eq [type=bool, outer=(1,11), constraints=(/1: (/NULL - ]; /11: (/NULL - ]), fd=(1)==(11), (11)==(1)]
      │                        ├── variable: x:1 [type=int]
      │                        └── variable: n:11 [type=int]
      └── filters
           └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: v:7 [type=int]

# Inner-join nested in inner-join-apply with outer column reference to top-level
# inner-join-apply.
opt
SELECT * FROM xysd WHERE (SELECT v FROM uv WHERE (SELECT m FROM mn WHERE m=y)=x)=x
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 └── select
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:7(int!null)
      ├── key: (1)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(7), (7)==(1)
      ├── prune: (2-4)
      ├── ensure-distinct-on
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:7(int)
      │    ├── grouping columns: x:1(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4,7), (3,4)~~>(1,2)
      │    ├── prune: (2-4,7)
      │    ├── right-join (hash)
      │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:7(int) m:10(int)
      │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    ├── prune: (3,4,7)
      │    │    ├── reject-nulls: (7,10)
      │    │    ├── interesting orderings: (+1) (-3,+4,+1) (+10)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: v:7(int!null) m:10(int!null)
      │    │    │    ├── prune: (7,10)
      │    │    │    ├── interesting orderings: (+10)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: v:7(int!null)
      │    │    │    │    ├── prune: (7)
      │    │    │    │    └── unfiltered-cols: (6-9)
      │    │    │    ├── scan mn
      │    │    │    │    ├── columns: m:10(int!null)
      │    │    │    │    ├── key: (10)
      │    │    │    │    ├── prune: (10)
      │    │    │    │    ├── interesting orderings: (+10)
      │    │    │    │    └── unfiltered-cols: (10-12)
      │    │    │    └── filters (true)
      │    │    ├── scan xysd
      │    │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    │    ├── prune: (1-4)
      │    │    │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    │    │    └── unfiltered-cols: (1-5)
      │    │    └── filters
      │    │         ├── eq [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      │    │         │    ├── variable: x:1 [type=int]
      │    │         │    └── variable: y:2 [type=int]
      │    │         └── eq [type=bool, outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
      │    │              ├── variable: x:1 [type=int]
      │    │              └── variable: m:10 [type=int]
      │    └── aggregations
      │         ├── const-agg [as=y:2, type=int, outer=(2)]
      │         │    └── variable: y:2 [type=int]
      │         ├── const-agg [as=s:3, type=string, outer=(3)]
      │         │    └── variable: s:3 [type=string]
      │         ├── const-agg [as=d:4, type=decimal, outer=(4)]
      │         │    └── variable: d:4 [type=decimal]
      │         └── const-agg [as=v:7, type=int, outer=(7)]
      │              └── variable: v:7 [type=int]
      └── filters
           └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: v:7 [type=int]

# Left-join.
build
SELECT *, rowid FROM xysd LEFT JOIN uv ON x=u
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) v:7(int) rowid:8(int)
 ├── key: (1,8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(6,7)
 ├── prune: (1-4,6-8)
 ├── reject-nulls: (6-8)
 ├── interesting orderings: (+1) (-3,+4,+1) (+8)
 └── left-join (hash)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) v:7(int) rowid:8(int) uv.crdb_internal_mvcc_timestamp:9(decimal)
      ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      ├── key: (1,8)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (8)-->(6,7,9)
      ├── prune: (2-5,7-9)
      ├── reject-nulls: (6-9)
      ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── scan uv
      │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    ├── key: (8)
      │    ├── fd: (8)-->(6,7,9)
      │    ├── prune: (6-9)
      │    ├── interesting orderings: (+8)
      │    └── unfiltered-cols: (6-9)
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: u:6 [type=int]

# Left-join-apply.
opt
SELECT * FROM xysd WHERE (SELECT u FROM uv WHERE u=x) IS NULL
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 └── select
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int)
      ├── key: (1)
      ├── fd: ()-->(6), (1)-->(2-4), (3,4)~~>(1,2)
      ├── prune: (2-4)
      ├── ensure-distinct-on
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int)
      │    ├── grouping columns: x:1(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4,6), (3,4)~~>(1,2)
      │    ├── prune: (2-4,6)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int)
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    ├── prune: (2-4)
      │    │    ├── reject-nulls: (6)
      │    │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    │    ├── scan xysd
      │    │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    │    ├── prune: (1-4)
      │    │    │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    │    │    └── unfiltered-cols: (1-5)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:6(int)
      │    │    │    ├── prune: (6)
      │    │    │    └── unfiltered-cols: (6-9)
      │    │    └── filters
      │    │         └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    │              ├── variable: u:6 [type=int]
      │    │              └── variable: x:1 [type=int]
      │    └── aggregations
      │         ├── const-agg [as=y:2, type=int, outer=(2)]
      │         │    └── variable: y:2 [type=int]
      │         ├── const-agg [as=s:3, type=string, outer=(3)]
      │         │    └── variable: s:3 [type=string]
      │         ├── const-agg [as=d:4, type=decimal, outer=(4)]
      │         │    └── variable: d:4 [type=decimal]
      │         └── const-agg [as=u:6, type=int, outer=(6)]
      │              └── variable: u:6 [type=int]
      └── filters
           └── is [type=bool, outer=(6), constraints=(/6: [/NULL - /NULL]; tight), fd=()-->(6)]
                ├── variable: u:6 [type=int]
                └── null [type=unknown]

# Right-join.
build
SELECT *, rowid FROM xysd RIGHT JOIN uv ON x=u
----
project
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:6(int) v:7(int!null) rowid:8(int!null)
 ├── key: (8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(1-4,6,7)
 ├── prune: (1-4,6-8)
 ├── reject-nulls: (1-4)
 ├── interesting orderings: (+1) (-3,+4,+1) (+8)
 └── right-join (hash)
      ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      ├── key: (8)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (8)-->(1-7,9)
      ├── prune: (2-5,7-9)
      ├── reject-nulls: (1-5)
      ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    └── interesting orderings: (+1) (-3,+4,+1)
      ├── scan uv
      │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    ├── key: (8)
      │    ├── fd: (8)-->(6,7,9)
      │    ├── prune: (6-9)
      │    └── interesting orderings: (+8)
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: u:6 [type=int]

# Full-join.
build
SELECT *, rowid FROM xysd FULL JOIN uv ON x=u
----
project
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:6(int) v:7(int) rowid:8(int)
 ├── key: (1,8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(6,7)
 ├── prune: (1-4,6-8)
 ├── reject-nulls: (1-4,6-8)
 ├── interesting orderings: (+1) (-3,+4,+1) (+8)
 └── full-join (hash)
      ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) v:7(int) rowid:8(int) uv.crdb_internal_mvcc_timestamp:9(decimal)
      ├── multiplicity: left-rows(one-or-more), right-rows(exactly-one)
      ├── key: (1,8)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (8)-->(6,7,9)
      ├── prune: (2-5,7-9)
      ├── reject-nulls: (1-9)
      ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── scan uv
      │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    ├── key: (8)
      │    ├── fd: (8)-->(6,7,9)
      │    ├── prune: (6-9)
      │    ├── interesting orderings: (+8)
      │    └── unfiltered-cols: (6-9)
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: u:6 [type=int]

# Semi-join.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE x=u)
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── inner-join (lookup xysd)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int!null)
      ├── key columns: [6] = [1]
      ├── lookup columns are key
      ├── key: (6)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(6), (6)==(1)
      ├── prune: (2-4)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── distinct-on
      │    ├── columns: u:6(int)
      │    ├── grouping columns: u:6(int)
      │    ├── key: (6)
      │    └── scan uv
      │         ├── columns: u:6(int)
      │         ├── prune: (6)
      │         └── unfiltered-cols: (6-9)
      └── filters (true)

# Semi-join-apply.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE v=x OFFSET 1)
----
semi-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── offset
 │    ├── columns: v:7(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(7)
 │    ├── select
 │    │    ├── columns: v:7(int!null)
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(7)
 │    │    ├── scan uv
 │    │    │    ├── columns: v:7(int!null)
 │    │    │    └── prune: (7)
 │    │    └── filters
 │    │         └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │              ├── variable: v:7 [type=int]
 │    │              └── variable: x:1 [type=int]
 │    └── const: 1 [type=int]
 └── filters (true)

# Semi-join nested in semi-join with outer column reference to top-level join.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE EXISTS(SELECT * FROM mn WHERE x=m AND x=v))
----
semi-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── semi-join (cross)
 │    ├── columns: v:7(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(7)
 │    ├── scan uv
 │    │    ├── columns: v:7(int!null)
 │    │    ├── prune: (7)
 │    │    └── unfiltered-cols: (6-9)
 │    ├── scan mn
 │    │    ├── columns: m:10(int!null)
 │    │    ├── key: (10)
 │    │    ├── prune: (10)
 │    │    ├── interesting orderings: (+10)
 │    │    └── unfiltered-cols: (10-12)
 │    └── filters
 │         ├── eq [type=bool, outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
 │         │    ├── variable: x:1 [type=int]
 │         │    └── variable: m:10 [type=int]
 │         └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │              ├── variable: x:1 [type=int]
 │              └── variable: v:7 [type=int]
 └── filters (true)

# Anti-join.
opt
SELECT * FROM xysd WHERE NOT EXISTS(SELECT * FROM uv WHERE x=u)
----
anti-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan uv
 │    ├── columns: u:6(int)
 │    ├── prune: (6)
 │    └── unfiltered-cols: (6-9)
 └── filters
      └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:6 [type=int]

# Anti-join-apply.
opt
SELECT * FROM xysd WHERE NOT EXISTS(SELECT * FROM uv WHERE v=x OFFSET 1)
----
anti-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── offset
 │    ├── columns: v:7(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(7)
 │    ├── select
 │    │    ├── columns: v:7(int!null)
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(7)
 │    │    ├── scan uv
 │    │    │    ├── columns: v:7(int!null)
 │    │    │    └── prune: (7)
 │    │    └── filters
 │    │         └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │              ├── variable: v:7 [type=int]
 │    │              └── variable: x:1 [type=int]
 │    └── const: 1 [type=int]
 └── filters (true)

# Cross-join.
build
SELECT * FROM xysd, uv
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) v:7(int!null)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4,6,7)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── inner-join (cross)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      ├── key: (1,8)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (8)-->(6,7,9)
      ├── prune: (1-9)
      ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── scan uv
      │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    ├── key: (8)
      │    ├── fd: (8)-->(6,7,9)
      │    ├── prune: (6-9)
      │    ├── interesting orderings: (+8)
      │    └── unfiltered-cols: (6-9)
      └── filters (true)

# Self-join.
build
SELECT * FROM xysd, xysd AS xysd
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)-->(7-9), (8,9)~~>(6,7)
 ├── prune: (1-4,6-9)
 ├── interesting orderings: (+1) (-3,+4,+1) (+6) (-8,+9,+6)
 └── inner-join (cross)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) crdb_internal_mvcc_timestamp:10(decimal)
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (6)-->(7-10), (8,9)~~>(6,7,10)
      ├── prune: (1-10)
      ├── interesting orderings: (+1) (-3,+4,+1) (+6) (-8,+9,+6)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── scan xysd
      │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) crdb_internal_mvcc_timestamp:10(decimal)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10)
      │    ├── prune: (6-10)
      │    ├── interesting orderings: (+6) (-8,+9,+6)
      │    └── unfiltered-cols: (6-10)
      └── filters (true)

# Propagate outer columns.
build
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM (SELECT x) INNER JOIN (SELECT y) ON x::string = s)
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── select
      ├── columns: xysd.x:1(int!null) xysd.y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal)
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      ├── prune: (4,5)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: xysd.x:1(int!null) xysd.y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    └── interesting orderings: (+1) (-3,+4,+1)
      └── filters
           └── exists [type=bool, outer=(1-3), immutable, correlated-subquery]
                └── inner-join (cross)
                     ├── columns: x:6(int) y:7(int)
                     ├── outer: (1-3)
                     ├── cardinality: [0 - 1]
                     ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
                     ├── immutable
                     ├── key: ()
                     ├── fd: ()-->(6,7)
                     ├── prune: (7)
                     ├── project
                     │    ├── columns: x:6(int)
                     │    ├── outer: (1)
                     │    ├── cardinality: [1 - 1]
                     │    ├── key: ()
                     │    ├── fd: ()-->(6)
                     │    ├── prune: (6)
                     │    ├── values
                     │    │    ├── cardinality: [1 - 1]
                     │    │    ├── key: ()
                     │    │    └── tuple [type=tuple]
                     │    └── projections
                     │         └── variable: xysd.x:1 [as=x:6, type=int, outer=(1)]
                     ├── project
                     │    ├── columns: y:7(int)
                     │    ├── outer: (2)
                     │    ├── cardinality: [1 - 1]
                     │    ├── key: ()
                     │    ├── fd: ()-->(7)
                     │    ├── prune: (7)
                     │    ├── values
                     │    │    ├── cardinality: [1 - 1]
                     │    │    ├── key: ()
                     │    │    └── tuple [type=tuple]
                     │    └── projections
                     │         └── variable: xysd.y:2 [as=y:7, type=int, outer=(2)]
                     └── filters
                          └── eq [type=bool, outer=(3,6), immutable]
                               ├── cast: STRING [type=string]
                               │    └── variable: x:6 [type=int]
                               └── variable: s:3 [type=string]

# Calculate semi-join cardinality when left side has non-zero cardinality.
opt
SELECT * FROM (SELECT count(*) cnt FROM xysd) WHERE EXISTS(SELECT * FROM uv WHERE cnt=1)
----
project
 ├── columns: cnt:6(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 └── inner-join (cross)
      ├── columns: count_rows:6(int!null)
      ├── cardinality: [0 - 1]
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      ├── key: ()
      ├── fd: ()-->(6)
      ├── select
      │    ├── columns: count_rows:6(int!null)
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6)
      │    ├── scalar-group-by
      │    │    ├── columns: count_rows:6(int!null)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6)
      │    │    ├── prune: (6)
      │    │    ├── scan xysd@secondary
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:6, type=int]
      │    └── filters
      │         └── eq [type=bool, outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
      │              ├── variable: count_rows:6 [type=int]
      │              └── const: 1 [type=int]
      ├── scan uv
      │    ├── limit: 1
      │    └── key: ()
      └── filters (true)

# Calculate semi-join-apply cardinality.
expr
(SemiJoinApply
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
            (Cardinality "0-10")
        ]
    )
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
        ]
    )
    [ ]
    [ ]
)
----
semi-join-apply
 ├── columns: a:1(int)
 ├── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:1(int)
 │    └── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:2(int)
 │    └── cardinality: [0 - 0]
 └── filters (true)

# Calculate anti-join cardinality when left side has non-zero cardinality.
opt
SELECT * FROM (SELECT * FROM (VALUES (1), (2))) WHERE NOT EXISTS(SELECT * FROM uv WHERE u=column1)
----
anti-join (hash)
 ├── columns: column1:1(int!null)
 ├── cardinality: [0 - 2]
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 ├── scan uv
 │    ├── columns: u:2(int)
 │    ├── prune: (2)
 │    └── unfiltered-cols: (2-5)
 └── filters
      └── eq [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
           ├── variable: u:2 [type=int]
           └── variable: column1:1 [type=int]

# Calculate anti-join-apply cardinality.
expr
(AntiJoinApply
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
            (Cardinality "0-10")
        ]
    )
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
        ]
    )
    [ ]
    [ ]
)
----
anti-join-apply
 ├── columns: a:1(int)
 ├── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:1(int)
 │    └── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:2(int)
 │    └── cardinality: [0 - 0]
 └── filters (true)

# Calculate inner-join cardinality.
build
SELECT * FROM (VALUES (1), (2)) INNER JOIN (SELECT * FROM uv LIMIT 2) ON True
----
inner-join (cross)
 ├── columns: column1:1(int!null) u:2(int) v:3(int!null)
 ├── cardinality: [0 - 4]
 ├── prune: (1-3)
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 ├── limit
 │    ├── columns: u:2(int) v:3(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (2,3)
 │    ├── project
 │    │    ├── columns: u:2(int) v:3(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (2,3)
 │    │    └── scan uv
 │    │         ├── columns: u:2(int) v:3(int!null) rowid:4(int!null) crdb_internal_mvcc_timestamp:5(decimal)
 │    │         ├── key: (4)
 │    │         ├── fd: (4)-->(2,3,5)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (2-5)
 │    │         └── interesting orderings: (+4)
 │    └── const: 2 [type=int]
 └── filters
      └── true [type=bool]

# Calculate left-join cardinality.
build
SELECT * FROM (VALUES (1), (2), (3)) LEFT JOIN (SELECT * FROM uv LIMIT 2) ON True
----
left-join (cross)
 ├── columns: column1:1(int!null) u:2(int) v:3(int)
 ├── cardinality: [3 - 6]
 ├── prune: (1-3)
 ├── reject-nulls: (2,3)
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [3 - 3]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 2 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 3 [type=int]
 ├── limit
 │    ├── columns: u:2(int) v:3(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (2,3)
 │    ├── project
 │    │    ├── columns: u:2(int) v:3(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (2,3)
 │    │    └── scan uv
 │    │         ├── columns: u:2(int) v:3(int!null) rowid:4(int!null) crdb_internal_mvcc_timestamp:5(decimal)
 │    │         ├── key: (4)
 │    │         ├── fd: (4)-->(2,3,5)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (2-5)
 │    │         └── interesting orderings: (+4)
 │    └── const: 2 [type=int]
 └── filters
      └── true [type=bool]

# Calculate right-join cardinality.
build
SELECT * FROM (SELECT * FROM uv LIMIT 2) RIGHT JOIN (VALUES (1), (2), (3)) ON True
----
right-join (cross)
 ├── columns: u:1(int) v:2(int) column1:5(int!null)
 ├── cardinality: [3 - 6]
 ├── prune: (1,2,5)
 ├── reject-nulls: (1,2)
 ├── limit
 │    ├── columns: u:1(int) v:2(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (1,2)
 │    ├── project
 │    │    ├── columns: u:1(int) v:2(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (1,2)
 │    │    └── scan uv
 │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null) crdb_internal_mvcc_timestamp:4(decimal)
 │    │         ├── key: (3)
 │    │         ├── fd: (3)-->(1,2,4)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (1-4)
 │    │         └── interesting orderings: (+3)
 │    └── const: 2 [type=int]
 ├── values
 │    ├── columns: column1:5(int!null)
 │    ├── cardinality: [3 - 3]
 │    ├── prune: (5)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 2 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 3 [type=int]
 └── filters
      └── true [type=bool]

# Calculate full-join cardinality.
build
SELECT * FROM (VALUES (NULL), (NULL)) a FULL JOIN (VALUES (NULL), (NULL)) b ON True
----
full-join (cross)
 ├── columns: column1:1(unknown) column1:2(unknown)
 ├── cardinality: [2 - 4]
 ├── prune: (1,2)
 ├── reject-nulls: (1,2)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── columns: column1:2(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (2)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 └── filters
      └── true [type=bool]

# Calculate full-join cardinality when both sides have an empty key (#44029).
build
SELECT * FROM (VALUES (1, 2)) a(a1,a2) FULL JOIN (VALUES (3, 4)) b(b1,b2) ON a1=b1
----
full-join (hash)
 ├── columns: a1:1(int) a2:2(int) b1:3(int) b2:4(int)
 ├── cardinality: [1 - 2]
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── prune: (2,4)
 ├── reject-nulls: (1-4)
 ├── values
 │    ├── columns: column1:1(int!null) column2:2(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1,2)
 │    ├── prune: (1,2)
 │    └── tuple [type=tuple{int, int}]
 │         ├── const: 1 [type=int]
 │         └── const: 2 [type=int]
 ├── values
 │    ├── columns: column1:3(int!null) column2:4(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,4)
 │    ├── prune: (3,4)
 │    └── tuple [type=tuple{int, int}]
 │         ├── const: 3 [type=int]
 │         └── const: 4 [type=int]
 └── filters
      └── eq [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
           ├── variable: column1:1 [type=int]
           └── variable: column1:3 [type=int]

# Calculate full-join cardinality with false filter.
build
SELECT * FROM (VALUES (NULL), (NULL)) a FULL JOIN (VALUES (NULL), (NULL)) b ON a.column1=b.column1
----
full-join (cross)
 ├── columns: column1:1(unknown) column1:2(unknown)
 ├── cardinality: [2 - 4]
 ├── immutable
 ├── prune: (1,2)
 ├── reject-nulls: (1,2)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── columns: column1:2(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (2)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 └── filters
      └── cast: BOOL [type=bool, immutable]
           └── null [type=unknown]

# Calculate full-join cardinality of one input with unknown cardinality.
build
SELECT * FROM xysd FULL JOIN (SELECT * FROM (VALUES (1), (2))) ON True
----
project
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) column1:6(int)
 ├── cardinality: [2 - ]
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4,6)
 ├── reject-nulls: (1-4,6)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── full-join (cross)
      ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) crdb_internal_mvcc_timestamp:5(decimal) column1:6(int)
      ├── cardinality: [2 - ]
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      ├── prune: (1-6)
      ├── reject-nulls: (1-6)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── values
      │    ├── columns: column1:6(int!null)
      │    ├── cardinality: [2 - 2]
      │    ├── prune: (6)
      │    ├── tuple [type=tuple{int}]
      │    │    └── const: 1 [type=int]
      │    └── tuple [type=tuple{int}]
      │         └── const: 2 [type=int]
      └── filters
           └── true [type=bool]

# Keys on both sides of full-join.
build
SELECT * FROM (SELECT * FROM xysd LIMIT 1) FULL JOIN (SELECT * FROM xysd LIMIT 1) ON True
----
full-join (cross)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) x:6(int) y:7(int) s:8(string) d:9(decimal)
 ├── cardinality: [0 - 2]
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── prune: (1-4,6-9)
 ├── reject-nulls: (1-4,6-9)
 ├── interesting orderings: (+1) (-3,+4,+1) (+6) (-8,+9,+6)
 ├── limit
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    ├── project
 │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    │    ├── limit hint: 1.00
 │    │    ├── prune: (1-4)
 │    │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    │    └── scan xysd
 │    │         ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) crdb_internal_mvcc_timestamp:5(decimal)
 │    │         ├── key: (1)
 │    │         ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
 │    │         ├── limit hint: 1.00
 │    │         ├── prune: (1-5)
 │    │         └── interesting orderings: (+1) (-3,+4,+1)
 │    └── const: 1 [type=int]
 ├── limit
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(6-9)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    ├── project
 │    │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    │    ├── limit hint: 1.00
 │    │    ├── prune: (6-9)
 │    │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    │    └── scan xysd
 │    │         ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) crdb_internal_mvcc_timestamp:10(decimal)
 │    │         ├── key: (6)
 │    │         ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10)
 │    │         ├── limit hint: 1.00
 │    │         ├── prune: (6-10)
 │    │         └── interesting orderings: (+6) (-8,+9,+6)
 │    └── const: 1 [type=int]
 └── filters
      └── true [type=bool]

# Nullable FD determinant on right side of left-join becomes lax.
build
SELECT * FROM xysd LEFT JOIN (SELECT u, sum(v) FROM uv GROUP BY u) ON u IS NOT NULL
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) sum:10(decimal)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)~~>(10), (1,6)-->(10)
 ├── prune: (1-4,6,10)
 ├── reject-nulls: (6,10)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── left-join (cross)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) sum:10(decimal)
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (6)~~>(10), (1,6)-->(10)
      ├── prune: (1-5,10)
      ├── reject-nulls: (6,10)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── group-by
      │    ├── columns: u:6(int) sum:10(decimal!null)
      │    ├── grouping columns: u:6(int)
      │    ├── key: (6)
      │    ├── fd: (6)-->(10)
      │    ├── prune: (10)
      │    ├── project
      │    │    ├── columns: u:6(int) v:7(int!null)
      │    │    ├── prune: (6,7)
      │    │    └── scan uv
      │    │         ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    │         ├── key: (8)
      │    │         ├── fd: (8)-->(6,7,9)
      │    │         ├── prune: (6-9)
      │    │         └── interesting orderings: (+8)
      │    └── aggregations
      │         └── sum [as=sum:10, type=decimal, outer=(7)]
      │              └── variable: v:7 [type=int]
      └── filters
           └── is-not [type=bool, outer=(6), constraints=(/6: (/NULL - ]; tight)]
                ├── variable: u:6 [type=int]
                └── null [type=unknown]

# Not-null FD determinant on right side of left-join stays strict.
build
SELECT * FROM xysd LEFT JOIN (SELECT u, sum(v) FROM uv WHERE u IS NOT NULL GROUP BY u) ON True
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) sum:10(decimal)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)-->(10)
 ├── prune: (1-4,6,10)
 ├── reject-nulls: (6,10)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── left-join (cross)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) sum:10(decimal)
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (6)-->(10)
      ├── prune: (1-5,10)
      ├── reject-nulls: (6,10)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── group-by
      │    ├── columns: u:6(int!null) sum:10(decimal!null)
      │    ├── grouping columns: u:6(int!null)
      │    ├── key: (6)
      │    ├── fd: (6)-->(10)
      │    ├── prune: (10)
      │    ├── project
      │    │    ├── columns: u:6(int!null) v:7(int!null)
      │    │    ├── prune: (6,7)
      │    │    └── select
      │    │         ├── columns: u:6(int!null) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    │         ├── key: (8)
      │    │         ├── fd: (8)-->(6,7,9)
      │    │         ├── prune: (7-9)
      │    │         ├── interesting orderings: (+8)
      │    │         ├── scan uv
      │    │         │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    │         │    ├── key: (8)
      │    │         │    ├── fd: (8)-->(6,7,9)
      │    │         │    ├── prune: (6-9)
      │    │         │    └── interesting orderings: (+8)
      │    │         └── filters
      │    │              └── is-not [type=bool, outer=(6), constraints=(/6: (/NULL - ]; tight)]
      │    │                   ├── variable: u:6 [type=int]
      │    │                   └── null [type=unknown]
      │    └── aggregations
      │         └── sum [as=sum:10, type=decimal, outer=(7)]
      │              └── variable: v:7 [type=int]
      └── filters
           └── true [type=bool]

# Nullable FD determinant on left side of right-join becomes lax.
build
SELECT * FROM (SELECT u, sum(v) FROM uv GROUP BY u) RIGHT JOIN xysd ON u IS NOT NULL
----
project
 ├── columns: u:1(int) sum:5(decimal) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── key: (1,6)
 ├── fd: (6)-->(7-9), (8,9)~~>(6,7), (1)~~>(5), (1,6)-->(5)
 ├── prune: (1,5-9)
 ├── reject-nulls: (1,5)
 ├── interesting orderings: (+6) (-8,+9,+6)
 └── right-join (cross)
      ├── columns: u:1(int) sum:5(decimal) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      ├── key: (1,6)
      ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10), (1)~~>(5), (1,6)-->(5)
      ├── prune: (5-10)
      ├── reject-nulls: (1,5)
      ├── interesting orderings: (+6) (-8,+9,+6)
      ├── group-by
      │    ├── columns: u:1(int) sum:5(decimal!null)
      │    ├── grouping columns: u:1(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(5)
      │    ├── prune: (5)
      │    ├── project
      │    │    ├── columns: u:1(int) v:2(int!null)
      │    │    ├── prune: (1,2)
      │    │    └── scan uv
      │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null) uv.crdb_internal_mvcc_timestamp:4(decimal)
      │    │         ├── key: (3)
      │    │         ├── fd: (3)-->(1,2,4)
      │    │         ├── prune: (1-4)
      │    │         └── interesting orderings: (+3)
      │    └── aggregations
      │         └── sum [as=sum:5, type=decimal, outer=(2)]
      │              └── variable: v:2 [type=int]
      ├── scan xysd
      │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10)
      │    ├── prune: (6-10)
      │    └── interesting orderings: (+6) (-8,+9,+6)
      └── filters
           └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
                ├── variable: u:1 [type=int]
                └── null [type=unknown]

# Not-null FD determinant on left side of right-join stays strict.
build
SELECT * FROM (SELECT u, sum(v) FROM uv WHERE u IS NOT NULL GROUP BY u) RIGHT JOIN xysd ON True
----
project
 ├── columns: u:1(int) sum:5(decimal) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── key: (1,6)
 ├── fd: (1)-->(5), (6)-->(7-9), (8,9)~~>(6,7)
 ├── prune: (1,5-9)
 ├── reject-nulls: (1,5)
 ├── interesting orderings: (+6) (-8,+9,+6)
 └── right-join (cross)
      ├── columns: u:1(int) sum:5(decimal) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      ├── key: (1,6)
      ├── fd: (1)-->(5), (6)-->(7-10), (8,9)~~>(6,7,10)
      ├── prune: (5-10)
      ├── reject-nulls: (1,5)
      ├── interesting orderings: (+6) (-8,+9,+6)
      ├── group-by
      │    ├── columns: u:1(int!null) sum:5(decimal!null)
      │    ├── grouping columns: u:1(int!null)
      │    ├── key: (1)
      │    ├── fd: (1)-->(5)
      │    ├── prune: (5)
      │    ├── project
      │    │    ├── columns: u:1(int!null) v:2(int!null)
      │    │    ├── prune: (1,2)
      │    │    └── select
      │    │         ├── columns: u:1(int!null) v:2(int!null) rowid:3(int!null) uv.crdb_internal_mvcc_timestamp:4(decimal)
      │    │         ├── key: (3)
      │    │         ├── fd: (3)-->(1,2,4)
      │    │         ├── prune: (2-4)
      │    │         ├── interesting orderings: (+3)
      │    │         ├── scan uv
      │    │         │    ├── columns: u:1(int) v:2(int!null) rowid:3(int!null) uv.crdb_internal_mvcc_timestamp:4(decimal)
      │    │         │    ├── key: (3)
      │    │         │    ├── fd: (3)-->(1,2,4)
      │    │         │    ├── prune: (1-4)
      │    │         │    └── interesting orderings: (+3)
      │    │         └── filters
      │    │              └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
      │    │                   ├── variable: u:1 [type=int]
      │    │                   └── null [type=unknown]
      │    └── aggregations
      │         └── sum [as=sum:5, type=decimal, outer=(2)]
      │              └── variable: v:2 [type=int]
      ├── scan xysd
      │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10)
      │    ├── prune: (6-10)
      │    └── interesting orderings: (+6) (-8,+9,+6)
      └── filters
           └── true [type=bool]

# Nullable FD determinant on right side of full-join becomes lax.
build
SELECT * FROM xysd FULL JOIN (SELECT u, sum(v) FROM uv GROUP BY u) ON u IS NOT NULL
----
project
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:6(int) sum:10(decimal)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)~~>(10), (1,6)-->(10)
 ├── prune: (1-4,6,10)
 ├── reject-nulls: (1-4,6,10)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── full-join (cross)
      ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) xysd.crdb_internal_mvcc_timestamp:5(decimal) u:6(int) sum:10(decimal)
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5), (6)~~>(10), (1,6)-->(10)
      ├── prune: (1-5,10)
      ├── reject-nulls: (1-6,10)
      ├── interesting orderings: (+1) (-3,+4,+1)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) xysd.crdb_internal_mvcc_timestamp:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2,5)
      │    ├── prune: (1-5)
      │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    └── unfiltered-cols: (1-5)
      ├── group-by
      │    ├── columns: u:6(int) sum:10(decimal!null)
      │    ├── grouping columns: u:6(int)
      │    ├── key: (6)
      │    ├── fd: (6)-->(10)
      │    ├── prune: (10)
      │    ├── project
      │    │    ├── columns: u:6(int) v:7(int!null)
      │    │    ├── prune: (6,7)
      │    │    └── scan uv
      │    │         ├── columns: u:6(int) v:7(int!null) rowid:8(int!null) uv.crdb_internal_mvcc_timestamp:9(decimal)
      │    │         ├── key: (8)
      │    │         ├── fd: (8)-->(6,7,9)
      │    │         ├── prune: (6-9)
      │    │         └── interesting orderings: (+8)
      │    └── aggregations
      │         └── sum [as=sum:10, type=decimal, outer=(7)]
      │              └── variable: v:7 [type=int]
      └── filters
           └── is-not [type=bool, outer=(6), constraints=(/6: (/NULL - ]; tight)]
                ├── variable: u:6 [type=int]
                └── null [type=unknown]

# Nullable FD determinant on left side of full-join becomes lax.
build
SELECT * FROM (SELECT u, sum(v) FROM uv GROUP BY u) FULL JOIN xysd ON u IS NOT NULL
----
project
 ├── columns: u:1(int) sum:5(decimal) x:6(int) y:7(int) s:8(string) d:9(decimal)
 ├── key: (1,6)
 ├── fd: (6)-->(7-9), (8,9)~~>(6,7), (1)~~>(5), (1,6)-->(5)
 ├── prune: (1,5-9)
 ├── reject-nulls: (1,5-9)
 ├── interesting orderings: (+6) (-8,+9,+6)
 └── full-join (cross)
      ├── columns: u:1(int) sum:5(decimal) x:6(int) y:7(int) s:8(string) d:9(decimal) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      ├── key: (1,6)
      ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10), (1)~~>(5), (1,6)-->(5)
      ├── prune: (5-10)
      ├── reject-nulls: (1,5-10)
      ├── interesting orderings: (+6) (-8,+9,+6)
      ├── group-by
      │    ├── columns: u:1(int) sum:5(decimal!null)
      │    ├── grouping columns: u:1(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(5)
      │    ├── prune: (5)
      │    ├── project
      │    │    ├── columns: u:1(int) v:2(int!null)
      │    │    ├── prune: (1,2)
      │    │    └── scan uv
      │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null) uv.crdb_internal_mvcc_timestamp:4(decimal)
      │    │         ├── key: (3)
      │    │         ├── fd: (3)-->(1,2,4)
      │    │         ├── prune: (1-4)
      │    │         └── interesting orderings: (+3)
      │    └── aggregations
      │         └── sum [as=sum:5, type=decimal, outer=(2)]
      │              └── variable: v:2 [type=int]
      ├── scan xysd
      │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) xysd.crdb_internal_mvcc_timestamp:10(decimal)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7-10), (8,9)~~>(6,7,10)
      │    ├── prune: (6-10)
      │    ├── interesting orderings: (+6) (-8,+9,+6)
      │    └── unfiltered-cols: (6-10)
      └── filters
           └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
                ├── variable: u:1 [type=int]
                └── null [type=unknown]

# Merge join (inner).
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ ]
    [
        (JoinType "inner-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
inner-join (merge)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int!null) v:7(int!null) rowid:8(int!null)
 ├── left ordering: +1
 ├── right ordering: +6
 ├── key: (8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(6,7), (1)==(6), (6)==(1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │    ├── key: (8)
 │    ├── fd: (8)-->(6,7)
 │    ├── ordering: +6
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+8)
 │    └── scan uv
 │         ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │         ├── key: (8)
 │         ├── fd: (8)-->(6,7)
 │         ├── prune: (6-8)
 │         └── interesting orderings: (+8)
 └── filters (true)

# Merge join (left).
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ ]
    [
        (JoinType "left-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
left-join (merge)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) v:7(int) rowid:8(int)
 ├── left ordering: +1
 ├── right ordering: +6
 ├── key: (1,8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(6,7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │    ├── key: (8)
 │    ├── fd: (8)-->(6,7)
 │    ├── ordering: +6
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+8)
 │    └── scan uv
 │         ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │         ├── key: (8)
 │         ├── fd: (8)-->(6,7)
 │         ├── prune: (6-8)
 │         └── interesting orderings: (+8)
 └── filters (true)

# Merge join (right) with remaining ON condition.
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ (Gt (Var "y") (Var "v")) ]
    [
        (JoinType "right-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
right-join (merge)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:6(int) v:7(int!null) rowid:8(int!null)
 ├── left ordering: +1
 ├── right ordering: +6
 ├── key: (8)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (8)-->(1-4,6,7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │    ├── key: (8)
 │    ├── fd: (8)-->(6,7)
 │    ├── ordering: +6
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+8)
 │    └── scan uv
 │         ├── columns: u:6(int) v:7(int!null) rowid:8(int!null)
 │         ├── key: (8)
 │         ├── fd: (8)-->(6,7)
 │         ├── prune: (6-8)
 │         └── interesting orderings: (+8)
 └── filters
      └── gt [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]
           ├── variable: y:2 [type=int]
           └── variable: v:7 [type=int]

# Regression test #36183.
opt
SELECT (SELECT m FROM
  (SELECT * FROM (SELECT * FROM [INSERT INTO uv VALUES (1, 2) RETURNING *] WHERE false) JOIN (SELECT * FROM uv WHERE false) ON true)
  JOIN (SELECT * FROM mn WHERE uv.u IN (SELECT n FROM mn)) ON true
) FROM uv
----
with &1
 ├── columns: m:24(int)
 ├── volatile, mutations
 ├── fd: ()-->(24)
 ├── prune: (24)
 ├── project
 │    ├── columns: uv.u:5(int!null) uv.v:6(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── volatile, mutations
 │    ├── key: ()
 │    ├── fd: ()-->(5,6)
 │    ├── prune: (5,6)
 │    └── insert uv
 │         ├── columns: uv.u:5(int!null) uv.v:6(int!null) rowid:7(int!null)
 │         ├── insert-mapping:
 │         │    ├── column1:9 => uv.u:5
 │         │    ├── column2:10 => uv.v:6
 │         │    └── column11:11 => rowid:7
 │         ├── cardinality: [1 - 1]
 │         ├── volatile, mutations
 │         ├── key: ()
 │         ├── fd: ()-->(5-7)
 │         └── values
 │              ├── columns: column1:9(int!null) column2:10(int!null) column11:11(int)
 │              ├── cardinality: [1 - 1]
 │              ├── volatile
 │              ├── key: ()
 │              ├── fd: ()-->(9-11)
 │              ├── prune: (9-11)
 │              └── tuple [type=tuple{int, int, int}]
 │                   ├── const: 1 [type=int]
 │                   ├── const: 2 [type=int]
 │                   └── function: unique_rowid [type=int]
 └── project
      ├── columns: m:24(int)
      ├── fd: ()-->(24)
      ├── prune: (24)
      ├── scan uv
      └── projections
           └── subquery [as=m:24, type=int, subquery]
                └── values
                     ├── columns: mn.m:18(int!null)
                     ├── cardinality: [0 - 0]
                     ├── key: ()
                     ├── fd: ()-->(18)
                     └── prune: (18)

# Regression test #40456.
opt
SELECT NULL
FROM uv
WHERE NOT EXISTS(SELECT uv.u);
----
values
 ├── columns: "?column?":6(unknown!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 ├── fd: ()-->(6)
 └── prune: (6)

# Regression test #43651: outer join with empty key.
opt
SELECT a FROM
    (VALUES (NULL)) AS t1(a)
  FULL JOIN
    (VALUES ('23:59:59.999999':::TIME)) AS t2(b)
  ON false
----
full-join (cross)
 ├── columns: a:1(unknown)
 ├── cardinality: [2 - 2]
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── prune: (1)
 ├── reject-nulls: (1)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1)
 │    ├── prune: (1)
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    └── tuple [type=tuple]
 └── filters
      └── false [type=bool, constraints=(contradiction; tight)]

exec-ddl
CREATE TABLE t1 (x INT, y INT)
----

exec-ddl
CREATE TABLE t2 (x INT, y INT)
----

# Outer join when both sides have a key. Because x can still have NULL values,
# we cannot say that the outer join has a strict key. For example, this is a
# possible valid result for this query:
#   t1.x | t1.y | t2.x | t2.y
#   -----+------+------+------
#      1 |    1 |    1 |    2
#   NULL |    1 | NULL | NULL
#   NULL | NULL | NULL |    2
# Here (t1.x, t2.x) is a lax key but not a strict key.
opt
SELECT * FROM
  (SELECT * FROM (SELECT DISTINCT ON (x) x, y FROM t1) WHERE y IS NOT NULL) AS t1
FULL JOIN
  (SELECT * FROM (SELECT DISTINCT ON (x) x, y FROM t2) WHERE y IS NOT NULL) AS t2
ON t1.x = t2.x
----
full-join (hash)
 ├── columns: x:1(int) y:2(int) x:5(int) y:6(int)
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── lax-key: (1,5)
 ├── fd: (1)~~>(2), (5)~~>(6), (1,5)~~>(2,6)
 ├── reject-nulls: (1,2,5,6)
 ├── select
 │    ├── columns: t1.x:1(int) t1.y:2(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── distinct-on
 │    │    ├── columns: t1.x:1(int) t1.y:2(int)
 │    │    ├── grouping columns: t1.x:1(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── prune: (2)
 │    │    ├── scan t1
 │    │    │    ├── columns: t1.x:1(int) t1.y:2(int)
 │    │    │    └── prune: (1,2)
 │    │    └── aggregations
 │    │         └── first-agg [as=t1.y:2, type=int, outer=(2)]
 │    │              └── variable: t1.y:2 [type=int]
 │    └── filters
 │         └── is-not [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │              ├── variable: t1.y:2 [type=int]
 │              └── null [type=unknown]
 ├── select
 │    ├── columns: t2.x:5(int) t2.y:6(int!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6)
 │    ├── distinct-on
 │    │    ├── columns: t2.x:5(int) t2.y:6(int)
 │    │    ├── grouping columns: t2.x:5(int)
 │    │    ├── key: (5)
 │    │    ├── fd: (5)-->(6)
 │    │    ├── prune: (6)
 │    │    ├── scan t2
 │    │    │    ├── columns: t2.x:5(int) t2.y:6(int)
 │    │    │    └── prune: (5,6)
 │    │    └── aggregations
 │    │         └── first-agg [as=t2.y:6, type=int, outer=(6)]
 │    │              └── variable: t2.y:6 [type=int]
 │    └── filters
 │         └── is-not [type=bool, outer=(6), constraints=(/6: (/NULL - ]; tight)]
 │              ├── variable: t2.y:6 [type=int]
 │              └── null [type=unknown]
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: t1.x:1 [type=int]
           └── variable: t2.x:5 [type=int]

# InnerJoin with an equality between one key column and one non-key column.
# Neither input is guaranteed a match for every row. Rows from uv will not be
# duplicated because the x column is unique. Rows from xysd may be duplicated
# because the v column is not unique.
norm
SELECT * FROM xysd INNER JOIN uv ON x=v
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:6(int) v:7(int!null)
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(7), (7)==(1)
 ├── prune: (2-4,6)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan uv
 │    ├── columns: u:6(int) v:7(int!null)
 │    ├── prune: (6,7)
 │    └── unfiltered-cols: (6-9)
 └── filters
      └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: v:7 [type=int]

# InnerJoin with a not-null foreign key equality. Since the foreign key is
# not-null, rows from the fk table are guaranteed a match. Since x is a key
# column, rows from the fk table will not be duplicated.
norm
SELECT * FROM fk INNER JOIN xysd ON x = r1
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (3)==(6), (6)==(3)
 ├── prune: (1,2,4,7-9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]
           ├── variable: x:6 [type=int]
           └── variable: r1:3 [type=int]

# InnerJoin with a nullable foreign key equality condition.
norm
SELECT * FROM fk INNER JOIN xysd ON x = r2
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int!null) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (4)==(6), (6)==(4)
 ├── prune: (1-3,7-9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]
           ├── variable: x:6 [type=int]
           └── variable: r2:4 [type=int]

# Cross join. Rows from fk are guaranteed matches because the not-null foreign
# key implies that xysd has at least one row whenever fk does.
norm
SELECT * FROM fk CROSS JOIN xysd
----
inner-join (cross)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7)
 ├── prune: (1-4,6-9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters (true)

# LeftJoin case with a not-null foreign key. Since fk rows are all guaranteed
# exactly one match, xysd will not be null-extended and the LeftJoin can
# therefore be simplified.
norm
SELECT * FROM fk LEFT JOIN xysd ON x = r1
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (3)==(6), (6)==(3)
 ├── prune: (1,2,4,7-9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]
           ├── variable: x:6 [type=int]
           └── variable: r1:3 [type=int]


# LeftJoin case with a nullable foreign key. The LeftJoin cannot be simplified
# because a nullable foreign key is not guaranteed matches.
norm
SELECT * FROM fk LEFT JOIN xysd ON x = r2
----
left-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int) y:7(int) s:8(string) d:9(decimal)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4,6-9), (6)-->(7-9), (8,9)~~>(6,7)
 ├── prune: (1-3,7-9)
 ├── reject-nulls: (6-9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]
           ├── variable: x:6 [type=int]
           └── variable: r2:4 [type=int]

# FullJoin with equality between key columns. The FullJoin adds back any rows
# that are filtered out, and the equality between key columns ensures that no
# rows are duplicated. Note that both sides may be null-extended.
norm
SELECT * FROM mn FULL JOIN xysd ON m = x
----
full-join (hash)
 ├── columns: m:1(int) n:2(int) x:4(int) y:5(int) s:6(string) d:7(decimal)
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── key: (1,4)
 ├── fd: (1)-->(2), (2)~~>(1), (4)-->(5-7), (6,7)~~>(4,5)
 ├── prune: (2,5-7)
 ├── reject-nulls: (1,2,4-7)
 ├── interesting orderings: (+1) (+2,+1) (+4) (-6,+7,+4)
 ├── scan mn
 │    ├── columns: m:1(int!null) n:2(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2), (2)~~>(1)
 │    ├── prune: (1,2)
 │    ├── interesting orderings: (+1) (+2,+1)
 │    └── unfiltered-cols: (1-3)
 ├── scan xysd
 │    ├── columns: x:4(int!null) y:5(int) s:6(string) d:7(decimal!null)
 │    ├── key: (4)
 │    ├── fd: (4)-->(5-7), (6,7)~~>(4,5)
 │    ├── prune: (4-7)
 │    ├── interesting orderings: (+4) (-6,+7,+4)
 │    └── unfiltered-cols: (4-8)
 └── filters
      └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
           ├── variable: m:1 [type=int]
           └── variable: x:4 [type=int]

# Self-join case. Since the condition is equating a key column with itself,
# every row from both inputs is guaranteed to be included in the join output
# exactly once.
norm
SELECT * FROM xysd INNER JOIN xysd AS a ON xysd.x = a.x
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)-->(7-9), (8,9)~~>(6,7), (1)==(6), (6)==(1)
 ├── prune: (2-4,7-9)
 ├── interesting orderings: (+1) (-3,+4,+1) (+6) (-8,+9,+6)
 ├── scan xysd
 │    ├── columns: xysd.x:1(int!null) xysd.y:2(int) xysd.s:3(string) xysd.d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd [as=a]
 │    ├── columns: a.x:6(int!null) a.y:7(int) a.s:8(string) a.d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── variable: xysd.x:1 [type=int]
           └── variable: a.x:6 [type=int]

# Case with duplicated referenced columns.
norm
SELECT * FROM
fk INNER JOIN (SELECT * FROM xysd FULL JOIN (VALUES (1), (2)) ON True) ON r1 = x
----
inner-join (cross)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) column1:11(int!null)
 ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (3)==(6), (6)==(3)
 ├── prune: (1,2,4,7-9,11)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── inner-join (hash)
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (3)==(6), (6)==(3)
 │    ├── prune: (1,2,4,7-9)
 │    ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 │    ├── unfiltered-cols: (1-5)
 │    ├── scan fk
 │    │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-4)
 │    │    ├── prune: (1-4)
 │    │    ├── interesting orderings: (+1)
 │    │    └── unfiltered-cols: (1-5)
 │    ├── scan xysd
 │    │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    │    ├── prune: (6-9)
 │    │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    │    └── unfiltered-cols: (6-10)
 │    └── filters
 │         └── eq [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]
 │              ├── variable: r1:3 [type=int]
 │              └── variable: x:6 [type=int]
 ├── values
 │    ├── columns: column1:11(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (11)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 └── filters (true)

# Case with a self-join in the input of an InnerJoin.
norm
SELECT * FROM fk
INNER JOIN (SELECT * FROM xysd INNER JOIN xysd AS a ON xysd.x = a.x) f(x) ON r1 = f.x
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int) s:8(string) d:9(decimal!null) x:11(int!null) y:12(int) s:13(string) d:14(decimal!null)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (11)-->(12-14), (13,14)~~>(11,12), (6)==(3,11), (11)==(3,6), (3)==(6,11)
 ├── prune: (1,2,4,7-9,12-14)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6) (+11) (-13,+14,+11)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── inner-join (hash)
 │    ├── columns: xysd.x:6(int!null) xysd.y:7(int) xysd.s:8(string) xysd.d:9(decimal!null) a.x:11(int!null) a.y:12(int) a.s:13(string) a.d:14(decimal!null)
 │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    ├── key: (11)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7), (11)-->(12-14), (13,14)~~>(11,12), (6)==(11), (11)==(6)
 │    ├── prune: (7-9,12-14)
 │    ├── interesting orderings: (+6) (-8,+9,+6) (+11) (-13,+14,+11)
 │    ├── unfiltered-cols: (6-15)
 │    ├── scan xysd
 │    │    ├── columns: xysd.x:6(int!null) xysd.y:7(int) xysd.s:8(string) xysd.d:9(decimal!null)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    │    ├── prune: (6-9)
 │    │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    │    └── unfiltered-cols: (6-10)
 │    ├── scan xysd [as=a]
 │    │    ├── columns: a.x:11(int!null) a.y:12(int) a.s:13(string) a.d:14(decimal!null)
 │    │    ├── key: (11)
 │    │    ├── fd: (11)-->(12-14), (13,14)~~>(11,12)
 │    │    ├── prune: (11-14)
 │    │    ├── interesting orderings: (+11) (-13,+14,+11)
 │    │    └── unfiltered-cols: (11-15)
 │    └── filters
 │         └── eq [type=bool, outer=(6,11), constraints=(/6: (/NULL - ]; /11: (/NULL - ]), fd=(6)==(11), (11)==(6)]
 │              ├── variable: xysd.x:6 [type=int]
 │              └── variable: a.x:11 [type=int]
 └── filters
      └── eq [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]
           ├── variable: r1:3 [type=int]
           └── variable: xysd.x:6 [type=int]

norm
SELECT * FROM fk
INNER JOIN (SELECT xysd.x, a.x AS t FROM xysd INNER JOIN xysd AS a ON xysd.x = a.x) ON r1 = t
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) t:11(int!null)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (6)==(3,11), (11)==(3,6), (3)==(6,11)
 ├── prune: (1,2,4)
 ├── interesting orderings: (+1) (+6) (+11)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── inner-join (hash)
 │    ├── columns: xysd.x:6(int!null) a.x:11(int!null)
 │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    ├── key: (11)
 │    ├── fd: (6)==(11), (11)==(6)
 │    ├── interesting orderings: (+6) (+11)
 │    ├── unfiltered-cols: (6-15)
 │    ├── scan xysd
 │    │    ├── columns: xysd.x:6(int!null)
 │    │    ├── key: (6)
 │    │    ├── prune: (6)
 │    │    ├── interesting orderings: (+6)
 │    │    └── unfiltered-cols: (6-10)
 │    ├── scan xysd [as=a]
 │    │    ├── columns: a.x:11(int!null)
 │    │    ├── key: (11)
 │    │    ├── prune: (11)
 │    │    ├── interesting orderings: (+11)
 │    │    └── unfiltered-cols: (11-15)
 │    └── filters
 │         └── eq [type=bool, outer=(6,11), constraints=(/6: (/NULL - ]; /11: (/NULL - ]), fd=(6)==(11), (11)==(6)]
 │              ├── variable: xysd.x:6 [type=int]
 │              └── variable: a.x:11 [type=int]
 └── filters
      └── eq [type=bool, outer=(3,11), constraints=(/3: (/NULL - ]; /11: (/NULL - ]), fd=(3)==(11), (11)==(3)]
           ├── variable: r1:3 [type=int]
           └── variable: a.x:11 [type=int]

# Case with an equality with a synthesized column.
norm
SELECT * FROM mn LEFT JOIN xysd ON y = (n * 2)
----
project
 ├── columns: m:1(int!null) n:2(int) x:4(int) y:5(int) s:6(string) d:7(decimal)
 ├── immutable
 ├── key: (1,4)
 ├── fd: (1)-->(2), (2)~~>(1), (4)-->(5-7), (6,7)~~>(4,5)
 ├── prune: (1,2,4-7)
 ├── reject-nulls: (4-7)
 ├── interesting orderings: (+1) (+2,+1) (+4) (-6,+7,+4)
 └── left-join (hash)
      ├── columns: m:1(int!null) n:2(int) x:4(int) y:5(int) s:6(string) d:7(decimal) column9:9(int)
      ├── immutable
      ├── key: (1,4)
      ├── fd: (1)-->(2), (2)~~>(1), (2)-->(9), (4)-->(5-7), (6,7)~~>(4,5)
      ├── prune: (1,2,4,6,7)
      ├── reject-nulls: (4-7)
      ├── interesting orderings: (+1) (+2,+1) (+4) (-6,+7,+4)
      ├── project
      │    ├── columns: column9:9(int) m:1(int!null) n:2(int)
      │    ├── immutable
      │    ├── key: (1)
      │    ├── fd: (1)-->(2), (2)~~>(1), (2)-->(9)
      │    ├── prune: (1,2,9)
      │    ├── interesting orderings: (+1) (+2,+1)
      │    ├── unfiltered-cols: (1-3)
      │    ├── scan mn
      │    │    ├── columns: m:1(int!null) n:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2), (2)~~>(1)
      │    │    ├── prune: (1,2)
      │    │    ├── interesting orderings: (+1) (+2,+1)
      │    │    └── unfiltered-cols: (1-3)
      │    └── projections
      │         └── mult [as=column9:9, type=int, outer=(2), immutable]
      │              ├── variable: n:2 [type=int]
      │              └── const: 2 [type=int]
      ├── scan xysd
      │    ├── columns: x:4(int!null) y:5(int) s:6(string) d:7(decimal!null)
      │    ├── key: (4)
      │    ├── fd: (4)-->(5-7), (6,7)~~>(4,5)
      │    ├── prune: (4-7)
      │    ├── interesting orderings: (+4) (-6,+7,+4)
      │    └── unfiltered-cols: (4-8)
      └── filters
           └── eq [type=bool, outer=(5,9), constraints=(/5: (/NULL - ]; /9: (/NULL - ]), fd=(5)==(9), (9)==(5)]
                ├── variable: column9:9 [type=int]
                └── variable: y:5 [type=int]

# Case with columns that don't come from base tables.
norm
SELECT * FROM (SELECT * FROM uv UNION (SELECT * FROM uv)) f(v1, v2) INNER JOIN xysd ON v2 = x
----
inner-join (hash)
 ├── columns: v1:9(int) v2:10(int!null) x:11(int!null) y:12(int) s:13(string) d:14(decimal!null)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (9,11)
 ├── fd: (11)-->(12-14), (13,14)~~>(11,12), (10)==(11), (11)==(10)
 ├── prune: (12-14)
 ├── interesting orderings: (+11) (-13,+14,+11)
 ├── union
 │    ├── columns: u:9(int) v:10(int!null)
 │    ├── left columns: uv.u:1(int) uv.v:2(int)
 │    ├── right columns: uv.u:5(int) uv.v:6(int)
 │    ├── key: (9,10)
 │    ├── scan uv
 │    │    ├── columns: uv.u:1(int) uv.v:2(int!null)
 │    │    └── prune: (1,2)
 │    └── scan uv
 │         ├── columns: uv.u:5(int) uv.v:6(int!null)
 │         └── prune: (5,6)
 ├── scan xysd
 │    ├── columns: x:11(int!null) y:12(int) s:13(string) d:14(decimal!null)
 │    ├── key: (11)
 │    ├── fd: (11)-->(12-14), (13,14)~~>(11,12)
 │    ├── prune: (11-14)
 │    ├── interesting orderings: (+11) (-13,+14,+11)
 │    └── unfiltered-cols: (11-15)
 └── filters
      └── eq [type=bool, outer=(10,11), constraints=(/10: (/NULL - ]; /11: (/NULL - ]), fd=(10)==(11), (11)==(10)]
           ├── variable: v:10 [type=int]
           └── variable: x:11 [type=int]

# Self-join case with different columns.
norm
SELECT * FROM xysd INNER JOIN xysd AS a ON xysd.x = a.y
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) x:6(int!null) y:7(int!null) s:8(string) d:9(decimal!null)
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)-->(7-9), (8,9)~~>(6,7), (1)==(7), (7)==(1)
 ├── prune: (2-4,6,8,9)
 ├── interesting orderings: (+1) (-3,+4,+1) (+6) (-8,+9,+6)
 ├── scan xysd
 │    ├── columns: xysd.x:1(int!null) xysd.y:2(int) xysd.s:3(string) xysd.d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd [as=a]
 │    ├── columns: a.x:6(int!null) a.y:7(int) a.s:8(string) a.d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
           ├── variable: xysd.x:1 [type=int]
           └── variable: a.y:7 [type=int]

# Case with an equality between a not-null foreign key and an unreferenced
# column.
norm
SELECT * FROM fk INNER JOIN xysd ON r1 = y
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) x:6(int!null) y:7(int!null) s:8(string) d:9(decimal!null)
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (6)-->(7-9), (8,9)~~>(6,7), (3)==(7), (7)==(3)
 ├── prune: (1,2,4,6,8,9)
 ├── interesting orderings: (+1) (+6) (-8,+9,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan xysd
 │    ├── columns: x:6(int!null) y:7(int) s:8(string) d:9(decimal!null)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-9), (8,9)~~>(6,7)
 │    ├── prune: (6-9)
 │    ├── interesting orderings: (+6) (-8,+9,+6)
 │    └── unfiltered-cols: (6-10)
 └── filters
      └── eq [type=bool, outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
           ├── variable: r1:3 [type=int]
           └── variable: y:7 [type=int]

# Case where left table has a foreign key that references a table that isn't
# from the right input.
norm
SELECT * FROM fk INNER JOIN mn ON k = m
----
inner-join (hash)
 ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int) m:6(int!null) n:7(int)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (7)~~>(6), (1)==(6), (6)==(1)
 ├── prune: (2-4,7)
 ├── interesting orderings: (+1) (+6) (+7,+6)
 ├── scan fk
 │    ├── columns: k:1(int!null) v:2(int) r1:3(int!null) r2:4(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1)
 │    └── unfiltered-cols: (1-5)
 ├── scan mn
 │    ├── columns: m:6(int!null) n:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7), (7)~~>(6)
 │    ├── prune: (6,7)
 │    ├── interesting orderings: (+6) (+7,+6)
 │    └── unfiltered-cols: (6-8)
 └── filters
      └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── variable: k:1 [type=int]
           └── variable: m:6 [type=int]

# Case with a match-simple foreign key with one nullable column.
norm
SELECT *
FROM ref
INNER JOIN abc 
ON (r1, r2, r3) = (a, b, c)
----
inner-join (hash)
 ├── columns: r1:1(int!null) r2:2(int!null) r3:3(int!null) a:6(int!null) b:7(int!null) c:8(int!null)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── fd: (1)==(6), (6)==(1), (2)==(7), (7)==(2), (3)==(8), (8)==(3)
 ├── interesting orderings: (+6,+7,+8)
 ├── scan ref
 │    ├── columns: r1:1(int!null) r2:2(int) r3:3(int!null)
 │    ├── prune: (1-3)
 │    └── unfiltered-cols: (1-5)
 ├── scan abc
 │    ├── columns: a:6(int!null) b:7(int!null) c:8(int!null)
 │    ├── key: (6-8)
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+6,+7,+8)
 │    └── unfiltered-cols: (6-9)
 └── filters
      ├── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    ├── variable: r1:1 [type=int]
      │    └── variable: a:6 [type=int]
      ├── eq [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
      │    ├── variable: r2:2 [type=int]
      │    └── variable: b:7 [type=int]
      └── eq [type=bool, outer=(3,8), constraints=(/3: (/NULL - ]; /8: (/NULL - ]), fd=(3)==(8), (8)==(3)]
           ├── variable: r3:3 [type=int]
           └── variable: c:8 [type=int]

# Case with a not-null multi-column foreign key.
norm
SELECT *
FROM (SELECT r1, r2, r3 FROM ref WHERE r2 IS NOT NULL)
INNER JOIN abc
ON (r1, r2, r3) = (a, b, c)
----
inner-join (hash)
 ├── columns: r1:1(int!null) r2:2(int!null) r3:3(int!null) a:6(int!null) b:7(int!null) c:8(int!null)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── fd: (1)==(6), (6)==(1), (2)==(7), (7)==(2), (3)==(8), (8)==(3)
 ├── interesting orderings: (+6,+7,+8)
 ├── select
 │    ├── columns: r1:1(int!null) r2:2(int!null) r3:3(int!null)
 │    ├── prune: (1,3)
 │    ├── scan ref
 │    │    ├── columns: r1:1(int!null) r2:2(int) r3:3(int!null)
 │    │    └── prune: (1-3)
 │    └── filters
 │         └── is-not [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │              ├── variable: r2:2 [type=int]
 │              └── null [type=unknown]
 ├── scan abc
 │    ├── columns: a:6(int!null) b:7(int!null) c:8(int!null)
 │    ├── key: (6-8)
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+6,+7,+8)
 │    └── unfiltered-cols: (6-9)
 └── filters
      ├── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    ├── variable: r1:1 [type=int]
      │    └── variable: a:6 [type=int]
      ├── eq [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
      │    ├── variable: r2:2 [type=int]
      │    └── variable: b:7 [type=int]
      └── eq [type=bool, outer=(3,8), constraints=(/3: (/NULL - ]; /8: (/NULL - ]), fd=(3)==(8), (8)==(3)]
           ├── variable: r3:3 [type=int]
           └── variable: c:8 [type=int]

# Case with a not-null multi-column foreign key and an equality on only one of
# the foreign key columns.
norm
SELECT *
FROM (SELECT r2 FROM ref WHERE r2 IS NOT NULL)
INNER JOIN abc
ON r2 = b
----
inner-join (hash)
 ├── columns: r2:2(int!null) a:6(int!null) b:7(int!null) c:8(int!null)
 ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 ├── fd: (2)==(7), (7)==(2)
 ├── prune: (6,8)
 ├── interesting orderings: (+6,+7,+8)
 ├── select
 │    ├── columns: r2:2(int!null)
 │    ├── scan ref
 │    │    ├── columns: r2:2(int)
 │    │    └── prune: (2)
 │    └── filters
 │         └── is-not [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │              ├── variable: r2:2 [type=int]
 │              └── null [type=unknown]
 ├── scan abc
 │    ├── columns: a:6(int!null) b:7(int!null) c:8(int!null)
 │    ├── key: (6-8)
 │    ├── prune: (6-8)
 │    ├── interesting orderings: (+6,+7,+8)
 │    └── unfiltered-cols: (6-9)
 └── filters
      └── eq [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
           ├── variable: r2:2 [type=int]
           └── variable: b:7 [type=int]

exec-ddl
CREATE TABLE trade_type (tt_id INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE exchange (ex_id INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE status_type (st_id INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE security (
    s_symb  INT PRIMARY KEY,
    s_st_id INT NOT NULL,
    s_ex_id INT NOT NULL,
    FOREIGN KEY (s_st_id) REFERENCES status_type (st_id),
    FOREIGN KEY (s_ex_id) REFERENCES exchange (ex_id)
)
----

exec-ddl
CREATE TABLE trade (
    t_st_id  INT NOT NULL,
    t_tt_id  INT NOT NULL,
    t_s_symb INT NOT NULL,
    FOREIGN KEY (t_st_id) REFERENCES status_type (st_id),
    FOREIGN KEY (t_tt_id) REFERENCES trade_type (tt_id),
    FOREIGN KEY (t_s_symb) REFERENCES security (s_symb)
)
----

# Regression test for #49821.
opt format=show-ruleprops disable=(RightAssociateJoinsLeft,RightAssociateJoinsRight,ReorderJoins)
SELECT *
FROM trade, status_type, trade_type, security, exchange
WHERE st_id = t_st_id
  AND tt_id = t_tt_id
  AND s_symb = t_s_symb
  AND ex_id = s_ex_id
LIMIT 50;
----
limit
 ├── columns: t_st_id:1(int!null) t_tt_id:2(int!null) t_s_symb:3(int!null) st_id:6(int!null) tt_id:8(int!null) s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null) ex_id:14(int!null)
 ├── cardinality: [0 - 50]
 ├── fd: (10)-->(11,12), (12)==(14), (14)==(12), (1)==(6), (6)==(1), (2)==(8), (8)==(2), (3)==(10), (10)==(3)
 ├── prune: (11)
 ├── interesting orderings: (+6) (+8) (+10) (+14)
 ├── inner-join (hash)
 │    ├── columns: t_st_id:1(int!null) t_tt_id:2(int!null) t_s_symb:3(int!null) st_id:6(int!null) tt_id:8(int!null) s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null) ex_id:14(int!null)
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── fd: (10)-->(11,12), (12)==(14), (14)==(12), (1)==(6), (6)==(1), (2)==(8), (8)==(2), (3)==(10), (10)==(3)
 │    ├── limit hint: 50.00
 │    ├── prune: (11)
 │    ├── interesting orderings: (+6) (+8) (+10) (+14)
 │    ├── scan trade
 │    │    ├── columns: t_st_id:1(int!null) t_tt_id:2(int!null) t_s_symb:3(int!null)
 │    │    ├── prune: (1-3)
 │    │    └── unfiltered-cols: (1-5)
 │    ├── inner-join (cross)
 │    │    ├── columns: st_id:6(int!null) tt_id:8(int!null) s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null) ex_id:14(int!null)
 │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(one-or-more)
 │    │    ├── key: (6,8,10)
 │    │    ├── fd: (10)-->(11,12), (12)==(14), (14)==(12)
 │    │    ├── prune: (6,8,10,11)
 │    │    ├── interesting orderings: (+6) (+8) (+10) (+14)
 │    │    ├── scan status_type
 │    │    │    ├── columns: st_id:6(int!null)
 │    │    │    ├── key: (6)
 │    │    │    ├── prune: (6)
 │    │    │    ├── interesting orderings: (+6)
 │    │    │    └── unfiltered-cols: (6,7)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: tt_id:8(int!null) s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null) ex_id:14(int!null)
 │    │    │    ├── key: (8,10)
 │    │    │    ├── fd: (10)-->(11,12), (12)==(14), (14)==(12)
 │    │    │    ├── prune: (8,10,11)
 │    │    │    ├── interesting orderings: (+8) (+10) (+14)
 │    │    │    ├── scan trade_type
 │    │    │    │    ├── columns: tt_id:8(int!null)
 │    │    │    │    ├── key: (8)
 │    │    │    │    ├── prune: (8)
 │    │    │    │    ├── interesting orderings: (+8)
 │    │    │    │    └── unfiltered-cols: (8,9)
 │    │    │    ├── inner-join (hash)
 │    │    │    │    ├── columns: s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null) ex_id:14(int!null)
 │    │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    │    │    │    ├── key: (10)
 │    │    │    │    ├── fd: (10)-->(11,12), (12)==(14), (14)==(12)
 │    │    │    │    ├── prune: (10,11)
 │    │    │    │    ├── interesting orderings: (+10) (+14)
 │    │    │    │    ├── unfiltered-cols: (10-13)
 │    │    │    │    ├── scan security
 │    │    │    │    │    ├── columns: s_symb:10(int!null) s_st_id:11(int!null) s_ex_id:12(int!null)
 │    │    │    │    │    ├── key: (10)
 │    │    │    │    │    ├── fd: (10)-->(11,12)
 │    │    │    │    │    ├── prune: (10-12)
 │    │    │    │    │    ├── interesting orderings: (+10)
 │    │    │    │    │    └── unfiltered-cols: (10-13)
 │    │    │    │    ├── scan exchange
 │    │    │    │    │    ├── columns: ex_id:14(int!null)
 │    │    │    │    │    ├── key: (14)
 │    │    │    │    │    ├── prune: (14)
 │    │    │    │    │    ├── interesting orderings: (+14)
 │    │    │    │    │    └── unfiltered-cols: (14,15)
 │    │    │    │    └── filters
 │    │    │    │         └── eq [type=bool, outer=(12,14), constraints=(/12: (/NULL - ]; /14: (/NULL - ]), fd=(12)==(14), (14)==(12)]
 │    │    │    │              ├── variable: ex_id:14 [type=int]
 │    │    │    │              └── variable: s_ex_id:12 [type=int]
 │    │    │    └── filters (true)
 │    │    └── filters (true)
 │    └── filters
 │         ├── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │         │    ├── variable: st_id:6 [type=int]
 │         │    └── variable: t_st_id:1 [type=int]
 │         ├── eq [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │         │    ├── variable: tt_id:8 [type=int]
 │         │    └── variable: t_tt_id:2 [type=int]
 │         └── eq [type=bool, outer=(3,10), constraints=(/3: (/NULL - ]; /10: (/NULL - ]), fd=(3)==(10), (10)==(3)]
 │              ├── variable: s_symb:10 [type=int]
 │              └── variable: t_s_symb:3 [type=int]
 └── const: 50 [type=int]

# Regression test for #50059.
exec-ddl
CREATE TABLE parent (a INT NOT NULL UNIQUE, b INT NOT NULL UNIQUE)
----

exec-ddl
CREATE TABLE child (
  r_a INT NOT NULL REFERENCES parent(a),
  r_b INT NOT NULL REFERENCES parent(b)
)
----

# LeftJoin shouldn't be simplified.
norm
SELECT * FROM child LEFT JOIN parent ON r_a = a AND r_b = b
----
left-join (hash)
 ├── columns: r_a:1(int!null) r_b:2(int!null) a:5(int) b:6(int)
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── fd: (5)-->(6), (6)-->(5)
 ├── reject-nulls: (5,6)
 ├── interesting orderings: (+5) (+6)
 ├── scan child
 │    ├── columns: r_a:1(int!null) r_b:2(int!null)
 │    ├── prune: (1,2)
 │    └── unfiltered-cols: (1-4)
 ├── scan parent
 │    ├── columns: a:5(int!null) b:6(int!null)
 │    ├── key: (6)
 │    ├── fd: (5)-->(6), (6)-->(5)
 │    ├── prune: (5,6)
 │    ├── interesting orderings: (+5) (+6)
 │    └── unfiltered-cols: (5-8)
 └── filters
      ├── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    ├── variable: r_a:1 [type=int]
      │    └── variable: a:5 [type=int]
      └── eq [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
           ├── variable: r_b:2 [type=int]
           └── variable: b:6 [type=int]
