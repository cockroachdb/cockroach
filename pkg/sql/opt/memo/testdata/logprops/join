exec-ddl
CREATE TABLE xysd (x INT PRIMARY KEY, y INT, s STRING, d DECIMAL NOT NULL, UNIQUE (s DESC, d))
----

exec-ddl
CREATE TABLE uv (u INT, v INT NOT NULL)
----

exec-ddl
CREATE TABLE mn (m INT PRIMARY KEY, n INT, UNIQUE (n))
----

# Inner-join.
build
SELECT *, rowid FROM xysd INNER JOIN uv ON x=u
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int!null) v:6(int!null) rowid:7(int!null)
 ├── key: (7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6), (1)==(5), (5)==(1)
 ├── prune: (2-4,6,7)
 ├── interesting orderings: (+1) (-3,+4,+1) (+7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan uv
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── prune: (5-7)
 │    └── interesting orderings: (+7)
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:5 [type=int]

# Inner-join-apply.
opt
SELECT (SELECT (VALUES (x), (y))) FROM xysd
----
project
 ├── columns: column1:7(int)
 ├── prune: (7)
 ├── inner-join-apply
 │    ├── columns: x:1(int!null) y:2(int) column1:5(int) column1:6(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6)
 │    ├── prune: (6)
 │    ├── interesting orderings: (+1)
 │    ├── scan xysd
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── prune: (1,2)
 │    │    └── interesting orderings: (+1)
 │    ├── inner-join-apply
 │    │    ├── columns: column1:5(int) column1:6(int)
 │    │    ├── outer: (1,2)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(5,6)
 │    │    ├── prune: (6)
 │    │    ├── max1-row
 │    │    │    ├── columns: column1:5(int)
 │    │    │    ├── error: "more than one row returned by a subquery used as an expression"
 │    │    │    ├── outer: (1,2)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(5)
 │    │    │    └── values
 │    │    │         ├── columns: column1:5(int)
 │    │    │         ├── outer: (1,2)
 │    │    │         ├── cardinality: [2 - 2]
 │    │    │         ├── prune: (5)
 │    │    │         ├── tuple [type=tuple{int}]
 │    │    │         │    └── variable: x:1 [type=int]
 │    │    │         └── tuple [type=tuple{int}]
 │    │    │              └── variable: y:2 [type=int]
 │    │    ├── values
 │    │    │    ├── columns: column1:6(int)
 │    │    │    ├── outer: (5)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(6)
 │    │    │    ├── prune: (6)
 │    │    │    └── tuple [type=tuple{int}]
 │    │    │         └── variable: column1:5 [type=int]
 │    │    └── filters (true)
 │    └── filters (true)
 └── projections
      └── variable: column1:6 [as=column1:7, type=int, outer=(6)]

# Inner-join-apply nested in inner-join-apply with outer column references to
# each parent.
opt
SELECT * FROM xysd WHERE (SELECT v FROM uv WHERE (SELECT n FROM mn WHERE n=v)=x)=x
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 └── select
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int!null)
      ├── key: (1)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(6), (6)==(1)
      ├── prune: (2-4)
      ├── ensure-distinct-on
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int)
      │    ├── grouping columns: x:1(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4,6), (3,4)~~>(1,2)
      │    ├── prune: (2-4,6)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int) n:9(int)
      │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (6)==(9), (9)==(6)
      │    │    ├── prune: (2-4)
      │    │    ├── reject-nulls: (6,9)
      │    │    ├── interesting orderings: (+1) (-3,+4,+1) (+9)
      │    │    ├── scan xysd
      │    │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    │    ├── prune: (1-4)
      │    │    │    └── interesting orderings: (+1) (-3,+4,+1)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: v:6(int!null) n:9(int!null)
      │    │    │    ├── fd: (6)==(9), (9)==(6)
      │    │    │    ├── interesting orderings: (+9)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: v:6(int!null)
      │    │    │    │    └── prune: (6)
      │    │    │    ├── scan mn
      │    │    │    │    ├── columns: n:9(int)
      │    │    │    │    ├── lax-key: (9)
      │    │    │    │    ├── prune: (9)
      │    │    │    │    └── interesting orderings: (+9)
      │    │    │    └── filters
      │    │    │         └── eq [type=bool, outer=(6,9), constraints=(/6: (/NULL - ]; /9: (/NULL - ]), fd=(6)==(9), (9)==(6)]
      │    │    │              ├── variable: n:9 [type=int]
      │    │    │              └── variable: v:6 [type=int]
      │    │    └── filters
      │    │         └── eq [type=bool, outer=(1,9), constraints=(/1: (/NULL - ]; /9: (/NULL - ]), fd=(1)==(9), (9)==(1)]
      │    │              ├── variable: x:1 [type=int]
      │    │              └── variable: n:9 [type=int]
      │    └── aggregations
      │         ├── const-agg [as=y:2, type=int, outer=(2)]
      │         │    └── variable: y:2 [type=int]
      │         ├── const-agg [as=s:3, type=string, outer=(3)]
      │         │    └── variable: s:3 [type=string]
      │         ├── const-agg [as=d:4, type=decimal, outer=(4)]
      │         │    └── variable: d:4 [type=decimal]
      │         └── const-agg [as=v:6, type=int, outer=(6)]
      │              └── variable: v:6 [type=int]
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: v:6 [type=int]

# Inner-join nested in inner-join-apply with outer column reference to top-level
# inner-join-apply.
opt
SELECT * FROM xysd WHERE (SELECT v FROM uv WHERE (SELECT m FROM mn WHERE m=y)=x)=x
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 └── select
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int!null)
      ├── key: (1)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(6), (6)==(1)
      ├── prune: (2-4)
      ├── ensure-distinct-on
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int)
      │    ├── grouping columns: x:1(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4,6), (3,4)~~>(1,2)
      │    ├── prune: (2-4,6)
      │    ├── right-join (hash)
      │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) v:6(int) m:8(int)
      │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    ├── prune: (3,4,6)
      │    │    ├── reject-nulls: (6,8)
      │    │    ├── interesting orderings: (+1) (-3,+4,+1) (+8)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: v:6(int!null) m:8(int!null)
      │    │    │    ├── prune: (6,8)
      │    │    │    ├── interesting orderings: (+8)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: v:6(int!null)
      │    │    │    │    └── prune: (6)
      │    │    │    ├── scan mn
      │    │    │    │    ├── columns: m:8(int!null)
      │    │    │    │    ├── key: (8)
      │    │    │    │    ├── prune: (8)
      │    │    │    │    └── interesting orderings: (+8)
      │    │    │    └── filters (true)
      │    │    ├── scan xysd
      │    │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    │    ├── prune: (1-4)
      │    │    │    └── interesting orderings: (+1) (-3,+4,+1)
      │    │    └── filters
      │    │         ├── eq [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      │    │         │    ├── variable: x:1 [type=int]
      │    │         │    └── variable: y:2 [type=int]
      │    │         └── eq [type=bool, outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    │              ├── variable: x:1 [type=int]
      │    │              └── variable: m:8 [type=int]
      │    └── aggregations
      │         ├── const-agg [as=y:2, type=int, outer=(2)]
      │         │    └── variable: y:2 [type=int]
      │         ├── const-agg [as=s:3, type=string, outer=(3)]
      │         │    └── variable: s:3 [type=string]
      │         ├── const-agg [as=d:4, type=decimal, outer=(4)]
      │         │    └── variable: d:4 [type=decimal]
      │         └── const-agg [as=v:6, type=int, outer=(6)]
      │              └── variable: v:6 [type=int]
      └── filters
           └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
                ├── variable: x:1 [type=int]
                └── variable: v:6 [type=int]

# Left-join.
build
SELECT *, rowid FROM xysd LEFT JOIN uv ON x=u
----
left-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) v:6(int) rowid:7(int)
 ├── key: (1,7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6)
 ├── prune: (2-4,6,7)
 ├── reject-nulls: (5-7)
 ├── interesting orderings: (+1) (-3,+4,+1) (+7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan uv
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── prune: (5-7)
 │    └── interesting orderings: (+7)
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:5 [type=int]

# Left-join-apply.
opt
SELECT * FROM xysd WHERE (SELECT u FROM uv WHERE u=x) IS NULL
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-4)
 └── select
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int)
      ├── key: (1)
      ├── fd: ()-->(5), (1)-->(2-4), (3,4)~~>(1,2)
      ├── prune: (2-4)
      ├── ensure-distinct-on
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int)
      │    ├── grouping columns: x:1(int!null)
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (3,4)~~>(1,2)
      │    ├── prune: (2-5)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int)
      │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    ├── prune: (2-4)
      │    │    ├── reject-nulls: (5)
      │    │    ├── interesting orderings: (+1) (-3,+4,+1)
      │    │    ├── scan xysd
      │    │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    │    │    ├── prune: (1-4)
      │    │    │    └── interesting orderings: (+1) (-3,+4,+1)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:5(int)
      │    │    │    └── prune: (5)
      │    │    └── filters
      │    │         └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    │              ├── variable: u:5 [type=int]
      │    │              └── variable: x:1 [type=int]
      │    └── aggregations
      │         ├── const-agg [as=y:2, type=int, outer=(2)]
      │         │    └── variable: y:2 [type=int]
      │         ├── const-agg [as=s:3, type=string, outer=(3)]
      │         │    └── variable: s:3 [type=string]
      │         ├── const-agg [as=d:4, type=decimal, outer=(4)]
      │         │    └── variable: d:4 [type=decimal]
      │         └── const-agg [as=u:5, type=int, outer=(5)]
      │              └── variable: u:5 [type=int]
      └── filters
           └── is [type=bool, outer=(5), constraints=(/5: [/NULL - /NULL]; tight), fd=()-->(5)]
                ├── variable: u:5 [type=int]
                └── null [type=unknown]

# Right-join.
build
SELECT *, rowid FROM xysd RIGHT JOIN uv ON x=u
----
right-join (hash)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:5(int) v:6(int!null) rowid:7(int!null)
 ├── key: (7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(1-6)
 ├── prune: (2-4,6,7)
 ├── reject-nulls: (1-4)
 ├── interesting orderings: (+1) (-3,+4,+1) (+7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan uv
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── prune: (5-7)
 │    └── interesting orderings: (+7)
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:5 [type=int]

# Full-join.
build
SELECT *, rowid FROM xysd FULL JOIN uv ON x=u
----
full-join (hash)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:5(int) v:6(int) rowid:7(int)
 ├── key: (1,7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6)
 ├── prune: (2-4,6,7)
 ├── reject-nulls: (1-7)
 ├── interesting orderings: (+1) (-3,+4,+1) (+7)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan uv
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── prune: (5-7)
 │    └── interesting orderings: (+7)
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:5 [type=int]

# Semi-join.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE x=u)
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 └── inner-join (lookup xysd)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int!null)
      ├── key columns: [5] = [1]
      ├── lookup columns are key
      ├── key: (5)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (1)==(5), (5)==(1)
      ├── distinct-on
      │    ├── columns: u:5(int)
      │    ├── grouping columns: u:5(int)
      │    ├── key: (5)
      │    └── scan uv
      │         ├── columns: u:5(int)
      │         └── prune: (5)
      └── filters (true)

# Semi-join-apply.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE v=x OFFSET 1)
----
semi-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── offset
 │    ├── columns: v:6(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(6)
 │    ├── select
 │    │    ├── columns: v:6(int!null)
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(6)
 │    │    ├── scan uv
 │    │    │    ├── columns: v:6(int!null)
 │    │    │    └── prune: (6)
 │    │    └── filters
 │    │         └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │              ├── variable: v:6 [type=int]
 │    │              └── variable: x:1 [type=int]
 │    └── const: 1 [type=int]
 └── filters (true)

# Semi-join nested in semi-join with outer column reference to top-level join.
opt
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM uv WHERE EXISTS(SELECT * FROM mn WHERE x=m AND x=v))
----
semi-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── semi-join (cross)
 │    ├── columns: v:6(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(6)
 │    ├── scan uv
 │    │    ├── columns: v:6(int!null)
 │    │    └── prune: (6)
 │    ├── scan mn
 │    │    ├── columns: m:8(int!null)
 │    │    ├── key: (8)
 │    │    ├── prune: (8)
 │    │    └── interesting orderings: (+8)
 │    └── filters
 │         ├── eq [type=bool, outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │         │    ├── variable: x:1 [type=int]
 │         │    └── variable: m:8 [type=int]
 │         └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │              ├── variable: x:1 [type=int]
 │              └── variable: v:6 [type=int]
 └── filters (true)

# Anti-join.
opt
SELECT * FROM xysd WHERE NOT EXISTS(SELECT * FROM uv WHERE x=u)
----
anti-join (hash)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan uv
 │    ├── columns: u:5(int)
 │    └── prune: (5)
 └── filters
      └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── variable: x:1 [type=int]
           └── variable: u:5 [type=int]

# Anti-join-apply.
opt
SELECT * FROM xysd WHERE NOT EXISTS(SELECT * FROM uv WHERE v=x OFFSET 1)
----
anti-join-apply
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (2-4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── offset
 │    ├── columns: v:6(int!null)
 │    ├── outer: (1)
 │    ├── fd: ()-->(6)
 │    ├── select
 │    │    ├── columns: v:6(int!null)
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(6)
 │    │    ├── scan uv
 │    │    │    ├── columns: v:6(int!null)
 │    │    │    └── prune: (6)
 │    │    └── filters
 │    │         └── eq [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │              ├── variable: v:6 [type=int]
 │    │              └── variable: x:1 [type=int]
 │    └── const: 1 [type=int]
 └── filters (true)

# Cross-join.
build
SELECT * FROM xysd, uv
----
project
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) v:6(int!null)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-6)
 ├── interesting orderings: (+1) (-3,+4,+1)
 └── inner-join (cross)
      ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) v:6(int!null) rowid:7(int!null)
      ├── key: (1,7)
      ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6)
      ├── prune: (1-7)
      ├── interesting orderings: (+1) (-3,+4,+1) (+7)
      ├── scan xysd
      │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
      │    ├── prune: (1-4)
      │    └── interesting orderings: (+1) (-3,+4,+1)
      ├── scan uv
      │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
      │    ├── key: (7)
      │    ├── fd: (7)-->(5,6)
      │    ├── prune: (5-7)
      │    └── interesting orderings: (+7)
      └── filters (true)

# Self-join.
build
SELECT * FROM xysd, xysd AS xysd
----
inner-join (cross)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 ├── key: (1,5)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (5)-->(6-8), (7,8)~~>(5,6)
 ├── prune: (1-8)
 ├── interesting orderings: (+1) (-3,+4,+1) (+5) (-7,+8,+5)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6-8), (7,8)~~>(5,6)
 │    ├── prune: (5-8)
 │    └── interesting orderings: (+5) (-7,+8,+5)
 └── filters (true)

# Propagate outer columns.
build
SELECT * FROM xysd WHERE EXISTS(SELECT * FROM (SELECT x) INNER JOIN (SELECT y) ON x::string = s)
----
select
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (4)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: xysd.x:1(int!null) xysd.y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 └── filters
      └── exists [type=bool, outer=(1-3), correlated-subquery]
           └── inner-join (cross)
                ├── columns: x:5(int) y:6(int)
                ├── outer: (1-3)
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(5,6)
                ├── prune: (6)
                ├── project
                │    ├── columns: x:5(int)
                │    ├── outer: (1)
                │    ├── cardinality: [1 - 1]
                │    ├── key: ()
                │    ├── fd: ()-->(5)
                │    ├── prune: (5)
                │    ├── values
                │    │    ├── cardinality: [1 - 1]
                │    │    ├── key: ()
                │    │    └── tuple [type=tuple]
                │    └── projections
                │         └── variable: xysd.x:1 [as=x:5, type=int, outer=(1)]
                ├── project
                │    ├── columns: y:6(int)
                │    ├── outer: (2)
                │    ├── cardinality: [1 - 1]
                │    ├── key: ()
                │    ├── fd: ()-->(6)
                │    ├── prune: (6)
                │    ├── values
                │    │    ├── cardinality: [1 - 1]
                │    │    ├── key: ()
                │    │    └── tuple [type=tuple]
                │    └── projections
                │         └── variable: xysd.y:2 [as=y:6, type=int, outer=(2)]
                └── filters
                     └── eq [type=bool, outer=(3,5)]
                          ├── cast: STRING [type=string]
                          │    └── variable: x:5 [type=int]
                          └── variable: s:3 [type=string]

# Calculate semi-join cardinality when left side has non-zero cardinality.
opt
SELECT * FROM (SELECT count(*) cnt FROM xysd) WHERE EXISTS(SELECT * FROM uv WHERE cnt=1)
----
project
 ├── columns: cnt:5(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 └── inner-join (cross)
      ├── columns: count_rows:5(int!null)
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(5)
      ├── select
      │    ├── columns: count_rows:5(int!null)
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(5)
      │    ├── scalar-group-by
      │    │    ├── columns: count_rows:5(int!null)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(5)
      │    │    ├── prune: (5)
      │    │    ├── scan xysd@secondary
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:5, type=int]
      │    └── filters
      │         └── eq [type=bool, outer=(5), constraints=(/5: [/1 - /1]; tight), fd=()-->(5)]
      │              ├── variable: count_rows:5 [type=int]
      │              └── const: 1 [type=int]
      ├── scan uv
      │    ├── limit: 1
      │    └── key: ()
      └── filters (true)

# Calculate semi-join-apply cardinality.
expr
(SemiJoinApply
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
            (Cardinality "0-10")
        ]
    )
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
        ]
    )
    [ ]
    [ ]
)
----
semi-join-apply
 ├── columns: a:1(int)
 ├── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:1(int)
 │    └── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:2(int)
 │    └── cardinality: [0 - 0]
 └── filters (true)

# Calculate anti-join cardinality when left side has non-zero cardinality.
opt
SELECT * FROM (SELECT * FROM (VALUES (1), (2))) WHERE NOT EXISTS(SELECT * FROM uv WHERE u=column1)
----
anti-join (hash)
 ├── columns: column1:1(int!null)
 ├── cardinality: [0 - 2]
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 ├── scan uv
 │    ├── columns: u:2(int)
 │    └── prune: (2)
 └── filters
      └── eq [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
           ├── variable: u:2 [type=int]
           └── variable: column1:1 [type=int]

# Calculate anti-join-apply cardinality.
expr
(AntiJoinApply
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
            (Cardinality "0-10")
        ]
    )
    (FakeRel
        [
            (OutputCols [ (NewColumn "a" "int") ])
        ]
    )
    [ ]
    [ ]
)
----
anti-join-apply
 ├── columns: a:1(int)
 ├── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:1(int)
 │    └── cardinality: [0 - 10]
 ├── fake-rel
 │    ├── columns: a:2(int)
 │    └── cardinality: [0 - 0]
 └── filters (true)

# Calculate inner-join cardinality.
build
SELECT * FROM (VALUES (1), (2)) INNER JOIN (SELECT * FROM uv LIMIT 2) ON True
----
inner-join (cross)
 ├── columns: column1:1(int!null) u:2(int) v:3(int!null)
 ├── cardinality: [0 - 4]
 ├── prune: (1-3)
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 ├── limit
 │    ├── columns: u:2(int) v:3(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (2,3)
 │    ├── project
 │    │    ├── columns: u:2(int) v:3(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (2,3)
 │    │    └── scan uv
 │    │         ├── columns: u:2(int) v:3(int!null) rowid:4(int!null)
 │    │         ├── key: (4)
 │    │         ├── fd: (4)-->(2,3)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (2-4)
 │    │         └── interesting orderings: (+4)
 │    └── const: 2 [type=int]
 └── filters
      └── true [type=bool]

# Calculate left-join cardinality.
build
SELECT * FROM (VALUES (1), (2), (3)) LEFT JOIN (SELECT * FROM uv LIMIT 2) ON True
----
left-join (cross)
 ├── columns: column1:1(int!null) u:2(int) v:3(int)
 ├── cardinality: [3 - 6]
 ├── prune: (1-3)
 ├── reject-nulls: (2,3)
 ├── values
 │    ├── columns: column1:1(int!null)
 │    ├── cardinality: [3 - 3]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 2 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 3 [type=int]
 ├── limit
 │    ├── columns: u:2(int) v:3(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (2,3)
 │    ├── project
 │    │    ├── columns: u:2(int) v:3(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (2,3)
 │    │    └── scan uv
 │    │         ├── columns: u:2(int) v:3(int!null) rowid:4(int!null)
 │    │         ├── key: (4)
 │    │         ├── fd: (4)-->(2,3)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (2-4)
 │    │         └── interesting orderings: (+4)
 │    └── const: 2 [type=int]
 └── filters
      └── true [type=bool]

# Calculate right-join cardinality.
build
SELECT * FROM (SELECT * FROM uv LIMIT 2) RIGHT JOIN (VALUES (1), (2), (3)) ON True
----
right-join (cross)
 ├── columns: u:1(int) v:2(int) column1:4(int!null)
 ├── cardinality: [3 - 6]
 ├── prune: (1,2,4)
 ├── reject-nulls: (1,2)
 ├── limit
 │    ├── columns: u:1(int) v:2(int!null)
 │    ├── cardinality: [0 - 2]
 │    ├── prune: (1,2)
 │    ├── project
 │    │    ├── columns: u:1(int) v:2(int!null)
 │    │    ├── limit hint: 2.00
 │    │    ├── prune: (1,2)
 │    │    └── scan uv
 │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null)
 │    │         ├── key: (3)
 │    │         ├── fd: (3)-->(1,2)
 │    │         ├── limit hint: 2.00
 │    │         ├── prune: (1-3)
 │    │         └── interesting orderings: (+3)
 │    └── const: 2 [type=int]
 ├── values
 │    ├── columns: column1:4(int!null)
 │    ├── cardinality: [3 - 3]
 │    ├── prune: (4)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 2 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 3 [type=int]
 └── filters
      └── true [type=bool]

# Calculate full-join cardinality.
build
SELECT * FROM (VALUES (NULL), (NULL)) a FULL JOIN (VALUES (NULL), (NULL)) b ON True
----
full-join (cross)
 ├── columns: column1:1(unknown) column1:2(unknown)
 ├── cardinality: [2 - 4]
 ├── prune: (1,2)
 ├── reject-nulls: (1,2)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── columns: column1:2(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (2)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 └── filters
      └── true [type=bool]

# Calculate full-join cardinality when both sides have an empty key (#44029).
build
SELECT * FROM (VALUES (1, 2)) a(a1,a2) FULL JOIN (VALUES (3, 4)) b(b1,b2) ON a1=b1
----
full-join (hash)
 ├── columns: a1:1(int) a2:2(int) b1:3(int) b2:4(int)
 ├── cardinality: [1 - 2]
 ├── prune: (2,4)
 ├── reject-nulls: (1-4)
 ├── values
 │    ├── columns: column1:1(int!null) column2:2(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1,2)
 │    ├── prune: (1,2)
 │    └── tuple [type=tuple{int, int}]
 │         ├── const: 1 [type=int]
 │         └── const: 2 [type=int]
 ├── values
 │    ├── columns: column1:3(int!null) column2:4(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,4)
 │    ├── prune: (3,4)
 │    └── tuple [type=tuple{int, int}]
 │         ├── const: 3 [type=int]
 │         └── const: 4 [type=int]
 └── filters
      └── eq [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
           ├── variable: column1:1 [type=int]
           └── variable: column1:3 [type=int]

# Calculate full-join cardinality with false filter.
build
SELECT * FROM (VALUES (NULL), (NULL)) a FULL JOIN (VALUES (NULL), (NULL)) b ON a.column1=b.column1
----
full-join (cross)
 ├── columns: column1:1(unknown) column1:2(unknown)
 ├── cardinality: [2 - 4]
 ├── prune: (1,2)
 ├── reject-nulls: (1,2)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (1)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── columns: column1:2(unknown)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (2)
 │    ├── tuple [type=tuple{unknown}]
 │    │    └── null [type=unknown]
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 └── filters
      └── cast: BOOL [type=bool]
           └── null [type=unknown]

# Calculate full-join cardinality of one input with unknown cardinality.
build
SELECT * FROM xysd FULL JOIN (SELECT * FROM (VALUES (1), (2))) ON True
----
full-join (cross)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) column1:5(int)
 ├── cardinality: [2 - ]
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 ├── prune: (1-5)
 ├── reject-nulls: (1-5)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── values
 │    ├── columns: column1:5(int!null)
 │    ├── cardinality: [2 - 2]
 │    ├── prune: (5)
 │    ├── tuple [type=tuple{int}]
 │    │    └── const: 1 [type=int]
 │    └── tuple [type=tuple{int}]
 │         └── const: 2 [type=int]
 └── filters
      └── true [type=bool]

# Keys on both sides of full-join.
build
SELECT * FROM (SELECT * FROM xysd LIMIT 1) FULL JOIN (SELECT * FROM xysd LIMIT 1) ON True
----
full-join (cross)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) x:5(int) y:6(int) s:7(string) d:8(decimal)
 ├── cardinality: [0 - 2]
 ├── prune: (1-8)
 ├── reject-nulls: (1-8)
 ├── interesting orderings: (+1) (-3,+4,+1) (+5) (-7,+8,+5)
 ├── limit
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-4)
 │    ├── prune: (1-4)
 │    ├── interesting orderings: (+1) (-3,+4,+1)
 │    ├── scan xysd
 │    │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    │    ├── limit hint: 1.00
 │    │    ├── prune: (1-4)
 │    │    └── interesting orderings: (+1) (-3,+4,+1)
 │    └── const: 1 [type=int]
 ├── limit
 │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(5-8)
 │    ├── prune: (5-8)
 │    ├── interesting orderings: (+5) (-7,+8,+5)
 │    ├── scan xysd
 │    │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    │    ├── key: (5)
 │    │    ├── fd: (5)-->(6-8), (7,8)~~>(5,6)
 │    │    ├── limit hint: 1.00
 │    │    ├── prune: (5-8)
 │    │    └── interesting orderings: (+5) (-7,+8,+5)
 │    └── const: 1 [type=int]
 └── filters
      └── true [type=bool]

# Nullable FD determinant on right side of left-join becomes lax.
build
SELECT * FROM xysd LEFT JOIN (SELECT u, sum(v) FROM uv GROUP BY u) ON u IS NOT NULL
----
left-join (cross)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) sum:8(decimal)
 ├── key: (1,5)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (5)~~>(8), (1,5)-->(8)
 ├── prune: (1-4,8)
 ├── reject-nulls: (5,8)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── group-by
 │    ├── columns: u:5(int) sum:8(decimal!null)
 │    ├── grouping columns: u:5(int)
 │    ├── key: (5)
 │    ├── fd: (5)-->(8)
 │    ├── prune: (8)
 │    ├── project
 │    │    ├── columns: u:5(int) v:6(int!null)
 │    │    ├── prune: (5,6)
 │    │    └── scan uv
 │    │         ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    │         ├── key: (7)
 │    │         ├── fd: (7)-->(5,6)
 │    │         ├── prune: (5-7)
 │    │         └── interesting orderings: (+7)
 │    └── aggregations
 │         └── sum [as=sum:8, type=decimal, outer=(6)]
 │              └── variable: v:6 [type=int]
 └── filters
      └── is-not [type=bool, outer=(5), constraints=(/5: (/NULL - ]; tight)]
           ├── variable: u:5 [type=int]
           └── null [type=unknown]

# Not-null FD determinant on right side of left-join stays strict.
build
SELECT * FROM xysd LEFT JOIN (SELECT u, sum(v) FROM uv WHERE u IS NOT NULL GROUP BY u) ON True
----
left-join (cross)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) sum:8(decimal)
 ├── key: (1,5)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (5)-->(8)
 ├── prune: (1-4,8)
 ├── reject-nulls: (5,8)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── group-by
 │    ├── columns: u:5(int!null) sum:8(decimal!null)
 │    ├── grouping columns: u:5(int!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(8)
 │    ├── prune: (8)
 │    ├── project
 │    │    ├── columns: u:5(int!null) v:6(int!null)
 │    │    ├── prune: (5,6)
 │    │    └── select
 │    │         ├── columns: u:5(int!null) v:6(int!null) rowid:7(int!null)
 │    │         ├── key: (7)
 │    │         ├── fd: (7)-->(5,6)
 │    │         ├── prune: (6,7)
 │    │         ├── interesting orderings: (+7)
 │    │         ├── scan uv
 │    │         │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    │         │    ├── key: (7)
 │    │         │    ├── fd: (7)-->(5,6)
 │    │         │    ├── prune: (5-7)
 │    │         │    └── interesting orderings: (+7)
 │    │         └── filters
 │    │              └── is-not [type=bool, outer=(5), constraints=(/5: (/NULL - ]; tight)]
 │    │                   ├── variable: u:5 [type=int]
 │    │                   └── null [type=unknown]
 │    └── aggregations
 │         └── sum [as=sum:8, type=decimal, outer=(6)]
 │              └── variable: v:6 [type=int]
 └── filters
      └── true [type=bool]

# Nullable FD determinant on left side of right-join becomes lax.
build
SELECT * FROM (SELECT u, sum(v) FROM uv GROUP BY u) RIGHT JOIN xysd ON u IS NOT NULL
----
right-join (cross)
 ├── columns: u:1(int) sum:4(decimal) x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 ├── key: (1,5)
 ├── fd: (5)-->(6-8), (7,8)~~>(5,6), (1)~~>(4), (1,5)-->(4)
 ├── prune: (4-8)
 ├── reject-nulls: (1,4)
 ├── interesting orderings: (+5) (-7,+8,+5)
 ├── group-by
 │    ├── columns: u:1(int) sum:4(decimal!null)
 │    ├── grouping columns: u:1(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── prune: (4)
 │    ├── project
 │    │    ├── columns: u:1(int) v:2(int!null)
 │    │    ├── prune: (1,2)
 │    │    └── scan uv
 │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null)
 │    │         ├── key: (3)
 │    │         ├── fd: (3)-->(1,2)
 │    │         ├── prune: (1-3)
 │    │         └── interesting orderings: (+3)
 │    └── aggregations
 │         └── sum [as=sum:4, type=decimal, outer=(2)]
 │              └── variable: v:2 [type=int]
 ├── scan xysd
 │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6-8), (7,8)~~>(5,6)
 │    ├── prune: (5-8)
 │    └── interesting orderings: (+5) (-7,+8,+5)
 └── filters
      └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
           ├── variable: u:1 [type=int]
           └── null [type=unknown]

# Not-null FD determinant on left side of right-join stays strict.
build
SELECT * FROM (SELECT u, sum(v) FROM uv WHERE u IS NOT NULL GROUP BY u) RIGHT JOIN xysd ON True
----
right-join (cross)
 ├── columns: u:1(int) sum:4(decimal) x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 ├── key: (1,5)
 ├── fd: (1)-->(4), (5)-->(6-8), (7,8)~~>(5,6)
 ├── prune: (4-8)
 ├── reject-nulls: (1,4)
 ├── interesting orderings: (+5) (-7,+8,+5)
 ├── group-by
 │    ├── columns: u:1(int!null) sum:4(decimal!null)
 │    ├── grouping columns: u:1(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── prune: (4)
 │    ├── project
 │    │    ├── columns: u:1(int!null) v:2(int!null)
 │    │    ├── prune: (1,2)
 │    │    └── select
 │    │         ├── columns: u:1(int!null) v:2(int!null) rowid:3(int!null)
 │    │         ├── key: (3)
 │    │         ├── fd: (3)-->(1,2)
 │    │         ├── prune: (2,3)
 │    │         ├── interesting orderings: (+3)
 │    │         ├── scan uv
 │    │         │    ├── columns: u:1(int) v:2(int!null) rowid:3(int!null)
 │    │         │    ├── key: (3)
 │    │         │    ├── fd: (3)-->(1,2)
 │    │         │    ├── prune: (1-3)
 │    │         │    └── interesting orderings: (+3)
 │    │         └── filters
 │    │              └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
 │    │                   ├── variable: u:1 [type=int]
 │    │                   └── null [type=unknown]
 │    └── aggregations
 │         └── sum [as=sum:4, type=decimal, outer=(2)]
 │              └── variable: v:2 [type=int]
 ├── scan xysd
 │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6-8), (7,8)~~>(5,6)
 │    ├── prune: (5-8)
 │    └── interesting orderings: (+5) (-7,+8,+5)
 └── filters
      └── true [type=bool]

# Nullable FD determinant on right side of full-join becomes lax.
build
SELECT * FROM xysd FULL JOIN (SELECT u, sum(v) FROM uv GROUP BY u) ON u IS NOT NULL
----
full-join (cross)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:5(int) sum:8(decimal)
 ├── key: (1,5)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (5)~~>(8), (1,5)-->(8)
 ├── prune: (1-4,8)
 ├── reject-nulls: (1-5,8)
 ├── interesting orderings: (+1) (-3,+4,+1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── group-by
 │    ├── columns: u:5(int) sum:8(decimal!null)
 │    ├── grouping columns: u:5(int)
 │    ├── key: (5)
 │    ├── fd: (5)-->(8)
 │    ├── prune: (8)
 │    ├── project
 │    │    ├── columns: u:5(int) v:6(int!null)
 │    │    ├── prune: (5,6)
 │    │    └── scan uv
 │    │         ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    │         ├── key: (7)
 │    │         ├── fd: (7)-->(5,6)
 │    │         ├── prune: (5-7)
 │    │         └── interesting orderings: (+7)
 │    └── aggregations
 │         └── sum [as=sum:8, type=decimal, outer=(6)]
 │              └── variable: v:6 [type=int]
 └── filters
      └── is-not [type=bool, outer=(5), constraints=(/5: (/NULL - ]; tight)]
           ├── variable: u:5 [type=int]
           └── null [type=unknown]

# Nullable FD determinant on left side of full-join becomes lax.
build
SELECT * FROM (SELECT u, sum(v) FROM uv GROUP BY u) FULL JOIN xysd ON u IS NOT NULL
----
full-join (cross)
 ├── columns: u:1(int) sum:4(decimal) x:5(int) y:6(int) s:7(string) d:8(decimal)
 ├── key: (1,5)
 ├── fd: (5)-->(6-8), (7,8)~~>(5,6), (1)~~>(4), (1,5)-->(4)
 ├── prune: (4-8)
 ├── reject-nulls: (1,4-8)
 ├── interesting orderings: (+5) (-7,+8,+5)
 ├── group-by
 │    ├── columns: u:1(int) sum:4(decimal!null)
 │    ├── grouping columns: u:1(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── prune: (4)
 │    ├── project
 │    │    ├── columns: u:1(int) v:2(int!null)
 │    │    ├── prune: (1,2)
 │    │    └── scan uv
 │    │         ├── columns: u:1(int) v:2(int!null) rowid:3(int!null)
 │    │         ├── key: (3)
 │    │         ├── fd: (3)-->(1,2)
 │    │         ├── prune: (1-3)
 │    │         └── interesting orderings: (+3)
 │    └── aggregations
 │         └── sum [as=sum:4, type=decimal, outer=(2)]
 │              └── variable: v:2 [type=int]
 ├── scan xysd
 │    ├── columns: x:5(int!null) y:6(int) s:7(string) d:8(decimal!null)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6-8), (7,8)~~>(5,6)
 │    ├── prune: (5-8)
 │    └── interesting orderings: (+5) (-7,+8,+5)
 └── filters
      └── is-not [type=bool, outer=(1), constraints=(/1: (/NULL - ]; tight)]
           ├── variable: u:1 [type=int]
           └── null [type=unknown]

# Merge join (inner).
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ ]
    [
        (JoinType "inner-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
inner-join (merge)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int!null) v:6(int!null) rowid:7(int!null)
 ├── left ordering: +1
 ├── right ordering: +5
 ├── key: (7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6), (1)==(5), (5)==(1)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── ordering: +5
 │    └── scan uv
 │         ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │         ├── key: (7)
 │         └── fd: (7)-->(5,6)
 └── filters (true)

# Merge join (left).
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ ]
    [
        (JoinType "left-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
left-join (merge)
 ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null) u:5(int) v:6(int) rowid:7(int)
 ├── left ordering: +1
 ├── right ordering: +5
 ├── key: (1,7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(5,6)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── ordering: +5
 │    └── scan uv
 │         ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │         ├── key: (7)
 │         └── fd: (7)-->(5,6)
 └── filters (true)

# Merge join (right) with remaining ON condition.
expr
(MergeJoin
    (Scan [ (Table "xysd") (Cols "x,y,s,d") ])
    (Sort (Scan [ (Table "uv") (Cols "u,v,rowid") ]))
    [ (Gt (Var "y") (Var "v")) ]
    [
        (JoinType "right-join")
        (LeftEq "+x")
        (RightEq "+u")
        (LeftOrdering "+x")
        (RightOrdering "+u")
    ]
)
----
right-join (merge)
 ├── columns: x:1(int) y:2(int) s:3(string) d:4(decimal) u:5(int) v:6(int!null) rowid:7(int!null)
 ├── left ordering: +1
 ├── right ordering: +5
 ├── key: (7)
 ├── fd: (1)-->(2-4), (3,4)~~>(1,2), (7)-->(1-6)
 ├── scan xysd
 │    ├── columns: x:1(int!null) y:2(int) s:3(string) d:4(decimal!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3,4)~~>(1,2)
 │    ├── ordering: +1
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1) (-3,+4,+1)
 ├── sort
 │    ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │    ├── key: (7)
 │    ├── fd: (7)-->(5,6)
 │    ├── ordering: +5
 │    └── scan uv
 │         ├── columns: u:5(int) v:6(int!null) rowid:7(int!null)
 │         ├── key: (7)
 │         └── fd: (7)-->(5,6)
 └── filters
      └── gt [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
           ├── variable: y:2 [type=int]
           └── variable: v:6 [type=int]

# Regression test #36183.
opt
SELECT (SELECT m FROM
  (SELECT * FROM (SELECT * FROM [INSERT INTO uv VALUES (1, 2) RETURNING *] WHERE false) JOIN (SELECT * FROM uv WHERE false) ON true)
  JOIN (SELECT * FROM mn WHERE uv.u IN (SELECT n FROM mn)) ON true
) FROM uv
----
with &1
 ├── columns: m:19(int)
 ├── side-effects, mutations
 ├── fd: ()-->(19)
 ├── prune: (19)
 ├── project
 │    ├── columns: uv.u:4(int!null) uv.v:5(int!null)
 │    ├── cardinality: [1 - 1]
 │    ├── side-effects, mutations
 │    ├── key: ()
 │    ├── fd: ()-->(4,5)
 │    ├── prune: (4,5)
 │    └── insert uv
 │         ├── columns: uv.u:4(int!null) uv.v:5(int!null) rowid:6(int!null)
 │         ├── insert-mapping:
 │         │    ├── column1:7 => uv.u:4
 │         │    ├── column2:8 => uv.v:5
 │         │    └── column9:9 => rowid:6
 │         ├── cardinality: [1 - 1]
 │         ├── side-effects, mutations
 │         ├── key: ()
 │         ├── fd: ()-->(4-6)
 │         └── values
 │              ├── columns: column1:7(int!null) column2:8(int!null) column9:9(int)
 │              ├── cardinality: [1 - 1]
 │              ├── side-effects
 │              ├── key: ()
 │              ├── fd: ()-->(7-9)
 │              ├── prune: (7-9)
 │              └── tuple [type=tuple{int, int, int}]
 │                   ├── const: 1 [type=int]
 │                   ├── const: 2 [type=int]
 │                   └── function: unique_rowid [type=int]
 └── project
      ├── columns: m:19(int)
      ├── fd: ()-->(19)
      ├── prune: (19)
      ├── scan uv
      └── projections
           └── subquery [as=m:19, type=int, subquery]
                └── values
                     ├── columns: mn.m:15(int!null)
                     ├── cardinality: [0 - 0]
                     ├── key: ()
                     ├── fd: ()-->(15)
                     └── prune: (15)

# Regression test #40456.
opt
SELECT NULL
FROM uv
WHERE NOT EXISTS(SELECT uv.u);
----
values
 ├── columns: "?column?":5(unknown!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 ├── fd: ()-->(5)
 └── prune: (5)

# Regression test #43651: outer join with empty key.
opt
SELECT a FROM
    (VALUES (NULL)) AS t1(a)
  FULL JOIN
    (VALUES ('23:59:59.999999':::TIME)) AS t2(b)
  ON false
----
full-join (cross)
 ├── columns: a:1(unknown)
 ├── cardinality: [2 - 2]
 ├── prune: (1)
 ├── reject-nulls: (1)
 ├── values
 │    ├── columns: column1:1(unknown)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1)
 │    ├── prune: (1)
 │    └── tuple [type=tuple{unknown}]
 │         └── null [type=unknown]
 ├── values
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    └── tuple [type=tuple]
 └── filters
      └── false [type=bool]

exec-ddl
CREATE TABLE t1 (x INT, y INT)
----

exec-ddl
CREATE TABLE t2 (x INT, y INT)
----

# Outer join when both sides have a key. Because x can still have NULL values,
# we cannot say that the outer join has a strict key. For example, this is a
# possible valid result for this query:
#   t1.x | t1.y | t2.x | t2.y
#   -----+------+------+------
#      1 |    1 |    1 |    2
#   NULL |    1 | NULL | NULL
#   NULL | NULL | NULL |    2
# Here (t1.x, t2.x) is a lax key but not a strict key.
opt
SELECT * FROM
  (SELECT * FROM (SELECT DISTINCT ON (x) x, y FROM t1) WHERE y IS NOT NULL) AS t1
FULL JOIN
  (SELECT * FROM (SELECT DISTINCT ON (x) x, y FROM t2) WHERE y IS NOT NULL) AS t2
ON t1.x = t2.x
----
full-join (hash)
 ├── columns: x:1(int) y:2(int) x:4(int) y:5(int)
 ├── lax-key: (1,4)
 ├── fd: (1)~~>(2), (4)~~>(5), (1,4)~~>(2,5)
 ├── reject-nulls: (1,2,4,5)
 ├── select
 │    ├── columns: t1.x:1(int) t1.y:2(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── distinct-on
 │    │    ├── columns: t1.x:1(int) t1.y:2(int)
 │    │    ├── grouping columns: t1.x:1(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── prune: (2)
 │    │    ├── scan t1
 │    │    │    ├── columns: t1.x:1(int) t1.y:2(int)
 │    │    │    └── prune: (1,2)
 │    │    └── aggregations
 │    │         └── first-agg [as=t1.y:2, type=int, outer=(2)]
 │    │              └── variable: t1.y:2 [type=int]
 │    └── filters
 │         └── is-not [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │              ├── variable: t1.y:2 [type=int]
 │              └── null [type=unknown]
 ├── select
 │    ├── columns: t2.x:4(int) t2.y:5(int!null)
 │    ├── key: (4)
 │    ├── fd: (4)-->(5)
 │    ├── distinct-on
 │    │    ├── columns: t2.x:4(int) t2.y:5(int)
 │    │    ├── grouping columns: t2.x:4(int)
 │    │    ├── key: (4)
 │    │    ├── fd: (4)-->(5)
 │    │    ├── prune: (5)
 │    │    ├── scan t2
 │    │    │    ├── columns: t2.x:4(int) t2.y:5(int)
 │    │    │    └── prune: (4,5)
 │    │    └── aggregations
 │    │         └── first-agg [as=t2.y:5, type=int, outer=(5)]
 │    │              └── variable: t2.y:5 [type=int]
 │    └── filters
 │         └── is-not [type=bool, outer=(5), constraints=(/5: (/NULL - ]; tight)]
 │              ├── variable: t2.y:5 [type=int]
 │              └── null [type=unknown]
 └── filters
      └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
           ├── variable: t1.x:1 [type=int]
           └── variable: t2.x:4 [type=int]
