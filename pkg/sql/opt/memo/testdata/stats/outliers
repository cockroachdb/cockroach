exec-ddl
CREATE TABLE t (
  k INT PRIMARY KEY,
  a STRING,
  b STRING,
  c STRING,
  d STRING,
  UNIQUE INDEX (a, b),
  INDEX (a, c)
)
----

exec-ddl
ALTER TABLE t INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000,
    "distinct_count": 40,
    "avg_size": 10,
    "histo_col_type": "string",
    "histo_buckets": [
      {"num_eq": 0, "num_range": 0, "distinct_range": 0, "upper_bound": "apple"},
      {"num_eq": 100, "num_range": 100, "distinct_range": 9, "upper_bound": "banana"},
      {"num_eq": 100, "num_range": 100, "distinct_range": 9, "upper_bound": "cherry"},
      {"num_eq": 200, "num_range": 100, "distinct_range": 9, "upper_bound": "mango"},
      {"num_eq": 200, "num_range": 100, "distinct_range": 9, "upper_bound": "pineapple"}
    ]
  },
  {
    "columns": ["b"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000,
    "distinct_count": 40,
    "avg_size": 10,
    "histo_col_type": "string",
    "histo_buckets": [
      {"num_eq": 0, "num_range": 0, "distinct_range": 0, "upper_bound": "apple"},
      {"num_eq": 100, "num_range": 100, "distinct_range": 9, "upper_bound": "banana"},
      {"num_eq": 100, "num_range": 100, "distinct_range": 9, "upper_bound": "cherry"},
      {"num_eq": 200, "num_range": 100, "distinct_range": 9, "upper_bound": "mango"},
      {"num_eq": 200, "num_range": 100, "distinct_range": 9, "upper_bound": "pineapple"}
    ]
  },
  {
    "columns": ["d"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000,
    "distinct_count": 40,
    "avg_size": 1000,
    "histo_col_type": "string"
  }
]'
----

# Because 'yuzu' is greater than the max value in the histogram, and the
# avg_size of d is large, we would pick the suboptimal plan below.
#
# select
#  ├── columns: k:1 a:2 b:3 c:4 d:5
#  ├── stats: [rows=0.9625]
#  ├── cost: 18.0600024
#  ├── index-join t
#  │    ├── columns: k:1 a:2 b:3 c:4 d:5
#  │    ├── stats: [rows=2e-07]
#  │    ├── cost: 18.0400024
#  │    └── scan t@t_a_c_idx
#  │         ├── columns: k:1 a:2 c:4
#  │         ├── constraint: /2/4/1: [/'yuzu' - /'yuzu']
#  │         ├── stats: [rows=2e-07]
#  │         └── cost: 18.0200002
#  └── filters
#       └── b:3 = 'banana'
#
# By synthesizing a bucket that contains all values greater than 'pineapple', we
# pick the optimal plan.
opt
SELECT * FROM t WHERE a = 'yuzu' AND b = 'banana'
----
index-join t
 ├── columns: k:1(int!null) a:2(string!null) b:3(string!null) c:4(string) d:5(string)
 ├── cardinality: [0 - 1]
 ├── stats: [rows=0.9625, distinct(2)=0.9625, null(2)=0, distinct(3)=0.9625, null(3)=0, distinct(2,3)=0.9625, null(2,3)=0]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── scan t@t_a_b_key
      ├── columns: k:1(int!null) a:2(string!null) b:3(string!null)
      ├── constraint: /2/3: [/'yuzu'/'banana' - /'yuzu'/'banana']
      ├── cardinality: [0 - 1]
      ├── stats: [rows=0.9625, distinct(2)=0.9625, null(2)=0, distinct(3)=0.9625, null(3)=0, distinct(2,3)=0.9625, null(2,3)=0]
      ├── key: ()
      └── fd: ()-->(1-3)

# Because 'aardvark' is less than the max value in the histogram, and the
# avg_size of d is large, we would pick the suboptimal plan below.
#
# select
#  ├── columns: k:1 a:2 b:3 c:4 d:5
#  ├── stats: [rows=0.9625]
#  ├── cost: 18.0600024
#  ├── index-join t
#  │    ├── columns: k:1 a:2 b:3 c:4(string) d:5(string)
#  │    ├── stats: [rows=2e-07]
#  │    ├── cost: 18.0400024
#  │    └── scan t@t_a_c_idx
#  │         ├── columns: k:1 a:2 c:4
#  │         ├── constraint: /2/4/1: [/'aardvark' - /'aardvark']
#  │         ├── stats: [rows=2e-07]
#  │         └── cost: 18.0200002
#  └── filters
#       └── b:3 = 'banana'
#
# By adding to the num_range and distinct_range of the minimum bucket, we pick
# the optimal plan.
opt
SELECT * FROM t WHERE a = 'aardvark' AND b = 'banana'
----
index-join t
 ├── columns: k:1(int!null) a:2(string!null) b:3(string!null) c:4(string) d:5(string)
 ├── cardinality: [0 - 1]
 ├── stats: [rows=0.9625, distinct(2)=0.9625, null(2)=0, distinct(3)=0.9625, null(3)=0, distinct(2,3)=0.9625, null(2,3)=0]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── scan t@t_a_b_key
      ├── columns: k:1(int!null) a:2(string!null) b:3(string!null)
      ├── constraint: /2/3: [/'aardvark'/'banana' - /'aardvark'/'banana']
      ├── cardinality: [0 - 1]
      ├── stats: [rows=0.9625, distinct(2)=0.9625, null(2)=0, distinct(3)=0.9625, null(3)=0, distinct(2,3)=0.9625, null(2,3)=0]
      ├── key: ()
      └── fd: ()-->(1-3)
