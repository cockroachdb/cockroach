exec-ddl
CREATE TABLE a (x INT PRIMARY KEY, y INT)
----
TABLE a
 ├── x int not null
 ├── y int
 └── INDEX primary
      └── x int not null

exec-ddl
CREATE TABLE b (x STRING PRIMARY KEY, z DECIMAL NOT NULL)
----
TABLE b
 ├── x string not null
 ├── z decimal not null
 └── INDEX primary
      └── x string not null

build
SELECT y, b.x, y+1
FROM a, b
WHERE a.y=1 AND a.x::string=b.x
ORDER BY y
LIMIT 10
----
limit
 ├── columns: y:2(int) x:3(string!null) column5:5(int)
 ├── stats: [rows=10]
 ├── cost: 127000.00
 ├── ordering: +2
 ├── sort
 │    ├── columns: a.y:2(int) b.x:3(string!null) column5:5(int)
 │    ├── stats: [rows=100000]
 │    ├── cost: 127000.00
 │    ├── ordering: +2
 │    └── project
 │         ├── columns: a.y:2(int) b.x:3(string!null) column5:5(int)
 │         ├── stats: [rows=100000]
 │         ├── cost: 102000.00
 │         ├── select
 │         │    ├── columns: a.x:1(int!null) a.y:2(int) b.x:3(string!null) b.z:4(decimal!null)
 │         │    ├── stats: [rows=100000]
 │         │    ├── cost: 102000.00
 │         │    ├── inner-join
 │         │    │    ├── columns: a.x:1(int!null) a.y:2(int) b.x:3(string!null) b.z:4(decimal!null)
 │         │    │    ├── stats: [rows=1000000]
 │         │    │    ├── cost: 2000.00
 │         │    │    ├── scan a
 │         │    │    │    ├── columns: a.x:1(int!null) a.y:2(int)
 │         │    │    │    ├── stats: [rows=1000]
 │         │    │    │    └── cost: 1000.00
 │         │    │    ├── scan b
 │         │    │    │    ├── columns: b.x:3(string!null) b.z:4(decimal!null)
 │         │    │    │    ├── stats: [rows=1000]
 │         │    │    │    └── cost: 1000.00
 │         │    │    └── true [type=bool]
 │         │    └── and [type=bool, outer=(1-3), constraints=(/2: [/1 - /1])]
 │         │         ├── eq [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]
 │         │         │    ├── variable: a.y [type=int, outer=(2)]
 │         │         │    └── const: 1 [type=int]
 │         │         └── eq [type=bool, outer=(1,3)]
 │         │              ├── cast: string [type=string, outer=(1)]
 │         │              │    └── variable: a.x [type=int, outer=(1)]
 │         │              └── variable: b.x [type=string, outer=(3)]
 │         └── projections [outer=(2,3)]
 │              ├── variable: a.y [type=int, outer=(2)]
 │              ├── variable: b.x [type=string, outer=(3)]
 │              └── plus [type=int, outer=(2)]
 │                   ├── variable: a.y [type=int, outer=(2)]
 │                   └── const: 1 [type=int]
 └── const: 10 [type=int]

opt
SELECT y, b.x, y+1
FROM a, b
WHERE a.y=1 AND a.x::string=b.x
ORDER BY y
LIMIT 10
----
project
 ├── columns: y:2(int) x:3(string!null) column5:5(int)
 ├── stats: [rows=10]
 ├── cost: 4600.00
 ├── ordering: +2
 ├── limit
 │    ├── columns: a.y:2(int) b.x:3(string!null)
 │    ├── stats: [rows=10]
 │    ├── cost: 4600.00
 │    ├── ordering: +2
 │    ├── sort
 │    │    ├── columns: a.y:2(int) b.x:3(string!null)
 │    │    ├── stats: [rows=10000]
 │    │    ├── cost: 4600.00
 │    │    ├── ordering: +2
 │    │    └── project
 │    │         ├── columns: a.y:2(int) b.x:3(string!null)
 │    │         ├── stats: [rows=10000]
 │    │         ├── cost: 2100.00
 │    │         ├── inner-join
 │    │         │    ├── columns: a.x:1(int!null) a.y:2(int) b.x:3(string!null)
 │    │         │    ├── stats: [rows=10000]
 │    │         │    ├── cost: 2100.00
 │    │         │    ├── select
 │    │         │    │    ├── columns: a.x:1(int!null) a.y:2(int)
 │    │         │    │    ├── stats: [rows=100]
 │    │         │    │    ├── cost: 1100.00
 │    │         │    │    ├── scan a
 │    │         │    │    │    ├── columns: a.x:1(int!null) a.y:2(int)
 │    │         │    │    │    ├── stats: [rows=1000]
 │    │         │    │    │    └── cost: 1000.00
 │    │         │    │    └── filters [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]
 │    │         │    │         └── eq [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]
 │    │         │    │              ├── variable: a.y [type=int, outer=(2)]
 │    │         │    │              └── const: 1 [type=int]
 │    │         │    ├── scan b
 │    │         │    │    ├── columns: b.x:3(string!null)
 │    │         │    │    ├── stats: [rows=1000]
 │    │         │    │    └── cost: 1000.00
 │    │         │    └── filters [type=bool, outer=(1,3)]
 │    │         │         └── eq [type=bool, outer=(1,3)]
 │    │         │              ├── variable: b.x [type=string, outer=(3)]
 │    │         │              └── cast: string [type=string, outer=(1)]
 │    │         │                   └── variable: a.x [type=int, outer=(1)]
 │    │         └── projections [outer=(2,3)]
 │    │              ├── variable: a.y [type=int, outer=(2)]
 │    │              └── variable: b.x [type=string, outer=(3)]
 │    └── const: 10 [type=int]
 └── projections [outer=(2,3)]
      ├── variable: a.y [type=int, outer=(2)]
      ├── variable: b.x [type=string, outer=(3)]
      └── plus [type=int, outer=(2)]
           ├── variable: a.y [type=int, outer=(2)]
           └── const: 1 [type=int]

memo
SELECT y, b.x, y+1
FROM a, b
WHERE a.y=1 AND a.x::string=b.x
ORDER BY y
LIMIT 10
----
[29: "physical: [presentation: y:2,x:3,column5:5] [ordering: +2]"]
memo
 ├── G29: (project G28 G20)
 │    ├── "" [cost=4600.00]
 │    │    └── best: (project G28 G20)
 │    └── "physical: [presentation: y:2,x:3,column5:5] [ordering: +2]" [cost=4600.00]
 │         └── best: (project G28="o:+2" G20)
 ├── G28: (limit G27 G24 +2)
 │    ├── "" [cost=4600.00]
 │    │    └── best: (limit G27="o:+2" G24 +2)
 │    └── "physical: [ordering: +2]" [cost=4600.00]
 │         └── best: (limit G27="o:+2" G24 +2)
 ├── G27: (project G22 G26)
 │    ├── "" [cost=2100.00]
 │    │    └── best: (project G22 G26)
 │    └── "physical: [ordering: +2]" [cost=4600.00]
 │         └── best: (sort G27)
 ├── G22: (inner-join G15 G21 G17)
 │    ├── "" [cost=2100.00]
 │    │    └── best: (inner-join G15 G21 G17)
 │    └── "physical: [ordering: +2]" [cost=4600.00]
 │         └── best: (sort G22)
 ├── G15: (select G1 G14)
 │    └── "" [cost=1100.00]
 │         └── best: (select G1 G14)
 ├── G1: (scan a)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G14: (filters G7)
 ├── G7: (eq G5 G6)
 ├── G21: (scan b)
 │    └── "" [cost=1000.00]
 │         └── best: (scan b)
 ├── G17: (filters G11)
 ├── G11: (eq G10 G9)
 ├── G9: (cast G8 string)
 ├── G8: (variable a.x)
 ├── G26: (projections G5 G10)
 ├── G24: (const 10)
 ├── G20: (projections G5 G10 G19)
 ├── G10: (variable b.x)
 ├── G19: (plus G5 G6)
 ├── G5: (variable a.y)
 └── G6: (const 1)

# Test interning of expressions.
memo
SELECT 1, 1+z, now()::timestamp, now()::timestamptz
FROM b
WHERE z=1 AND concat(x, 'foo', x)=concat(x, 'foo', x)
----
[17: "physical: [presentation: column3:3,column4:4,column5:5,column6:6]"]
memo
 ├── G17: (project G11 G16)
 │    └── "physical: [presentation: column3:3,column4:4,column5:5,column6:6]" [cost=1100.00]
 │         └── best: (project G11 G16)
 ├── G11: (select G1 G10)
 │    └── "" [cost=1100.00]
 │         └── best: (select G1 G10)
 ├── G1: (scan b)
 │    └── "" [cost=1000.00]
 │         └── best: (scan b)
 ├── G10: (filters G4 G8)
 ├── G4: (eq G2 G3)
 ├── G8: (eq G7 G7)
 ├── G7: (function G5 G6 G5 concat)
 ├── G6: (const 'foo')
 ├── G5: (variable b.x)
 ├── G16: (projections G12 G13 G15 G14)
 ├── G12: (const 1)
 ├── G13: (plus G2 G3)
 ├── G2: (variable b.z)
 ├── G3: (const 1)
 ├── G15: (cast G14 timestamp)
 └── G14: (function now)

# Test topological sorting
memo
SELECT x FROM a WHERE x = 1 AND x+y = 1
----
[12: "physical: [presentation: x:1]"]
memo
 ├── G12: (project G10 G11)
 │    └── "physical: [presentation: x:1]" [cost=110.00]
 │         └── best: (project G10 G11)
 ├── G10: (select G1 G9) (select G15 G14)
 │    └── "" [cost=110.00]
 │         └── best: (select G15 G14)
 ├── G15: (scan a,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a,constrained)
 ├── G14: (filters G7)
 ├── G1: (scan a)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G9: (filters G4 G7)
 ├── G4: (eq G2 G3)
 ├── G7: (eq G6 G3)
 ├── G6: (plus G2 G5)
 ├── G5: (variable a.y)
 ├── G3: (const 1)
 ├── G11: (projections G2)
 └── G2: (variable a.x)
