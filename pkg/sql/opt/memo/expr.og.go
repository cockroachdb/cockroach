// Code generated by optgen; DO NOT EDIT.

package memo

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

var opLayoutTable = [...]opLayout{
	opt.UnknownOp:         0xFF, // will cause a crash if used
	opt.SortOp:            makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ScanOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
	opt.ValuesOp:          makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/),
	opt.SelectOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ProjectOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.InnerJoinOp:       makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LeftJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.RightJoinOp:       makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FullJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.SemiJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.AntiJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.InnerJoinApplyOp:  makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LeftJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.RightJoinApplyOp:  makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FullJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.SemiJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.AntiJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.GroupByOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.UnionOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.IntersectOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.ExceptOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.UnionAllOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.IntersectAllOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.ExceptAllOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.LimitOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.OffsetOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/),
	opt.Max1RowOp:         makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.SubqueryOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.AnyOp:             makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.VariableOp:        makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
	opt.ConstOp:           makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
	opt.NullOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
	opt.TrueOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FalseOp:           makeOpLayout(0 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.PlaceholderOp:     makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
	opt.TupleOp:           makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/),
	opt.ProjectionsOp:     makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/),
	opt.AggregationsOp:    makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/),
	opt.ExistsOp:          makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FiltersOp:         makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/),
	opt.AndOp:             makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/),
	opt.OrOp:              makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/),
	opt.NotOp:             makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.EqOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LtOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.GtOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.GeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.InOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotInOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LikeOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotLikeOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ILikeOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotILikeOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.SimilarToOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotSimilarToOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.RegMatchOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotRegMatchOp:     makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.RegIMatchOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.NotRegIMatchOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.IsOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.IsNotOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ContainsOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.JsonExistsOp:      makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.JsonAllExistsOp:   makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.JsonSomeExistsOp:  makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.BitandOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.BitorOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.BitxorOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.PlusOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.MinusOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.MultOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.DivOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FloorDivOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ModOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.PowOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ConcatOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.LShiftOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.RShiftOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FetchValOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FetchTextOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FetchValPathOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.FetchTextPathOp:   makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.UnaryMinusOp:      makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.UnaryComplementOp: makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.CastOp:            makeOpLayout(1 /*base*/, 0 /*list*/, 2 /*priv*/),
	opt.CaseOp:            makeOpLayout(1 /*base*/, 2 /*list*/, 0 /*priv*/),
	opt.WhenOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/),
	opt.ArrayOp:           makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/),
	opt.FunctionOp:        makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/),
	opt.CoalesceOp:        makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/),
	opt.UnsupportedExprOp: makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/),
}

var isEnforcerLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            true,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isRelationalLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            true,
	opt.ValuesOp:          true,
	opt.SelectOp:          true,
	opt.ProjectOp:         true,
	opt.InnerJoinOp:       true,
	opt.LeftJoinOp:        true,
	opt.RightJoinOp:       true,
	opt.FullJoinOp:        true,
	opt.SemiJoinOp:        true,
	opt.AntiJoinOp:        true,
	opt.InnerJoinApplyOp:  true,
	opt.LeftJoinApplyOp:   true,
	opt.RightJoinApplyOp:  true,
	opt.FullJoinApplyOp:   true,
	opt.SemiJoinApplyOp:   true,
	opt.AntiJoinApplyOp:   true,
	opt.GroupByOp:         true,
	opt.UnionOp:           true,
	opt.IntersectOp:       true,
	opt.ExceptOp:          true,
	opt.UnionAllOp:        true,
	opt.IntersectAllOp:    true,
	opt.ExceptAllOp:       true,
	opt.LimitOp:           true,
	opt.OffsetOp:          true,
	opt.Max1RowOp:         true,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isJoinLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       true,
	opt.LeftJoinOp:        true,
	opt.RightJoinOp:       true,
	opt.FullJoinOp:        true,
	opt.SemiJoinOp:        true,
	opt.AntiJoinOp:        true,
	opt.InnerJoinApplyOp:  true,
	opt.LeftJoinApplyOp:   true,
	opt.RightJoinApplyOp:  true,
	opt.FullJoinApplyOp:   true,
	opt.SemiJoinApplyOp:   true,
	opt.AntiJoinApplyOp:   true,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isJoinApplyLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  true,
	opt.LeftJoinApplyOp:   true,
	opt.RightJoinApplyOp:  true,
	opt.FullJoinApplyOp:   true,
	opt.SemiJoinApplyOp:   true,
	opt.AntiJoinApplyOp:   true,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isScalarLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        true,
	opt.AnyOp:             true,
	opt.VariableOp:        true,
	opt.ConstOp:           true,
	opt.NullOp:            true,
	opt.TrueOp:            true,
	opt.FalseOp:           true,
	opt.PlaceholderOp:     true,
	opt.TupleOp:           true,
	opt.ProjectionsOp:     true,
	opt.AggregationsOp:    true,
	opt.ExistsOp:          true,
	opt.FiltersOp:         true,
	opt.AndOp:             true,
	opt.OrOp:              true,
	opt.NotOp:             true,
	opt.EqOp:              true,
	opt.LtOp:              true,
	opt.GtOp:              true,
	opt.LeOp:              true,
	opt.GeOp:              true,
	opt.NeOp:              true,
	opt.InOp:              true,
	opt.NotInOp:           true,
	opt.LikeOp:            true,
	opt.NotLikeOp:         true,
	opt.ILikeOp:           true,
	opt.NotILikeOp:        true,
	opt.SimilarToOp:       true,
	opt.NotSimilarToOp:    true,
	opt.RegMatchOp:        true,
	opt.NotRegMatchOp:     true,
	opt.RegIMatchOp:       true,
	opt.NotRegIMatchOp:    true,
	opt.IsOp:              true,
	opt.IsNotOp:           true,
	opt.ContainsOp:        true,
	opt.JsonExistsOp:      true,
	opt.JsonAllExistsOp:   true,
	opt.JsonSomeExistsOp:  true,
	opt.BitandOp:          true,
	opt.BitorOp:           true,
	opt.BitxorOp:          true,
	opt.PlusOp:            true,
	opt.MinusOp:           true,
	opt.MultOp:            true,
	opt.DivOp:             true,
	opt.FloorDivOp:        true,
	opt.ModOp:             true,
	opt.PowOp:             true,
	opt.ConcatOp:          true,
	opt.LShiftOp:          true,
	opt.RShiftOp:          true,
	opt.FetchValOp:        true,
	opt.FetchTextOp:       true,
	opt.FetchValPathOp:    true,
	opt.FetchTextPathOp:   true,
	opt.UnaryMinusOp:      true,
	opt.UnaryComplementOp: true,
	opt.CastOp:            true,
	opt.CaseOp:            true,
	opt.WhenOp:            true,
	opt.ArrayOp:           true,
	opt.FunctionOp:        true,
	opt.CoalesceOp:        true,
	opt.UnsupportedExprOp: true,
}

var isConstValueLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           true,
	opt.NullOp:            true,
	opt.TrueOp:            true,
	opt.FalseOp:           true,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isBooleanLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            true,
	opt.FalseOp:           true,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         true,
	opt.AndOp:             true,
	opt.OrOp:              true,
	opt.NotOp:             true,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isComparisonLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              true,
	opt.LtOp:              true,
	opt.GtOp:              true,
	opt.LeOp:              true,
	opt.GeOp:              true,
	opt.NeOp:              true,
	opt.InOp:              true,
	opt.NotInOp:           true,
	opt.LikeOp:            true,
	opt.NotLikeOp:         true,
	opt.ILikeOp:           true,
	opt.NotILikeOp:        true,
	opt.SimilarToOp:       true,
	opt.NotSimilarToOp:    true,
	opt.RegMatchOp:        true,
	opt.NotRegMatchOp:     true,
	opt.RegIMatchOp:       true,
	opt.NotRegIMatchOp:    true,
	opt.IsOp:              true,
	opt.IsNotOp:           true,
	opt.ContainsOp:        true,
	opt.JsonExistsOp:      true,
	opt.JsonAllExistsOp:   true,
	opt.JsonSomeExistsOp:  true,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isBinaryLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          true,
	opt.BitorOp:           true,
	opt.BitxorOp:          true,
	opt.PlusOp:            true,
	opt.MinusOp:           true,
	opt.MultOp:            true,
	opt.DivOp:             true,
	opt.FloorDivOp:        true,
	opt.ModOp:             true,
	opt.PowOp:             true,
	opt.ConcatOp:          true,
	opt.LShiftOp:          true,
	opt.RShiftOp:          true,
	opt.FetchValOp:        true,
	opt.FetchTextOp:       true,
	opt.FetchValPathOp:    true,
	opt.FetchTextPathOp:   true,
	opt.UnaryMinusOp:      false,
	opt.UnaryComplementOp: false,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

var isUnaryLookup = [...]bool{
	opt.UnknownOp: false,

	opt.SortOp:            false,
	opt.ScanOp:            false,
	opt.ValuesOp:          false,
	opt.SelectOp:          false,
	opt.ProjectOp:         false,
	opt.InnerJoinOp:       false,
	opt.LeftJoinOp:        false,
	opt.RightJoinOp:       false,
	opt.FullJoinOp:        false,
	opt.SemiJoinOp:        false,
	opt.AntiJoinOp:        false,
	opt.InnerJoinApplyOp:  false,
	opt.LeftJoinApplyOp:   false,
	opt.RightJoinApplyOp:  false,
	opt.FullJoinApplyOp:   false,
	opt.SemiJoinApplyOp:   false,
	opt.AntiJoinApplyOp:   false,
	opt.GroupByOp:         false,
	opt.UnionOp:           false,
	opt.IntersectOp:       false,
	opt.ExceptOp:          false,
	opt.UnionAllOp:        false,
	opt.IntersectAllOp:    false,
	opt.ExceptAllOp:       false,
	opt.LimitOp:           false,
	opt.OffsetOp:          false,
	opt.Max1RowOp:         false,
	opt.SubqueryOp:        false,
	opt.AnyOp:             false,
	opt.VariableOp:        false,
	opt.ConstOp:           false,
	opt.NullOp:            false,
	opt.TrueOp:            false,
	opt.FalseOp:           false,
	opt.PlaceholderOp:     false,
	opt.TupleOp:           false,
	opt.ProjectionsOp:     false,
	opt.AggregationsOp:    false,
	opt.ExistsOp:          false,
	opt.FiltersOp:         false,
	opt.AndOp:             false,
	opt.OrOp:              false,
	opt.NotOp:             false,
	opt.EqOp:              false,
	opt.LtOp:              false,
	opt.GtOp:              false,
	opt.LeOp:              false,
	opt.GeOp:              false,
	opt.NeOp:              false,
	opt.InOp:              false,
	opt.NotInOp:           false,
	opt.LikeOp:            false,
	opt.NotLikeOp:         false,
	opt.ILikeOp:           false,
	opt.NotILikeOp:        false,
	opt.SimilarToOp:       false,
	opt.NotSimilarToOp:    false,
	opt.RegMatchOp:        false,
	opt.NotRegMatchOp:     false,
	opt.RegIMatchOp:       false,
	opt.NotRegIMatchOp:    false,
	opt.IsOp:              false,
	opt.IsNotOp:           false,
	opt.ContainsOp:        false,
	opt.JsonExistsOp:      false,
	opt.JsonAllExistsOp:   false,
	opt.JsonSomeExistsOp:  false,
	opt.BitandOp:          false,
	opt.BitorOp:           false,
	opt.BitxorOp:          false,
	opt.PlusOp:            false,
	opt.MinusOp:           false,
	opt.MultOp:            false,
	opt.DivOp:             false,
	opt.FloorDivOp:        false,
	opt.ModOp:             false,
	opt.PowOp:             false,
	opt.ConcatOp:          false,
	opt.LShiftOp:          false,
	opt.RShiftOp:          false,
	opt.FetchValOp:        false,
	opt.FetchTextOp:       false,
	opt.FetchValPathOp:    false,
	opt.FetchTextPathOp:   false,
	opt.UnaryMinusOp:      true,
	opt.UnaryComplementOp: true,
	opt.CastOp:            false,
	opt.CaseOp:            false,
	opt.WhenOp:            false,
	opt.ArrayOp:           false,
	opt.FunctionOp:        false,
	opt.CoalesceOp:        false,
	opt.UnsupportedExprOp: false,
}

func (ev ExprView) IsEnforcer() bool {
	return isEnforcerLookup[ev.op]
}

func (ev ExprView) IsRelational() bool {
	return isRelationalLookup[ev.op]
}

func (ev ExprView) IsJoin() bool {
	return isJoinLookup[ev.op]
}

func (ev ExprView) IsJoinApply() bool {
	return isJoinApplyLookup[ev.op]
}

func (ev ExprView) IsScalar() bool {
	return isScalarLookup[ev.op]
}

func (ev ExprView) IsConstValue() bool {
	return isConstValueLookup[ev.op]
}

func (ev ExprView) IsBoolean() bool {
	return isBooleanLookup[ev.op]
}

func (ev ExprView) IsComparison() bool {
	return isComparisonLookup[ev.op]
}

func (ev ExprView) IsBinary() bool {
	return isBinaryLookup[ev.op]
}

func (ev ExprView) IsUnary() bool {
	return isUnaryLookup[ev.op]
}

func (e *Expr) IsEnforcer() bool {
	return isEnforcerLookup[e.op]
}

func (e *Expr) IsRelational() bool {
	return isRelationalLookup[e.op]
}

func (e *Expr) IsJoin() bool {
	return isJoinLookup[e.op]
}

func (e *Expr) IsJoinApply() bool {
	return isJoinApplyLookup[e.op]
}

func (e *Expr) IsScalar() bool {
	return isScalarLookup[e.op]
}

func (e *Expr) IsConstValue() bool {
	return isConstValueLookup[e.op]
}

func (e *Expr) IsBoolean() bool {
	return isBooleanLookup[e.op]
}

func (e *Expr) IsComparison() bool {
	return isComparisonLookup[e.op]
}

func (e *Expr) IsBinary() bool {
	return isBinaryLookup[e.op]
}

func (e *Expr) IsUnary() bool {
	return isUnaryLookup[e.op]
}

// ScanExpr returns a result set containing every row in the specified table, by
// scanning one of the table's indexes according to its ordering. The private
// Def field is an *opt.ScanOpDef that identifies the table and index to scan,
// as well as the subset of columns to project from it.
type ScanExpr Expr

func MakeScanExpr(def PrivateID) ScanExpr {
	return ScanExpr{op: opt.ScanOp, state: exprState{uint32(def)}}
}

func (e *ScanExpr) Def() PrivateID {
	return PrivateID(e.state[0])
}

func (e *ScanExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsScan() *ScanExpr {
	if e.op != opt.ScanOp {
		return nil
	}
	return (*ScanExpr)(e)
}

// ValuesExpr returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as an opt.ColList. It is legal for Cols to be empty.
type ValuesExpr Expr

func MakeValuesExpr(rows ListID, cols PrivateID) ValuesExpr {
	return ValuesExpr{op: opt.ValuesOp, state: exprState{rows.Offset, rows.Length, uint32(cols)}}
}

func (e *ValuesExpr) Rows() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *ValuesExpr) Cols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *ValuesExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsValues() *ValuesExpr {
	if e.op != opt.ValuesOp {
		return nil
	}
	return (*ValuesExpr)(e)
}

// SelectExpr filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded. While
// the Filter operand can be any boolean expression, normalization rules will
// typically convert it to a Filters operator in order to make conjunction list
// matching easier.
type SelectExpr Expr

func MakeSelectExpr(input GroupID, filter GroupID) SelectExpr {
	return SelectExpr{op: opt.SelectOp, state: exprState{uint32(input), uint32(filter)}}
}

func (e *SelectExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *SelectExpr) Filter() GroupID {
	return GroupID(e.state[1])
}

func (e *SelectExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsSelect() *SelectExpr {
	if e.op != opt.SelectOp {
		return nil
	}
	return (*SelectExpr)(e)
}

// ProjectExpr modifies the set of columns returned by the input result set. Columns
// can be removed, reordered, or renamed. In addition, new columns can be
// synthesized. Projections is a scalar Projections list operator that contains
// the list of expressions that describe the output columns. The Cols field of
// the Projections operator provides the indexes of each of the output columns.
type ProjectExpr Expr

func MakeProjectExpr(input GroupID, projections GroupID) ProjectExpr {
	return ProjectExpr{op: opt.ProjectOp, state: exprState{uint32(input), uint32(projections)}}
}

func (e *ProjectExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *ProjectExpr) Projections() GroupID {
	return GroupID(e.state[1])
}

func (e *ProjectExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsProject() *ProjectExpr {
	if e.op != opt.ProjectOp {
		return nil
	}
	return (*ProjectExpr)(e)
}

// InnerJoinExpr creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
type InnerJoinExpr Expr

func MakeInnerJoinExpr(left GroupID, right GroupID, on GroupID) InnerJoinExpr {
	return InnerJoinExpr{op: opt.InnerJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *InnerJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *InnerJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *InnerJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *InnerJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsInnerJoin() *InnerJoinExpr {
	if e.op != opt.InnerJoinOp {
		return nil
	}
	return (*InnerJoinExpr)(e)
}

type LeftJoinExpr Expr

func MakeLeftJoinExpr(left GroupID, right GroupID, on GroupID) LeftJoinExpr {
	return LeftJoinExpr{op: opt.LeftJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *LeftJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LeftJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LeftJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *LeftJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLeftJoin() *LeftJoinExpr {
	if e.op != opt.LeftJoinOp {
		return nil
	}
	return (*LeftJoinExpr)(e)
}

type RightJoinExpr Expr

func MakeRightJoinExpr(left GroupID, right GroupID, on GroupID) RightJoinExpr {
	return RightJoinExpr{op: opt.RightJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *RightJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *RightJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *RightJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *RightJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsRightJoin() *RightJoinExpr {
	if e.op != opt.RightJoinOp {
		return nil
	}
	return (*RightJoinExpr)(e)
}

type FullJoinExpr Expr

func MakeFullJoinExpr(left GroupID, right GroupID, on GroupID) FullJoinExpr {
	return FullJoinExpr{op: opt.FullJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *FullJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *FullJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *FullJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *FullJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFullJoin() *FullJoinExpr {
	if e.op != opt.FullJoinOp {
		return nil
	}
	return (*FullJoinExpr)(e)
}

type SemiJoinExpr Expr

func MakeSemiJoinExpr(left GroupID, right GroupID, on GroupID) SemiJoinExpr {
	return SemiJoinExpr{op: opt.SemiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *SemiJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *SemiJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *SemiJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *SemiJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsSemiJoin() *SemiJoinExpr {
	if e.op != opt.SemiJoinOp {
		return nil
	}
	return (*SemiJoinExpr)(e)
}

type AntiJoinExpr Expr

func MakeAntiJoinExpr(left GroupID, right GroupID, on GroupID) AntiJoinExpr {
	return AntiJoinExpr{op: opt.AntiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *AntiJoinExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *AntiJoinExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *AntiJoinExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *AntiJoinExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsAntiJoin() *AntiJoinExpr {
	if e.op != opt.AntiJoinOp {
		return nil
	}
	return (*AntiJoinExpr)(e)
}

// InnerJoinApplyExpr has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
type InnerJoinApplyExpr Expr

func MakeInnerJoinApplyExpr(left GroupID, right GroupID, on GroupID) InnerJoinApplyExpr {
	return InnerJoinApplyExpr{op: opt.InnerJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *InnerJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *InnerJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *InnerJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *InnerJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsInnerJoinApply() *InnerJoinApplyExpr {
	if e.op != opt.InnerJoinApplyOp {
		return nil
	}
	return (*InnerJoinApplyExpr)(e)
}

type LeftJoinApplyExpr Expr

func MakeLeftJoinApplyExpr(left GroupID, right GroupID, on GroupID) LeftJoinApplyExpr {
	return LeftJoinApplyExpr{op: opt.LeftJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *LeftJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LeftJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LeftJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *LeftJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLeftJoinApply() *LeftJoinApplyExpr {
	if e.op != opt.LeftJoinApplyOp {
		return nil
	}
	return (*LeftJoinApplyExpr)(e)
}

type RightJoinApplyExpr Expr

func MakeRightJoinApplyExpr(left GroupID, right GroupID, on GroupID) RightJoinApplyExpr {
	return RightJoinApplyExpr{op: opt.RightJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *RightJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *RightJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *RightJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *RightJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsRightJoinApply() *RightJoinApplyExpr {
	if e.op != opt.RightJoinApplyOp {
		return nil
	}
	return (*RightJoinApplyExpr)(e)
}

type FullJoinApplyExpr Expr

func MakeFullJoinApplyExpr(left GroupID, right GroupID, on GroupID) FullJoinApplyExpr {
	return FullJoinApplyExpr{op: opt.FullJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *FullJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *FullJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *FullJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *FullJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFullJoinApply() *FullJoinApplyExpr {
	if e.op != opt.FullJoinApplyOp {
		return nil
	}
	return (*FullJoinApplyExpr)(e)
}

type SemiJoinApplyExpr Expr

func MakeSemiJoinApplyExpr(left GroupID, right GroupID, on GroupID) SemiJoinApplyExpr {
	return SemiJoinApplyExpr{op: opt.SemiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *SemiJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *SemiJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *SemiJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *SemiJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsSemiJoinApply() *SemiJoinApplyExpr {
	if e.op != opt.SemiJoinApplyOp {
		return nil
	}
	return (*SemiJoinApplyExpr)(e)
}

type AntiJoinApplyExpr Expr

func MakeAntiJoinApplyExpr(left GroupID, right GroupID, on GroupID) AntiJoinApplyExpr {
	return AntiJoinApplyExpr{op: opt.AntiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *AntiJoinApplyExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *AntiJoinApplyExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *AntiJoinApplyExpr) On() GroupID {
	return GroupID(e.state[2])
}

func (e *AntiJoinApplyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsAntiJoinApply() *AntiJoinApplyExpr {
	if e.op != opt.AntiJoinApplyOp {
		return nil
	}
	return (*AntiJoinApplyExpr)(e)
}

// GroupByExpr is an operator that is used for performing aggregations (for queries
// with aggregate functions, HAVING clauses and/or group by expressions). It
// groups results that are equal on the grouping columns and computes
// aggregations as described by Aggregations (which is always an Aggregations
// operator). The arguments of the aggregations are columns from the input.
type GroupByExpr Expr

func MakeGroupByExpr(input GroupID, aggregations GroupID, groupingCols PrivateID) GroupByExpr {
	return GroupByExpr{op: opt.GroupByOp, state: exprState{uint32(input), uint32(aggregations), uint32(groupingCols)}}
}

func (e *GroupByExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *GroupByExpr) Aggregations() GroupID {
	return GroupID(e.state[1])
}

func (e *GroupByExpr) GroupingCols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *GroupByExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsGroupBy() *GroupByExpr {
	if e.op != opt.GroupByOp {
		return nil
	}
	return (*GroupByExpr)(e)
}

// UnionExpr is an operator used to combine the Left and Right input relations into
// a single set containing rows from both inputs. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Union with the output columns. See the comment above opt.SetOpColMap
// for more details.
type UnionExpr Expr

func MakeUnionExpr(left GroupID, right GroupID, colMap PrivateID) UnionExpr {
	return UnionExpr{op: opt.UnionOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *UnionExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *UnionExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *UnionExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *UnionExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsUnion() *UnionExpr {
	if e.op != opt.UnionOp {
		return nil
	}
	return (*UnionExpr)(e)
}

// IntersectExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that are also present in the Right relation. Duplicate rows are
// discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Intersect with the output columns. See the comment above
// opt.SetOpColMap for more details.
type IntersectExpr Expr

func MakeIntersectExpr(left GroupID, right GroupID, colMap PrivateID) IntersectExpr {
	return IntersectExpr{op: opt.IntersectOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *IntersectExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *IntersectExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *IntersectExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *IntersectExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsIntersect() *IntersectExpr {
	if e.op != opt.IntersectOp {
		return nil
	}
	return (*IntersectExpr)(e)
}

// ExceptExpr is an operator used to perform a set difference between the Left and
// Right input relations. The result consists only of rows in the Left relation
// that are not present in the Right relation. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Except with the output columns. See the comment above opt.SetOpColMap
// for more details.
type ExceptExpr Expr

func MakeExceptExpr(left GroupID, right GroupID, colMap PrivateID) ExceptExpr {
	return ExceptExpr{op: opt.ExceptOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *ExceptExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ExceptExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ExceptExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *ExceptExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsExcept() *ExceptExpr {
	if e.op != opt.ExceptOp {
		return nil
	}
	return (*ExceptExpr)(e)
}

// UnionAllExpr is an operator used to combine the Left and Right input relations
// into a single set containing rows from both inputs. Duplicate rows are
// not discarded. For example:
//   SELECT x FROM xx UNION ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       2    ->    1
//     2       3          1
//                        2
//                        2
//                        3
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the UnionAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type UnionAllExpr Expr

func MakeUnionAllExpr(left GroupID, right GroupID, colMap PrivateID) UnionAllExpr {
	return UnionAllExpr{op: opt.UnionAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *UnionAllExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *UnionAllExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *UnionAllExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *UnionAllExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsUnionAll() *UnionAllExpr {
	if e.op != opt.UnionAllOp {
		return nil
	}
	return (*UnionAllExpr)(e)
}

// IntersectAllExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that have a corresponding row in the Right relation. Duplicate rows
// are not discarded. This effectively creates a one-to-one mapping between the
// Left and Right rows. For example:
//   SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       1    ->    1
//     1       2          2
//     2       2          2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the IntersectAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type IntersectAllExpr Expr

func MakeIntersectAllExpr(left GroupID, right GroupID, colMap PrivateID) IntersectAllExpr {
	return IntersectAllExpr{op: opt.IntersectAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *IntersectAllExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *IntersectAllExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *IntersectAllExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *IntersectAllExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsIntersectAll() *IntersectAllExpr {
	if e.op != opt.IntersectAllOp {
		return nil
	}
	return (*IntersectAllExpr)(e)
}

// ExceptAllExpr is an operator used to perform a set difference between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that do not have a corresponding row in the Right relation.
// Duplicate rows are not discarded. This effectively creates a one-to-one
// mapping between the Left and Right rows. For example:
//   SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1    ->    1
//     1       1          4
//     1       2
//     2       2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the ExceptAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type ExceptAllExpr Expr

func MakeExceptAllExpr(left GroupID, right GroupID, colMap PrivateID) ExceptAllExpr {
	return ExceptAllExpr{op: opt.ExceptAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *ExceptAllExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ExceptAllExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ExceptAllExpr) ColMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *ExceptAllExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsExceptAll() *ExceptAllExpr {
	if e.op != opt.ExceptAllOp {
		return nil
	}
	return (*ExceptAllExpr)(e)
}

// LimitExpr returns a limited subset of the results in the input relation.
// The limit expression is a scalar value; the operator returns at most this many
// rows. The private field is an opt.Ordering which indicates the desired
// row ordering (the first rows with respect to this ordering are returned).
type LimitExpr Expr

func MakeLimitExpr(input GroupID, limit GroupID, ordering PrivateID) LimitExpr {
	return LimitExpr{op: opt.LimitOp, state: exprState{uint32(input), uint32(limit), uint32(ordering)}}
}

func (e *LimitExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *LimitExpr) Limit() GroupID {
	return GroupID(e.state[1])
}

func (e *LimitExpr) Ordering() PrivateID {
	return PrivateID(e.state[2])
}

func (e *LimitExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLimit() *LimitExpr {
	if e.op != opt.LimitOp {
		return nil
	}
	return (*LimitExpr)(e)
}

// OffsetExpr filters out the first Offset rows of the input relation; used in
// conjunction with Limit.
type OffsetExpr Expr

func MakeOffsetExpr(input GroupID, offset GroupID, ordering PrivateID) OffsetExpr {
	return OffsetExpr{op: opt.OffsetOp, state: exprState{uint32(input), uint32(offset), uint32(ordering)}}
}

func (e *OffsetExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *OffsetExpr) Offset() GroupID {
	return GroupID(e.state[1])
}

func (e *OffsetExpr) Ordering() PrivateID {
	return PrivateID(e.state[2])
}

func (e *OffsetExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsOffset() *OffsetExpr {
	if e.op != opt.OffsetOp {
		return nil
	}
	return (*OffsetExpr)(e)
}

// Max1RowExpr is an operator which enforces that its input must return at most one
// row. It is used as input to the Subquery operator. See the comment above
// Subquery for more details.
type Max1RowExpr Expr

func MakeMax1RowExpr(input GroupID) Max1RowExpr {
	return Max1RowExpr{op: opt.Max1RowOp, state: exprState{uint32(input)}}
}

func (e *Max1RowExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *Max1RowExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsMax1Row() *Max1RowExpr {
	if e.op != opt.Max1RowOp {
		return nil
	}
	return (*Max1RowExpr)(e)
}

// SubqueryExpr is a subquery in a single-row context such as
// `SELECT 1 = (SELECT 1)` or `SELECT (1, 'a') = (SELECT 1, 'a')`.
// In a single-row context, the outer query is only valid if the subquery
// returns at most one row.
//
// Subqueries in a multi-row context such as
// `SELECT 1 IN (SELECT c FROM t)` or `SELECT (1, 'a') IN (SELECT 1, 'a')`
// can be transformed to a single row context using the Any operator. (Note that
// this is different from the SQL ANY operator. See the comment above the Any
// operator for more details.)
//
// We use the following transformations:
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// `<var> IN (<subquery>)`
//    ==> `Any(SELECT <var> = x FROM (<subquery>) AS q(x))`
//
// `<var> NOT IN (<subquery>)`
//    ==> `NOT Any(SELECT <var> = x FROM (<subquery>) AS q(x))`
//
// `<var> <comp> {SOME|ANY}(<subquery>)`
//    ==> `Any(SELECT <var> <comp> x FROM (<subquery>) AS q(x))`
//
// `<var> <comp> ALL(<subquery>)`
//    ==> `NOT Any(SELECT NOT(<var> <comp> x) FROM (<subquery>) AS q(x))`
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
// The Input field contains the subquery itself, which should be wrapped in a
// Max1Row operator to enforce that the subquery can return at most one row
// (Max1Row may be removed by the optimizer later if it can determine statically
// that the subquery will always return at most one row). The Projection field
// contains a single column representing the output of the subquery. For
// example, `(SELECT 1, 'a')` would be represented by the following structure:
//
// (Subquery
//   (Max1Row
//     (Project (Values (Tuple)) (Projections (Tuple (Const 1) (Const 'a'))))
//   )
//   (Variable 3)
// )
//
// Here Variable 3 refers to the projection from the Input,
// (Tuple (Const 1) (Const 'a')).
type SubqueryExpr Expr

func MakeSubqueryExpr(input GroupID, projection GroupID) SubqueryExpr {
	return SubqueryExpr{op: opt.SubqueryOp, state: exprState{uint32(input), uint32(projection)}}
}

func (e *SubqueryExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *SubqueryExpr) Projection() GroupID {
	return GroupID(e.state[1])
}

func (e *SubqueryExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsSubquery() *SubqueryExpr {
	if e.op != opt.SubqueryOp {
		return nil
	}
	return (*SubqueryExpr)(e)
}

// AnyExpr is a special operator that does not exist in SQL. However, it is very
// similar to the SQL ANY, and can be converted to the SQL ANY operator using
// the following transformation:
//  `Any(<subquery>)` ==> `True = ANY(<subquery>)`
//
// Any expects the subquery to return a single boolean column. The semantics
// are equivalent to the SQL ANY expression above on the right: Any returns true
// if any of the values returned by the subquery are true, else returns NULL
// if any of the values are NULL, else returns false.
type AnyExpr Expr

func MakeAnyExpr(input GroupID) AnyExpr {
	return AnyExpr{op: opt.AnyOp, state: exprState{uint32(input)}}
}

func (e *AnyExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *AnyExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsAny() *AnyExpr {
	if e.op != opt.AnyOp {
		return nil
	}
	return (*AnyExpr)(e)
}

// VariableExpr is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnID that references the column by index.
type VariableExpr Expr

func MakeVariableExpr(col PrivateID) VariableExpr {
	return VariableExpr{op: opt.VariableOp, state: exprState{uint32(col)}}
}

func (e *VariableExpr) Col() PrivateID {
	return PrivateID(e.state[0])
}

func (e *VariableExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsVariable() *VariableExpr {
	if e.op != opt.VariableOp {
		return nil
	}
	return (*VariableExpr)(e)
}

// ConstExpr is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
type ConstExpr Expr

func MakeConstExpr(value PrivateID) ConstExpr {
	return ConstExpr{op: opt.ConstOp, state: exprState{uint32(value)}}
}

func (e *ConstExpr) Value() PrivateID {
	return PrivateID(e.state[0])
}

func (e *ConstExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsConst() *ConstExpr {
	if e.op != opt.ConstOp {
		return nil
	}
	return (*ConstExpr)(e)
}

// NullExpr is the constant SQL null value that has "unknown value" semantics. If
// the Typ field is not types.Unknown, then the value is known to be in the
// domain of that type. This is important for preserving correct types in
// replacement patterns. For example:
//   (Plus (Function ...) (Const 1))
//
// If the function in that expression has a static type of Int, but then it gets
// constant folded to (Null), then its type must remain as Int. Any other type
// violates logical equivalence of the expression, breaking type inference and
// possibly changing the results of execution. The solution is to tag the null
// with the correct type:
//   (Plus (Null (Int)) (Const 1))
//
// Null is its own operator rather than a Const datum in order to make matching
// and replacement easier and more efficient, as patterns can contain (Null)
// expressions.
type NullExpr Expr

func MakeNullExpr(typ PrivateID) NullExpr {
	return NullExpr{op: opt.NullOp, state: exprState{uint32(typ)}}
}

func (e *NullExpr) Typ() PrivateID {
	return PrivateID(e.state[0])
}

func (e *NullExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNull() *NullExpr {
	if e.op != opt.NullOp {
		return nil
	}
	return (*NullExpr)(e)
}

// TrueExpr is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
type TrueExpr Expr

func MakeTrueExpr() TrueExpr {
	return TrueExpr{op: opt.TrueOp, state: exprState{}}
}

func (e *TrueExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsTrue() *TrueExpr {
	if e.op != opt.TrueOp {
		return nil
	}
	return (*TrueExpr)(e)
}

// FalseExpr is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
type FalseExpr Expr

func MakeFalseExpr() FalseExpr {
	return FalseExpr{op: opt.FalseOp, state: exprState{}}
}

func (e *FalseExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFalse() *FalseExpr {
	if e.op != opt.FalseOp {
		return nil
	}
	return (*FalseExpr)(e)
}

type PlaceholderExpr Expr

func MakePlaceholderExpr(value PrivateID) PlaceholderExpr {
	return PlaceholderExpr{op: opt.PlaceholderOp, state: exprState{uint32(value)}}
}

func (e *PlaceholderExpr) Value() PrivateID {
	return PrivateID(e.state[0])
}

func (e *PlaceholderExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsPlaceholder() *PlaceholderExpr {
	if e.op != opt.PlaceholderOp {
		return nil
	}
	return (*PlaceholderExpr)(e)
}

type TupleExpr Expr

func MakeTupleExpr(elems ListID) TupleExpr {
	return TupleExpr{op: opt.TupleOp, state: exprState{elems.Offset, elems.Length}}
}

func (e *TupleExpr) Elems() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *TupleExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsTuple() *TupleExpr {
	if e.op != opt.TupleOp {
		return nil
	}
	return (*TupleExpr)(e)
}

// ProjectionsExpr is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the list of column indexes returned by the expression, as an opt.ColList. It
// is not legal for Cols to be empty.
type ProjectionsExpr Expr

func MakeProjectionsExpr(elems ListID, cols PrivateID) ProjectionsExpr {
	return ProjectionsExpr{op: opt.ProjectionsOp, state: exprState{elems.Offset, elems.Length, uint32(cols)}}
}

func (e *ProjectionsExpr) Elems() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *ProjectionsExpr) Cols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *ProjectionsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsProjections() *ProjectionsExpr {
	if e.op != opt.ProjectionsOp {
		return nil
	}
	return (*ProjectionsExpr)(e)
}

// AggregationsExpr is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the list of column indexes returned by the expression, as an opt.ColList. It
// is legal for Cols to be empty.
type AggregationsExpr Expr

func MakeAggregationsExpr(aggs ListID, cols PrivateID) AggregationsExpr {
	return AggregationsExpr{op: opt.AggregationsOp, state: exprState{aggs.Offset, aggs.Length, uint32(cols)}}
}

func (e *AggregationsExpr) Aggs() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *AggregationsExpr) Cols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *AggregationsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsAggregations() *AggregationsExpr {
	if e.op != opt.AggregationsOp {
		return nil
	}
	return (*AggregationsExpr)(e)
}

type ExistsExpr Expr

func MakeExistsExpr(input GroupID) ExistsExpr {
	return ExistsExpr{op: opt.ExistsOp, state: exprState{uint32(input)}}
}

func (e *ExistsExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *ExistsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsExists() *ExistsExpr {
	if e.op != opt.ExistsOp {
		return nil
	}
	return (*ExistsExpr)(e)
}

// FiltersExpr is a boolean And operator that only appears as the Filters child of
// a Select operator, or the On child of a Join operator. For example:
//   (Select
//     (Scan a)
//     (Filters (Gt (Variable a) 1) (Lt (Variable a) 5))
//   )
//
// Normalization rules ensure that a Filters expression is always created if
// there is at least one condition, so that other rules can rely on its presence
// when matching, even in the case where there is only one condition. The
// semantics of the Filters operator are identical to those of the And operator.
type FiltersExpr Expr

func MakeFiltersExpr(conditions ListID) FiltersExpr {
	return FiltersExpr{op: opt.FiltersOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *FiltersExpr) Conditions() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *FiltersExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFilters() *FiltersExpr {
	if e.op != opt.FiltersOp {
		return nil
	}
	return (*FiltersExpr)(e)
}

// AndExpr is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
type AndExpr Expr

func MakeAndExpr(conditions ListID) AndExpr {
	return AndExpr{op: opt.AndOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *AndExpr) Conditions() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *AndExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsAnd() *AndExpr {
	if e.op != opt.AndOp {
		return nil
	}
	return (*AndExpr)(e)
}

// OrExpr is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
type OrExpr Expr

func MakeOrExpr(conditions ListID) OrExpr {
	return OrExpr{op: opt.OrOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *OrExpr) Conditions() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *OrExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsOr() *OrExpr {
	if e.op != opt.OrOp {
		return nil
	}
	return (*OrExpr)(e)
}

// NotExpr is the boolean negation operator that evaluates to true if its input
// evalutes to false.
type NotExpr Expr

func MakeNotExpr(input GroupID) NotExpr {
	return NotExpr{op: opt.NotOp, state: exprState{uint32(input)}}
}

func (e *NotExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *NotExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNot() *NotExpr {
	if e.op != opt.NotOp {
		return nil
	}
	return (*NotExpr)(e)
}

type EqExpr Expr

func MakeEqExpr(left GroupID, right GroupID) EqExpr {
	return EqExpr{op: opt.EqOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *EqExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *EqExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *EqExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsEq() *EqExpr {
	if e.op != opt.EqOp {
		return nil
	}
	return (*EqExpr)(e)
}

type LtExpr Expr

func MakeLtExpr(left GroupID, right GroupID) LtExpr {
	return LtExpr{op: opt.LtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *LtExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LtExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LtExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLt() *LtExpr {
	if e.op != opt.LtOp {
		return nil
	}
	return (*LtExpr)(e)
}

type GtExpr Expr

func MakeGtExpr(left GroupID, right GroupID) GtExpr {
	return GtExpr{op: opt.GtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *GtExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *GtExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *GtExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsGt() *GtExpr {
	if e.op != opt.GtOp {
		return nil
	}
	return (*GtExpr)(e)
}

type LeExpr Expr

func MakeLeExpr(left GroupID, right GroupID) LeExpr {
	return LeExpr{op: opt.LeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *LeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLe() *LeExpr {
	if e.op != opt.LeOp {
		return nil
	}
	return (*LeExpr)(e)
}

type GeExpr Expr

func MakeGeExpr(left GroupID, right GroupID) GeExpr {
	return GeExpr{op: opt.GeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *GeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *GeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *GeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsGe() *GeExpr {
	if e.op != opt.GeOp {
		return nil
	}
	return (*GeExpr)(e)
}

type NeExpr Expr

func MakeNeExpr(left GroupID, right GroupID) NeExpr {
	return NeExpr{op: opt.NeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNe() *NeExpr {
	if e.op != opt.NeOp {
		return nil
	}
	return (*NeExpr)(e)
}

type InExpr Expr

func MakeInExpr(left GroupID, right GroupID) InExpr {
	return InExpr{op: opt.InOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *InExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *InExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *InExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsIn() *InExpr {
	if e.op != opt.InOp {
		return nil
	}
	return (*InExpr)(e)
}

type NotInExpr Expr

func MakeNotInExpr(left GroupID, right GroupID) NotInExpr {
	return NotInExpr{op: opt.NotInOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotInExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotInExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotInExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotIn() *NotInExpr {
	if e.op != opt.NotInOp {
		return nil
	}
	return (*NotInExpr)(e)
}

type LikeExpr Expr

func MakeLikeExpr(left GroupID, right GroupID) LikeExpr {
	return LikeExpr{op: opt.LikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *LikeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LikeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LikeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLike() *LikeExpr {
	if e.op != opt.LikeOp {
		return nil
	}
	return (*LikeExpr)(e)
}

type NotLikeExpr Expr

func MakeNotLikeExpr(left GroupID, right GroupID) NotLikeExpr {
	return NotLikeExpr{op: opt.NotLikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotLikeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotLikeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotLikeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotLike() *NotLikeExpr {
	if e.op != opt.NotLikeOp {
		return nil
	}
	return (*NotLikeExpr)(e)
}

type ILikeExpr Expr

func MakeILikeExpr(left GroupID, right GroupID) ILikeExpr {
	return ILikeExpr{op: opt.ILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ILikeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ILikeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ILikeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsILike() *ILikeExpr {
	if e.op != opt.ILikeOp {
		return nil
	}
	return (*ILikeExpr)(e)
}

type NotILikeExpr Expr

func MakeNotILikeExpr(left GroupID, right GroupID) NotILikeExpr {
	return NotILikeExpr{op: opt.NotILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotILikeExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotILikeExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotILikeExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotILike() *NotILikeExpr {
	if e.op != opt.NotILikeOp {
		return nil
	}
	return (*NotILikeExpr)(e)
}

type SimilarToExpr Expr

func MakeSimilarToExpr(left GroupID, right GroupID) SimilarToExpr {
	return SimilarToExpr{op: opt.SimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *SimilarToExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *SimilarToExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *SimilarToExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsSimilarTo() *SimilarToExpr {
	if e.op != opt.SimilarToOp {
		return nil
	}
	return (*SimilarToExpr)(e)
}

type NotSimilarToExpr Expr

func MakeNotSimilarToExpr(left GroupID, right GroupID) NotSimilarToExpr {
	return NotSimilarToExpr{op: opt.NotSimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotSimilarToExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotSimilarToExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotSimilarToExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotSimilarTo() *NotSimilarToExpr {
	if e.op != opt.NotSimilarToOp {
		return nil
	}
	return (*NotSimilarToExpr)(e)
}

type RegMatchExpr Expr

func MakeRegMatchExpr(left GroupID, right GroupID) RegMatchExpr {
	return RegMatchExpr{op: opt.RegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *RegMatchExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *RegMatchExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *RegMatchExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsRegMatch() *RegMatchExpr {
	if e.op != opt.RegMatchOp {
		return nil
	}
	return (*RegMatchExpr)(e)
}

type NotRegMatchExpr Expr

func MakeNotRegMatchExpr(left GroupID, right GroupID) NotRegMatchExpr {
	return NotRegMatchExpr{op: opt.NotRegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotRegMatchExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotRegMatchExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotRegMatchExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotRegMatch() *NotRegMatchExpr {
	if e.op != opt.NotRegMatchOp {
		return nil
	}
	return (*NotRegMatchExpr)(e)
}

type RegIMatchExpr Expr

func MakeRegIMatchExpr(left GroupID, right GroupID) RegIMatchExpr {
	return RegIMatchExpr{op: opt.RegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *RegIMatchExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *RegIMatchExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *RegIMatchExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsRegIMatch() *RegIMatchExpr {
	if e.op != opt.RegIMatchOp {
		return nil
	}
	return (*RegIMatchExpr)(e)
}

type NotRegIMatchExpr Expr

func MakeNotRegIMatchExpr(left GroupID, right GroupID) NotRegIMatchExpr {
	return NotRegIMatchExpr{op: opt.NotRegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *NotRegIMatchExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *NotRegIMatchExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *NotRegIMatchExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsNotRegIMatch() *NotRegIMatchExpr {
	if e.op != opt.NotRegIMatchOp {
		return nil
	}
	return (*NotRegIMatchExpr)(e)
}

type IsExpr Expr

func MakeIsExpr(left GroupID, right GroupID) IsExpr {
	return IsExpr{op: opt.IsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *IsExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *IsExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *IsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsIs() *IsExpr {
	if e.op != opt.IsOp {
		return nil
	}
	return (*IsExpr)(e)
}

type IsNotExpr Expr

func MakeIsNotExpr(left GroupID, right GroupID) IsNotExpr {
	return IsNotExpr{op: opt.IsNotOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *IsNotExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *IsNotExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *IsNotExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsIsNot() *IsNotExpr {
	if e.op != opt.IsNotOp {
		return nil
	}
	return (*IsNotExpr)(e)
}

type ContainsExpr Expr

func MakeContainsExpr(left GroupID, right GroupID) ContainsExpr {
	return ContainsExpr{op: opt.ContainsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ContainsExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ContainsExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ContainsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsContains() *ContainsExpr {
	if e.op != opt.ContainsOp {
		return nil
	}
	return (*ContainsExpr)(e)
}

type JsonExistsExpr Expr

func MakeJsonExistsExpr(left GroupID, right GroupID) JsonExistsExpr {
	return JsonExistsExpr{op: opt.JsonExistsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *JsonExistsExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *JsonExistsExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *JsonExistsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsJsonExists() *JsonExistsExpr {
	if e.op != opt.JsonExistsOp {
		return nil
	}
	return (*JsonExistsExpr)(e)
}

type JsonAllExistsExpr Expr

func MakeJsonAllExistsExpr(left GroupID, right GroupID) JsonAllExistsExpr {
	return JsonAllExistsExpr{op: opt.JsonAllExistsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *JsonAllExistsExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *JsonAllExistsExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *JsonAllExistsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsJsonAllExists() *JsonAllExistsExpr {
	if e.op != opt.JsonAllExistsOp {
		return nil
	}
	return (*JsonAllExistsExpr)(e)
}

type JsonSomeExistsExpr Expr

func MakeJsonSomeExistsExpr(left GroupID, right GroupID) JsonSomeExistsExpr {
	return JsonSomeExistsExpr{op: opt.JsonSomeExistsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *JsonSomeExistsExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *JsonSomeExistsExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *JsonSomeExistsExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsJsonSomeExists() *JsonSomeExistsExpr {
	if e.op != opt.JsonSomeExistsOp {
		return nil
	}
	return (*JsonSomeExistsExpr)(e)
}

type BitandExpr Expr

func MakeBitandExpr(left GroupID, right GroupID) BitandExpr {
	return BitandExpr{op: opt.BitandOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *BitandExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *BitandExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *BitandExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsBitand() *BitandExpr {
	if e.op != opt.BitandOp {
		return nil
	}
	return (*BitandExpr)(e)
}

type BitorExpr Expr

func MakeBitorExpr(left GroupID, right GroupID) BitorExpr {
	return BitorExpr{op: opt.BitorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *BitorExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *BitorExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *BitorExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsBitor() *BitorExpr {
	if e.op != opt.BitorOp {
		return nil
	}
	return (*BitorExpr)(e)
}

type BitxorExpr Expr

func MakeBitxorExpr(left GroupID, right GroupID) BitxorExpr {
	return BitxorExpr{op: opt.BitxorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *BitxorExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *BitxorExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *BitxorExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsBitxor() *BitxorExpr {
	if e.op != opt.BitxorOp {
		return nil
	}
	return (*BitxorExpr)(e)
}

type PlusExpr Expr

func MakePlusExpr(left GroupID, right GroupID) PlusExpr {
	return PlusExpr{op: opt.PlusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *PlusExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *PlusExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *PlusExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsPlus() *PlusExpr {
	if e.op != opt.PlusOp {
		return nil
	}
	return (*PlusExpr)(e)
}

type MinusExpr Expr

func MakeMinusExpr(left GroupID, right GroupID) MinusExpr {
	return MinusExpr{op: opt.MinusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *MinusExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *MinusExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *MinusExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsMinus() *MinusExpr {
	if e.op != opt.MinusOp {
		return nil
	}
	return (*MinusExpr)(e)
}

type MultExpr Expr

func MakeMultExpr(left GroupID, right GroupID) MultExpr {
	return MultExpr{op: opt.MultOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *MultExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *MultExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *MultExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsMult() *MultExpr {
	if e.op != opt.MultOp {
		return nil
	}
	return (*MultExpr)(e)
}

type DivExpr Expr

func MakeDivExpr(left GroupID, right GroupID) DivExpr {
	return DivExpr{op: opt.DivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *DivExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *DivExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *DivExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsDiv() *DivExpr {
	if e.op != opt.DivOp {
		return nil
	}
	return (*DivExpr)(e)
}

type FloorDivExpr Expr

func MakeFloorDivExpr(left GroupID, right GroupID) FloorDivExpr {
	return FloorDivExpr{op: opt.FloorDivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *FloorDivExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *FloorDivExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *FloorDivExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFloorDiv() *FloorDivExpr {
	if e.op != opt.FloorDivOp {
		return nil
	}
	return (*FloorDivExpr)(e)
}

type ModExpr Expr

func MakeModExpr(left GroupID, right GroupID) ModExpr {
	return ModExpr{op: opt.ModOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ModExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ModExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ModExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsMod() *ModExpr {
	if e.op != opt.ModOp {
		return nil
	}
	return (*ModExpr)(e)
}

type PowExpr Expr

func MakePowExpr(left GroupID, right GroupID) PowExpr {
	return PowExpr{op: opt.PowOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *PowExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *PowExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *PowExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsPow() *PowExpr {
	if e.op != opt.PowOp {
		return nil
	}
	return (*PowExpr)(e)
}

type ConcatExpr Expr

func MakeConcatExpr(left GroupID, right GroupID) ConcatExpr {
	return ConcatExpr{op: opt.ConcatOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ConcatExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *ConcatExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *ConcatExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsConcat() *ConcatExpr {
	if e.op != opt.ConcatOp {
		return nil
	}
	return (*ConcatExpr)(e)
}

type LShiftExpr Expr

func MakeLShiftExpr(left GroupID, right GroupID) LShiftExpr {
	return LShiftExpr{op: opt.LShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *LShiftExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *LShiftExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *LShiftExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsLShift() *LShiftExpr {
	if e.op != opt.LShiftOp {
		return nil
	}
	return (*LShiftExpr)(e)
}

type RShiftExpr Expr

func MakeRShiftExpr(left GroupID, right GroupID) RShiftExpr {
	return RShiftExpr{op: opt.RShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *RShiftExpr) Left() GroupID {
	return GroupID(e.state[0])
}

func (e *RShiftExpr) Right() GroupID {
	return GroupID(e.state[1])
}

func (e *RShiftExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsRShift() *RShiftExpr {
	if e.op != opt.RShiftOp {
		return nil
	}
	return (*RShiftExpr)(e)
}

type FetchValExpr Expr

func MakeFetchValExpr(json GroupID, index GroupID) FetchValExpr {
	return FetchValExpr{op: opt.FetchValOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *FetchValExpr) Json() GroupID {
	return GroupID(e.state[0])
}

func (e *FetchValExpr) Index() GroupID {
	return GroupID(e.state[1])
}

func (e *FetchValExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFetchVal() *FetchValExpr {
	if e.op != opt.FetchValOp {
		return nil
	}
	return (*FetchValExpr)(e)
}

type FetchTextExpr Expr

func MakeFetchTextExpr(json GroupID, index GroupID) FetchTextExpr {
	return FetchTextExpr{op: opt.FetchTextOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *FetchTextExpr) Json() GroupID {
	return GroupID(e.state[0])
}

func (e *FetchTextExpr) Index() GroupID {
	return GroupID(e.state[1])
}

func (e *FetchTextExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFetchText() *FetchTextExpr {
	if e.op != opt.FetchTextOp {
		return nil
	}
	return (*FetchTextExpr)(e)
}

type FetchValPathExpr Expr

func MakeFetchValPathExpr(json GroupID, path GroupID) FetchValPathExpr {
	return FetchValPathExpr{op: opt.FetchValPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *FetchValPathExpr) Json() GroupID {
	return GroupID(e.state[0])
}

func (e *FetchValPathExpr) Path() GroupID {
	return GroupID(e.state[1])
}

func (e *FetchValPathExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFetchValPath() *FetchValPathExpr {
	if e.op != opt.FetchValPathOp {
		return nil
	}
	return (*FetchValPathExpr)(e)
}

type FetchTextPathExpr Expr

func MakeFetchTextPathExpr(json GroupID, path GroupID) FetchTextPathExpr {
	return FetchTextPathExpr{op: opt.FetchTextPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *FetchTextPathExpr) Json() GroupID {
	return GroupID(e.state[0])
}

func (e *FetchTextPathExpr) Path() GroupID {
	return GroupID(e.state[1])
}

func (e *FetchTextPathExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFetchTextPath() *FetchTextPathExpr {
	if e.op != opt.FetchTextPathOp {
		return nil
	}
	return (*FetchTextPathExpr)(e)
}

type UnaryMinusExpr Expr

func MakeUnaryMinusExpr(input GroupID) UnaryMinusExpr {
	return UnaryMinusExpr{op: opt.UnaryMinusOp, state: exprState{uint32(input)}}
}

func (e *UnaryMinusExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *UnaryMinusExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsUnaryMinus() *UnaryMinusExpr {
	if e.op != opt.UnaryMinusOp {
		return nil
	}
	return (*UnaryMinusExpr)(e)
}

type UnaryComplementExpr Expr

func MakeUnaryComplementExpr(input GroupID) UnaryComplementExpr {
	return UnaryComplementExpr{op: opt.UnaryComplementOp, state: exprState{uint32(input)}}
}

func (e *UnaryComplementExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *UnaryComplementExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsUnaryComplement() *UnaryComplementExpr {
	if e.op != opt.UnaryComplementOp {
		return nil
	}
	return (*UnaryComplementExpr)(e)
}

type CastExpr Expr

func MakeCastExpr(input GroupID, typ PrivateID) CastExpr {
	return CastExpr{op: opt.CastOp, state: exprState{uint32(input), uint32(typ)}}
}

func (e *CastExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *CastExpr) Typ() PrivateID {
	return PrivateID(e.state[1])
}

func (e *CastExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsCast() *CastExpr {
	if e.op != opt.CastOp {
		return nil
	}
	return (*CastExpr)(e)
}

// CaseExpr is a CASE statement of the form:
//   CASE [ <Input> ]
//       WHEN <condval1> THEN <expr1>
//     [ WHEN <condval2> THEN <expr2> ] ...
//     [ ELSE <expr> ]
//   END
//
// The Case operator evaluates <Input> (if not provided, Input is set to True),
// then picks the WHEN branch where <condval> is equal to
// <Input>, then evaluates and returns the corresponding THEN expression. If no
// WHEN branch matches, the ELSE expression is evaluated and returned, if any.
// Otherwise, NULL is returned.
//
// Note that the Whens list inside Case is used to represent all the WHEN
// branches as well as the ELSE statement if it exists. It is of the form:
// [(When <condval1> <expr1>),(When <condval2> <expr2>),...,<expr>]
type CaseExpr Expr

func MakeCaseExpr(input GroupID, whens ListID) CaseExpr {
	return CaseExpr{op: opt.CaseOp, state: exprState{uint32(input), whens.Offset, whens.Length}}
}

func (e *CaseExpr) Input() GroupID {
	return GroupID(e.state[0])
}

func (e *CaseExpr) Whens() ListID {
	return ListID{Offset: e.state[1], Length: e.state[2]}
}

func (e *CaseExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsCase() *CaseExpr {
	if e.op != opt.CaseOp {
		return nil
	}
	return (*CaseExpr)(e)
}

// WhenExpr represents a single WHEN ... THEN ... condition inside a CASE statement.
// It is the type of each list item in Whens (except for the last item which is
// a raw expression for the ELSE statement).
type WhenExpr Expr

func MakeWhenExpr(condition GroupID, value GroupID) WhenExpr {
	return WhenExpr{op: opt.WhenOp, state: exprState{uint32(condition), uint32(value)}}
}

func (e *WhenExpr) Condition() GroupID {
	return GroupID(e.state[0])
}

func (e *WhenExpr) Value() GroupID {
	return GroupID(e.state[1])
}

func (e *WhenExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsWhen() *WhenExpr {
	if e.op != opt.WhenOp {
		return nil
	}
	return (*WhenExpr)(e)
}

// ArrayExpr is an ARRAY literal of the form ARRAY[<expr1>, <expr2>, ..., <exprN>].
type ArrayExpr Expr

func MakeArrayExpr(elems ListID, typ PrivateID) ArrayExpr {
	return ArrayExpr{op: opt.ArrayOp, state: exprState{elems.Offset, elems.Length, uint32(typ)}}
}

func (e *ArrayExpr) Elems() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *ArrayExpr) Typ() PrivateID {
	return PrivateID(e.state[2])
}

func (e *ArrayExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsArray() *ArrayExpr {
	if e.op != opt.ArrayOp {
		return nil
	}
	return (*ArrayExpr)(e)
}

// FunctionExpr invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The private field is a *opt.FuncOpDef struct that provides the
// name of the function as well as a pointer to the builtin overload definition.
type FunctionExpr Expr

func MakeFunctionExpr(args ListID, def PrivateID) FunctionExpr {
	return FunctionExpr{op: opt.FunctionOp, state: exprState{args.Offset, args.Length, uint32(def)}}
}

func (e *FunctionExpr) Args() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *FunctionExpr) Def() PrivateID {
	return PrivateID(e.state[2])
}

func (e *FunctionExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsFunction() *FunctionExpr {
	if e.op != opt.FunctionOp {
		return nil
	}
	return (*FunctionExpr)(e)
}

type CoalesceExpr Expr

func MakeCoalesceExpr(args ListID) CoalesceExpr {
	return CoalesceExpr{op: opt.CoalesceOp, state: exprState{args.Offset, args.Length}}
}

func (e *CoalesceExpr) Args() ListID {
	return ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *CoalesceExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsCoalesce() *CoalesceExpr {
	if e.op != opt.CoalesceOp {
		return nil
	}
	return (*CoalesceExpr)(e)
}

// UnsupportedExprExpr is used for interfacing with the old planner code. It can
// encapsulate a TypedExpr that is otherwise not supported by the optimizer.
type UnsupportedExprExpr Expr

func MakeUnsupportedExprExpr(value PrivateID) UnsupportedExprExpr {
	return UnsupportedExprExpr{op: opt.UnsupportedExprOp, state: exprState{uint32(value)}}
}

func (e *UnsupportedExprExpr) Value() PrivateID {
	return PrivateID(e.state[0])
}

func (e *UnsupportedExprExpr) Fingerprint() Fingerprint {
	return Fingerprint(*e)
}

func (e *Expr) AsUnsupportedExpr() *UnsupportedExprExpr {
	if e.op != opt.UnsupportedExprOp {
		return nil
	}
	return (*UnsupportedExprExpr)(e)
}

// InternScanOpDef adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternScanOpDef(val *ScanOpDef) PrivateID {
	return m.privateStorage.internScanOpDef(val)
}

// InternColList adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternColList(val opt.ColList) PrivateID {
	return m.privateStorage.internColList(val)
}

// InternColSet adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternColSet(val opt.ColSet) PrivateID {
	return m.privateStorage.internColSet(val)
}

// InternSetOpColMap adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternSetOpColMap(val *SetOpColMap) PrivateID {
	return m.privateStorage.internSetOpColMap(val)
}

// InternOrdering adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternOrdering(val Ordering) PrivateID {
	return m.privateStorage.internOrdering(val)
}

// InternColumnID adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternColumnID(val opt.ColumnID) PrivateID {
	return m.privateStorage.internColumnID(val)
}

// InternDatum adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternDatum(val tree.Datum) PrivateID {
	return m.privateStorage.internDatum(val)
}

// InternType adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternType(val types.T) PrivateID {
	return m.privateStorage.internType(val)
}

// InternTypedExpr adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternTypedExpr(val tree.TypedExpr) PrivateID {
	return m.privateStorage.internTypedExpr(val)
}

// InternFuncOpDef adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (m *Memo) InternFuncOpDef(val *FuncOpDef) PrivateID {
	return m.privateStorage.internFuncOpDef(val)
}
