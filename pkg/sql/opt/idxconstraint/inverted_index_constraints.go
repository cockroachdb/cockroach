// Copyright 2020 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package idxconstraint

import (
	"context"

	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/cat"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/norm"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/json"
	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/cockroachdb/errors"
)

// InvertedIndexConstraintIter is a struct for iterating over all possible
// constraints of an inverted index based on a FiltersExpr.
//
// Example usage:
//
//   var iter InvertedIndexConstraintIter
//   iter.Init(index, tabId, filters, factory, evalCtx)
//   for iter.Next() {
//     constraint := iter.Constraint()
//     tight := iter.IsTight()
//     remainingFilter := iter.RemainingFilters()
//   }
//
// Inverted indexes are inherently different from standard indexes. They can
// index only a single column and multiple entries can reference the same
// primary key. This requires special treatment when generating constraints.
//
// For example, consider the following expression:
//
//   a @> '{"a": 1}' AND a @> '{"b": 2}'
//
// This expression cannot generate a constraint over an inverted index with
// multiple spans. If it did, those spans would be:
//
//   [/'{"a": 1}' - /'{"a": 1}']
//   [/'{"b": 2}' - /'{"b": 2}']
//
// However, this is semantically incorrect. A single row may reside in both
// spans, making this constraint a logical disjunction, not a conjunction.
//
// In addition, note that the original expression above is not a contradiction,
// as a = 1 AND a = 2 would be.
//
// Because of these differences, it is necessary to be able to enumerate
// multiple constraints over the same inverted index for a given expression. The
// following assumptions are made by this iterator:
//
//   - An inverted index indexes a single column.
//   - Optional filters, like the ones derived from check constraints for
//     standard indexes, are not considered when enumerating constraints.
//
// Currently, inverted indexes on arrays are not supported.
//
// TODO(mgartner): Support inverted indexes on arrays.
type InvertedIndexConstraintIter struct {
	// keyCtx is the single KeyContext for the indexed column.
	keyCtx constraint.KeyContext

	// evalCtx is the EvalContext of the query.
	evalCtx *tree.EvalContext

	// factory is used for creating new ScalarExpr when executing
	// RemainingFilters.
	factory *norm.Factory

	// colID is the column ID indexed by the inverted index.
	colID opt.ColumnID

	// filters is the FiltersExpr to generate constraints from.
	filters memo.FiltersExpr

	// filtersItemIdx is the index of the top-level FiltersItem within the input
	// FiltersExpr that is currently being search. When a constraintResult is
	// generated, the current filtersItemIdx is saved. This allows
	// RemainingFilters to locate and remove the expression that generated the
	// constraintResult from the input filters.
	filtersItemIdx int

	// exprStack stores expressions that have not yet been searched for
	// constraints. See Next for more information about the exprStack.
	exprStack []opt.Expr

	// results stores constraints that have been found but not yet been
	// enumerated by the Next function. It is necessary to store these results
	// for future iteration when multiple constraints are collected at a leaf
	// node of the FiltersExpr.
	results []constraintResult

	// initialized is true when the Init function has been called.
	initialized bool
}

// constraintResult is a struct representing a constraint that has been
// generated by the iterator. It store the constraint struct, a tight boolean,
// and the FiltersItem index and ScalarExpr which the constraint was generated
// from.
type constraintResult struct {
	constraint     *constraint.Constraint
	tight          bool
	filtersItemIdx int
	expr           opt.ScalarExpr
}

// Init initializes a new InvertedIndexConstraintIter.
func (iter *InvertedIndexConstraintIter) Init(
	index cat.Index,
	tabID opt.TableID,
	filters memo.FiltersExpr,
	f *norm.Factory,
	evalCtx *tree.EvalContext,
) {
	iter.factory = f
	iter.evalCtx = evalCtx
	iter.filters = filters

	// Set the column ID to the first and only column in the inverted index.
	col := index.Column(0)
	colID := tabID.ColumnID(col.Ordinal)
	iter.colID = colID

	// Initialize the keyCtx with the single column indexed.
	orderingCol := opt.MakeOrderingColumn(colID, col.Descending)
	iter.keyCtx.Columns.InitSingle(orderingCol)

	// Set the index of the currently searched FiltersItem to -1.
	iter.filtersItemIdx = -1

	// Push the top-level filters expr onto the stack.
	iter.exprStack = append(iter.exprStack, &filters)

	// Set initialized to true.
	iter.initialized = true
}

// Constraint returns the current constraint found by the iterator. Returns nil
// if there is not current constraint.
func (iter *InvertedIndexConstraintIter) Constraint() *constraint.Constraint {
	if !iter.initialized {
		panic(errors.AssertionFailedf("iterator not initialized"))
	}

	if len(iter.results) == 0 {
		return nil
	}
	return iter.results[0].constraint
}

// IsTight returns true if the current constraint is tight, false otherwise.
func (iter *InvertedIndexConstraintIter) IsTight() bool {
	if !iter.initialized {
		panic(errors.AssertionFailedf("iterator not initialized"))
	}

	if len(iter.results) == 0 {
		return false
	}
	return iter.results[0].tight
}

// RemainingFilters returns a FiltersExpr that contains all filters not covered
// by the currenct constraint.
//
// For example, given the following expression:
//
//   @1 @> '{"a": 1}' AND @1 @> '{"b": 2}'
//
// The first constraint produced will be:
//
//   [/'{"a": 1}' - /'{"a": 1}']
//
// And the remaining filters will be:
//
//   @1 @> '{"b": 2}'
//
// If the current constraint is not "tight" over its associated ScalarExpr, the
// entire ScalarExpr is returning in the Remaining Filters. Consider the
// expression:
//
//   @1 @> '{"a": 1, "b": 2}'
//
// The first constraint produced will be:
//
//   [/'{"a": 1}' - /'{"a": 1}']
//
// Because this function cannot currently break the JSON object apart, the
// returned FiltersExpr is the same as the original:
//
//   @1 @> '{"a": 1, "b": 2}'
//
// If there is no currently enumerate constraint, an empty FiltersExpr is
// returned.
func (iter *InvertedIndexConstraintIter) RemainingFilters() memo.FiltersExpr {
	if !iter.initialized {
		panic(errors.AssertionFailedf("iterator not initialized"))
	}

	// If there is no current constraint, return an empty FiltersExpr.
	if len(iter.results) == 0 {
		return memo.EmptyFiltersExpr
	}

	// If the current constraint is not tight, return all the original filters.
	if !iter.IsTight() {
		return iter.filters
	}

	// Fetch the current result.
	result := iter.results[0]
	i := result.filtersItemIdx

	newFilters := make(memo.FiltersExpr, 0, len(iter.filters))

	// Add all FiltersItems up to i to the filters.
	newFilters = append(newFilters, iter.filters[:i]...)

	// Reconstruct the i-th FiltersExpr by copying its structure, but replacing
	// the ScalarExpr that generated the constraint with True.
	replacedExpr := iter.replaceExprWithTrue(iter.filters[i].Condition, result.expr)
	if replacedExpr != memo.TrueSingleton {
		newFilters = append(newFilters, iter.factory.ConstructFiltersItem(replacedExpr))
	}

	// Add all the remaining FiltersItems to the filters.
	newFilters = append(newFilters, iter.filters[i+1:]...)

	return newFilters
}

// Next iterates through all possible constraints of the inverted index by the
// given FiltersExpr. It returns true if there is a new constraint found, and
// false when there are no more constraints to enumerate.
//
// The current constraint and information about it are available via the
// Constraint, IsTight, and RemainingFilters functions.
//
// Next will enumerate any previously collected constraints in iter.results.
// Multiple constraint results may be previously collect by exploration of a single
// expression node (see collectResultsForJSONExpr). When those nodes are
// explored, all their constraints are added to iter.results. This avoids having
// to re-traverse the expression tree on every call to Next.
//
// When iter.results is empty, Next will continue searching the original
// expression tree by popping the next expression off of iter.exprStack.
//
// The exprStack stores expressions that have not yet been searched for
// constraints. It is necessary to store child expressions that can be searched
// later when traversing the FiltersExpr tree. For example, when a memo.AndExpr
// is encountered, the left side is immediately searched for constraints. If a
// constraint is found, the right side is pushed onto exprStack, rather than
// being search immediately. If no more constraints are desired from the user of
// the iterator, the right side is never searched, and computation is reduced.
func (iter *InvertedIndexConstraintIter) Next() bool {
	if !iter.initialized {
		panic(errors.AssertionFailedf("iterator not initialized"))
	}

	// If the results list is non-empty, remove the first result.
	if len(iter.results) != 0 {
		iter.results = iter.results[1:]
	}

	// If there are no constraints in the results list, search the remaining
	// expressions for constraints.
	if len(iter.results) == 0 {
		for e, ok := iter.nextExpr(); ok; e, ok = iter.nextExpr() {
			found := iter.collectResultsForExpr(e)
			if found {
				// Stop searching once some constraints have been found.
				break
			}
		}
	}

	// If the search found no constraints, there are no more to be found.
	if len(iter.results) == 0 {
		return false
	}

	return true
}

// nextExpr returns the next expr on the stack and true if there is at least one
// expression on the stack. It returns (nil, false) if the stack is empty. See
// Next for more information about the exprStack.
func (iter *InvertedIndexConstraintIter) nextExpr() (opt.Expr, bool) {
	// Return false if there are no more expr on the stack.
	if len(iter.exprStack) == 0 {
		return nil, false
	}

	// Pop the last expr off the stack and return it.
	lastIndex := len(iter.exprStack) - 1
	e := iter.exprStack[lastIndex]
	iter.exprStack = iter.exprStack[:lastIndex]

	return e, true
}

// collectResultsForExpr explores the expression tree and collects constraints
// into the iter.results field. It returns true if one or more constraints were
// found and appended to iter.results. It returns false if no constraints were
// found.
//
// NOTE: The replaceExprWithTrue function must be updated when this function is
// updated to handle new ScalarExpr types.
func (iter *InvertedIndexConstraintIter) collectResultsForExpr(e opt.Expr) bool {
	switch t := e.(type) {
	case *memo.FiltersItem:
		// Increment filtersItemIdx every time a new FiltersItem in encountered.
		iter.filtersItemIdx++
		return iter.collectResultsForExpr(t.Condition)
	case *memo.ContainsExpr:
		return iter.collectResultsForContainsExpr(t)
	case *memo.FiltersExpr:
		return iter.collectResultsForAndExpr(t)
	case *memo.AndExpr:
		return iter.collectResultsForAndExpr(t)
	}
	return false
}

// collectResultsForAndExpr is the implementation of collectResultsForExpr
// specifically for memo.AndExprs and memo.FiltersItem. It iteratively searches
// for constraints in child nodes. If constraints are found in a child node, the
// remaining children are not immediately searched. Instead, they are pushed
// onto the iter.exprStack for later searching. See Next for more information
// about the exprStack.
func (iter *InvertedIndexConstraintIter) collectResultsForAndExpr(e opt.Expr) bool {
	i := 0
	n := e.ChildCount()
	found := false

	// Find the first constraint from the child expressions.
	for ; i < n; i++ {
		found = iter.collectResultsForExpr(e.Child(i))
		if found {
			break
		}
	}

	// Add the remaining children to the stack to be searched later.
	for ; i < n; i++ {
		iter.exprStack = append(iter.exprStack, e.Child(i))
	}

	return found
}

// collectResultsForContainsExpr is the implementation of collectResultsForExpr
// specifically for memo.ContainsExprs.
func (iter *InvertedIndexConstraintIter) collectResultsForContainsExpr(e opt.Expr) bool {
	contains := e.(*memo.ContainsExpr)

	left := contains.Left
	right := contains.Right

	if !iter.isIndexColumn(left) || !opt.IsConstValueOp(right) {
		return false
	}

	rightDatum := memo.ExtractConstDatum(right)

	if rightDatum == tree.DNull {
		return false
	}

	switch rightDatum.ResolvedType().Family() {
	case types.JsonFamily:
		return iter.collectResultsForJSONExpr(rightDatum.(*tree.DJSON), contains)
	}

	log.Errorf(context.TODO(), "unexpected type in inverted index: %s", rightDatum.ResolvedType())
	return false
}

// collectResultsForContainsExpr is the implementation of collectResultsForExpr
// specifically for JSON expressions. The input datum is the JSON to produce
// constraints for, and the contains argument is the contains expression
// containing that datum.
//
// Note that this function can append multiple constraint results to
// iter.results. This prevents re-traversing the expression tree for each call
// to Next.
//
// If an error is encountered during JSON processing, it is assumed that a
// constraint cannot be created, and the function returns false without
// collecting any results.
//
// The contains expressions is attached to any resulting constraints, so that
// RemainingFilters can find and replace any tight constraints with True
// expressions to remove them from the remaining filters. See RemainingFilters
// for more information.
func (iter *InvertedIndexConstraintIter) collectResultsForJSONExpr(
	datum *tree.DJSON, contains *memo.ContainsExpr,
) bool {
	j := datum.JSON

	// Check all paths through the datum for Object and Array JSON types.
	if j.Type() == json.ArrayJSONType || j.Type() == json.ObjectJSONType {
		paths, err := json.AllPaths(j)
		if err != nil {
			log.Errorf(context.TODO(), "unexpected JSON error: %+v", err)
			return false
		}

		constrained := false

		// The constraints generated are tight if there was only 1 path through
		// the index constraint.
		tight := len(paths) == 1

		// Loop through all JSON paths and collect all possible constraints.
		var results []constraintResult
		for i := range paths {
			hasContainerLeaf, err := paths[i].HasContainerLeaf()
			if err != nil {
				log.Errorf(context.TODO(), "unexpected JSON error: %+v", err)
				return false
			}

			if hasContainerLeaf {
				// No constraints possible if the datum contains either [] or {}.
				continue
			}

			pathDatum, err := tree.MakeDJSON(paths[i])
			if err != nil {
				log.Errorf(context.TODO(), "unexpected JSON error: %+v", err)
				return false
			}

			cr := constraintResult{
				constraint:     iter.eqSpan(pathDatum),
				tight:          tight,
				filtersItemIdx: iter.filtersItemIdx,
				expr:           contains,
			}
			results = append(results, cr)
		}

		iter.results = append(iter.results, results...)
		return constrained
	}

	// A scalar on the right side of the @> operator indicates that scalars and
	// arrays must be found that contain that value. In order to do so, two
	// logical spans are generated, one for the original scalar and on for
	// arrasy containing the scalar. In this case this is valid and these two
	// spans will not generate duplicate results. The spans are guaranteed not
	// to overlap because a JSON value can either be a scalar or an array, but
	// not both. Therefore, the two spans will not overlap when mapped to the
	// primary key space, and there will not be duplicate primary keys when rows
	// are retrieved.
	builder := json.NewArrayBuilder(1)
	builder.Add(j)
	dJSON, err := tree.MakeDJSON(builder.Build())
	if err != nil {
		log.Errorf(context.TODO(), "unexpected JSON error: %+v", err)
		return false
	}

	// Generate the scalar span.
	span := iter.eqSpan(datum)

	// Union with the array span.
	span.UnionWith(iter.evalCtx, iter.eqSpan(dJSON))

	cr := constraintResult{
		constraint:     span,
		tight:          true,
		filtersItemIdx: iter.filtersItemIdx,
		expr:           contains,
	}
	iter.results = append(iter.results, cr)

	return true
}

// isIndexColumn returns true if e is a variable with the same column as the
// indexed column.
func (iter *InvertedIndexConstraintIter) isIndexColumn(e opt.Expr) bool {
	if v, ok := e.(*memo.VariableExpr); ok {
		return v.Col == iter.colID
	}
	return false
}

// eqSpan returns a span that constrains a column to a single value.
func (iter *InvertedIndexConstraintIter) eqSpan(value tree.Datum) *constraint.Constraint {
	key := constraint.MakeKey(value)

	var s constraint.Span
	s.Init(key, constraint.IncludeBoundary, key, constraint.IncludeBoundary)

	var c constraint.Constraint
	c.InitSingleSpan(&iter.keyCtx, &s)

	return &c
}

// replaceExprWithTrue traverse the ScalarExpr e, building a copy of the
// expression tree, but replacing the ScalarExpr toReplace with
// memo.TrueSingleton.
//
// NOTE: This function must be updated to handle new ScalarExpr types when support for
// those types are added in collectResultsForExpr.
func (iter *InvertedIndexConstraintIter) replaceExprWithTrue(
	e, toReplace opt.ScalarExpr,
) opt.ScalarExpr {
	if e == toReplace {
		return memo.TrueSingleton
	}

	switch t := e.(type) {
	case *memo.FiltersItem:
		return iter.replaceExprWithTrue(t.Condition, toReplace)
	case *memo.AndExpr:
		left := iter.replaceExprWithTrue(t.Left, toReplace)
		right := iter.replaceExprWithTrue(t.Right, toReplace)
		return iter.factory.ConstructAnd(left, right)
	default:
		return e
	}
}
