# Every query has two tests, one showing its index candidates and the other
# showing its final index recommendations.

exec-ddl
CREATE TABLE t1 (k INT, i INT, f FLOAT, s STRING)
----

exec-ddl
CREATE TABLE t2 (k INT, i INT, s STRING)
----

exec-ddl
CREATE TABLE t3 (k INT, i INT, f FLOAT)
----

# Basic tests for comparison operator, range, equality, join, order by, and
# group by candidates.

index-candidates
SELECT i FROM t1 WHERE i >= 3
----
t1:
 (i)

index-recommendations
SELECT i FROM t1 WHERE i >= 3
----
index recommendation: create 1 index
1. table: t1
   columns: [i] ASC
   SQL command: CREATE INDEX ON t1 (i);

index-candidates
SELECT f FROM t1 WHERE f > 2 AND f < 8
----
t1:
 (f)

index-recommendations
SELECT f FROM t1 WHERE f > 2 AND f < 8
----
index recommendation: create 1 index
1. table: t1
   columns: [f] ASC
   SQL command: CREATE INDEX ON t1 (f);

index-candidates
SELECT s FROM t1 WHERE s = 'NG'
----
t1:
 (s)

index-recommendations
SELECT s FROM t1 WHERE s = 'NG'
----
index recommendation: create 1 index
1. table: t1
   columns: [s] ASC
   SQL command: CREATE INDEX ON t1 (s);


index-candidates
SELECT t1.k FROM t1 JOIN t2 ON t1.k = t2.i
----
t1:
 (k)
t2:
 (i)

index-recommendations
SELECT t1.k FROM t1 JOIN t2 ON t1.k = t2.i
----
index recommendation: create 2 indexes
1. table: t1
   columns: [k] ASC
   SQL command: CREATE INDEX ON t1 (k);
2. table: t2
   columns: [i] ASC
   SQL command: CREATE INDEX ON t2 (i);

index-candidates
SELECT t2.s FROM t1 RIGHT JOIN t2 ON t1.s LIKE t2.s
----
t1:
 (s)
t2:
 (s)

index-recommendations
SELECT t2.s FROM t1 RIGHT JOIN t2 ON t1.s LIKE t2.s
----
index recommendation: create 2 indexes
1. table: t1
   columns: [s] ASC
   SQL command: CREATE INDEX ON t1 (s);
2. table: t2
   columns: [s] ASC
   SQL command: CREATE INDEX ON t2 (s);

index-candidates
SELECT i FROM t1 ORDER BY i
----
t1:
 (i)

index-recommendations
SELECT i FROM t1 ORDER BY i
----
index recommendation: create 1 index
1. table: t1
   columns: [i] ASC
   SQL command: CREATE INDEX ON t1 (i);

index-candidates
SELECT k, i FROM t1 ORDER BY k DESC, i ASC
----
t1:
 (k, i DESC)

index-recommendations
SELECT k, i FROM t1 ORDER BY k DESC, i ASC
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] DESC
   SQL command: CREATE INDEX ON t1 (k, i DESC);

index-candidates
SELECT count(*) FROM t1 GROUP BY k
----
t1:
 (k)

index-recommendations
SELECT count(*) FROM t1 GROUP BY k
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC
   SQL command: CREATE INDEX ON t1 (k);

index-candidates
SELECT sum(k) FROM t1 GROUP BY i, f, k
----
t1:
 (k, i, f)

index-recommendations
SELECT sum(k) FROM t1 GROUP BY i, f, k
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] ASC, [f] ASC
   SQL command: CREATE INDEX ON t1 (k, i, f);

# Test joins with more complex predicates and test queries with more complex
# comparison conditions. See rule 3 and rule 4 in indexrec.FindIndexCandidates.

index-candidates
SELECT t1.f, t2.k, t2.i
FROM t1 FULL JOIN t2
ON t2.k IS NULL
AND t1.f::STRING NOT LIKE t2.i::STRING
----
t1:
 (f)
t2:
 (i)
 (k)
 (k, i)

index-recommendations
SELECT t1.f, t2.k, t2.i
FROM t1 FULL JOIN t2
ON t2.k IS NULL
AND t1.f::STRING NOT LIKE t2.i::STRING
----
index recommendation: create 2 indexes
1. table: t1
   columns: [f] ASC
   SQL command: CREATE INDEX ON t1 (f);
2. table: t2
   columns: [k] ASC, [i] ASC
   SQL command: CREATE INDEX ON t2 (k, i);

index-candidates
SELECT t1.k, t1.s, t2.k, t2.i
FROM t1 LEFT JOIN t2
ON t1.k != t2.k
AND t1.s IS NOT NULL
AND t2.i IS NULL
----
t1:
 (k)
 (k, s)
 (s)
t2:
 (i)
 (i, k)
 (k)

index-recommendations
SELECT t1.k, t1.s, t2.k, t2.i
FROM t1 LEFT JOIN t2
ON t1.k != t2.k
AND t1.s IS NOT NULL
AND t2.i IS NULL
----
index recommendation: create 2 indexes
1. table: t1
   columns: [k] ASC, [s] ASC
   SQL command: CREATE INDEX ON t1 (k, s);
2. table: t2
   columns: [i] ASC, [k] ASC
   SQL command: CREATE INDEX ON t2 (i, k);

index-candidates
SELECT i FROM t1 WHERE k < 3 AND i > 5
----
t1:
 (i)
 (k)
 (k, i)

index-recommendations
SELECT i FROM t1 WHERE k < 3 AND i > 5
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] ASC
   SQL command: CREATE INDEX ON t1 (k, i);

index-candidates
SELECT i FROM t1 WHERE k < 3 AND i > 5 OR f < 7
----
t1:
 (f)
 (i)
 (k)
 (k, i, f)

index-recommendations
SELECT i FROM t1 WHERE k < 3 AND i > 5 OR f < 7
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] ASC, [f] ASC
   SQL command: CREATE INDEX ON t1 (k, i, f);

# Test more complex queries. See rule 5 in indexrec.FindIndexCandidates. The
# aspects of rule 5 that are demonstrated by each test are highlighted the
# test's comment.

# Multi-column combinations used: EQ.
index-candidates
SELECT k, i FROM t1 WHERE k = 1 AND i = 2
----
t1:
 (i)
 (k)
 (k, i)

# No recommendations here. The existing plan is optimal.
index-recommendations
SELECT k, i FROM t1 WHERE k = 1 AND i = 2
----

# Multi-column combinations used: EQ + R.
index-candidates
SELECT * FROM t1 WHERE k = 1 AND f > 0
----
t1:
 (f)
 (k)
 (k, f)

index-recommendations
SELECT * FROM t1 WHERE k = 1 AND f > 0
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [f] ASC
   SQL command: CREATE INDEX ON t1 (k, f);

# Multi-column combinations used: EQ, EQ + R.
index-candidates
SELECT  k, i, f FROM t1 WHERE k = 1 AND i = 2 AND f > 0
----
t1:
 (f)
 (i)
 (k)
 (k, i)
 (k, i, f)

index-recommendations
SELECT k, i, f FROM t1 WHERE k = 1 AND i = 2 AND f > 0
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] ASC, [f] ASC
   SQL command: CREATE INDEX ON t1 (k, i, f);

# Multi-column combinations used: J + R.
index-candidates
SELECT t1.k, t1.f FROM t1 JOIN t2 ON t1.k != t2.k WHERE t1.f > 0
----
t1:
 (f)
 (k)
 (k, f)
t2:
 (k)

index-recommendations
SELECT t1.k, t1.f FROM t1 JOIN t2 ON t1.k != t2.k WHERE t1.f > 0
----
index recommendation: create 2 indexes
1. table: t1
   columns: [k] ASC, [f] ASC
   SQL command: CREATE INDEX ON t1 (k, f);
2. table: t2
   columns: [k] ASC
   SQL command: CREATE INDEX ON t2 (k);

# Multi-column combinations used: EQ, EQ + J.
index-candidates
SELECT t1.i, t1.s FROM t1 JOIN t2 ON t1.k != t2.k WHERE t1.i = 2 AND t1.s = 'NG'
----
t1:
 (i)
 (i, s)
 (i, s, k)
 (k)
 (s)
t2:
 (k)

index-recommendations
SELECT t1.i, t1.s FROM t1 JOIN t2 ON t1.k != t2.k WHERE t1.i = 2 AND t1.s = 'NG'
----
index recommendation: create 2 indexes
1. table: t1
   columns: [i] ASC, [s] ASC, [k] ASC
   SQL command: CREATE INDEX ON t1 (i, s, k);
2. table: t2
   columns: [k] ASC
   SQL command: CREATE INDEX ON t2 (k);

# Multi-column combinations used: EQ, EQ + R, J + R, EQ + J, EQ + J + R.
index-candidates
SELECT count(*)
FROM t1 LEFT JOIN t2
ON t1.k != t2.k
GROUP BY t2.s, t2.i
UNION ALL
SELECT count(*)
FROM (
  SELECT *
  FROM t1
  WHERE t1.f > t1.i
  AND t1.s = 'NG'
)
----
t1:
 (f)
 (f, i)
 (i)
 (k)
 (k, f)
 (k, i)
 (s)
 (s, f)
 (s, i)
 (s, k)
 (s, k, f)
 (s, k, i)
t2:
 (i, s)
 (k)

index-recommendations
SELECT count(*)
FROM t1 LEFT JOIN t2
ON t1.k != t2.k
GROUP BY t2.s, t2.i
UNION ALL
SELECT count(*)
FROM (
  SELECT *
  FROM t1
  WHERE t1.f > t1.i
  AND t1.s = 'NG'
)
----
index recommendation: create 2 indexes
1. table: t1
   columns: [k] ASC
   SQL command: CREATE INDEX ON t1 (k);
2. table: t1
   columns: [s] ASC
   SQL command: CREATE INDEX ON t1 (s);

# No rule 5 multi-column index combinations.
index-candidates
SELECT t1.k, t1.i, t2.i
FROM t1 LEFT JOIN t2
ON t1.k = t2.k
WHERE EXISTS (SELECT * FROM t3 WHERE t3.f > t3.k)
ORDER BY t1.k, t2.i, t1.i DESC
----
t1:
 (k)
 (k, i DESC)
t2:
 (i)
 (k)
t3:
 (f)
 (f, k)
 (k)

index-recommendations
SELECT t1.k, t1.i, t2.i
FROM t1 LEFT JOIN t2
ON t1.k = t2.k
WHERE EXISTS (SELECT * FROM t3 WHERE t3.f > t3.k)
ORDER BY t1.k, t2.i, t1.i DESC
----
index recommendation: create 1 index
1. table: t1
   columns: [k] ASC, [i] DESC
   SQL command: CREATE INDEX ON t1 (k, i DESC);
