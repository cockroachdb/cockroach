# =============================================================================
# select.opt contains exploration rules for the Select operator.
# =============================================================================

# GeneratePartialIndexScans generates a set of unconstrained Scan expressions,
# one for each eligible partial index on the scanned table. A partial index is
# eligible to be scanned if the filters imply the partial index predicate.
#
# Note that this rule differs from both the GenerateIndexScans and
# GenerateConstrainedScans. GenerateIndexScans matches only Scan operators and
# does not deal with filters. GenerateConstrainedScans does not generate
# unconstrained scans. These subtle differences require this rule to be
# separate from the other rules.
#
# The resulting Scan expressions can consist of Scans, Selects, and IndexJoins,
# depending on remaining filters and the columns included in the index. See the
# comment for the GeneratePartialIndexScans custom method for more details and
# examples.
[GeneratePartialIndexScans, Explore]
(Select
    (Scan $scanPrivate:* & (IsCanonicalScan $scanPrivate))
    $filters:*
)
=>
(GeneratePartialIndexScans $scanPrivate $filters)

# GenerateConstrainedScans generates a set of constrained Scan expressions, one
# for each matching index on the scanned table. The expressions consist of
# either a standalone Scan operator (if no remaining filter), or else a Scan
# wrapped by a Select (with a remaining filter). Or, if a secondary index cannot
# provide all the output columns, an IndexJoin is introduced to supply them. See
# the comment for the GenerateConstrainedScans custom method for more details
# and examples.
[GenerateConstrainedScans, Explore]
(Select
    (Scan $scanPrivate:* & (IsCanonicalScan $scanPrivate))
    $filters:*
)
=>
(GenerateConstrainedScans $scanPrivate $filters)

# GenerateInvertedIndexScans creates alternate expressions for filters that can
# be serviced by an inverted index.
[GenerateInvertedIndexScans, Explore]
(Select
    (Scan
        $scanPrivate:* &
            (IsCanonicalScan $scanPrivate) &
            (HasInvertedIndexes $scanPrivate)
    )
    $filters:*
)
=>
(GenerateInvertedIndexScans $scanPrivate $filters)

# GenerateZigzagJoins creates ZigzagJoin operators for all index pairs (of the
# Scan table) where the prefix column(s) of both indexes is/are fixed to
# constant values in the filters. See comments in GenerateZigzagJoin and
# distsqlrun/zigzagjoiner.go for more details on when a zigzag join can be
# planned.
#
# Zigzag joins are prohibited when the source Scan operator has been configured
# with a row-level locking mode. This is mostly out of convenience so that these
# row-level locking modes don't need to added to the ZigzagJoin operator. There
# doesn't seem to be a strong reason to support this, but if one comes up, it
# should be possible to lift this restriction.
[GenerateZigzagJoins, Explore]
(Select
    (Scan $scan:*) & (IsCanonicalScan $scan) & ^(IsLocking $scan)
    $filters:*
)
=>
(GenerateZigzagJoins $scan $filters)

# GenerateInvertedIndexZigzagJoins creates ZigzagJoin operators for inverted
# indexes that can be constrained with two or more distinct constant values.
# Inverted indexes contain one row for each path-to-leaf in a JSON value, so one
# row in the primary index could generate multiple inverted index keys. This
# property can be exploited by zigzag joining on the same inverted index, fixed
# at any two of the JSON paths we are querying for.
#
# Zigzag joins are prohibited when the source Scan operator has been configured
# with a row-level locking mode. This is mostly out of convenience so that these
# row-level locking modes don't need to added to the ZigzagJoin operator. There
# doesn't seem to be a strong reason to support this, but if one comes up, it
# should be possible to lift this restriction.
[GenerateInvertedIndexZigzagJoins, Explore]
(Select
    (Scan $scan:*) &
        (IsCanonicalScan $scan) &
        ^(IsLocking $scan) &
        (HasInvertedIndexes $scan)
    $filters:*
)
=>
(GenerateInvertedIndexZigzagJoins $scan $filters)

# SplitDisjunction splits disjunctions (Or expressions) into a Union of two
# Select expressions, the first containing the left sub-expression of the Or
# expression and the second containing the right sub-expression. All other
# filter items in the original expression are preserved in the new Select
# expressions.
#
# This can produce better query plans in cases where indexes cover both sides of
# the Or expression. The execution plan can use both indexes to satisfy both
# sides of the disjunction and union the results together.
#
# The actual expression generated is a (DistinctOn (UnionAll ...)). This is more
# performant than a (Union ...) when there are many non-key columns of the
# expression. During execution a Union expression has to store and compare all
# columns when de-duplicating rows from its inputs. The generated (DistinctOn
# (UnionAll ...)) de-duplicates rows during the DistinctOn expression, where
# only the key columns are compared.
#
# This rule only matches when the following conditions are true:
#
#   - The Scan within the Select is a canonical scan. Because of this, scan
#     constraints do no need to be duplicated in the left and right scans of the
#     UnionAll.
#   - The Select's output column include a strict key. This is required for
#     generating the DistinctOn expression. SplitDisjunctionAddKey is a similar
#     rule that matches Selects without strict keys.
#   - The newly constructed Selects on the left and right side of the UnionAll
#     have non-zero cardinality. This avoids constructing unnecessary UnionAlls
#     which normalize to Value expressions with zero rows.
#
[SplitDisjunction, Explore]
(Select
    $input:(Scan
            $scanPrivate:* & (IsCanonicalScan $scanPrivate)
        ) &
        (HasStrictKey $input)
    $filters:* &
        (ExprPairSucceeded
            $pair:(ExprPairForSplitDisjunction
                $scanPrivate
                $filters
            )
        ) &
        ^(HasZeroRows
            $leftSelect:(MakeSelect
                $input
                (ReplaceFiltersItem
                    $filters
                    (ExprPairFiltersItemToReplace $pair)
                    (ExprPairLeft $pair)
                )
            )
        ) &
        ^(HasZeroRows
            $rightSelect:(MakeSelect
                $rightScan:(DuplicateScan $input)
                (MapScanFilterCols
                    (ReplaceFiltersItem
                        $filters
                        (ExprPairFiltersItemToReplace $pair)
                        (ExprPairRight $pair)
                    )
                    $input
                    $rightScan
                )
            )
        )
)
=>
(DistinctOn
    (UnionAll
        $leftSelect
        $rightSelect
        (MakeSetPrivateForSplitDisjunction $input $rightScan)
    )
    (MakeAggCols ConstAgg (NonKeyCols $input))
    (MakeGrouping (KeyCols $input) (EmptyOrdering))
)

# SplitDisjunctionAddKey performs a transformation similar to SplitDisjunction,
# but it handles the special case when the original Scan does not have a strict
# key in its output ColSet. The generated DistinctOn requires strict key columns
# in order to de-duplicate rows.
#
# The replace pattern adds primary key columns to the original Scan ColSet. It
# also adds a Project to remove those columns after the DistinctOn expression.
[SplitDisjunctionAddKey, Explore]
(Select
    $input:(Scan
            $scanPrivate:* & (IsCanonicalScan $scanPrivate)
        ) &
        ^(HasStrictKey $input)
    $filters:* &
        (ExprPairSucceeded
            $pair:(ExprPairForSplitDisjunction
                $scanPrivate
                $filters
            )
        ) &
        ^(HasZeroRows
            $leftSelect:(MakeSelect
                $leftScan:(MakeScanAddPrimaryKeyCols
                    $scanPrivate
                )
                (ReplaceFiltersItem
                    $filters
                    (ExprPairFiltersItemToReplace $pair)
                    (ExprPairLeft $pair)
                )
            )
        ) &
        ^(HasZeroRows
            $rightSelect:(MakeSelect
                $rightScan:(DuplicateScan $leftScan)
                (MapScanFilterCols
                    (ReplaceFiltersItem
                        $filters
                        (ExprPairFiltersItemToReplace $pair)
                        (ExprPairRight $pair)
                    )
                    $leftScan
                    $rightScan
                )
            )
        )
)
=>
(Project
    (DistinctOn
        (UnionAll
            $leftSelect
            $rightSelect
            (MakeSetPrivateForSplitDisjunction
                $leftScan
                $rightScan
            )
        )
        (MakeAggCols ConstAgg (NonKeyCols $leftScan))
        (MakeGrouping (KeyCols $leftScan) (EmptyOrdering))
    )
    []
    (OutputCols $input)
)
