# =============================================================================
# limit.opt contains exploration rules for the Limit and Offset operators.
# =============================================================================

# GenerateLimitedScans generates a set of limited Scan operators, one for each
# matching index on the scanned table. If the secondary index cannot provide all
# the output columns, an IndexJoin is introduced to supply them. Pushing a limit
# into Scan operators can substantially reduce the cost of execution, as rows
# are never fetched to begin with, rather than fetched only to be discarded by
# a Limit operator.
[GenerateLimitedScans, Explore]
(Limit
    (Scan $scanPrivate:* & (IsCanonicalScan $scanPrivate))
    (Const $limit:* & (IsPositiveInt $limit))
    $ordering:*
)
=>
(GenerateLimitedScans $scanPrivate $limit $ordering)

# PushLimitIntoConstrainedScan constructs a new Scan operator that adds a hard
# row limit to an existing Scan operator that already has a constraint
# associated with it (added by the ConstrainScans rule). The Scan operator
# always applies the limit after any constraint.
[PushLimitIntoConstrainedScan, Explore]
(Limit
    (Scan $scanPrivate:*)
    (Const $limit:* & (IsPositiveInt $limit))
    $ordering:* &
        (CanLimitConstrainedScan $scanPrivate $ordering)
)
=>
(Scan (LimitScanPrivate $scanPrivate $limit $ordering))

# PushLimitIntoIndexJoin pushes a limit through an index join and constructs a
# new Scan operator that incorporates it. Since index lookup can be expensive,
# it's always better to discard rows beforehand.
#
# TODO(radu): we can similarly push Offset too.
[PushLimitIntoIndexJoin, Explore]
(Limit
    (IndexJoin (Scan $scanPrivate:*) $indexJoinPrivate:*)
    (Const $limit:* & (IsPositiveInt $limit))
    $ordering:* &
        (CanLimitConstrainedScan $scanPrivate $ordering)
)
=>
(IndexJoin
    (Scan (LimitScanPrivate $scanPrivate $limit $ordering))
    $indexJoinPrivate
)

# SplitScanIntoUnionScans splits a scan under a limit into a union of limited
# scans when:
# 1. The limit orders on a single column.
# 2. The scan is constrained.
# 3. The number of keys within the scan's spans is statically known and is less
#    than maxScanCount (defined in SplitScanIntoUnionScans).
# 4. The scan's index includes the limit's ordering column at ordinal position
#    one or greater.
[SplitScanIntoUnionScans, Explore]
(Limit
    $scan:(Scan $scanPrivate:*) &
        (ScanIsConstrained $scanPrivate) &
        ^(ScanIsLimited $scanPrivate)
    $limitExpr:(Const $limit:*) & (IsPositiveInt $limit)
    $ordering:* &
        (Succeeded
            $unionScans:(SplitScanIntoUnionScans
                $ordering
                $scan
                $scanPrivate
                $limit
            )
        )
)
=>
(Limit $unionScans $limitExpr $ordering)
