# =============================================================================
# generic.opt contains exploration rules for optimizing generic query plans.
# =============================================================================

# GenerateParameterizedIndexJoin converts a Select expression with placeholders
# into an IndexJoin. It only applies if the Select filters hold all PK columns
# equal to a placeholder value, and there are no other filters.
#
# For example, consider a schema and query like:
#
#   CREATE TABLE t (k INT PRIMARY KEY, i INT)
#   SELECT * FROM t WHERE k = $1
#
# GenerateParameterizedIndexJoin will perform the transformation below, from a
# Select into a IndexJoin.
#
#   Select (i=$1)         IndexJoin (t)
# 	    |           ->          |
# 	    |                       |
# 	  Scan t                 Values ($1)
#
# The IndexJoin produced by this rule is more efficient than the LookupJoin that
# is ultimately produced by GenerateParameterizedJoin. The narrower capabilities
# of IndexJoins allow for optimizations throughout the optimizer and execution
# engine. And there is a vectorized implementation of IndexJoins, while there is
# not one for LookupJoins currently. Therefore, if this rule applies then it
# disables GenerateParameterizedJoin for the Select's group by setting the
# GeneratedParameterizedIndexJoin AvailableRuleProps.
[GenerateParameterizedIndexJoin, Explore]
(Select
    $scan:(Scan $scanPrivate:*) &
        (GenericRulesEnabled) &
        (IsCanonicalScan $scanPrivate)
    $filters:* &
        (HasPlaceholders (Root)) &
        (Let
            (
                $values
                $indexJoinPrivate
                $ok
            ):(GenerateParameterizedIndexJoin
                (Root)
                $scanPrivate
                $filters
            )
            $ok
        )
)
=>
(IndexJoin $values $indexJoinPrivate)

# GenerateParameterizedJoin converts a Select expression with placeholders and
# stable filter expressions into an InnerJoin that joins the Select's input with
# a Values expression that produces the placeholder values and stable
# expressions. It is more general than GenerateParameterizedIndexJoin.
#
# This rule allows generic query plans, in which placeholder values are not
# known and stable expressions are not folded, to be optimized. By converting
# the Select into an InnerJoin, the optimizer can, in many cases, plan a lookup
# join which has similar performance characteristics to the constrained Scan
# that would be planned if the placeholder values were known.
#
# For example, consider a schema and query like:
#
#   CREATE TABLE t (k INT PRIMARY KEY, i INT, INDEX i_idx (i))
#   SELECT k FROM t WHERE i = $1
#
# GenerateParameterizedJoin will perform the first transformation below, from a
# Select into a Join. GenerateLookupJoins will perform the second transformation
# from a (hash) Join into a LookupJoin.
#
#   Select (i=$1)              Join (i=col_$1)         LookupJoin (t@i_idx)
# 	    |           ->            /   \           ->          |
# 	    |                        /     \                      |
# 	  Scan t             Values ($1)   Scan t              Values ($1)
#
[GenerateParameterizedJoin, Explore]
(Select
    $scan:(Scan $scanPrivate:*) &
        (GenericRulesEnabled) &
        (IsCanonicalScan $scanPrivate)
    $filters:* &
        ^(GeneratedParameterizedIndexJoin (Root)) &
        (HasPlaceholdersOrStableExprs (Root)) &
        (Let
            (
                $values
                $newFilters
                $ok
            ):(GenerateParameterizedJoinValuesAndFilters
                $filters
            )
            $ok
        )
)
=>
(Project
    (InnerJoin
        $values
        $scan
        $newFilters
        (ParameterizedJoinPrivate)
    )
    []
    (OutputCols (Root))
)
