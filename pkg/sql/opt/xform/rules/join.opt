# =============================================================================
# join.opt contains exploration rules for the Join operator.
# =============================================================================

# CommuteJoin creates a Join with the left and right inputs swapped. This is
# useful for other rules that convert joins to other operators (like merge
# join).
[CommuteJoin, Explore]
(InnerJoin | FullJoin
  $left:*
  $right:*
  $on:*
)
=>
((OpName) $right $left $on)

# CommuteLeftJoin creates a Join with the left and right inputs swapped.
[CommuteLeftJoin, Explore]
(LeftJoin
  $left:*
  $right:*
  $on:*
)
=>
(RightJoin $right $left $on)

# CommuteRightJoin creates a Join with the left and right inputs swapped.
[CommuteRightJoin, Explore]
(RightJoin
  $left:*
  $right:*
  $on:*
)
=>
(LeftJoin $right $left $on)

# GenerateMergeJoins creates MergeJoin operators for the join, using the
# interesting orderings property.
[GenerateMergeJoins, Explore]
(JoinNonApply $left:* $right:* $on:*)
=>
(ConstructMergeJoins (OpName) $left $right $on)

# GenerateLookupJoin creates a LookupJoin alternative for a Join which has a
# Scan as its right input.
[GenerateLookupJoin, Explore]
(InnerJoin | LeftJoin
    $left:*
    (Scan $scanDef:*)
    $on:* & (CanUseLookupJoin $left $scanDef $on)
)
=>
(GenerateLookupJoin (OpName) $left $scanDef $on)

# GenerateLookupJoinWithFilter creates a LookupJoin alternative for a Join which
# has a Select->Scan combination as its right input. The filter can get merged
# with the ON condition (this is correct for both inner and left join).
[GenerateLookupJoinWithFilter, Explore]
(InnerJoin | LeftJoin
    $left:*
    (Select
        (Scan $scanDef:*)
        $filter:*
    )
    $on:* & (CanUseLookupJoin $left $scanDef $on)
)
=>
(GenerateLookupJoin (OpName) $left $scanDef (ConcatFilters $on $filter))

# GenerateNonCoveringLookupJoin takes an expression which joins a table that
# uses a non-covering index and produces an expression which performs a lookup
# join on that index, followed by an index join.
#
#     Join                           LookupJoin(t)
#     /   \                               |
#    /     \              ->              |
#  Left  IndexJoin(t)                LookupJoin(t@idx)
#           |                             |
#           |                             |
#         Scan(t@idx)                    Left
#
# Note that the IndexJoin becomes a more general LookupJoin because an IndexJoin
# can only output columns from one table, whereas we also need to output columns
# from Left.
#
# The rule can only be applied when the ON condition doesn't depend on columns
# added by the index join.
#
# Note: this could be a more general PushJoinThroughIndexJoin rule which creates
# a join that can then be converted to a lookup join. However, this currently
# results in too many expressions being considered.
[GenerateNonCoveringLookupJoin, Explore]
(InnerJoin | LeftJoin
    $left:*
    (IndexJoin
        $right:(Scan $scanDef:*)
        $indexJoinDef:*
    )
    $on:* &
        (IsBoundBy $on (OutputCols2 $left $right)) &
        (CanUseLookupJoin $left $scanDef $on)
)
=>
(LookupJoin
   $newJoin:(ConstructLookupJoin (OpName) $left $scanDef $on)
   (True)
   (HoistIndexJoinDef $indexJoinDef $newJoin (OpName))
)

# GenerateNonCoveringLookupJoinWithFilter is similar to
# GenerateNonCoveringLookupJoin, except that it accepts a (Select (Scan))
# complex instead of the Scan. The filter is incorporated with the ON condition
# (see GenerateLookupJoinWithFilter).
[GenerateNonCoveringLookupJoinWithFilter, Explore]
(InnerJoin | LeftJoin
    $left:*
    (IndexJoin
        $right:(Select
            (Scan $scanDef:*)
            $filter:*
        )
        $indexJoinDef:*
    )
    $on:* &
        (IsBoundBy $on (OutputCols2 $left $right)) &
        (CanUseLookupJoin $left $scanDef $on)
)
=>
(LookupJoin
   $newJoin:(ConstructLookupJoin
       (OpName)
       $left
       $scanDef
       (ConcatFilters $on $filter)
   )
   (True)
   (HoistIndexJoinDef $indexJoinDef $newJoin (OpName))
)

# GenerateNonCoveringLookupJoinSplitOn and
# GenerateNonCoveringLookupJoinWithFilterSplitOn are specializations of the
# previous rules for the case of an inner join where only part of the ON
# condition can be evaluated "under" the index join.
#
# This is particularly important because any filters on the results of an inner
# join get pushed into the ON condition; so simply adding a WHERE clause can
# stop the previous rules from running.
#
# TODO(radu): these rules doen't cover left join because of a technicality: if a
# left row has matches in newJoin but has no matches in the lookup join, only
# the looked up columns get NULL-extended (whereas some of the table columns are
# coming from newJoin and those would need to be NULLed out too). The fix would
# be to lookup all columns and discard those from newJoin. This requires a
# top-level projection, as well as an inner projection to avoid having the same
# ColumnID on both sides of the lookup join.
[GenerateNonCoveringLookupJoinSplitOn, Explore]
(InnerJoin
    $left:*
    (IndexJoin
        $right:(Scan $scanDef:*)
        $indexJoinDef:*
    )
    $on:* &
        (CanUseLookupJoin $left $scanDef $on) &
        ^(IsBoundBy $on $innerCols:(OutputCols2 $left $right)) &
        (Filters $onList:[
            ...
            $condition:* & (IsBoundBy $condition $innerCols)
            ...
        ])
)
=>
(LookupJoin
    $newJoin:(ConstructLookupJoin
        InnerJoin
        $left
        $scanDef
        (Filters (ExtractBoundConditions $onList $innerCols))
    )
    (Filters (ExtractUnboundConditions $onList $innerCols))
    (HoistIndexJoinDef $indexJoinDef $newJoin (OpName))
)

[GenerateNonCoveringLookupJoinWithFilterSplitOn, Explore]
(InnerJoin
    $left:*
    (IndexJoin
        $right:(Select
            (Scan $scanDef:*)
            $filter:*
        )
        $indexJoinDef:*
    )
    $on:* &
        (CanUseLookupJoin $left $scanDef $on) &
        ^(IsBoundBy $on $innerCols:(OutputCols2 $left $right)) &
        (Filters $onList:[
            ...
            $condition:* & (IsBoundBy $condition $innerCols)
            ...
        ])
)
=>
(LookupJoin
    $newJoin:(ConstructLookupJoin
        InnerJoin
        $left
        $scanDef
        (ConcatFilters
            (Filters (ExtractBoundConditions $onList $innerCols))
            $filter
        )
    )
    (Filters (ExtractUnboundConditions $onList $innerCols))
    (HoistIndexJoinDef $indexJoinDef $newJoin (OpName))
)
