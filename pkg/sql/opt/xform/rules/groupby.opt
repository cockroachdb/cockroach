# =============================================================================
# groupby.opt contains exploration rules for the groupby operators
# =============================================================================


# ReplaceMinWithLimit replaces a min with a limit 1. This rule may result in a
# lower cost plan if the column min(x) is applied to is indexed.
[ReplaceMinWithLimit, Explore]
(ScalarGroupBy
    $input:*
    [ (AggregationsItem (Min $variable:(Variable $col:*)) $aggPrivate:*) ]
    $groupingPrivate:* & (IsCanonicalGroupBy $groupingPrivate)
)
=>
(ScalarGroupBy
    (Limit
        (Select
            $input
            [ (FiltersItem (IsNot $variable (Null (AnyType)))) ]
        )
        (Const 1)
        (MakeOrderingChoiceFromColumn Min $col)
    )
    [ (AggregationsItem (ConstAgg $variable) $aggPrivate) ]
    $groupingPrivate
)

# ReplaceMaxWithLimit is analogous to the ReplaceMinWithLimit rule.
# Due to limitations with OpName in exploration rules, the rule
# had to be duplicated with minor modifications (we replace occurrences
# of Min with Max)
[ReplaceMaxWithLimit, Explore]
(ScalarGroupBy
    $input:*
    [ (AggregationsItem (Max $variable:(Variable $col:*)) $aggPrivate:*) ]
    $groupingPrivate:* & (IsCanonicalGroupBy $groupingPrivate)
)
=>
(ScalarGroupBy
    (Limit
        (Select
            $input
            [ (FiltersItem (IsNot $variable (Null (AnyType)))) ]
        )
        (Const 1)
        (MakeOrderingChoiceFromColumn Max $col)
    )
    [ (AggregationsItem (ConstAgg $variable) $aggPrivate) ]
    $groupingPrivate
)

# GenerateStreamingGroupBy creates variants of a GroupBy or DistinctOn which
# require more specific orderings on the grouping columns, using the interesting
# orderings property. When we have orderings on grouping columns, we can execute
# aggregations in a streaming fashion which is more efficient.
[GenerateStreamingGroupBy, Explore]
(GroupBy | DistinctOn
    $input:*
    $aggs:*
    $private:* & (IsCanonicalGroupBy $private)
)
=>
(GenerateStreamingGroupBy (OpName) $input $aggs $private)

# GenerateIndexSkipScan creates an index-skip-scan expression
# when we have a DistinctOn a prefix of the index.
[GenerateIndexSkipScan, Explore]
(DistinctOn
    (Scan $scanPrivate:*)
    $aggregations:*
    $groupingPrivate:* &
        (IsIndexPrefix $scanPrivate $groupingCols: (ExtractGroupingCols $groupingPrivate)) &
        (ScanCanProvideOrdering $scanPrivate $ordering:(ExtractGroupingOrdering $groupingPrivate))
)
=>
(IndexSkipScan
    (PruneIndexSkipScanPrivate
        (SynthesizeIndexSkipScanPrivate $scanPrivate (ColSetLen $groupingCols) $ordering)
        (UnionCols
            $groupingCols
            (AggregationCols $aggregations)
        )
    )
)

# GenerateIndexSkipScanThroughIndexJoins creates an index-skip scan
# in place of the scan that is underneath a projection and a DistinctOn
# when possible.
[GenerateIndexSkipScanThroughIndexJoins, Explore]
(DistinctOn
    (IndexJoin
        (Scan $scanPrivate:*)
        $indexJoinPrivate:*
    )
    $aggregations:*
    $groupingPrivate:* &
        (IsIndexPrefix $scanPrivate $groupingCols: (ExtractGroupingCols $groupingPrivate)) &
        (ScanCanProvideOrdering $scanPrivate $ordering: (ExtractGroupingOrdering $groupingPrivate))
)
=>
(LookupJoin
    (IndexSkipScan
        (PruneIndexSkipScanPrivate
            (SynthesizeIndexSkipScanPrivate $scanPrivate (ColSetLen $groupingCols) $ordering)
            (UnionCols
                $groupingCols
                (AggregationCols $aggregations)
            )
        )
    )
    [ ]
    (SynthesizeLookupJoinPrivate $indexJoinPrivate $scanPrivate)
)

# GenerateIndexSkipScanThroughProjection creates an index-skip scan
# in place of the scan that is underneath a projection and a DistinctOn
# when possible.
[GenerateIndexSkipScanThroughProjection, Explore]
(DistinctOn
    (Project
        (Scan $scanPrivate:*)
        $projections:*
        $passthrough:*
    )
    $aggregations:*
    $groupingPrivate:* &
        (IsIndexPrefix $scanPrivate $groupingCols: (ExtractGroupingCols $groupingPrivate)) &
        (ScanCanProvideOrdering $scanPrivate $ordering: (ExtractGroupingOrdering $groupingPrivate))
)
=>
(Project
    (IndexSkipScan
        (PruneIndexSkipScanPrivate
            (SynthesizeIndexSkipScanPrivate $scanPrivate (ColSetLen $groupingCols) $ordering)
            (UnionCols
                $groupingCols
                (AggregationCols $aggregations)
            )
        )
    )
    $projections
    $passthrough
)

# GenerateIndexSkipScanThroughAggregates converts the scan to an index-skip-scan
# by leveraging the AggDistinct clause in the aggregate.
# We can't do this if there is more an one aggregate as the index-skip-scan would
# omit rows the other aggregations would require. Similarly, we can't do this when
# there are grouping columns specified.
[GenerateIndexSkipScanThroughAggregates, Explore]
(GroupBy | ScalarGroupBy
    (Scan $scanPrivate:*)
    $aggregations:[
        (AggregationsItem
            $aggregate:* & (HasDistinctOnIndexPrefix $aggregate $scanPrivate)
        )
    ]
    $groupingPrivate:* &
        (HasNoGroupingCols $groupingPrivate) &
        (ScanCanProvideOrdering $scanPrivate $ordering: (ExtractGroupingOrdering $groupingPrivate))
)
=>
((OpName)
    (IndexSkipScan (SynthesizeSingleColIndexSkipScanPrivate $scanPrivate $ordering))
    (RemoveAggDistinct $aggregations)
    $groupingPrivate
)
