// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructSubquery constructs an expression for the Subquery operator.
func (_f *factory) ConstructSubquery(
	input opt.GroupID,
	projection opt.GroupID,
) opt.GroupID {
	_subqueryExpr := makeSubqueryExpr(input, projection)
	_group := _f.mem.lookupGroupByFingerprint(_subqueryExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_subqueryExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_subqueryExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
// Variable is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnIndex that references the column by index.
func (_f *factory) ConstructVariable(
	col opt.PrivateID,
) opt.GroupID {
	_variableExpr := makeVariableExpr(col)
	_group := _f.mem.lookupGroupByFingerprint(_variableExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_variableExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_variableExpr)))
}

// ConstructConst constructs an expression for the Const operator.
// Const is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
func (_f *factory) ConstructConst(
	value opt.PrivateID,
) opt.GroupID {
	_constExpr := makeConstExpr(value)
	_group := _f.mem.lookupGroupByFingerprint(_constExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_constExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_constExpr)))
}

// ConstructTrue constructs an expression for the True operator.
// True is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
func (_f *factory) ConstructTrue() opt.GroupID {
	_trueExpr := makeTrueExpr()
	_group := _f.mem.lookupGroupByFingerprint(_trueExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_trueExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_trueExpr)))
}

// ConstructFalse constructs an expression for the False operator.
// False is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
func (_f *factory) ConstructFalse() opt.GroupID {
	_falseExpr := makeFalseExpr()
	_group := _f.mem.lookupGroupByFingerprint(_falseExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_falseExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_falseExpr)))
}

// ConstructPlaceholder constructs an expression for the Placeholder operator.
func (_f *factory) ConstructPlaceholder(
	value opt.PrivateID,
) opt.GroupID {
	_placeholderExpr := makePlaceholderExpr(value)
	_group := _f.mem.lookupGroupByFingerprint(_placeholderExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_placeholderExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_placeholderExpr)))
}

// ConstructTuple constructs an expression for the Tuple operator.
func (_f *factory) ConstructTuple(
	elems opt.ListID,
) opt.GroupID {
	_tupleExpr := makeTupleExpr(elems)
	_group := _f.mem.lookupGroupByFingerprint(_tupleExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_tupleExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_tupleExpr)))
}

// ConstructProjections constructs an expression for the Projections operator.
// Projections is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the set of column indexes returned by the expression, as a *ColList.
func (_f *factory) ConstructProjections(
	elems opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_projectionsExpr := makeProjectionsExpr(elems, cols)
	_group := _f.mem.lookupGroupByFingerprint(_projectionsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_projectionsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_projectionsExpr)))
}

// ConstructAggregations constructs an expression for the Aggregations operator.
// Aggregations is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the set of column indexes returned by the expression, as a *ColList.
func (_f *factory) ConstructAggregations(
	aggs opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_aggregationsExpr := makeAggregationsExpr(aggs, cols)
	_group := _f.mem.lookupGroupByFingerprint(_aggregationsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_aggregationsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_aggregationsExpr)))
}

// ConstructGroupings constructs an expression for the Groupings operator.
// Groupings is a set of grouping expressions that will become output columns
// for a containing GroupBy operator. The GroupBy operator groups its input by
// the value of these expressions, and may compute aggregates over the groups.
// The private Cols field contains the set of column indexes returned by the
// expression, as a *ColList.
func (_f *factory) ConstructGroupings(
	elems opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_groupingsExpr := makeGroupingsExpr(elems, cols)
	_group := _f.mem.lookupGroupByFingerprint(_groupingsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_groupingsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_groupingsExpr)))
}

// ConstructExists constructs an expression for the Exists operator.
func (_f *factory) ConstructExists(
	input opt.GroupID,
) opt.GroupID {
	_existsExpr := makeExistsExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_existsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_existsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_existsExpr)))
}

// ConstructAnd constructs an expression for the And operator.
// And is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
func (_f *factory) ConstructAnd(
	conditions opt.ListID,
) opt.GroupID {
	_andExpr := makeAndExpr(conditions)
	_group := _f.mem.lookupGroupByFingerprint(_andExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_andExpr))
	}

	// [EliminateAnd]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_false := _f.mem.lookupNormExpr(_item).asFalse()
			if _false != nil {
				_f.reportOptimization()
				_group = _f.ConstructFalse()
				_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FlattenAnd]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_and := _f.mem.lookupNormExpr(_item).asAnd()
			if _and != nil {
				_f.reportOptimization()
				_group = _f.flattenAnd(conditions)
				_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_andExpr)))
}

// ConstructOr constructs an expression for the Or operator.
// Or is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
func (_f *factory) ConstructOr(
	conditions opt.ListID,
) opt.GroupID {
	_orExpr := makeOrExpr(conditions)
	_group := _f.mem.lookupGroupByFingerprint(_orExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_orExpr))
	}

	// [EliminateOr]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_true := _f.mem.lookupNormExpr(_item).asTrue()
			if _true != nil {
				_f.reportOptimization()
				_group = _f.ConstructTrue()
				_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FlattenOr]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_or := _f.mem.lookupNormExpr(_item).asOr()
			if _or != nil {
				_f.reportOptimization()
				_group = _f.flattenOr(conditions)
				_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_orExpr)))
}

// ConstructNot constructs an expression for the Not operator.
// Not is the boolean negation operator that evaluates to true if its input
// evalutes to false.
func (_f *factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notExpr))
	}

	// [NegateComparison]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if isComparisonLookup[_norm.op] {
			if _f.canInvertComparison(input) {
				_f.reportOptimization()
				_group = _f.invertComparison(input)
				_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [EliminateNot]
	{
		_not := _f.mem.lookupNormExpr(input).asNot()
		if _not != nil {
			input := _not.input()
			_f.reportOptimization()
			_group = input
			_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notExpr)))
}

// ConstructEq constructs an expression for the Eq operator.
func (_f *factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr))
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.reportOptimization()
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [NormalizeTupleEquality]
	{
		_tuple := _f.mem.lookupNormExpr(left).asTuple()
		if _tuple != nil {
			left := _tuple.elems()
			_tuple2 := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple2 != nil {
				right := _tuple2.elems()
				_f.reportOptimization()
				_group = _f.normalizeTupleEquality(left, right)
				_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr)))
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *factory) ConstructLt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_ltExpr := makeLtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_ltExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_ltExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_ltExpr)))
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *factory) ConstructGt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_gtExpr := makeGtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_gtExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_gtExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_gtExpr)))
}

// ConstructLe constructs an expression for the Le operator.
func (_f *factory) ConstructLe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_leExpr := makeLeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_leExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_leExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_leExpr)))
}

// ConstructGe constructs an expression for the Ge operator.
func (_f *factory) ConstructGe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_geExpr := makeGeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_geExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_geExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_geExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *factory) ConstructNe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_neExpr := makeNeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_neExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_neExpr))
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.reportOptimization()
				_group = _f.ConstructNe(right, left)
				_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_neExpr)))
}

// ConstructIn constructs an expression for the In operator.
func (_f *factory) ConstructIn(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_inExpr := makeInExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_inExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_inExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_inExpr)))
}

// ConstructNotIn constructs an expression for the NotIn operator.
func (_f *factory) ConstructNotIn(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notInExpr := makeNotInExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notInExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notInExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notInExpr)))
}

// ConstructLike constructs an expression for the Like operator.
func (_f *factory) ConstructLike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_likeExpr := makeLikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_likeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_likeExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_likeExpr)))
}

// ConstructNotLike constructs an expression for the NotLike operator.
func (_f *factory) ConstructNotLike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notLikeExpr := makeNotLikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notLikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notLikeExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notLikeExpr)))
}

// ConstructILike constructs an expression for the ILike operator.
func (_f *factory) ConstructILike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_iLikeExpr := makeILikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_iLikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_iLikeExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_iLikeExpr)))
}

// ConstructNotILike constructs an expression for the NotILike operator.
func (_f *factory) ConstructNotILike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notILikeExpr := makeNotILikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notILikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notILikeExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notILikeExpr)))
}

// ConstructSimilarTo constructs an expression for the SimilarTo operator.
func (_f *factory) ConstructSimilarTo(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_similarToExpr := makeSimilarToExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_similarToExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_similarToExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_similarToExpr)))
}

// ConstructNotSimilarTo constructs an expression for the NotSimilarTo operator.
func (_f *factory) ConstructNotSimilarTo(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notSimilarToExpr := makeNotSimilarToExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notSimilarToExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notSimilarToExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notSimilarToExpr)))
}

// ConstructRegMatch constructs an expression for the RegMatch operator.
func (_f *factory) ConstructRegMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_regMatchExpr := makeRegMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_regMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_regMatchExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_regMatchExpr)))
}

// ConstructNotRegMatch constructs an expression for the NotRegMatch operator.
func (_f *factory) ConstructNotRegMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notRegMatchExpr := makeNotRegMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notRegMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notRegMatchExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notRegMatchExpr)))
}

// ConstructRegIMatch constructs an expression for the RegIMatch operator.
func (_f *factory) ConstructRegIMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_regIMatchExpr := makeRegIMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_regIMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_regIMatchExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_regIMatchExpr)))
}

// ConstructNotRegIMatch constructs an expression for the NotRegIMatch operator.
func (_f *factory) ConstructNotRegIMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notRegIMatchExpr := makeNotRegIMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notRegIMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notRegIMatchExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notRegIMatchExpr)))
}

// ConstructIs constructs an expression for the Is operator.
func (_f *factory) ConstructIs(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_isExpr := makeIsExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_isExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_isExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_isExpr)))
}

// ConstructIsNot constructs an expression for the IsNot operator.
func (_f *factory) ConstructIsNot(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_isNotExpr := makeIsNotExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_isNotExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_isNotExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_isNotExpr)))
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *factory) ConstructContains(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_containsExpr := makeContainsExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_containsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_containsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_containsExpr)))
}

// ConstructBitand constructs an expression for the Bitand operator.
func (_f *factory) ConstructBitand(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitandExpr := makeBitandExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitandExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_bitandExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_bitandExpr)))
}

// ConstructBitor constructs an expression for the Bitor operator.
func (_f *factory) ConstructBitor(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitorExpr := makeBitorExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitorExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_bitorExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_bitorExpr)))
}

// ConstructBitxor constructs an expression for the Bitxor operator.
func (_f *factory) ConstructBitxor(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitxorExpr := makeBitxorExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitxorExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_bitxorExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_bitxorExpr)))
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *factory) ConstructPlus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_plusExpr := makePlusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_plusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_plusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *factory) ConstructMinus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_minusExpr := makeMinusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_minusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_minusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_minusExpr)))
}

// ConstructMult constructs an expression for the Mult operator.
func (_f *factory) ConstructMult(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_multExpr := makeMultExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_multExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_multExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_multExpr)))
}

// ConstructDiv constructs an expression for the Div operator.
func (_f *factory) ConstructDiv(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_divExpr := makeDivExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_divExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_divExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_divExpr)))
}

// ConstructFloorDiv constructs an expression for the FloorDiv operator.
func (_f *factory) ConstructFloorDiv(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_floorDivExpr := makeFloorDivExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_floorDivExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_floorDivExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_floorDivExpr)))
}

// ConstructMod constructs an expression for the Mod operator.
func (_f *factory) ConstructMod(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_modExpr := makeModExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_modExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_modExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_modExpr)))
}

// ConstructPow constructs an expression for the Pow operator.
func (_f *factory) ConstructPow(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_powExpr := makePowExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_powExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_powExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_powExpr)))
}

// ConstructConcat constructs an expression for the Concat operator.
func (_f *factory) ConstructConcat(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_concatExpr := makeConcatExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_concatExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_concatExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_concatExpr)))
}

// ConstructLShift constructs an expression for the LShift operator.
func (_f *factory) ConstructLShift(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_lShiftExpr := makeLShiftExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_lShiftExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_lShiftExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_lShiftExpr)))
}

// ConstructRShift constructs an expression for the RShift operator.
func (_f *factory) ConstructRShift(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_rShiftExpr := makeRShiftExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_rShiftExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_rShiftExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_rShiftExpr)))
}

// ConstructFetchVal constructs an expression for the FetchVal operator.
func (_f *factory) ConstructFetchVal(
	json opt.GroupID,
	index opt.GroupID,
) opt.GroupID {
	_fetchValExpr := makeFetchValExpr(json, index)
	_group := _f.mem.lookupGroupByFingerprint(_fetchValExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fetchValExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fetchValExpr)))
}

// ConstructFetchText constructs an expression for the FetchText operator.
func (_f *factory) ConstructFetchText(
	json opt.GroupID,
	index opt.GroupID,
) opt.GroupID {
	_fetchTextExpr := makeFetchTextExpr(json, index)
	_group := _f.mem.lookupGroupByFingerprint(_fetchTextExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fetchTextExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fetchTextExpr)))
}

// ConstructFetchValPath constructs an expression for the FetchValPath operator.
func (_f *factory) ConstructFetchValPath(
	json opt.GroupID,
	path opt.GroupID,
) opt.GroupID {
	_fetchValPathExpr := makeFetchValPathExpr(json, path)
	_group := _f.mem.lookupGroupByFingerprint(_fetchValPathExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fetchValPathExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fetchValPathExpr)))
}

// ConstructFetchTextPath constructs an expression for the FetchTextPath operator.
func (_f *factory) ConstructFetchTextPath(
	json opt.GroupID,
	path opt.GroupID,
) opt.GroupID {
	_fetchTextPathExpr := makeFetchTextPathExpr(json, path)
	_group := _f.mem.lookupGroupByFingerprint(_fetchTextPathExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fetchTextPathExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fetchTextPathExpr)))
}

// ConstructUnaryPlus constructs an expression for the UnaryPlus operator.
func (_f *factory) ConstructUnaryPlus(
	input opt.GroupID,
) opt.GroupID {
	_unaryPlusExpr := makeUnaryPlusExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_unaryPlusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_unaryPlusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_unaryPlusExpr)))
}

// ConstructUnaryMinus constructs an expression for the UnaryMinus operator.
func (_f *factory) ConstructUnaryMinus(
	input opt.GroupID,
) opt.GroupID {
	_unaryMinusExpr := makeUnaryMinusExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_unaryMinusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_unaryMinusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_unaryMinusExpr)))
}

// ConstructUnaryComplement constructs an expression for the UnaryComplement operator.
func (_f *factory) ConstructUnaryComplement(
	input opt.GroupID,
) opt.GroupID {
	_unaryComplementExpr := makeUnaryComplementExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_unaryComplementExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_unaryComplementExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_unaryComplementExpr)))
}

// ConstructFunction constructs an expression for the Function operator.
func (_f *factory) ConstructFunction(
	args opt.ListID,
	def opt.PrivateID,
) opt.GroupID {
	_functionExpr := makeFunctionExpr(args, def)
	_group := _f.mem.lookupGroupByFingerprint(_functionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_functionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_functionExpr)))
}

// ConstructScan constructs an expression for the Scan operator.
// Scan returns a result set containing every row in the specified table. Rows
// and columns are not expected to have any particular ordering. The private
// Table field is a Metadata.TableIndex that references an optbase.Table
// definition in the query's metadata.
func (_f *factory) ConstructScan(
	table opt.PrivateID,
) opt.GroupID {
	_scanExpr := makeScanExpr(table)
	_group := _f.mem.lookupGroupByFingerprint(_scanExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_scanExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_scanExpr)))
}

// ConstructValues constructs an expression for the Values operator.
// Values returns a manufactured result set containing a constant number of rows
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order. The Cols field contains the set of column indexes
// returned by each row, as a *ColSet.
func (_f *factory) ConstructValues(
	rows opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_valuesExpr := makeValuesExpr(rows, cols)
	_group := _f.mem.lookupGroupByFingerprint(_valuesExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_valuesExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_valuesExpr)))
}

// ConstructSelect constructs an expression for the Select operator.
// Select filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded.
func (_f *factory) ConstructSelect(
	input opt.GroupID,
	filter opt.GroupID,
) opt.GroupID {
	_selectExpr := makeSelectExpr(input, filter)
	_group := _f.mem.lookupGroupByFingerprint(_selectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_selectExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_selectExpr)))
}

// ConstructProject constructs an expression for the Project operator.
func (_f *factory) ConstructProject(
	input opt.GroupID,
	projections opt.GroupID,
) opt.GroupID {
	_projectExpr := makeProjectExpr(input, projections)
	_group := _f.mem.lookupGroupByFingerprint(_projectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_projectExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_projectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
// InnerJoin creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
func (_f *factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr)))
}

// ConstructLeftJoin constructs an expression for the LeftJoin operator.
func (_f *factory) ConstructLeftJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_leftJoinExpr := makeLeftJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_leftJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_leftJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_leftJoinExpr)))
}

// ConstructRightJoin constructs an expression for the RightJoin operator.
func (_f *factory) ConstructRightJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_rightJoinExpr := makeRightJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_rightJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_rightJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_rightJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *factory) ConstructFullJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_fullJoinExpr := makeFullJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinExpr)))
}

// ConstructSemiJoin constructs an expression for the SemiJoin operator.
func (_f *factory) ConstructSemiJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_semiJoinExpr := makeSemiJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_semiJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_semiJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_semiJoinExpr)))
}

// ConstructAntiJoin constructs an expression for the AntiJoin operator.
func (_f *factory) ConstructAntiJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_antiJoinExpr := makeAntiJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_antiJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_antiJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_antiJoinExpr)))
}

// ConstructInnerJoinApply constructs an expression for the InnerJoinApply operator.
// InnerJoinApply has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
func (_f *factory) ConstructInnerJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_innerJoinApplyExpr := makeInnerJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinApplyExpr)))
}

// ConstructLeftJoinApply constructs an expression for the LeftJoinApply operator.
func (_f *factory) ConstructLeftJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_leftJoinApplyExpr := makeLeftJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_leftJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_leftJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_leftJoinApplyExpr)))
}

// ConstructRightJoinApply constructs an expression for the RightJoinApply operator.
func (_f *factory) ConstructRightJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_rightJoinApplyExpr := makeRightJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_rightJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_rightJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_rightJoinApplyExpr)))
}

// ConstructFullJoinApply constructs an expression for the FullJoinApply operator.
func (_f *factory) ConstructFullJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_fullJoinApplyExpr := makeFullJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinApplyExpr)))
}

// ConstructSemiJoinApply constructs an expression for the SemiJoinApply operator.
func (_f *factory) ConstructSemiJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_semiJoinApplyExpr := makeSemiJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_semiJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_semiJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_semiJoinApplyExpr)))
}

// ConstructAntiJoinApply constructs an expression for the AntiJoinApply operator.
func (_f *factory) ConstructAntiJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_antiJoinApplyExpr := makeAntiJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_antiJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_antiJoinApplyExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_antiJoinApplyExpr)))
}

// ConstructGroupBy constructs an expression for the GroupBy operator.
func (_f *factory) ConstructGroupBy(
	input opt.GroupID,
	groupings opt.GroupID,
	aggregations opt.GroupID,
) opt.GroupID {
	_groupByExpr := makeGroupByExpr(input, groupings, aggregations)
	_group := _f.mem.lookupGroupByFingerprint(_groupByExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_groupByExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_groupByExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
func (_f *factory) ConstructUnion(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_unionExpr := makeUnionExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_unionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_unionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_unionExpr)))
}

// ConstructIntersect constructs an expression for the Intersect operator.
func (_f *factory) ConstructIntersect(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_intersectExpr := makeIntersectExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_intersectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_intersectExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_intersectExpr)))
}

// ConstructExcept constructs an expression for the Except operator.
func (_f *factory) ConstructExcept(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_exceptExpr := makeExceptExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_exceptExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_exceptExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_exceptExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [77]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// SubqueryOp
	dynConstructLookup[opt.SubqueryOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSubquery(children[0], children[1])
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructVariable(private)
	}

	// ConstOp
	dynConstructLookup[opt.ConstOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructConst(private)
	}

	// TrueOp
	dynConstructLookup[opt.TrueOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructTrue()
	}

	// FalseOp
	dynConstructLookup[opt.FalseOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFalse()
	}

	// PlaceholderOp
	dynConstructLookup[opt.PlaceholderOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructPlaceholder(private)
	}

	// TupleOp
	dynConstructLookup[opt.TupleOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructTuple(f.InternList(children))
	}

	// ProjectionsOp
	dynConstructLookup[opt.ProjectionsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructProjections(f.InternList(children), private)
	}

	// AggregationsOp
	dynConstructLookup[opt.AggregationsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAggregations(f.InternList(children), private)
	}

	// GroupingsOp
	dynConstructLookup[opt.GroupingsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructGroupings(f.InternList(children), private)
	}

	// ExistsOp
	dynConstructLookup[opt.ExistsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructExists(children[0])
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAnd(f.InternList(children))
	}

	// OrOp
	dynConstructLookup[opt.OrOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructOr(f.InternList(children))
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNot(children[0])
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLt(children[0], children[1])
	}

	// GtOp
	dynConstructLookup[opt.GtOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructGt(children[0], children[1])
	}

	// LeOp
	dynConstructLookup[opt.LeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLe(children[0], children[1])
	}

	// GeOp
	dynConstructLookup[opt.GeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructGe(children[0], children[1])
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNe(children[0], children[1])
	}

	// InOp
	dynConstructLookup[opt.InOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructIn(children[0], children[1])
	}

	// NotInOp
	dynConstructLookup[opt.NotInOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotIn(children[0], children[1])
	}

	// LikeOp
	dynConstructLookup[opt.LikeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLike(children[0], children[1])
	}

	// NotLikeOp
	dynConstructLookup[opt.NotLikeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotLike(children[0], children[1])
	}

	// ILikeOp
	dynConstructLookup[opt.ILikeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructILike(children[0], children[1])
	}

	// NotILikeOp
	dynConstructLookup[opt.NotILikeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotILike(children[0], children[1])
	}

	// SimilarToOp
	dynConstructLookup[opt.SimilarToOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSimilarTo(children[0], children[1])
	}

	// NotSimilarToOp
	dynConstructLookup[opt.NotSimilarToOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotSimilarTo(children[0], children[1])
	}

	// RegMatchOp
	dynConstructLookup[opt.RegMatchOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructRegMatch(children[0], children[1])
	}

	// NotRegMatchOp
	dynConstructLookup[opt.NotRegMatchOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotRegMatch(children[0], children[1])
	}

	// RegIMatchOp
	dynConstructLookup[opt.RegIMatchOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructRegIMatch(children[0], children[1])
	}

	// NotRegIMatchOp
	dynConstructLookup[opt.NotRegIMatchOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNotRegIMatch(children[0], children[1])
	}

	// IsOp
	dynConstructLookup[opt.IsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructIs(children[0], children[1])
	}

	// IsNotOp
	dynConstructLookup[opt.IsNotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructIsNot(children[0], children[1])
	}

	// ContainsOp
	dynConstructLookup[opt.ContainsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructContains(children[0], children[1])
	}

	// BitandOp
	dynConstructLookup[opt.BitandOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructBitand(children[0], children[1])
	}

	// BitorOp
	dynConstructLookup[opt.BitorOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructBitor(children[0], children[1])
	}

	// BitxorOp
	dynConstructLookup[opt.BitxorOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructBitxor(children[0], children[1])
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructPlus(children[0], children[1])
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructMinus(children[0], children[1])
	}

	// MultOp
	dynConstructLookup[opt.MultOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructMult(children[0], children[1])
	}

	// DivOp
	dynConstructLookup[opt.DivOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructDiv(children[0], children[1])
	}

	// FloorDivOp
	dynConstructLookup[opt.FloorDivOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFloorDiv(children[0], children[1])
	}

	// ModOp
	dynConstructLookup[opt.ModOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructMod(children[0], children[1])
	}

	// PowOp
	dynConstructLookup[opt.PowOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructPow(children[0], children[1])
	}

	// ConcatOp
	dynConstructLookup[opt.ConcatOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructConcat(children[0], children[1])
	}

	// LShiftOp
	dynConstructLookup[opt.LShiftOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLShift(children[0], children[1])
	}

	// RShiftOp
	dynConstructLookup[opt.RShiftOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructRShift(children[0], children[1])
	}

	// FetchValOp
	dynConstructLookup[opt.FetchValOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFetchVal(children[0], children[1])
	}

	// FetchTextOp
	dynConstructLookup[opt.FetchTextOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFetchText(children[0], children[1])
	}

	// FetchValPathOp
	dynConstructLookup[opt.FetchValPathOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFetchValPath(children[0], children[1])
	}

	// FetchTextPathOp
	dynConstructLookup[opt.FetchTextPathOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFetchTextPath(children[0], children[1])
	}

	// UnaryPlusOp
	dynConstructLookup[opt.UnaryPlusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnaryPlus(children[0])
	}

	// UnaryMinusOp
	dynConstructLookup[opt.UnaryMinusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnaryMinus(children[0])
	}

	// UnaryComplementOp
	dynConstructLookup[opt.UnaryComplementOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnaryComplement(children[0])
	}

	// FunctionOp
	dynConstructLookup[opt.FunctionOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFunction(f.InternList(children), private)
	}

	// ScanOp
	dynConstructLookup[opt.ScanOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructScan(private)
	}

	// ValuesOp
	dynConstructLookup[opt.ValuesOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructValues(f.InternList(children), private)
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSelect(children[0], children[1])
	}

	// ProjectOp
	dynConstructLookup[opt.ProjectOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructProject(children[0], children[1])
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoin(children[0], children[1], children[2])
	}

	// LeftJoinOp
	dynConstructLookup[opt.LeftJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLeftJoin(children[0], children[1], children[2])
	}

	// RightJoinOp
	dynConstructLookup[opt.RightJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructRightJoin(children[0], children[1], children[2])
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFullJoin(children[0], children[1], children[2])
	}

	// SemiJoinOp
	dynConstructLookup[opt.SemiJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSemiJoin(children[0], children[1], children[2])
	}

	// AntiJoinOp
	dynConstructLookup[opt.AntiJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAntiJoin(children[0], children[1], children[2])
	}

	// InnerJoinApplyOp
	dynConstructLookup[opt.InnerJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoinApply(children[0], children[1], children[2])
	}

	// LeftJoinApplyOp
	dynConstructLookup[opt.LeftJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLeftJoinApply(children[0], children[1], children[2])
	}

	// RightJoinApplyOp
	dynConstructLookup[opt.RightJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructRightJoinApply(children[0], children[1], children[2])
	}

	// FullJoinApplyOp
	dynConstructLookup[opt.FullJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFullJoinApply(children[0], children[1], children[2])
	}

	// SemiJoinApplyOp
	dynConstructLookup[opt.SemiJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSemiJoinApply(children[0], children[1], children[2])
	}

	// AntiJoinApplyOp
	dynConstructLookup[opt.AntiJoinApplyOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAntiJoinApply(children[0], children[1], children[2])
	}

	// GroupByOp
	dynConstructLookup[opt.GroupByOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructGroupBy(children[0], children[1], children[2])
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnion(children[0], children[1], private)
	}

	// IntersectOp
	dynConstructLookup[opt.IntersectOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructIntersect(children[0], children[1])
	}

	// ExceptOp
	dynConstructLookup[opt.ExceptOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructExcept(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
