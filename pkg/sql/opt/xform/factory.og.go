// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructScan constructs an expression for the Scan operator.
// Scan returns a result set containing every row in the specified table. The
// private Def field is an *opt.ScanOpDef that identifies the table to scan, as
// well as the subset of columns to project from it. Rows and columns are not
// expected to have any particular ordering unless a physical property requires
// it.
func (_f *Factory) ConstructScan(
	def opt.PrivateID,
) opt.GroupID {
	_scanExpr := makeScanExpr(def)
	_group := _f.mem.lookupGroupByFingerprint(_scanExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_scanExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_scanExpr)))
}

// ConstructValues constructs an expression for the Values operator.
// Values returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as a *ColList. It is legal for Cols to be empty.
func (_f *Factory) ConstructValues(
	rows opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_valuesExpr := makeValuesExpr(rows, cols)
	_group := _f.mem.lookupGroupByFingerprint(_valuesExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_valuesExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_valuesExpr)))
}

// ConstructSelect constructs an expression for the Select operator.
// Select filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded. While
// the Filter operand can be any boolean expression, normalization rules will
// typically convert it to a Filters operator in order to make conjunction list
// matching easier.
func (_f *Factory) ConstructSelect(
	input opt.GroupID,
	filter opt.GroupID,
) opt.GroupID {
	_selectExpr := makeSelectExpr(input, filter)
	_group := _f.mem.lookupGroupByFingerprint(_selectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_selectExpr))
	}

	// [EnsureSelectFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(filter).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureSelectFiltersAnd)
			_group = _f.ConstructSelect(input, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureSelectFilters]
	{
		_norm := _f.mem.lookupNormExpr(filter)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureSelectFilters)
			_group = _f.ConstructSelect(input, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EliminateSelect]
	{
		_true := _f.mem.lookupNormExpr(filter).asTrue()
		if _true != nil {
			_f.o.reportOptimization(EliminateSelect)
			_group = input
			_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [MergeSelects]
	{
		_select := _f.mem.lookupNormExpr(input).asSelect()
		if _select != nil {
			input := _select.input()
			innerFilter := _select.filter()
			_f.o.reportOptimization(MergeSelects)
			_group = _f.ConstructSelect(input, _f.concatFilters(innerFilter, filter))
			_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownSelectJoinLeft]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.op == opt.InnerJoinOp || _norm.op == opt.InnerJoinApplyOp || _norm.op == opt.LeftJoinOp || _norm.op == opt.LeftJoinApplyOp {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			on := _norm.childGroup(_f.mem, 2)
			_filters := _f.mem.lookupNormExpr(filter).asFilters()
			if _filters != nil {
				list := _filters.conditions()
				for _, _item := range _f.mem.lookupList(_filters.conditions()) {
					condition := _item
					if !_f.isCorrelated(condition, right) {
						_f.o.reportOptimization(PushDownSelectJoinLeft)
						_group = _f.ConstructSelect(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, opt.DynamicOperands{opt.DynamicID(_f.ConstructSelect(left, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, right)))), opt.DynamicID(right), opt.DynamicID(on)}), _f.ConstructFilters(_f.extractCorrelatedConditions(list, right)))
						_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	// [PushDownSelectJoinRight]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.op == opt.InnerJoinOp || _norm.op == opt.InnerJoinApplyOp || _norm.op == opt.RightJoinOp || _norm.op == opt.RightJoinApplyOp {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			on := _norm.childGroup(_f.mem, 2)
			_filters := _f.mem.lookupNormExpr(filter).asFilters()
			if _filters != nil {
				list := _filters.conditions()
				for _, _item := range _f.mem.lookupList(_filters.conditions()) {
					condition := _item
					if !_f.isCorrelated(condition, left) {
						_f.o.reportOptimization(PushDownSelectJoinRight)
						_group = _f.ConstructSelect(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, opt.DynamicOperands{opt.DynamicID(left), opt.DynamicID(_f.ConstructSelect(right, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, left)))), opt.DynamicID(on)}), _f.ConstructFilters(_f.extractCorrelatedConditions(list, left)))
						_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	// [MergeSelectInnerJoin]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.op == opt.InnerJoinOp || _norm.op == opt.InnerJoinApplyOp {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			on := _norm.childGroup(_f.mem, 2)
			_f.o.reportOptimization(MergeSelectInnerJoin)
			_group = _f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, opt.DynamicOperands{opt.DynamicID(left), opt.DynamicID(right), opt.DynamicID(_f.concatFilters(on, filter))})
			_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownSelectGroupBy]
	{
		_groupBy := _f.mem.lookupNormExpr(input).asGroupBy()
		if _groupBy != nil {
			input := _groupBy.input()
			aggregations := _groupBy.aggregations()
			groupingCols := _groupBy.groupingCols()
			if !_f.emptyGroupingCols(groupingCols) {
				_filters := _f.mem.lookupNormExpr(filter).asFilters()
				if _filters != nil {
					list := _filters.conditions()
					for _, _item := range _f.mem.lookupList(_filters.conditions()) {
						condition := _item
						if !_f.isCorrelated(condition, aggregations) {
							_f.o.reportOptimization(PushDownSelectGroupBy)
							_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructSelect(input, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, aggregations))), aggregations, groupingCols), _f.ConstructFilters(_f.extractCorrelatedConditions(list, aggregations)))
							_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_selectExpr)))
}

// ConstructProject constructs an expression for the Project operator.
// Project modifies the set of columns returned by the input result set. Columns
// can be removed, reordered, or renamed. In addition, new columns can be
// synthesized. Projections is a scalar Projections list operator that contains
// the list of expressions that describe the output columns. The Cols field of
// the Projections operator provides the indexes of each of the output columns.
func (_f *Factory) ConstructProject(
	input opt.GroupID,
	projections opt.GroupID,
) opt.GroupID {
	_projectExpr := makeProjectExpr(input, projections)
	_group := _f.mem.lookupGroupByFingerprint(_projectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_projectExpr))
	}

	// [EliminateProject]
	{
		if _f.hasSameCols(input, projections) {
			_f.o.reportOptimization(EliminateProject)
			_group = input
			_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FilterUnusedProjectCols]
	{
		_project := _f.mem.lookupNormExpr(input).asProject()
		if _project != nil {
			innerInput := _project.input()
			innerProjections := _project.projections()
			if _f.hasUnusedColumns(innerProjections, _f.neededCols(projections)) {
				_f.o.reportOptimization(FilterUnusedProjectCols)
				_group = _f.ConstructProject(_f.ConstructProject(innerInput, _f.filterUnusedColumns(innerProjections, _f.neededCols(projections))), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedScanCols]
	{
		_scan := _f.mem.lookupNormExpr(input).asScan()
		if _scan != nil {
			if _f.hasUnusedColumns(input, _f.neededCols(projections)) {
				_f.o.reportOptimization(FilterUnusedScanCols)
				_group = _f.ConstructProject(_f.filterUnusedColumns(input, _f.neededCols(projections)), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedSelectCols]
	{
		_select := _f.mem.lookupNormExpr(input).asSelect()
		if _select != nil {
			innerInput := _select.input()
			filter := _select.filter()
			if _f.hasUnusedColumns(innerInput, _f.neededCols2(projections, filter)) {
				_f.o.reportOptimization(FilterUnusedSelectCols)
				_group = _f.ConstructProject(_f.ConstructSelect(_f.filterUnusedColumns(innerInput, _f.neededCols2(projections, filter)), filter), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedLimitCols]
	{
		_limit := _f.mem.lookupNormExpr(input).asLimit()
		if _limit != nil {
			input := _limit.input()
			limit := _limit.limit()
			ordering := _limit.ordering()
			if _f.hasUnusedColumns(input, _f.neededColsLimit(projections, ordering)) {
				_f.o.reportOptimization(FilterUnusedLimitCols)
				_group = _f.ConstructProject(_f.ConstructLimit(_f.filterUnusedColumns(input, _f.neededColsLimit(projections, ordering)), limit, ordering), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedOffsetCols]
	{
		_offset := _f.mem.lookupNormExpr(input).asOffset()
		if _offset != nil {
			input := _offset.input()
			offset := _offset.offset()
			ordering := _offset.ordering()
			if _f.hasUnusedColumns(input, _f.neededColsLimit(projections, ordering)) {
				_f.o.reportOptimization(FilterUnusedOffsetCols)
				_group = _f.ConstructProject(_f.ConstructOffset(_f.filterUnusedColumns(input, _f.neededColsLimit(projections, ordering)), offset, ordering), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedJoinLeftCols]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.isJoin() {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			on := _norm.childGroup(_f.mem, 2)
			if _f.hasUnusedColumns(left, _f.neededCols3(projections, right, on)) {
				_f.o.reportOptimization(FilterUnusedJoinLeftCols)
				_group = _f.ConstructProject(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, opt.DynamicOperands{opt.DynamicID(_f.filterUnusedColumns(left, _f.neededCols3(projections, right, on))), opt.DynamicID(right), opt.DynamicID(on)}), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedJoinRightCols]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.isJoin() {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			on := _norm.childGroup(_f.mem, 2)
			if _f.hasUnusedColumns(right, _f.neededCols2(projections, on)) {
				_f.o.reportOptimization(FilterUnusedJoinRightCols)
				_group = _f.ConstructProject(_f.DynamicConstruct(_f.mem.lookupNormExpr(input).op, opt.DynamicOperands{opt.DynamicID(left), opt.DynamicID(_f.filterUnusedColumns(right, _f.neededCols2(projections, on))), opt.DynamicID(on)}), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedAggCols]
	{
		_groupBy := _f.mem.lookupNormExpr(input).asGroupBy()
		if _groupBy != nil {
			innerInput := _groupBy.input()
			aggregations := _groupBy.aggregations()
			groupingCols := _groupBy.groupingCols()
			if _f.hasUnusedColumns(aggregations, _f.neededCols(projections)) {
				_f.o.reportOptimization(FilterUnusedAggCols)
				_group = _f.ConstructProject(_f.ConstructGroupBy(innerInput, _f.filterUnusedColumns(aggregations, _f.neededCols(projections)), groupingCols), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FilterUnusedValueCols]
	{
		_values := _f.mem.lookupNormExpr(input).asValues()
		if _values != nil {
			if _f.hasUnusedColumns(input, _f.neededCols(projections)) {
				_f.o.reportOptimization(FilterUnusedValueCols)
				_group = _f.ConstructProject(_f.filterUnusedColumns(input, _f.neededCols(projections)), projections)
				_f.mem.addAltFingerprint(_projectExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_projectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
// InnerJoin creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
func (_f *Factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructInnerJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructInnerJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinLeft]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.o.reportOptimization(PushDownJoinLeft)
					_group = _f.ConstructInnerJoin(_f.ConstructSelect(left, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, right))), right, _f.ConstructFilters(_f.extractCorrelatedConditions(list, right)))
					_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [PushDownJoinRight]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, left) {
					_f.o.reportOptimization(PushDownJoinRight)
					_group = _f.ConstructInnerJoin(left, _f.ConstructSelect(right, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, left))), _f.ConstructFilters(_f.extractCorrelatedConditions(list, left)))
					_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr)))
}

// ConstructLeftJoin constructs an expression for the LeftJoin operator.
func (_f *Factory) ConstructLeftJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_leftJoinExpr := makeLeftJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_leftJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_leftJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructLeftJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_leftJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructLeftJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_leftJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinRight]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, left) {
					_f.o.reportOptimization(PushDownJoinRight)
					_group = _f.ConstructLeftJoin(left, _f.ConstructSelect(right, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, left))), _f.ConstructFilters(_f.extractCorrelatedConditions(list, left)))
					_f.mem.addAltFingerprint(_leftJoinExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_leftJoinExpr)))
}

// ConstructRightJoin constructs an expression for the RightJoin operator.
func (_f *Factory) ConstructRightJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_rightJoinExpr := makeRightJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_rightJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_rightJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructRightJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_rightJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructRightJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_rightJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinLeft]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.o.reportOptimization(PushDownJoinLeft)
					_group = _f.ConstructRightJoin(_f.ConstructSelect(left, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, right))), right, _f.ConstructFilters(_f.extractCorrelatedConditions(list, right)))
					_f.mem.addAltFingerprint(_rightJoinExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_rightJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *Factory) ConstructFullJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_fullJoinExpr := makeFullJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fullJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructFullJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_fullJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructFullJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_fullJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fullJoinExpr)))
}

// ConstructSemiJoin constructs an expression for the SemiJoin operator.
func (_f *Factory) ConstructSemiJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_semiJoinExpr := makeSemiJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_semiJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_semiJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructSemiJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_semiJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructSemiJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_semiJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_semiJoinExpr)))
}

// ConstructAntiJoin constructs an expression for the AntiJoin operator.
func (_f *Factory) ConstructAntiJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_antiJoinExpr := makeAntiJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_antiJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_antiJoinExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructAntiJoin(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_antiJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructAntiJoin(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_antiJoinExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_antiJoinExpr)))
}

// ConstructInnerJoinApply constructs an expression for the InnerJoinApply operator.
// InnerJoinApply has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
func (_f *Factory) ConstructInnerJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_innerJoinApplyExpr := makeInnerJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_innerJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructInnerJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_innerJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructInnerJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_innerJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinLeft]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.o.reportOptimization(PushDownJoinLeft)
					_group = _f.ConstructInnerJoinApply(_f.ConstructSelect(left, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, right))), right, _f.ConstructFilters(_f.extractCorrelatedConditions(list, right)))
					_f.mem.addAltFingerprint(_innerJoinApplyExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [PushDownJoinRight]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, left) {
					_f.o.reportOptimization(PushDownJoinRight)
					_group = _f.ConstructInnerJoinApply(left, _f.ConstructSelect(right, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, left))), _f.ConstructFilters(_f.extractCorrelatedConditions(list, left)))
					_f.mem.addAltFingerprint(_innerJoinApplyExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_innerJoinApplyExpr)))
}

// ConstructLeftJoinApply constructs an expression for the LeftJoinApply operator.
func (_f *Factory) ConstructLeftJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_leftJoinApplyExpr := makeLeftJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_leftJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_leftJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructLeftJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_leftJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructLeftJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_leftJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinRight]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, left) {
					_f.o.reportOptimization(PushDownJoinRight)
					_group = _f.ConstructLeftJoinApply(left, _f.ConstructSelect(right, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, left))), _f.ConstructFilters(_f.extractCorrelatedConditions(list, left)))
					_f.mem.addAltFingerprint(_leftJoinApplyExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_leftJoinApplyExpr)))
}

// ConstructRightJoinApply constructs an expression for the RightJoinApply operator.
func (_f *Factory) ConstructRightJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_rightJoinApplyExpr := makeRightJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_rightJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_rightJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructRightJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_rightJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructRightJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_rightJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [PushDownJoinLeft]
	{
		_filters := _f.mem.lookupNormExpr(on).asFilters()
		if _filters != nil {
			list := _filters.conditions()
			for _, _item := range _f.mem.lookupList(_filters.conditions()) {
				condition := _item
				if !_f.isCorrelated(condition, right) {
					_f.o.reportOptimization(PushDownJoinLeft)
					_group = _f.ConstructRightJoinApply(_f.ConstructSelect(left, _f.ConstructFilters(_f.extractUncorrelatedConditions(list, right))), right, _f.ConstructFilters(_f.extractCorrelatedConditions(list, right)))
					_f.mem.addAltFingerprint(_rightJoinApplyExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_rightJoinApplyExpr)))
}

// ConstructFullJoinApply constructs an expression for the FullJoinApply operator.
func (_f *Factory) ConstructFullJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_fullJoinApplyExpr := makeFullJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fullJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructFullJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_fullJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructFullJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_fullJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fullJoinApplyExpr)))
}

// ConstructSemiJoinApply constructs an expression for the SemiJoinApply operator.
func (_f *Factory) ConstructSemiJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_semiJoinApplyExpr := makeSemiJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_semiJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_semiJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructSemiJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_semiJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructSemiJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_semiJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_semiJoinApplyExpr)))
}

// ConstructAntiJoinApply constructs an expression for the AntiJoinApply operator.
func (_f *Factory) ConstructAntiJoinApply(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_antiJoinApplyExpr := makeAntiJoinApplyExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_antiJoinApplyExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_antiJoinApplyExpr))
	}

	// [EnsureJoinFiltersAnd]
	{
		_and := _f.mem.lookupNormExpr(on).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(EnsureJoinFiltersAnd)
			_group = _f.ConstructAntiJoinApply(left, right, _f.ConstructFilters(conditions))
			_f.mem.addAltFingerprint(_antiJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EnsureJoinFilters]
	{
		filter := on
		_norm := _f.mem.lookupNormExpr(on)
		if !(_norm.op == opt.FiltersOp || _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp) {
			_f.o.reportOptimization(EnsureJoinFilters)
			_group = _f.ConstructAntiJoinApply(left, right, _f.ConstructFilters(_f.mem.internList([]opt.GroupID{filter})))
			_f.mem.addAltFingerprint(_antiJoinApplyExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_antiJoinApplyExpr)))
}

// ConstructGroupBy constructs an expression for the GroupBy operator.
// GroupBy is an operator that is used for performing aggregations (for queries
// with aggregate functions, HAVING clauses and/or group by expressions). It
// groups results that are equal on the grouping columns and computes
// aggregations as described by Aggregations (which is always an Aggregations
// operator). The arguments of the aggregations are columns from the input.
func (_f *Factory) ConstructGroupBy(
	input opt.GroupID,
	aggregations opt.GroupID,
	groupingCols opt.PrivateID,
) opt.GroupID {
	_groupByExpr := makeGroupByExpr(input, aggregations, groupingCols)
	_group := _f.mem.lookupGroupByFingerprint(_groupByExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_groupByExpr))
	}

	// [FilterUnusedGroupByCols]
	{
		if _f.hasUnusedColumns(input, _f.neededColsGroupBy(aggregations, groupingCols)) {
			_f.o.reportOptimization(FilterUnusedGroupByCols)
			_group = _f.ConstructGroupBy(_f.filterUnusedColumns(input, _f.neededColsGroupBy(aggregations, groupingCols)), aggregations, groupingCols)
			_f.mem.addAltFingerprint(_groupByExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_groupByExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
// Union is an operator used to combine the Left and Right input relations into
// a single set containing rows from both inputs. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Union with the output columns. See the comment above opt.SetOpColMap
// for more details.
func (_f *Factory) ConstructUnion(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_unionExpr := makeUnionExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_unionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unionExpr)))
}

// ConstructIntersect constructs an expression for the Intersect operator.
// Intersect is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that are also present in the Right relation. Duplicate rows are
// discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Intersect with the output columns. See the comment above
// opt.SetOpColMap for more details.
func (_f *Factory) ConstructIntersect(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_intersectExpr := makeIntersectExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_intersectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_intersectExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_intersectExpr)))
}

// ConstructExcept constructs an expression for the Except operator.
// Except is an operator used to perform a set difference between the Left and
// Right input relations. The result consists only of rows in the Left relation
// that are not present in the Right relation. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Except with the output columns. See the comment above opt.SetOpColMap
// for more details.
func (_f *Factory) ConstructExcept(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_exceptExpr := makeExceptExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_exceptExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_exceptExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_exceptExpr)))
}

// ConstructUnionAll constructs an expression for the UnionAll operator.
// UnionAll is an operator used to combine the Left and Right input relations
// into a single set containing rows from both inputs. Duplicate rows are
// not discarded. For example:
//   SELECT x FROM xx UNION ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       2    ->    1
//     2       3          1
//                        2
//                        2
//                        3
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the UnionAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
func (_f *Factory) ConstructUnionAll(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_unionAllExpr := makeUnionAllExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_unionAllExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unionAllExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unionAllExpr)))
}

// ConstructIntersectAll constructs an expression for the IntersectAll operator.
// IntersectAll is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that have a corresponding row in the Right relation. Duplicate rows
// are not discarded. This effectively creates a one-to-one mapping between the
// Left and Right rows. For example:
//   SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       1    ->    1
//     1       2          2
//     2       2          2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the IntersectAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
func (_f *Factory) ConstructIntersectAll(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_intersectAllExpr := makeIntersectAllExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_intersectAllExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_intersectAllExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_intersectAllExpr)))
}

// ConstructExceptAll constructs an expression for the ExceptAll operator.
// ExceptAll is an operator used to perform a set difference between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that do not have a corresponding row in the Right relation.
// Duplicate rows are not discarded. This effectively creates a one-to-one
// mapping between the Left and Right rows. For example:
//   SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1    ->    1
//     1       1          4
//     1       2
//     2       2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the ExceptAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
func (_f *Factory) ConstructExceptAll(
	left opt.GroupID,
	right opt.GroupID,
	colMap opt.PrivateID,
) opt.GroupID {
	_exceptAllExpr := makeExceptAllExpr(left, right, colMap)
	_group := _f.mem.lookupGroupByFingerprint(_exceptAllExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_exceptAllExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_exceptAllExpr)))
}

// ConstructLimit constructs an expression for the Limit operator.
// Limit returns a limited subset of the results in the input relation.
// The limit expression is a scalar value; the operator returns at most this many
// rows. The private field is an *opt.Ordering which indicates the desired
// row ordering (the first rows with respect to this ordering are returned).
func (_f *Factory) ConstructLimit(
	input opt.GroupID,
	limit opt.GroupID,
	ordering opt.PrivateID,
) opt.GroupID {
	_limitExpr := makeLimitExpr(input, limit, ordering)
	_group := _f.mem.lookupGroupByFingerprint(_limitExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_limitExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_limitExpr)))
}

// ConstructOffset constructs an expression for the Offset operator.
// Offset filters out the first Offset rows of the input relation; used in
// conjunction with Limit.
func (_f *Factory) ConstructOffset(
	input opt.GroupID,
	offset opt.GroupID,
	ordering opt.PrivateID,
) opt.GroupID {
	_offsetExpr := makeOffsetExpr(input, offset, ordering)
	_group := _f.mem.lookupGroupByFingerprint(_offsetExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_offsetExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_offsetExpr)))
}

// ConstructSubquery constructs an expression for the Subquery operator.
func (_f *Factory) ConstructSubquery(
	input opt.GroupID,
	projection opt.GroupID,
) opt.GroupID {
	_subqueryExpr := makeSubqueryExpr(input, projection)
	_group := _f.mem.lookupGroupByFingerprint(_subqueryExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_subqueryExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_subqueryExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
// Variable is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnIndex that references the column by index.
func (_f *Factory) ConstructVariable(
	col opt.PrivateID,
) opt.GroupID {
	_variableExpr := makeVariableExpr(col)
	_group := _f.mem.lookupGroupByFingerprint(_variableExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_variableExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_variableExpr)))
}

// ConstructConst constructs an expression for the Const operator.
// Const is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
func (_f *Factory) ConstructConst(
	value opt.PrivateID,
) opt.GroupID {
	_constExpr := makeConstExpr(value)
	_group := _f.mem.lookupGroupByFingerprint(_constExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_constExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_constExpr)))
}

// ConstructNull constructs an expression for the Null operator.
// Null is the constant SQL null value that has "unknown value" semantics. If
// the Typ field is not types.Unknown, then the value is known to be in the
// domain of that type. This is important for preserving correct types in
// replacement patterns. For example:
//   (Plus (Function ...) (Const 1))
//
// If the function in that expression has a static type of Int, but then it gets
// constant folded to (Null), then its type must remain as Int. Any other type
// violates logical equivalence of the expression, breaking type inference and
// possibly changing the results of execution. The solution is to tag the null
// with the correct type:
//   (Plus (Null (Int)) (Const 1))
//
// Null is its own operator rather than a Const datum in order to make matching
// and replacement easier and more efficient, as patterns can contain (Null)
// expressions.
func (_f *Factory) ConstructNull(
	typ opt.PrivateID,
) opt.GroupID {
	_nullExpr := makeNullExpr(typ)
	_group := _f.mem.lookupGroupByFingerprint(_nullExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_nullExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_nullExpr)))
}

// ConstructTrue constructs an expression for the True operator.
// True is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
func (_f *Factory) ConstructTrue() opt.GroupID {
	_trueExpr := makeTrueExpr()
	_group := _f.mem.lookupGroupByFingerprint(_trueExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_trueExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_trueExpr)))
}

// ConstructFalse constructs an expression for the False operator.
// False is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
func (_f *Factory) ConstructFalse() opt.GroupID {
	_falseExpr := makeFalseExpr()
	_group := _f.mem.lookupGroupByFingerprint(_falseExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_falseExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_falseExpr)))
}

// ConstructPlaceholder constructs an expression for the Placeholder operator.
func (_f *Factory) ConstructPlaceholder(
	value opt.PrivateID,
) opt.GroupID {
	_placeholderExpr := makePlaceholderExpr(value)
	_group := _f.mem.lookupGroupByFingerprint(_placeholderExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_placeholderExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_placeholderExpr)))
}

// ConstructTuple constructs an expression for the Tuple operator.
func (_f *Factory) ConstructTuple(
	elems opt.ListID,
) opt.GroupID {
	_tupleExpr := makeTupleExpr(elems)
	_group := _f.mem.lookupGroupByFingerprint(_tupleExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_tupleExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_tupleExpr)))
}

// ConstructProjections constructs an expression for the Projections operator.
// Projections is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *opt.ColList. It
// is not legal for Cols to be empty.
func (_f *Factory) ConstructProjections(
	elems opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_projectionsExpr := makeProjectionsExpr(elems, cols)
	_group := _f.mem.lookupGroupByFingerprint(_projectionsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_projectionsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_projectionsExpr)))
}

// ConstructAggregations constructs an expression for the Aggregations operator.
// Aggregations is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *ColList. It
// is legal for Cols to be empty.
func (_f *Factory) ConstructAggregations(
	aggs opt.ListID,
	cols opt.PrivateID,
) opt.GroupID {
	_aggregationsExpr := makeAggregationsExpr(aggs, cols)
	_group := _f.mem.lookupGroupByFingerprint(_aggregationsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_aggregationsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_aggregationsExpr)))
}

// ConstructExists constructs an expression for the Exists operator.
func (_f *Factory) ConstructExists(
	input opt.GroupID,
) opt.GroupID {
	_existsExpr := makeExistsExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_existsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_existsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_existsExpr)))
}

// ConstructFilters constructs an expression for the Filters operator.
// Filters is a boolean And operator that only appears as the Filters child of
// a Select operator, or the On child of a Join operator. For example:
//   (Select
//     (Scan a)
//     (Filters (Gt (Variable a) 1) (Lt (Variable a) 5))
//   )
//
// Normalization rules ensure that a Filters expression is always created if
// there is at least one condition, so that other rules can rely on its presence
// when matching, even in the case where there is only one condition. The
// semantics of the Filters operator are identical to those of the And operator.
func (_f *Factory) ConstructFilters(
	conditions opt.ListID,
) opt.GroupID {
	_filtersExpr := makeFiltersExpr(conditions)
	_group := _f.mem.lookupGroupByFingerprint(_filtersExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_filtersExpr))
	}

	// [EliminateEmptyAnd]
	{
		if conditions.Length == 0 {
			_f.o.reportOptimization(EliminateEmptyAnd)
			_group = _f.ConstructTrue()
			_f.mem.addAltFingerprint(_filtersExpr.fingerprint(), _group)
			return _group
		}
	}

	// [SimplifyFilters]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_norm := _f.mem.lookupNormExpr(_item)
			if _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp || _norm.op == opt.NullOp {
				_f.o.reportOptimization(SimplifyFilters)
				_group = _f.simplifyFilters(conditions)
				_f.mem.addAltFingerprint(_filtersExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_filtersExpr)))
}

// ConstructAnd constructs an expression for the And operator.
// And is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
func (_f *Factory) ConstructAnd(
	conditions opt.ListID,
) opt.GroupID {
	_andExpr := makeAndExpr(conditions)
	_group := _f.mem.lookupGroupByFingerprint(_andExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_andExpr))
	}

	// [EliminateEmptyAnd]
	{
		if conditions.Length == 0 {
			_f.o.reportOptimization(EliminateEmptyAnd)
			_group = _f.ConstructTrue()
			_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EliminateSingletonAndOr]
	{
		if conditions.Length == 1 {
			_item := _f.mem.lookupList(conditions)[0]
			item := _item
			_f.o.reportOptimization(EliminateSingletonAndOr)
			_group = item
			_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
			return _group
		}
	}

	// [SimplifyAnd]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_norm := _f.mem.lookupNormExpr(_item)
			if _norm.op == opt.AndOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp {
				_f.o.reportOptimization(SimplifyAnd)
				_group = _f.simplifyAnd(conditions)
				_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullAndOr]
	{
		if conditions.Length > 0 {
			_item := _f.mem.lookupList(conditions)[0]
			_null := _f.mem.lookupNormExpr(_item).asNull()
			if _null != nil {
				if _f.listOnlyHasNulls(conditions) {
					_f.o.reportOptimization(FoldNullAndOr)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_andExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_andExpr)))
}

// ConstructOr constructs an expression for the Or operator.
// Or is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
func (_f *Factory) ConstructOr(
	conditions opt.ListID,
) opt.GroupID {
	_orExpr := makeOrExpr(conditions)
	_group := _f.mem.lookupGroupByFingerprint(_orExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_orExpr))
	}

	// [EliminateEmptyOr]
	{
		if conditions.Length == 0 {
			_f.o.reportOptimization(EliminateEmptyOr)
			_group = _f.ConstructFalse()
			_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
			return _group
		}
	}

	// [EliminateSingletonAndOr]
	{
		if conditions.Length == 1 {
			_item := _f.mem.lookupList(conditions)[0]
			item := _item
			_f.o.reportOptimization(EliminateSingletonAndOr)
			_group = item
			_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
			return _group
		}
	}

	// [SimplifyOr]
	{
		for _, _item := range _f.mem.lookupList(conditions) {
			_norm := _f.mem.lookupNormExpr(_item)
			if _norm.op == opt.OrOp || _norm.op == opt.TrueOp || _norm.op == opt.FalseOp {
				_f.o.reportOptimization(SimplifyOr)
				_group = _f.simplifyOr(conditions)
				_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullAndOr]
	{
		if conditions.Length > 0 {
			_item := _f.mem.lookupList(conditions)[0]
			_null := _f.mem.lookupNormExpr(_item).asNull()
			if _null != nil {
				if _f.listOnlyHasNulls(conditions) {
					_f.o.reportOptimization(FoldNullAndOr)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_orExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_orExpr)))
}

// ConstructNot constructs an expression for the Not operator.
// Not is the boolean negation operator that evaluates to true if its input
// evalutes to false.
func (_f *Factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notExpr))
	}

	// [NegateComparison]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.isComparison() {
			left := _norm.childGroup(_f.mem, 0)
			right := _norm.childGroup(_f.mem, 1)
			_contains := _f.mem.lookupNormExpr(input).asContains()
			if _contains == nil {
				_f.o.reportOptimization(NegateComparison)
				_group = _f.negateComparison(_f.mem.lookupNormExpr(input).op, left, right)
				_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [EliminateNot]
	{
		_not := _f.mem.lookupNormExpr(input).asNot()
		if _not != nil {
			input := _not.input()
			_f.o.reportOptimization(EliminateNot)
			_group = input
			_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
			return _group
		}
	}

	// [NegateAnd]
	{
		_and := _f.mem.lookupNormExpr(input).asAnd()
		if _and != nil {
			conditions := _and.conditions()
			_f.o.reportOptimization(NegateAnd)
			_group = _f.ConstructOr(_f.negateConditions(conditions))
			_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
			return _group
		}
	}

	// [NegateOr]
	{
		_or := _f.mem.lookupNormExpr(input).asOr()
		if _or != nil {
			conditions := _or.conditions()
			_f.o.reportOptimization(NegateOr)
			_group = _f.ConstructAnd(_f.negateConditions(conditions))
			_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notExpr)))
}

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_eqExpr))
	}

	// [NormalizeCmpPlusConst]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _plus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpPlusConst)
							_group = _f.ConstructEq(leftLeft, _f.ConstructMinus(right, leftRight))
							_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.PlusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpMinusConst)
							_group = _f.ConstructEq(leftLeft, _f.ConstructPlus(right, leftRight))
							_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if _f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if !_f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, leftLeft, right) {
							_f.o.reportOptimization(NormalizeCmpConstMinus)
							_group = _f.ConstructEq(_f.ConstructMinus(leftLeft, right), leftRight)
							_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeTupleEquality]
	{
		_tuple := _f.mem.lookupNormExpr(left).asTuple()
		if _tuple != nil {
			left := _tuple.elems()
			_tuple2 := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple2 != nil {
				right := _tuple2.elems()
				_f.o.reportOptimization(NormalizeTupleEquality)
				_group = _f.normalizeTupleEquality(left, right)
				_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
			return _group
		}
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_eqExpr)))
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_ltExpr := makeLtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_ltExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_ltExpr))
	}

	// [CommuteVarInequality]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVarInequality)
				_group = _f.commuteInequality(opt.LtOp, left, right)
				_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConstInequality]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConstInequality)
				_group = _f.commuteInequality(opt.LtOp, left, right)
				_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _plus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpPlusConst)
							_group = _f.ConstructLt(leftLeft, _f.ConstructMinus(right, leftRight))
							_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.PlusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpMinusConst)
							_group = _f.ConstructLt(leftLeft, _f.ConstructPlus(right, leftRight))
							_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if _f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if !_f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, leftLeft, right) {
							_f.o.reportOptimization(NormalizeCmpConstMinus)
							_group = _f.ConstructLt(_f.ConstructMinus(leftLeft, right), leftRight)
							_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_ltExpr)))
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *Factory) ConstructGt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_gtExpr := makeGtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_gtExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_gtExpr))
	}

	// [CommuteVarInequality]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVarInequality)
				_group = _f.commuteInequality(opt.GtOp, left, right)
				_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConstInequality]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConstInequality)
				_group = _f.commuteInequality(opt.GtOp, left, right)
				_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _plus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpPlusConst)
							_group = _f.ConstructGt(leftLeft, _f.ConstructMinus(right, leftRight))
							_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.PlusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpMinusConst)
							_group = _f.ConstructGt(leftLeft, _f.ConstructPlus(right, leftRight))
							_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if _f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if !_f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, leftLeft, right) {
							_f.o.reportOptimization(NormalizeCmpConstMinus)
							_group = _f.ConstructGt(_f.ConstructMinus(leftLeft, right), leftRight)
							_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_gtExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_gtExpr)))
}

// ConstructLe constructs an expression for the Le operator.
func (_f *Factory) ConstructLe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_leExpr := makeLeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_leExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_leExpr))
	}

	// [CommuteVarInequality]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVarInequality)
				_group = _f.commuteInequality(opt.LeOp, left, right)
				_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConstInequality]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConstInequality)
				_group = _f.commuteInequality(opt.LeOp, left, right)
				_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _plus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpPlusConst)
							_group = _f.ConstructLe(leftLeft, _f.ConstructMinus(right, leftRight))
							_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.PlusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpMinusConst)
							_group = _f.ConstructLe(leftLeft, _f.ConstructPlus(right, leftRight))
							_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if _f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if !_f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, leftLeft, right) {
							_f.o.reportOptimization(NormalizeCmpConstMinus)
							_group = _f.ConstructLe(_f.ConstructMinus(leftLeft, right), leftRight)
							_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_leExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_leExpr)))
}

// ConstructGe constructs an expression for the Ge operator.
func (_f *Factory) ConstructGe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_geExpr := makeGeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_geExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_geExpr))
	}

	// [CommuteVarInequality]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVarInequality)
				_group = _f.commuteInequality(opt.GeOp, left, right)
				_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConstInequality]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConstInequality)
				_group = _f.commuteInequality(opt.GeOp, left, right)
				_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _plus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpPlusConst)
							_group = _f.ConstructGe(leftLeft, _f.ConstructMinus(right, leftRight))
							_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if !_f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if _f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.PlusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeCmpMinusConst)
							_group = _f.ConstructGe(leftLeft, _f.ConstructPlus(right, leftRight))
							_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus := _f.mem.lookupNormExpr(left).asMinus()
		if _minus != nil {
			leftLeft := _minus.left()
			if _f.onlyConstants(leftLeft) {
				leftRight := _minus.right()
				if !_f.onlyConstants(leftRight) {
					if _f.onlyConstants(right) {
						if _f.canConstructBinary(opt.MinusOp, leftLeft, right) {
							_f.o.reportOptimization(NormalizeCmpConstMinus)
							_group = _f.ConstructGe(_f.ConstructMinus(leftLeft, right), leftRight)
							_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_geExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_geExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *Factory) ConstructNe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_neExpr := makeNeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_neExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_neExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
			return _group
		}
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructNe(right, left)
				_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructNe(right, left)
				_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_neExpr)))
}

// ConstructIn constructs an expression for the In operator.
func (_f *Factory) ConstructIn(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_inExpr := makeInExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_inExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_inExpr))
	}

	// [FoldNullInNonEmpty]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_tuple := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple != nil {
				if _tuple.elems().Length != 0 {
					_f.o.reportOptimization(FoldNullInNonEmpty)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_inExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [FoldNullInEmpty]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_tuple := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple != nil {
				if _tuple.elems().Length == 0 {
					_f.o.reportOptimization(FoldNullInEmpty)
					_group = _f.ConstructFalse()
					_f.mem.addAltFingerprint(_inExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [NormalizeInConst]
	{
		_tuple := _f.mem.lookupNormExpr(right).asTuple()
		if _tuple != nil {
			elems := _tuple.elems()
			if !_f.isSortedUniqueList(elems) {
				_f.o.reportOptimization(NormalizeInConst)
				_group = _f.ConstructIn(left, _f.ConstructTuple(_f.constructSortedUniqueList(elems)))
				_f.mem.addAltFingerprint(_inExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldInNull]
	{
		_tuple := _f.mem.lookupNormExpr(right).asTuple()
		if _tuple != nil {
			if _tuple.elems().Length == 1 {
				_item := _f.mem.lookupList(_tuple.elems())[0]
				_null := _f.mem.lookupNormExpr(_item).asNull()
				if _null != nil {
					_f.o.reportOptimization(FoldInNull)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_inExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_inExpr)))
}

// ConstructNotIn constructs an expression for the NotIn operator.
func (_f *Factory) ConstructNotIn(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notInExpr := makeNotInExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notInExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notInExpr))
	}

	// [FoldNullInNonEmpty]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_tuple := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple != nil {
				if _tuple.elems().Length != 0 {
					_f.o.reportOptimization(FoldNullInNonEmpty)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_notInExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [FoldNullNotInEmpty]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_tuple := _f.mem.lookupNormExpr(right).asTuple()
			if _tuple != nil {
				if _tuple.elems().Length == 0 {
					_f.o.reportOptimization(FoldNullNotInEmpty)
					_group = _f.ConstructTrue()
					_f.mem.addAltFingerprint(_notInExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	// [NormalizeInConst]
	{
		_tuple := _f.mem.lookupNormExpr(right).asTuple()
		if _tuple != nil {
			elems := _tuple.elems()
			if !_f.isSortedUniqueList(elems) {
				_f.o.reportOptimization(NormalizeInConst)
				_group = _f.ConstructNotIn(left, _f.ConstructTuple(_f.constructSortedUniqueList(elems)))
				_f.mem.addAltFingerprint(_notInExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldInNull]
	{
		_tuple := _f.mem.lookupNormExpr(right).asTuple()
		if _tuple != nil {
			if _tuple.elems().Length == 1 {
				_item := _f.mem.lookupList(_tuple.elems())[0]
				_null := _f.mem.lookupNormExpr(_item).asNull()
				if _null != nil {
					_f.o.reportOptimization(FoldInNull)
					_group = _f.ConstructNull(_f.boolType())
					_f.mem.addAltFingerprint(_notInExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notInExpr)))
}

// ConstructLike constructs an expression for the Like operator.
func (_f *Factory) ConstructLike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_likeExpr := makeLikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_likeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_likeExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_likeExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_likeExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_likeExpr)))
}

// ConstructNotLike constructs an expression for the NotLike operator.
func (_f *Factory) ConstructNotLike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notLikeExpr := makeNotLikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notLikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notLikeExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notLikeExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notLikeExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notLikeExpr)))
}

// ConstructILike constructs an expression for the ILike operator.
func (_f *Factory) ConstructILike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_iLikeExpr := makeILikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_iLikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_iLikeExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_iLikeExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_iLikeExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_iLikeExpr)))
}

// ConstructNotILike constructs an expression for the NotILike operator.
func (_f *Factory) ConstructNotILike(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notILikeExpr := makeNotILikeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notILikeExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notILikeExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notILikeExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notILikeExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notILikeExpr)))
}

// ConstructSimilarTo constructs an expression for the SimilarTo operator.
func (_f *Factory) ConstructSimilarTo(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_similarToExpr := makeSimilarToExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_similarToExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_similarToExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_similarToExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_similarToExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_similarToExpr)))
}

// ConstructNotSimilarTo constructs an expression for the NotSimilarTo operator.
func (_f *Factory) ConstructNotSimilarTo(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notSimilarToExpr := makeNotSimilarToExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notSimilarToExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notSimilarToExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notSimilarToExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notSimilarToExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notSimilarToExpr)))
}

// ConstructRegMatch constructs an expression for the RegMatch operator.
func (_f *Factory) ConstructRegMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_regMatchExpr := makeRegMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_regMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_regMatchExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_regMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_regMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_regMatchExpr)))
}

// ConstructNotRegMatch constructs an expression for the NotRegMatch operator.
func (_f *Factory) ConstructNotRegMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notRegMatchExpr := makeNotRegMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notRegMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notRegMatchExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notRegMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notRegMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notRegMatchExpr)))
}

// ConstructRegIMatch constructs an expression for the RegIMatch operator.
func (_f *Factory) ConstructRegIMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_regIMatchExpr := makeRegIMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_regIMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_regIMatchExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_regIMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_regIMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_regIMatchExpr)))
}

// ConstructNotRegIMatch constructs an expression for the NotRegIMatch operator.
func (_f *Factory) ConstructNotRegIMatch(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_notRegIMatchExpr := makeNotRegIMatchExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_notRegIMatchExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notRegIMatchExpr))
	}

	// [FoldNullComparisonLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonLeft)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notRegIMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullComparisonRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullComparisonRight)
			_group = _f.ConstructNull(_f.boolType())
			_f.mem.addAltFingerprint(_notRegIMatchExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notRegIMatchExpr)))
}

// ConstructIs constructs an expression for the Is operator.
func (_f *Factory) ConstructIs(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_isExpr := makeIsExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_isExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_isExpr))
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructIs(right, left)
				_f.mem.addAltFingerprint(_isExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructIs(right, left)
				_f.mem.addAltFingerprint(_isExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_isExpr)))
}

// ConstructIsNot constructs an expression for the IsNot operator.
func (_f *Factory) ConstructIsNot(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_isNotExpr := makeIsNotExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_isNotExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_isNotExpr))
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructIsNot(right, left)
				_f.mem.addAltFingerprint(_isNotExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructIsNot(right, left)
				_f.mem.addAltFingerprint(_isNotExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_isNotExpr)))
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *Factory) ConstructContains(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_containsExpr := makeContainsExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_containsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_containsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_containsExpr)))
}

// ConstructBitand constructs an expression for the Bitand operator.
func (_f *Factory) ConstructBitand(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitandExpr := makeBitandExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitandExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_bitandExpr))
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructBitand(right, left)
				_f.mem.addAltFingerprint(_bitandExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructBitand(right, left)
				_f.mem.addAltFingerprint(_bitandExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitandOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.BitandOp, left, right)
				_f.mem.addAltFingerprint(_bitandExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitandOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.BitandOp, left, right)
				_f.mem.addAltFingerprint(_bitandExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_bitandExpr)))
}

// ConstructBitor constructs an expression for the Bitor operator.
func (_f *Factory) ConstructBitor(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitorExpr := makeBitorExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitorExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_bitorExpr))
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructBitor(right, left)
				_f.mem.addAltFingerprint(_bitorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructBitor(right, left)
				_f.mem.addAltFingerprint(_bitorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitorOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.BitorOp, left, right)
				_f.mem.addAltFingerprint(_bitorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitorOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.BitorOp, left, right)
				_f.mem.addAltFingerprint(_bitorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_bitorExpr)))
}

// ConstructBitxor constructs an expression for the Bitxor operator.
func (_f *Factory) ConstructBitxor(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_bitxorExpr := makeBitxorExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_bitxorExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_bitxorExpr))
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructBitxor(right, left)
				_f.mem.addAltFingerprint(_bitxorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructBitxor(right, left)
				_f.mem.addAltFingerprint(_bitxorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitxorOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.BitxorOp, left, right)
				_f.mem.addAltFingerprint(_bitxorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.BitxorOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.BitxorOp, left, right)
				_f.mem.addAltFingerprint(_bitxorExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_bitxorExpr)))
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_plusExpr := makePlusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_plusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_plusExpr))
	}

	// [FoldPlusZero]
	{
		_const := _f.mem.lookupNormExpr(right).asConst()
		if _const != nil {
			if _f.isZero(right) {
				_f.o.reportOptimization(FoldPlusZero)
				_group = left
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldZeroPlus]
	{
		_const := _f.mem.lookupNormExpr(left).asConst()
		if _const != nil {
			if _f.isZero(left) {
				_f.o.reportOptimization(FoldZeroPlus)
				_group = right
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructPlus(right, left)
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructPlus(right, left)
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.PlusOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.PlusOp, left, right)
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.PlusOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.PlusOp, left, right)
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_minusExpr := makeMinusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_minusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_minusExpr))
	}

	// [FoldMinusZero]
	{
		_const := _f.mem.lookupNormExpr(right).asConst()
		if _const != nil {
			if _f.isZero(right) {
				_f.o.reportOptimization(FoldMinusZero)
				_group = left
				_f.mem.addAltFingerprint(_minusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.MinusOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.MinusOp, left, right)
				_f.mem.addAltFingerprint(_minusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.MinusOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.MinusOp, left, right)
				_f.mem.addAltFingerprint(_minusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_minusExpr)))
}

// ConstructMult constructs an expression for the Mult operator.
func (_f *Factory) ConstructMult(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_multExpr := makeMultExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_multExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_multExpr))
	}

	// [FoldMultOne]
	{
		_const := _f.mem.lookupNormExpr(right).asConst()
		if _const != nil {
			if _f.isOne(right) {
				_f.o.reportOptimization(FoldMultOne)
				_group = left
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldOneMult]
	{
		_const := _f.mem.lookupNormExpr(left).asConst()
		if _const != nil {
			if _f.isOne(left) {
				_f.o.reportOptimization(FoldOneMult)
				_group = right
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.o.reportOptimization(CommuteVar)
				_group = _f.ConstructMult(right, left)
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [CommuteConst]
	{
		if _f.onlyConstants(left) {
			if !_f.onlyConstants(right) {
				_f.o.reportOptimization(CommuteConst)
				_group = _f.ConstructMult(right, left)
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.MultOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.MultOp, left, right)
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.MultOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.MultOp, left, right)
				_f.mem.addAltFingerprint(_multExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_multExpr)))
}

// ConstructDiv constructs an expression for the Div operator.
func (_f *Factory) ConstructDiv(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_divExpr := makeDivExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_divExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_divExpr))
	}

	// [FoldDivOne]
	{
		_const := _f.mem.lookupNormExpr(right).asConst()
		if _const != nil {
			if _f.isOne(right) {
				_f.o.reportOptimization(FoldDivOne)
				_group = left
				_f.mem.addAltFingerprint(_divExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.DivOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.DivOp, left, right)
				_f.mem.addAltFingerprint(_divExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.DivOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.DivOp, left, right)
				_f.mem.addAltFingerprint(_divExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_divExpr)))
}

// ConstructFloorDiv constructs an expression for the FloorDiv operator.
func (_f *Factory) ConstructFloorDiv(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_floorDivExpr := makeFloorDivExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_floorDivExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_floorDivExpr))
	}

	// [FoldDivOne]
	{
		_const := _f.mem.lookupNormExpr(right).asConst()
		if _const != nil {
			if _f.isOne(right) {
				_f.o.reportOptimization(FoldDivOne)
				_group = left
				_f.mem.addAltFingerprint(_floorDivExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FloorDivOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.FloorDivOp, left, right)
				_f.mem.addAltFingerprint(_floorDivExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FloorDivOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.FloorDivOp, left, right)
				_f.mem.addAltFingerprint(_floorDivExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_floorDivExpr)))
}

// ConstructMod constructs an expression for the Mod operator.
func (_f *Factory) ConstructMod(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_modExpr := makeModExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_modExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_modExpr))
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.ModOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.ModOp, left, right)
				_f.mem.addAltFingerprint(_modExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.ModOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.ModOp, left, right)
				_f.mem.addAltFingerprint(_modExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_modExpr)))
}

// ConstructPow constructs an expression for the Pow operator.
func (_f *Factory) ConstructPow(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_powExpr := makePowExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_powExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_powExpr))
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.PowOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.PowOp, left, right)
				_f.mem.addAltFingerprint(_powExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.PowOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.PowOp, left, right)
				_f.mem.addAltFingerprint(_powExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_powExpr)))
}

// ConstructConcat constructs an expression for the Concat operator.
func (_f *Factory) ConstructConcat(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_concatExpr := makeConcatExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_concatExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_concatExpr))
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.ConcatOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.ConcatOp, left, right)
				_f.mem.addAltFingerprint(_concatExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.ConcatOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.ConcatOp, left, right)
				_f.mem.addAltFingerprint(_concatExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_concatExpr)))
}

// ConstructLShift constructs an expression for the LShift operator.
func (_f *Factory) ConstructLShift(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_lShiftExpr := makeLShiftExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_lShiftExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_lShiftExpr))
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.LShiftOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.LShiftOp, left, right)
				_f.mem.addAltFingerprint(_lShiftExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.LShiftOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.LShiftOp, left, right)
				_f.mem.addAltFingerprint(_lShiftExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_lShiftExpr)))
}

// ConstructRShift constructs an expression for the RShift operator.
func (_f *Factory) ConstructRShift(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_rShiftExpr := makeRShiftExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_rShiftExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_rShiftExpr))
	}

	// [FoldNullBinaryLeft]
	{
		_null := _f.mem.lookupNormExpr(left).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.RShiftOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.RShiftOp, left, right)
				_f.mem.addAltFingerprint(_rShiftExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.RShiftOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.RShiftOp, left, right)
				_f.mem.addAltFingerprint(_rShiftExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_rShiftExpr)))
}

// ConstructFetchVal constructs an expression for the FetchVal operator.
func (_f *Factory) ConstructFetchVal(
	json opt.GroupID,
	index opt.GroupID,
) opt.GroupID {
	_fetchValExpr := makeFetchValExpr(json, index)
	_group := _f.mem.lookupGroupByFingerprint(_fetchValExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fetchValExpr))
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null := _f.mem.lookupNormExpr(json).asNull()
		if _null != nil {
			right := index
			if !_f.allowNullArgs(opt.FetchValOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.FetchValOp, left, right)
				_f.mem.addAltFingerprint(_fetchValExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := index
		_null := _f.mem.lookupNormExpr(index).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FetchValOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.FetchValOp, left, right)
				_f.mem.addAltFingerprint(_fetchValExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fetchValExpr)))
}

// ConstructFetchText constructs an expression for the FetchText operator.
func (_f *Factory) ConstructFetchText(
	json opt.GroupID,
	index opt.GroupID,
) opt.GroupID {
	_fetchTextExpr := makeFetchTextExpr(json, index)
	_group := _f.mem.lookupGroupByFingerprint(_fetchTextExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fetchTextExpr))
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null := _f.mem.lookupNormExpr(json).asNull()
		if _null != nil {
			right := index
			if !_f.allowNullArgs(opt.FetchTextOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.FetchTextOp, left, right)
				_f.mem.addAltFingerprint(_fetchTextExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := index
		_null := _f.mem.lookupNormExpr(index).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FetchTextOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.FetchTextOp, left, right)
				_f.mem.addAltFingerprint(_fetchTextExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fetchTextExpr)))
}

// ConstructFetchValPath constructs an expression for the FetchValPath operator.
func (_f *Factory) ConstructFetchValPath(
	json opt.GroupID,
	path opt.GroupID,
) opt.GroupID {
	_fetchValPathExpr := makeFetchValPathExpr(json, path)
	_group := _f.mem.lookupGroupByFingerprint(_fetchValPathExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fetchValPathExpr))
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null := _f.mem.lookupNormExpr(json).asNull()
		if _null != nil {
			right := path
			if !_f.allowNullArgs(opt.FetchValPathOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.FetchValPathOp, left, right)
				_f.mem.addAltFingerprint(_fetchValPathExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := path
		_null := _f.mem.lookupNormExpr(path).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FetchValPathOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.FetchValPathOp, left, right)
				_f.mem.addAltFingerprint(_fetchValPathExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fetchValPathExpr)))
}

// ConstructFetchTextPath constructs an expression for the FetchTextPath operator.
func (_f *Factory) ConstructFetchTextPath(
	json opt.GroupID,
	path opt.GroupID,
) opt.GroupID {
	_fetchTextPathExpr := makeFetchTextPathExpr(json, path)
	_group := _f.mem.lookupGroupByFingerprint(_fetchTextPathExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fetchTextPathExpr))
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null := _f.mem.lookupNormExpr(json).asNull()
		if _null != nil {
			right := path
			if !_f.allowNullArgs(opt.FetchTextPathOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryLeft)
				_group = _f.foldNullBinary(opt.FetchTextPathOp, left, right)
				_f.mem.addAltFingerprint(_fetchTextPathExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := path
		_null := _f.mem.lookupNormExpr(path).asNull()
		if _null != nil {
			if !_f.allowNullArgs(opt.FetchTextPathOp, left, right) {
				_f.o.reportOptimization(FoldNullBinaryRight)
				_group = _f.foldNullBinary(opt.FetchTextPathOp, left, right)
				_f.mem.addAltFingerprint(_fetchTextPathExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fetchTextPathExpr)))
}

// ConstructUnaryMinus constructs an expression for the UnaryMinus operator.
func (_f *Factory) ConstructUnaryMinus(
	input opt.GroupID,
) opt.GroupID {
	_unaryMinusExpr := makeUnaryMinusExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_unaryMinusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unaryMinusExpr))
	}

	// [InvertMinus]
	{
		_minus := _f.mem.lookupNormExpr(input).asMinus()
		if _minus != nil {
			left := _minus.left()
			right := _minus.right()
			if _f.canConstructBinary(opt.MinusOp, right, left) {
				_f.o.reportOptimization(InvertMinus)
				_group = _f.ConstructMinus(right, left)
				_f.mem.addAltFingerprint(_unaryMinusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	// [EliminateUnaryMinus]
	{
		_unaryMinus := _f.mem.lookupNormExpr(input).asUnaryMinus()
		if _unaryMinus != nil {
			input := _unaryMinus.input()
			_f.o.reportOptimization(EliminateUnaryMinus)
			_group = input
			_f.mem.addAltFingerprint(_unaryMinusExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullUnary]
	{
		_null := _f.mem.lookupNormExpr(input).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullUnary)
			_group = _f.foldNullUnary(opt.UnaryMinusOp, input)
			_f.mem.addAltFingerprint(_unaryMinusExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unaryMinusExpr)))
}

// ConstructUnaryComplement constructs an expression for the UnaryComplement operator.
func (_f *Factory) ConstructUnaryComplement(
	input opt.GroupID,
) opt.GroupID {
	_unaryComplementExpr := makeUnaryComplementExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_unaryComplementExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unaryComplementExpr))
	}

	// [FoldNullUnary]
	{
		_null := _f.mem.lookupNormExpr(input).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullUnary)
			_group = _f.foldNullUnary(opt.UnaryComplementOp, input)
			_f.mem.addAltFingerprint(_unaryComplementExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unaryComplementExpr)))
}

// ConstructCast constructs an expression for the Cast operator.
func (_f *Factory) ConstructCast(
	input opt.GroupID,
	typ opt.PrivateID,
) opt.GroupID {
	_castExpr := makeCastExpr(input, typ)
	_group := _f.mem.lookupGroupByFingerprint(_castExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_castExpr))
	}

	// [EliminateCast]
	{
		if _f.hasType(input, typ) {
			_f.o.reportOptimization(EliminateCast)
			_group = input
			_f.mem.addAltFingerprint(_castExpr.fingerprint(), _group)
			return _group
		}
	}

	// [FoldNullCast]
	{
		_null := _f.mem.lookupNormExpr(input).asNull()
		if _null != nil {
			_f.o.reportOptimization(FoldNullCast)
			_group = _f.ConstructNull(typ)
			_f.mem.addAltFingerprint(_castExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_castExpr)))
}

// ConstructCase constructs an expression for the Case operator.
// Case is a CASE statement of the form:
//   CASE [ <Input> ]
//       WHEN <condval1> THEN <expr1>
//     [ WHEN <condval2> THEN <expr2> ] ...
//     [ ELSE <expr> ]
//   END
//
// The Case operator evaluates <Input> (if not provided, Input is set to True),
// then picks the WHEN branch where <condval> is equal to
// <cond>, then evaluates and returns the corresponding THEN expression. If no
// WHEN branch matches, the ELSE expression is evaluated and returned, if any.
// Otherwise, NULL is returned.
//
// Note that the Whens list inside Case is used to represent all the WHEN
// branches as well as the ELSE statement if it exists. It is of the form:
// [(When <condval1> <expr1>),(When <condval2> <expr2>),...,<expr>]
func (_f *Factory) ConstructCase(
	input opt.GroupID,
	whens opt.ListID,
) opt.GroupID {
	_caseExpr := makeCaseExpr(input, whens)
	_group := _f.mem.lookupGroupByFingerprint(_caseExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_caseExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_caseExpr)))
}

// ConstructWhen constructs an expression for the When operator.
// When represents a single WHEN ... THEN ... condition inside a CASE statement.
// It is the type of each list item in Whens (except for the last item which is
// a raw expression for the ELSE statement).
func (_f *Factory) ConstructWhen(
	condition opt.GroupID,
	value opt.GroupID,
) opt.GroupID {
	_whenExpr := makeWhenExpr(condition, value)
	_group := _f.mem.lookupGroupByFingerprint(_whenExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_whenExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_whenExpr)))
}

// ConstructFunction constructs an expression for the Function operator.
// Function invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The private field is an opt.FuncOpDef struct that provides the
// name of the function as well as a pointer to the builtin overload definition.
func (_f *Factory) ConstructFunction(
	args opt.ListID,
	def opt.PrivateID,
) opt.GroupID {
	_functionExpr := makeFunctionExpr(args, def)
	_group := _f.mem.lookupGroupByFingerprint(_functionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_functionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_functionExpr)))
}

// ConstructCoalesce constructs an expression for the Coalesce operator.
func (_f *Factory) ConstructCoalesce(
	args opt.ListID,
) opt.GroupID {
	_coalesceExpr := makeCoalesceExpr(args)
	_group := _f.mem.lookupGroupByFingerprint(_coalesceExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_coalesceExpr))
	}

	// [EliminateCoalesce]
	{
		if args.Length == 1 {
			_item := _f.mem.lookupList(args)[0]
			item := _item
			_f.o.reportOptimization(EliminateCoalesce)
			_group = item
			_f.mem.addAltFingerprint(_coalesceExpr.fingerprint(), _group)
			return _group
		}
	}

	// [SimplifyCoalesce]
	{
		if args.Length > 0 {
			_item := _f.mem.lookupList(args)[0]
			_norm := _f.mem.lookupNormExpr(_item)
			if _norm.isConstValue() {
				_f.o.reportOptimization(SimplifyCoalesce)
				_group = _f.simplifyCoalesce(args)
				_f.mem.addAltFingerprint(_coalesceExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_coalesceExpr)))
}

// ConstructUnsupportedExpr constructs an expression for the UnsupportedExpr operator.
// UnsupportedExpr is used for interfacing with the old planner code. It can
// encapsulate a TypedExpr that is otherwise not supported by the optimizer.
func (_f *Factory) ConstructUnsupportedExpr(
	value opt.PrivateID,
) opt.GroupID {
	_unsupportedExprExpr := makeUnsupportedExprExpr(value)
	_group := _f.mem.lookupGroupByFingerprint(_unsupportedExprExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unsupportedExprExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unsupportedExprExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands opt.DynamicOperands) opt.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		panic("op type not initialized")
	}

	// ScanOp
	dynConstructLookup[opt.ScanOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructScan(opt.PrivateID(operands[0]))
	}

	// ValuesOp
	dynConstructLookup[opt.ValuesOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructValues(operands[0].ListID(), opt.PrivateID(operands[1]))
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructSelect(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// ProjectOp
	dynConstructLookup[opt.ProjectOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructProject(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructInnerJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// LeftJoinOp
	dynConstructLookup[opt.LeftJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLeftJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// RightJoinOp
	dynConstructLookup[opt.RightJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructRightJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFullJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// SemiJoinOp
	dynConstructLookup[opt.SemiJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructSemiJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// AntiJoinOp
	dynConstructLookup[opt.AntiJoinOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructAntiJoin(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// InnerJoinApplyOp
	dynConstructLookup[opt.InnerJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructInnerJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// LeftJoinApplyOp
	dynConstructLookup[opt.LeftJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLeftJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// RightJoinApplyOp
	dynConstructLookup[opt.RightJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructRightJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// FullJoinApplyOp
	dynConstructLookup[opt.FullJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFullJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// SemiJoinApplyOp
	dynConstructLookup[opt.SemiJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructSemiJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// AntiJoinApplyOp
	dynConstructLookup[opt.AntiJoinApplyOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructAntiJoinApply(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.GroupID(operands[2]))
	}

	// GroupByOp
	dynConstructLookup[opt.GroupByOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructGroupBy(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructUnion(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// IntersectOp
	dynConstructLookup[opt.IntersectOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructIntersect(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// ExceptOp
	dynConstructLookup[opt.ExceptOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructExcept(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// UnionAllOp
	dynConstructLookup[opt.UnionAllOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructUnionAll(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// IntersectAllOp
	dynConstructLookup[opt.IntersectAllOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructIntersectAll(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// ExceptAllOp
	dynConstructLookup[opt.ExceptAllOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructExceptAll(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// LimitOp
	dynConstructLookup[opt.LimitOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLimit(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// OffsetOp
	dynConstructLookup[opt.OffsetOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructOffset(opt.GroupID(operands[0]), opt.GroupID(operands[1]), opt.PrivateID(operands[2]))
	}

	// SubqueryOp
	dynConstructLookup[opt.SubqueryOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructSubquery(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructVariable(opt.PrivateID(operands[0]))
	}

	// ConstOp
	dynConstructLookup[opt.ConstOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructConst(opt.PrivateID(operands[0]))
	}

	// NullOp
	dynConstructLookup[opt.NullOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNull(opt.PrivateID(operands[0]))
	}

	// TrueOp
	dynConstructLookup[opt.TrueOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructTrue()
	}

	// FalseOp
	dynConstructLookup[opt.FalseOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFalse()
	}

	// PlaceholderOp
	dynConstructLookup[opt.PlaceholderOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructPlaceholder(opt.PrivateID(operands[0]))
	}

	// TupleOp
	dynConstructLookup[opt.TupleOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructTuple(operands[0].ListID())
	}

	// ProjectionsOp
	dynConstructLookup[opt.ProjectionsOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructProjections(operands[0].ListID(), opt.PrivateID(operands[1]))
	}

	// AggregationsOp
	dynConstructLookup[opt.AggregationsOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructAggregations(operands[0].ListID(), opt.PrivateID(operands[1]))
	}

	// ExistsOp
	dynConstructLookup[opt.ExistsOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructExists(opt.GroupID(operands[0]))
	}

	// FiltersOp
	dynConstructLookup[opt.FiltersOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFilters(operands[0].ListID())
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructAnd(operands[0].ListID())
	}

	// OrOp
	dynConstructLookup[opt.OrOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructOr(operands[0].ListID())
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNot(opt.GroupID(operands[0]))
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructEq(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLt(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// GtOp
	dynConstructLookup[opt.GtOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructGt(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// LeOp
	dynConstructLookup[opt.LeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLe(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// GeOp
	dynConstructLookup[opt.GeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructGe(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNe(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// InOp
	dynConstructLookup[opt.InOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructIn(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotInOp
	dynConstructLookup[opt.NotInOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotIn(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// LikeOp
	dynConstructLookup[opt.LikeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLike(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotLikeOp
	dynConstructLookup[opt.NotLikeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotLike(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// ILikeOp
	dynConstructLookup[opt.ILikeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructILike(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotILikeOp
	dynConstructLookup[opt.NotILikeOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotILike(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// SimilarToOp
	dynConstructLookup[opt.SimilarToOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructSimilarTo(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotSimilarToOp
	dynConstructLookup[opt.NotSimilarToOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotSimilarTo(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// RegMatchOp
	dynConstructLookup[opt.RegMatchOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructRegMatch(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotRegMatchOp
	dynConstructLookup[opt.NotRegMatchOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotRegMatch(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// RegIMatchOp
	dynConstructLookup[opt.RegIMatchOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructRegIMatch(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// NotRegIMatchOp
	dynConstructLookup[opt.NotRegIMatchOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructNotRegIMatch(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// IsOp
	dynConstructLookup[opt.IsOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructIs(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// IsNotOp
	dynConstructLookup[opt.IsNotOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructIsNot(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// ContainsOp
	dynConstructLookup[opt.ContainsOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructContains(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// BitandOp
	dynConstructLookup[opt.BitandOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructBitand(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// BitorOp
	dynConstructLookup[opt.BitorOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructBitor(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// BitxorOp
	dynConstructLookup[opt.BitxorOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructBitxor(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructPlus(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructMinus(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// MultOp
	dynConstructLookup[opt.MultOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructMult(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// DivOp
	dynConstructLookup[opt.DivOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructDiv(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FloorDivOp
	dynConstructLookup[opt.FloorDivOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFloorDiv(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// ModOp
	dynConstructLookup[opt.ModOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructMod(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// PowOp
	dynConstructLookup[opt.PowOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructPow(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// ConcatOp
	dynConstructLookup[opt.ConcatOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructConcat(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// LShiftOp
	dynConstructLookup[opt.LShiftOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructLShift(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// RShiftOp
	dynConstructLookup[opt.RShiftOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructRShift(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FetchValOp
	dynConstructLookup[opt.FetchValOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFetchVal(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FetchTextOp
	dynConstructLookup[opt.FetchTextOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFetchText(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FetchValPathOp
	dynConstructLookup[opt.FetchValPathOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFetchValPath(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FetchTextPathOp
	dynConstructLookup[opt.FetchTextPathOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFetchTextPath(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// UnaryMinusOp
	dynConstructLookup[opt.UnaryMinusOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructUnaryMinus(opt.GroupID(operands[0]))
	}

	// UnaryComplementOp
	dynConstructLookup[opt.UnaryComplementOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructUnaryComplement(opt.GroupID(operands[0]))
	}

	// CastOp
	dynConstructLookup[opt.CastOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructCast(opt.GroupID(operands[0]), opt.PrivateID(operands[1]))
	}

	// CaseOp
	dynConstructLookup[opt.CaseOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructCase(opt.GroupID(operands[0]), operands[1].ListID())
	}

	// WhenOp
	dynConstructLookup[opt.WhenOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructWhen(opt.GroupID(operands[0]), opt.GroupID(operands[1]))
	}

	// FunctionOp
	dynConstructLookup[opt.FunctionOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructFunction(operands[0].ListID(), opt.PrivateID(operands[1]))
	}

	// CoalesceOp
	dynConstructLookup[opt.CoalesceOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructCoalesce(operands[0].ListID())
	}

	// UnsupportedExprOp
	dynConstructLookup[opt.UnsupportedExprOp] = func(f *Factory, operands opt.DynamicOperands) opt.GroupID {
		return f.ConstructUnsupportedExpr(opt.PrivateID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands opt.DynamicOperands) opt.GroupID {
	return dynConstructLookup[op](f, operands)
}
