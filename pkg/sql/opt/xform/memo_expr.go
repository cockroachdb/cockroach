// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// exprState is opaque storage used to store operator-specific fields in the
// memo expression.
type exprState [opt.MaxOperands]uint32

// memoExpr is a memoized representation of an expression. Strongly-typed
// specializations of memoExpr are generated by optgen for each operator (see
// expr.og.go). Each memoExpr belongs to a memo group, which contains logically
// equivalent expressions. Two expressions are considered logically equivalent
// if they both reduce to an identical normal form after normalizing
// transformations have been applied.
//
// The children of memoExpr are recursively memoized in the same way as the
// memoExpr, and are referenced by their memo group. Therefore, the memoExpr
// is the root of a forest of expressions.
type memoExpr struct {
	// op is this expression's operator type. Each operator may have additional
	// fields. To access these fields in a strongly-typed way, use the asXXX()
	// generated methods to cast the memoExpr to the more specialized
	// expression type.
	op opt.Operator

	// state stores operator-specific state. Depending upon the value of the
	// op field, this state will be interpreted in different ways.
	state exprState
}

// fingerprint uniquely identifies a memo expression by combining its operator
// type plus its operator fields. It can be used as a map key. If two
// expressions share the same fingerprint, then they are the identical
// expression. If they don't share a fingerprint, then they still may be
// logically equivalent expressions. Since a memo expression is 16 bytes and
// contains no pointers, it can function as its own fingerprint/hash.
type fingerprint memoExpr

// fingerprint returns this memo expression's unique fingerprint.
func (me *memoExpr) fingerprint() fingerprint {
	return fingerprint(*me)
}

// opLayout describes the "layout" of each op's children. It contains multiple
// fields:
//
//  - baseCount (bits 0,1):
//      number of children, excluding any list; the children are in
//      state[0] through state[baseCount-1], unless the op is an enforcer.
//
//  - list (bits 2,3):
//      0 if op has no list, otherwise 1 + position of the list in state
//      (specifically Offset=state[list-1] Length=state[list]).
//
//  - priv (bits 4,5):
//      0 if op has no private, otherwise 1 + position of the private in state.
//
// The table of values (opLayoutTable) is generated by optgen.
type opLayout uint8

func (val opLayout) baseCount() uint8 {
	return uint8(val) & 3
}

func (val opLayout) list() uint8 {
	return (uint8(val) >> 2) & 3
}

func (val opLayout) priv() uint8 {
	return (uint8(val) >> 4) & 3
}

func makeOpLayout(baseCount, list, priv uint8) opLayout {
	return opLayout(baseCount | (list << 2) | (priv << 4))
}

// childCount returns the number of expressions that are inputs to this parent
// expression.
func (me *memoExpr) childCount() int {
	layout := opLayoutTable[me.op]
	baseCount := layout.baseCount()
	list := layout.list()
	if list == 0 {
		return int(baseCount)
	}
	return int(baseCount) + int(me.state[list])
}

// childGroup returns the memo group containing the nth child of this parent
// expression.
func (me *memoExpr) childGroup(mem *memo, nth int) opt.GroupID {
	layout := opLayoutTable[me.op]
	baseCount := layout.baseCount()
	if nth < int(baseCount) {
		return opt.GroupID(me.state[nth])
	}
	nth -= int(baseCount)
	list := layout.list()
	if list != 0 && nth < int(me.state[list]) {
		listID := opt.ListID{Offset: me.state[list-1], Length: me.state[list]}
		return mem.lookupList(listID)[nth]
	}
	panic("child index out of range")
}

// private returns the value of this expression's private field, if it has one,
// or nil if not.
func (me *memoExpr) private(mem *memo) interface{} {
	return mem.lookupPrivate(me.privateID())
}

func (me *memoExpr) privateID() opt.PrivateID {
	priv := opLayoutTable[me.op].priv()
	if priv == 0 {
		return 0
	}
	return opt.PrivateID(me.state[priv-1])
}
