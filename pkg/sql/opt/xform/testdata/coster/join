exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, s STRING, d DECIMAL NOT NULL)
----

exec-ddl
CREATE TABLE b (x INT, z INT NOT NULL)
----

exec-ddl
CREATE TABLE g (k INT PRIMARY KEY, geom GEOMETRY, INVERTED INDEX (geom))
----

opt
SELECT k, x FROM a INNER JOIN b ON k=x WHERE d=1.0
----
project
 ├── columns: k:1!null x:6!null
 ├── immutable
 ├── stats: [rows=99]
 ├── cost: 2153.725
 ├── fd: (1)==(6), (6)==(1)
 └── inner-join (hash)
      ├── columns: k:1!null d:4!null x:6!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── immutable
      ├── stats: [rows=99, distinct(1)=10, null(1)=0, distinct(6)=10, null(6)=0]
      ├── cost: 2152.725
      ├── fd: ()-->(4), (1)==(6), (6)==(1)
      ├── scan b
      │    ├── columns: x:6
      │    ├── stats: [rows=1000, distinct(6)=100, null(6)=10]
      │    └── cost: 1054.41
      ├── select
      │    ├── columns: k:1!null d:4!null
      │    ├── immutable
      │    ├── stats: [rows=10, distinct(1)=10, null(1)=0, distinct(4)=1, null(4)=0]
      │    ├── cost: 1084.63
      │    ├── key: (1)
      │    ├── fd: ()-->(4)
      │    ├── scan a
      │    │    ├── columns: k:1!null d:4!null
      │    │    ├── stats: [rows=1000, distinct(1)=1000, null(1)=0, distinct(4)=100, null(4)=0]
      │    │    ├── cost: 1074.61
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(4)
      │    └── filters
      │         └── d:4 = 1.0 [outer=(4), immutable, constraints=(/4: [/1.0 - /1.0]; tight), fd=()-->(4)]
      └── filters
           └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Verify that we pick merge join if we force it.
opt
SELECT k, x FROM a INNER MERGE JOIN b ON k=x
----
inner-join (merge)
 ├── columns: k:1!null x:6!null
 ├── flags: force merge join
 ├── left ordering: +1
 ├── right ordering: +6
 ├── stats: [rows=990, distinct(1)=99, null(1)=0, distinct(6)=99, null(6)=0]
 ├── cost: 2378.15569
 ├── fd: (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1!null
 │    ├── stats: [rows=1000, distinct(1)=1000, null(1)=0]
 │    ├── cost: 1064.51
 │    ├── key: (1)
 │    └── ordering: +1
 ├── sort
 │    ├── columns: x:6
 │    ├── stats: [rows=1000, distinct(6)=100, null(6)=10]
 │    ├── cost: 1283.73569
 │    ├── ordering: +6
 │    └── scan b
 │         ├── columns: x:6
 │         ├── stats: [rows=1000, distinct(6)=100, null(6)=10]
 │         └── cost: 1054.41
 └── filters (true)

# Verify that we pick lookup join if we force it. Note that lookup join is only
# possible if b is the left table.
opt
SELECT k, x FROM b INNER LOOKUP JOIN a ON k=x
----
inner-join (lookup a)
 ├── columns: k:5!null x:1!null
 ├── flags: force lookup join (into right side)
 ├── key columns: [1] = [5]
 ├── lookup columns are key
 ├── stats: [rows=990, distinct(1)=99, null(1)=0, distinct(5)=99, null(5)=0]
 ├── cost: 7093.82
 ├── fd: (1)==(5), (5)==(1)
 ├── scan b
 │    ├── columns: x:1
 │    ├── stats: [rows=1000, distinct(1)=100, null(1)=10]
 │    └── cost: 1054.41
 └── filters (true)


# Verify that if we force lookup join but one isn't possible, the hash join has
# huge cost (this will result in an error if we try to execbuild the result).
opt
SELECT k, x FROM a INNER LOOKUP JOIN b ON k=x
----
inner-join (hash)
 ├── columns: k:1!null x:6!null
 ├── flags: force lookup join (into right side)
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── stats: [rows=990, distinct(1)=99, null(1)=0, distinct(6)=99, null(6)=0]
 ├── cost: 1e+100
 ├── fd: (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1!null
 │    ├── stats: [rows=1000, distinct(1)=1000, null(1)=0]
 │    ├── cost: 1064.51
 │    └── key: (1)
 ├── scan b
 │    ├── columns: x:6
 │    ├── stats: [rows=1000, distinct(6)=100, null(6)=10]
 │    └── cost: 1054.41
 └── filters
      └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Verify that we pick inverted join if we force it.
opt
SELECT * FROM g AS g1 INNER INVERTED JOIN g AS g2 ON ST_Contains(g1.geom, g2.geom)
----
inner-join (lookup g [as=g2])
 ├── columns: k:1!null geom:2!null k:5!null geom:6!null
 ├── key columns: [9] = [5]
 ├── lookup columns are key
 ├── immutable
 ├── stats: [rows=9801]
 ├── cost: 1101954.44
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── inner-join (inverted g@secondary [as=g2])
 │    ├── columns: g1.k:1!null g1.geom:2 g2.k:9!null
 │    ├── flags: force inverted join (into right side)
 │    ├── inverted-expr
 │    │    └── st_contains(g1.geom:2, g2.geom:10)
 │    ├── stats: [rows=10000, distinct(1)=999.956829, null(1)=0, distinct(9)=999.956829, null(9)=0]
 │    ├── cost: 41454.42
 │    ├── key: (1,9)
 │    ├── fd: (1)-->(2)
 │    ├── scan g [as=g1]
 │    │    ├── columns: g1.k:1!null g1.geom:2
 │    │    ├── stats: [rows=1000, distinct(1)=1000, null(1)=0, distinct(2)=100, null(2)=10]
 │    │    ├── cost: 1054.41
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── filters (true)
 └── filters
      └── st_contains(g1.geom:2, g2.geom:6) [outer=(2,6), immutable, constraints=(/2: (/NULL - ]; /6: (/NULL - ])]

# Verify that if we force inverted join but one isn't possible, the hash join has
# huge cost (this will result in an error if we try to execbuild the result).
opt
SELECT * FROM g AS g1 INNER INVERTED JOIN g AS g2 ON ST_Contains(g1.geom, g2.geom) OR g1.k = 5
----
inner-join (cross)
 ├── columns: k:1!null geom:2 k:5!null geom:6
 ├── flags: force inverted join (into right side)
 ├── immutable
 ├── stats: [rows=333333.333]
 ├── cost: 1e+100
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── scan g [as=g1]
 │    ├── columns: g1.k:1!null g1.geom:2
 │    ├── stats: [rows=1000]
 │    ├── cost: 1054.41
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── scan g [as=g2]
 │    ├── columns: g2.k:5!null g2.geom:6
 │    ├── stats: [rows=1000, distinct(5)=1000, null(5)=0]
 │    ├── cost: 1054.41
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── st_contains(g1.geom:2, g2.geom:6) OR (g1.k:1 = 5) [outer=(1,2,6), immutable]


exec-ddl
ALTER TABLE a INJECT STATISTICS '[
  {
    "columns": ["k"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 100000,
    "distinct_count": 100000
  }
]'
----

exec-ddl
ALTER TABLE b INJECT STATISTICS '[
  {
    "columns": ["x"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 10000,
    "distinct_count": 1000
  }
]'
----

# Lookup join with no limit hint.
opt
SELECT * FROM a JOIN b ON k=z WHERE x > 0 AND x <= 5000
----
inner-join (lookup a)
 ├── columns: k:1!null i:2 s:3 d:4!null x:6!null z:7!null
 ├── key columns: [7] = [1]
 ├── lookup columns are key
 ├── stats: [rows=10000, distinct(1)=1000, null(1)=0, distinct(7)=1000, null(7)=0]
 ├── cost: 71514.54
 ├── fd: (1)-->(2-4), (1)==(7), (7)==(1)
 ├── select
 │    ├── columns: x:6!null z:7!null
 │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    ├── cost: 10614.53
 │    ├── scan b
 │    │    ├── columns: x:6 z:7!null
 │    │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    │    └── cost: 10514.51
 │    └── filters
 │         └── (x:6 > 0) AND (x:6 <= 5000) [outer=(6), constraints=(/6: [/1 - /5000]; tight)]
 └── filters (true)

# With the limit hint, the cost of the lookup join is reduced.
opt
SELECT * FROM a JOIN b ON k=z WHERE x > 0 AND x <= 5000 LIMIT 6000
----
limit
 ├── columns: k:1!null i:2 s:3 d:4!null x:6!null z:7!null
 ├── cardinality: [0 - 6000]
 ├── stats: [rows=6000]
 ├── cost: 42964.05
 ├── fd: (1)-->(2-4), (1)==(7), (7)==(1)
 ├── inner-join (lookup a)
 │    ├── columns: k:1!null i:2 s:3 d:4!null x:6!null z:7!null
 │    ├── key columns: [7] = [1]
 │    ├── lookup columns are key
 │    ├── stats: [rows=10000, distinct(1)=1000, null(1)=0, distinct(7)=1000, null(7)=0]
 │    ├── cost: 42904.04
 │    ├── fd: (1)-->(2-4), (1)==(7), (7)==(1)
 │    ├── limit hint: 6000.00
 │    ├── select
 │    │    ├── columns: x:6!null z:7!null
 │    │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    │    ├── cost: 6364.03
 │    │    ├── limit hint: 6000.00
 │    │    ├── scan b
 │    │    │    ├── columns: x:6 z:7!null
 │    │    │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    │    │    ├── cost: 6304.01
 │    │    │    └── limit hint: 6000.00
 │    │    └── filters
 │    │         └── (x:6 > 0) AND (x:6 <= 5000) [outer=(6), constraints=(/6: [/1 - /5000]; tight)]
 │    └── filters (true)
 └── 6000

# The limit hint for the lookup join input will be rounded up to the nearest
# multiple of the batch size, so the cost of the lookup join here is the same
# as the test case above.
opt
SELECT * FROM a JOIN b ON k=z WHERE x > 0 AND x <= 5000 LIMIT 5950
----
limit
 ├── columns: k:1!null i:2 s:3 d:4!null x:6!null z:7!null
 ├── cardinality: [0 - 5950]
 ├── stats: [rows=5950]
 ├── cost: 42963.55
 ├── fd: (1)-->(2-4), (1)==(7), (7)==(1)
 ├── inner-join (lookup a)
 │    ├── columns: k:1!null i:2 s:3 d:4!null x:6!null z:7!null
 │    ├── key columns: [7] = [1]
 │    ├── lookup columns are key
 │    ├── stats: [rows=10000, distinct(1)=1000, null(1)=0, distinct(7)=1000, null(7)=0]
 │    ├── cost: 42904.04
 │    ├── fd: (1)-->(2-4), (1)==(7), (7)==(1)
 │    ├── limit hint: 5950.00
 │    ├── select
 │    │    ├── columns: x:6!null z:7!null
 │    │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    │    ├── cost: 6364.03
 │    │    ├── limit hint: 6000.00
 │    │    ├── scan b
 │    │    │    ├── columns: x:6 z:7!null
 │    │    │    ├── stats: [rows=10000, distinct(6)=1000, null(6)=0, distinct(7)=1000, null(7)=0]
 │    │    │    ├── cost: 6304.01
 │    │    │    └── limit hint: 6000.00
 │    │    └── filters
 │    │         └── (x:6 > 0) AND (x:6 <= 5000) [outer=(6), constraints=(/6: [/1 - /5000]; tight)]
 │    └── filters (true)
 └── 5950

# Test case where the best plan is a lookup join only if the rows processed are
# also scaled correctly according to the limit hint (#48791).
exec-ddl
CREATE TABLE wallet (
    id bigserial primary key,
    name text not null,
    gender int,
    email text,
    first_name text,
    last_name text,
    creation_date timestamp not null,
    situation int,
    balance decimal not null,
    is_blocked bool,
    INDEX (name),
    INDEX (situation),
    INDEX (is_blocked),
    INDEX (balance)
);
----

exec-ddl
CREATE TABLE transaction (
    id bigserial primary key,
    sender_id bigint,
    receiver_id bigint,
    amount decimal not null,
    creation_date timestamp not null,
    last_update timestamp,
    schedule_date timestamp,
    status int,
    comment text,
    linked_trans_id bigint,
    c1 text,
    c2 text,
    c3 text,
    INDEX (sender_id),
    INDEX (receiver_id),
    INDEX (linked_trans_id)
);
----

opt
SELECT * FROM transaction t
JOIN wallet AS s on t.sender_id = s.id
JOIN wallet AS r on t.receiver_id = r.id
limit 10;
----
limit
 ├── columns: id:1!null sender_id:2!null receiver_id:3!null amount:4!null creation_date:5!null last_update:6 schedule_date:7 status:8 comment:9 linked_trans_id:10 c1:11 c2:12 c3:13 id:15!null name:16!null gender:17 email:18 first_name:19 last_name:20 creation_date:21!null situation:22 balance:23!null is_blocked:24 id:26!null name:27!null gender:28 email:29 first_name:30 last_name:31 creation_date:32!null situation:33 balance:34!null is_blocked:35
 ├── cardinality: [0 - 10]
 ├── stats: [rows=10]
 ├── cost: 2112.51
 ├── key: (1)
 ├── fd: (1)-->(2-13), (15)-->(16-24), (2)==(15), (15)==(2), (26)-->(27-35), (3)==(26), (26)==(3)
 ├── inner-join (lookup wallet [as=r])
 │    ├── columns: t.id:1!null sender_id:2!null receiver_id:3!null amount:4!null t.creation_date:5!null last_update:6 schedule_date:7 status:8 comment:9 linked_trans_id:10 c1:11 c2:12 c3:13 s.id:15!null s.name:16!null s.gender:17 s.email:18 s.first_name:19 s.last_name:20 s.creation_date:21!null s.situation:22 s.balance:23!null s.is_blocked:24 r.id:26!null r.name:27!null r.gender:28 r.email:29 r.first_name:30 r.last_name:31 r.creation_date:32!null r.situation:33 r.balance:34!null r.is_blocked:35
 │    ├── key columns: [3] = [26]
 │    ├── lookup columns are key
 │    ├── stats: [rows=980.1, distinct(3)=98.9950071, null(3)=0, distinct(26)=98.9950071, null(26)=0]
 │    ├── cost: 2112.4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-13), (15)-->(16-24), (2)==(15), (15)==(2), (26)-->(27-35), (3)==(26), (26)==(3)
 │    ├── limit hint: 10.00
 │    ├── inner-join (lookup wallet [as=s])
 │    │    ├── columns: t.id:1!null sender_id:2!null receiver_id:3 amount:4!null t.creation_date:5!null last_update:6 schedule_date:7 status:8 comment:9 linked_trans_id:10 c1:11 c2:12 c3:13 s.id:15!null s.name:16!null s.gender:17 s.email:18 s.first_name:19 s.last_name:20 s.creation_date:21!null s.situation:22 s.balance:23!null s.is_blocked:24
 │    │    ├── key columns: [2] = [15]
 │    │    ├── lookup columns are key
 │    │    ├── stats: [rows=990, distinct(1)=628.605476, null(1)=0, distinct(2)=99, null(2)=0, distinct(3)=99.9950071, null(3)=9.9, distinct(4)=99.9950071, null(4)=0, distinct(5)=99.9950071, null(5)=0, distinct(15)=99, null(15)=0, distinct(16)=99.9950071, null(16)=0, distinct(21)=99.9950071, null(21)=0, distinct(23)=99.9950071, null(23)=0]
 │    │    ├── cost: 1493.6
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-13), (15)-->(16-24), (2)==(15), (15)==(2)
 │    │    ├── limit hint: 100.00
 │    │    ├── scan transaction [as=t]
 │    │    │    ├── columns: t.id:1!null sender_id:2 receiver_id:3 amount:4!null t.creation_date:5!null last_update:6 schedule_date:7 status:8 comment:9 linked_trans_id:10 c1:11 c2:12 c3:13
 │    │    │    ├── stats: [rows=1000, distinct(1)=1000, null(1)=0, distinct(2)=100, null(2)=10, distinct(3)=100, null(3)=10, distinct(4)=100, null(4)=0, distinct(5)=100, null(5)=0]
 │    │    │    ├── cost: 256.01
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2-13)
 │    │    │    └── limit hint: 200.00
 │    │    └── filters (true)
 │    └── filters (true)
 └── 10

exec-ddl
CREATE TABLE abc (a INT PRIMARY KEY, b INT, c INT, INDEX c_idx (c))
----

exec-ddl
ALTER TABLE abc INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-05-01 1:00:00.00000+00:00",
    "row_count": 500000000,
    "distinct_count": 500000000
  }
]'
----

# Check that we choose the index join when it makes sense.
opt
SELECT * FROM abc WHERE c = 1
----
index-join abc
 ├── columns: a:1!null b:2 c:3!null
 ├── stats: [rows=9.9005002, distinct(3)=1, null(3)=0]
 ├── cost: 74.2145464
 ├── key: (1)
 ├── fd: ()-->(3), (1)-->(2)
 └── scan abc@c_idx
      ├── columns: a:1!null c:3!null
      ├── constraint: /3/1: [/1 - /1]
      ├── stats: [rows=9.9005002, distinct(3)=1, null(3)=0]
      ├── cost: 14.3065202
      ├── key: (1)
      └── fd: ()-->(3)

# Regression test for #34810: make sure we pick the lookup join that uses
# all equality columns.

exec-ddl
CREATE TABLE abcde (
  a TEXT NOT NULL,
  b UUID NOT NULL,
  c UUID NOT NULL,
  d VARCHAR(255) NOT NULL,
  e TEXT NOT NULL,
  UNIQUE INDEX idx_abd (a, b, d) STORING (c),
  UNIQUE INDEX idx_abcd (a, b, c, d)
)
----

exec-ddl
ALTER TABLE abcde INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 250000,
    "distinct_count": 1
  },
  {
    "columns": ["b"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 250000,
    "distinct_count": 2
  },
  {
    "columns": ["d"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 250000,
    "distinct_count": 125000
  }
]'
----

exec-ddl
CREATE TABLE wxyz (
  w TEXT NOT NULL,
  x UUID NOT NULL,
  y UUID NOT NULL,
  z TEXT NOT NULL
)
----

exec-ddl
ALTER TABLE wxyz INJECT STATISTICS '[
  {
    "columns": ["w"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 100,
    "distinct_count": 1
  },
  {
    "columns": ["x"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 100,
    "distinct_count": 1
  },
  {
    "columns": ["y"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 100,
    "distinct_count": 25
  }
]'
----

opt
SELECT w, x, y, z
FROM wxyz
INNER JOIN abcde
ON w = a AND x = b AND y = c
WHERE w = 'foo' AND x = '2AB23800-06B1-4E19-A3BB-DF3768B808D2'
----
project
 ├── columns: w:1!null x:2!null y:3!null z:4!null
 ├── stats: [rows=500.488759]
 ├── cost: 3174.98489
 ├── fd: ()-->(1,2)
 └── inner-join (lookup abcde@idx_abcd)
      ├── columns: w:1!null x:2!null y:3!null z:4!null a:7!null b:8!null c:9!null
      ├── key columns: [1 2 3] = [7 8 9]
      ├── stats: [rows=500.488759, distinct(1)=1, null(1)=0, distinct(2)=1, null(2)=0, distinct(3)=25, null(3)=0, distinct(7)=1, null(7)=0, distinct(8)=1, null(8)=0, distinct(9)=25, null(9)=0]
      ├── cost: 3169.97
      ├── fd: ()-->(1,2,7,8), (1)==(7), (7)==(1), (2)==(8), (8)==(2), (3)==(9), (9)==(3)
      ├── select
      │    ├── columns: w:1!null x:2!null y:3!null z:4!null
      │    ├── stats: [rows=100, distinct(1)=1, null(1)=0, distinct(2)=1, null(2)=0, distinct(3)=25, null(3)=0, distinct(4)=10, null(4)=0]
      │    ├── cost: 124.94
      │    ├── fd: ()-->(1,2)
      │    ├── scan wxyz
      │    │    ├── columns: w:1!null x:2!null y:3!null z:4!null
      │    │    ├── stats: [rows=100, distinct(1)=1, null(1)=0, distinct(2)=1, null(2)=0, distinct(3)=25, null(3)=0, distinct(4)=10, null(4)=0]
      │    │    └── cost: 123.91
      │    └── filters
      │         ├── w:1 = 'foo' [outer=(1), constraints=(/1: [/'foo' - /'foo']; tight), fd=()-->(1)]
      │         └── x:2 = '2ab23800-06b1-4e19-a3bb-df3768b808d2' [outer=(2), constraints=(/2: [/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'2ab23800-06b1-4e19-a3bb-df3768b808d2']; tight), fd=()-->(2)]
      └── filters
           ├── a:7 = 'foo' [outer=(7), constraints=(/7: [/'foo' - /'foo']; tight), fd=()-->(7)]
           └── b:8 = '2ab23800-06b1-4e19-a3bb-df3768b808d2' [outer=(8), constraints=(/8: [/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'2ab23800-06b1-4e19-a3bb-df3768b808d2']; tight), fd=()-->(8)]

# Also for 34810: make sure the cost adjustment works when the estimated row
# count is tiny.
exec-ddl
CREATE TABLE wxyzijklmn (
  w TEXT NOT NULL,
  x UUID NOT NULL,
  y UUID NOT NULL,
  z TEXT NOT NULL,
  i INT,
  j INT,
  k INT,
  l INT,
  m INT,
  n INT
)
----

exec-ddl
ALTER TABLE wxyzijklmn INJECT STATISTICS '[
  {
    "columns": ["w"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 10000,
    "distinct_count": 1
  },
  {
    "columns": ["x"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 1
  },
  {
    "columns": ["y"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 25
  },
  {
    "columns": ["i"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["j"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["k"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["l"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["m"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["n"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'
----

opt
SELECT w, x, y, z
FROM wxyzijklmn
INNER JOIN abcde
ON w = a AND x = b AND y = c
WHERE w = 'foo' AND x = '2AB23800-06B1-4E19-A3BB-DF3768B808D2' AND (i,j,k,l,m,n)=(1,2,3,4,5,6)
----
project
 ├── columns: w:1!null x:2!null y:3!null z:4!null
 ├── stats: [rows=4.50439933]
 ├── cost: 12243.69
 ├── fd: ()-->(1,2)
 └── inner-join (lookup abcde@idx_abcd)
      ├── columns: w:1!null x:2!null y:3!null z:4!null i:5!null j:6!null k:7!null l:8!null m:9!null n:10!null a:13!null b:14!null c:15!null
      ├── key columns: [1 2 3] = [13 14 15]
      ├── stats: [rows=4.50439933, distinct(1)=0.9000001, null(1)=0, distinct(2)=0.9000001, null(2)=0, distinct(3)=0.88403183, null(3)=0, distinct(13)=0.9000001, null(13)=0, distinct(14)=0.9000001, null(14)=0, distinct(15)=0.88403183, null(15)=0]
      ├── cost: 12243.635
      ├── fd: ()-->(1,2,5-10,13,14), (1)==(13), (13)==(1), (2)==(14), (14)==(2), (3)==(15), (15)==(3)
      ├── select
      │    ├── columns: w:1!null x:2!null y:3!null z:4!null i:5!null j:6!null k:7!null l:8!null m:9!null n:10!null
      │    ├── stats: [rows=0.9000001, distinct(1)=0.9000001, null(1)=0, distinct(2)=0.9000001, null(2)=0, distinct(3)=0.88403183, null(3)=0, distinct(4)=0.899635687, null(4)=0, distinct(5)=0.9000001, null(5)=0, distinct(6)=0.9000001, null(6)=0, distinct(7)=0.9000001, null(7)=0, distinct(8)=0.9000001, null(8)=0, distinct(9)=0.9000001, null(9)=0, distinct(10)=0.9000001, null(10)=0, distinct(5-10)=0.9000001, null(5-10)=0]
      │    ├── cost: 12216.2
      │    ├── fd: ()-->(1,2,5-10)
      │    ├── scan wxyzijklmn
      │    │    ├── columns: w:1!null x:2!null y:3!null z:4!null i:5 j:6 k:7 l:8 m:9 n:10
      │    │    ├── stats: [rows=10000, distinct(1)=1, null(1)=0, distinct(2)=1, null(2)=0, distinct(3)=25, null(3)=0, distinct(4)=1000, null(4)=0, distinct(5)=10000, null(5)=0, distinct(6)=10000, null(6)=0, distinct(7)=10000, null(7)=0, distinct(8)=10000, null(8)=0, distinct(9)=10000, null(9)=0, distinct(10)=10000, null(10)=0, distinct(5-10)=10000, null(5-10)=0]
      │    │    └── cost: 12116.11
      │    └── filters
      │         ├── w:1 = 'foo' [outer=(1), constraints=(/1: [/'foo' - /'foo']; tight), fd=()-->(1)]
      │         ├── x:2 = '2ab23800-06b1-4e19-a3bb-df3768b808d2' [outer=(2), constraints=(/2: [/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'2ab23800-06b1-4e19-a3bb-df3768b808d2']; tight), fd=()-->(2)]
      │         ├── i:5 = 1 [outer=(5), constraints=(/5: [/1 - /1]; tight), fd=()-->(5)]
      │         ├── j:6 = 2 [outer=(6), constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]
      │         ├── k:7 = 3 [outer=(7), constraints=(/7: [/3 - /3]; tight), fd=()-->(7)]
      │         ├── l:8 = 4 [outer=(8), constraints=(/8: [/4 - /4]; tight), fd=()-->(8)]
      │         ├── m:9 = 5 [outer=(9), constraints=(/9: [/5 - /5]; tight), fd=()-->(9)]
      │         └── n:10 = 6 [outer=(10), constraints=(/10: [/6 - /6]; tight), fd=()-->(10)]
      └── filters
           ├── a:13 = 'foo' [outer=(13), constraints=(/13: [/'foo' - /'foo']; tight), fd=()-->(13)]
           └── b:14 = '2ab23800-06b1-4e19-a3bb-df3768b808d2' [outer=(14), constraints=(/14: [/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'2ab23800-06b1-4e19-a3bb-df3768b808d2']; tight), fd=()-->(14)]

exec-ddl
DROP TABLE abcde
----

exec-ddl
DROP TABLE wxyz
----

exec-ddl
CREATE TABLE abcde (
  a TEXT NOT NULL,
  b UUID NOT NULL,
  c UUID NOT NULL,
  d VARCHAR(255) NOT NULL,
  e TEXT NOT NULL,
  CONSTRAINT "primary" PRIMARY KEY (a, b, c),
  UNIQUE INDEX idx_abd (a, b, d),
  UNIQUE INDEX idx_abcd (a, b, c, d)
)
----

exec-ddl
ALTER TABLE abcde INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 250000,
    "distinct_count": 1
  },
  {
    "columns": ["b"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 250000,
    "distinct_count": 2
  },
  {
    "columns": ["d"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 250000,
    "distinct_count": 125000
  }
]'
----

exec-ddl
CREATE TABLE wxyz (
  w TEXT NOT NULL,
  x UUID NOT NULL,
  y UUID NOT NULL,
  z TEXT NOT NULL,
  CONSTRAINT "primary" PRIMARY KEY (w, x, y),
  CONSTRAINT "foreign" FOREIGN KEY (w, x, y) REFERENCES abcde (a, b, c)
)
----

exec-ddl
ALTER TABLE wxyz INJECT STATISTICS '[
  {
    "columns": ["w"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 10000,
    "distinct_count": 1
  },
  {
    "columns": ["x"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 1
  },
  {
    "columns": ["y"],
    "created_at": "2019-02-08 04:10:40.119954+00:00",
    "row_count": 10000,
    "distinct_count": 2500
  }
]'
----

# Regression test for #34811. Ensure the soft limit propagation causes us to
# select a lookup join.
opt
SELECT w, x, y, z
FROM wxyz
INNER JOIN abcde
ON w = a AND x = b AND y = c
WHERE w = 'foo' AND x = '2AB23800-06B1-4E19-A3BB-DF3768B808D2'
ORDER BY d
LIMIT 10
----
project
 ├── columns: w:1!null x:2!null y:3!null z:4!null  [hidden: d:9!null]
 ├── cardinality: [0 - 10]
 ├── stats: [rows=10]
 ├── cost: 595.94172
 ├── key: (9)
 ├── fd: ()-->(1,2), (3)-->(4,9), (9)-->(3,4)
 ├── ordering: +9 opt(1,2) [actual: +9]
 └── limit
      ├── columns: w:1!null x:2!null y:3!null z:4!null a:6!null b:7!null c:8!null d:9!null
      ├── internal-ordering: +9 opt(1,2,6,7)
      ├── cardinality: [0 - 10]
      ├── stats: [rows=10]
      ├── cost: 595.83172
      ├── key: (8)
      ├── fd: ()-->(1,2,6,7), (3)-->(4), (8)-->(9), (9)-->(8), (1)==(6), (6)==(1), (2)==(7), (7)==(2), (3)==(8), (8)==(3)
      ├── ordering: +9 opt(1,2,6,7) [actual: +9]
      ├── inner-join (lookup wxyz)
      │    ├── columns: w:1!null x:2!null y:3!null z:4!null a:6!null b:7!null c:8!null d:9!null
      │    ├── key columns: [6 7 8] = [1 2 3]
      │    ├── lookup columns are key
      │    ├── stats: [rows=50048.8759, distinct(1)=1, null(1)=0, distinct(2)=1, null(2)=0, distinct(3)=2500, null(3)=0, distinct(6)=1, null(6)=0, distinct(7)=1, null(7)=0, distinct(8)=2500, null(8)=0]
      │    ├── cost: 595.72172
      │    ├── key: (8)
      │    ├── fd: ()-->(1,2,6,7), (3)-->(4), (8)-->(9), (9)-->(8), (1)==(6), (6)==(1), (2)==(7), (7)==(2), (3)==(8), (8)==(3)
      │    ├── ordering: +9 opt(1,2,6,7) [actual: +9]
      │    ├── limit hint: 10.00
      │    ├── scan abcde@idx_abd
      │    │    ├── columns: a:6!null b:7!null c:8!null d:9!null
      │    │    ├── constraint: /6/7/9: [/'foo'/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'foo'/'2ab23800-06b1-4e19-a3bb-df3768b808d2']
      │    │    ├── stats: [rows=125000, distinct(6)=1, null(6)=0, distinct(7)=1, null(7)=0, distinct(8)=24975.5859, null(8)=0, distinct(9)=93750, null(9)=0]
      │    │    ├── cost: 112.01
      │    │    ├── key: (8)
      │    │    ├── fd: ()-->(6,7), (8)-->(9), (9)-->(8)
      │    │    ├── ordering: +9 opt(6,7) [actual: +9]
      │    │    └── limit hint: 100.00
      │    └── filters
      │         ├── w:1 = 'foo' [outer=(1), constraints=(/1: [/'foo' - /'foo']; tight), fd=()-->(1)]
      │         └── x:2 = '2ab23800-06b1-4e19-a3bb-df3768b808d2' [outer=(2), constraints=(/2: [/'2ab23800-06b1-4e19-a3bb-df3768b808d2' - /'2ab23800-06b1-4e19-a3bb-df3768b808d2']; tight), fd=()-->(2)]
      └── 10

exec-ddl
CREATE TABLE p (p INT PRIMARY KEY)
----

exec-ddl
CREATE TABLE c (c INT PRIMARY KEY, p INT REFERENCES p(p));
----

opt
INSERT INTO c VALUES (1,1), (2,2)
----
insert c
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:4 => c:1
 │    └── column2:5 => c.p:2
 ├── input binding: &1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 ├── stats: [rows=0]
 ├── cost: 12.12
 ├── values
 │    ├── columns: column1:4!null column2:5!null
 │    ├── cardinality: [2 - 2]
 │    ├── stats: [rows=2, distinct(5)=2, null(5)=0]
 │    ├── cost: 0.03
 │    ├── (1, 1)
 │    └── (2, 2)
 └── f-k-checks
      └── f-k-checks-item: c(p) -> p(p)
           └── anti-join (lookup p)
                ├── columns: p:6!null
                ├── key columns: [6] = [7]
                ├── lookup columns are key
                ├── cardinality: [0 - 2]
                ├── stats: [rows=1e-10]
                ├── cost: 12.08
                ├── with-scan &1
                │    ├── columns: p:6!null
                │    ├── mapping:
                │    │    └──  column2:5 => p:6
                │    ├── cardinality: [2 - 2]
                │    ├── stats: [rows=2, distinct(6)=2, null(6)=0]
                │    └── cost: 0.01
                └── filters (true)

# The cost should be much smaller with this hint.
opt prefer-lookup-joins-for-fks
INSERT INTO c VALUES (1,1), (2,2)
----
insert c
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:4 => c:1
 │    └── column2:5 => c.p:2
 ├── input binding: &1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 ├── stats: [rows=0]
 ├── cost: 0.06001206
 ├── values
 │    ├── columns: column1:4!null column2:5!null
 │    ├── cardinality: [2 - 2]
 │    ├── stats: [rows=2, distinct(5)=2, null(5)=0]
 │    ├── cost: 0.03
 │    ├── (1, 1)
 │    └── (2, 2)
 └── f-k-checks
      └── f-k-checks-item: c(p) -> p(p)
           └── anti-join (lookup p)
                ├── columns: p:6!null
                ├── flags: prefer lookup join (into right side)
                ├── key columns: [6] = [7]
                ├── lookup columns are key
                ├── cardinality: [0 - 2]
                ├── stats: [rows=1e-10]
                ├── cost: 0.02001206
                ├── with-scan &1
                │    ├── columns: p:6!null
                │    ├── mapping:
                │    │    └──  column2:5 => p:6
                │    ├── cardinality: [2 - 2]
                │    ├── stats: [rows=2, distinct(6)=2, null(6)=0]
                │    └── cost: 0.01
                └── filters (true)

# Verify that we prefer lookup join for the FK check when inserting a single
# row, even if the other table is very small. See #41701.
exec-ddl
ALTER TABLE p INJECT STATISTICS '[
  {
    "columns": ["p"],
    "created_at": "2019-02-08 04:10:40.001179+00:00",
    "row_count": 2,
    "distinct_count": 2
  }
]'
----

opt
INSERT INTO c VALUES (1, 1)
----
insert c
 ├── columns: <none>
 ├── insert-mapping:
 │    ├── column1:4 => c:1
 │    └── column2:5 => c.p:2
 ├── input binding: &1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 ├── stats: [rows=0]
 ├── cost: 6.08
 ├── values
 │    ├── columns: column1:4!null column2:5!null
 │    ├── cardinality: [1 - 1]
 │    ├── stats: [rows=1, distinct(5)=1, null(5)=0]
 │    ├── cost: 0.02
 │    ├── key: ()
 │    ├── fd: ()-->(4,5)
 │    └── (1, 1)
 └── f-k-checks
      └── f-k-checks-item: c(p) -> p(p)
           └── anti-join (lookup p)
                ├── columns: p:6!null
                ├── key columns: [6] = [7]
                ├── lookup columns are key
                ├── cardinality: [0 - 1]
                ├── stats: [rows=1e-10]
                ├── cost: 6.05
                ├── key: ()
                ├── fd: ()-->(6)
                ├── with-scan &1
                │    ├── columns: p:6!null
                │    ├── mapping:
                │    │    └──  column2:5 => p:6
                │    ├── cardinality: [1 - 1]
                │    ├── stats: [rows=1, distinct(6)=1, null(6)=0]
                │    ├── cost: 0.01
                │    ├── key: ()
                │    └── fd: ()-->(6)
                └── filters (true)

# Avoid performing a lookup join with virtual tables if the filter is
# not extremely selective.

opt
SELECT
  a.attname,
  a.atttypid,
  t.typbasetype,
  t.typtype
FROM
  pg_catalog.pg_attribute AS a
  JOIN pg_catalog.pg_type AS t ON (a.atttypid = t.oid)
WHERE
  a.attname IN ('descriptor_id', 'descriptor_name')
----
project
 ├── columns: attname:3!null atttypid:4!null typbasetype:51 typtype:33
 ├── stats: [rows=198]
 ├── cost: 2880.95877
 └── inner-join (merge)
      ├── columns: attname:3!null atttypid:4!null oid:27!null typtype:33 typbasetype:51
      ├── left ordering: +27
      ├── right ordering: +4
      ├── stats: [rows=198, distinct(4)=17.2927193, null(4)=0, distinct(27)=17.2927193, null(27)=0]
      ├── cost: 2878.96877
      ├── fd: (4)==(27), (27)==(4)
      ├── scan pg_type@secondary [as=t]
      │    ├── columns: oid:27!null typtype:33 typbasetype:51
      │    ├── stats: [rows=1000, distinct(27)=100, null(27)=0]
      │    ├── cost: 1467.51
      │    └── ordering: +27
      ├── sort
      │    ├── columns: attname:3!null atttypid:4
      │    ├── stats: [rows=20, distinct(3)=2, null(3)=0, distinct(4)=18.2927193, null(4)=0.2]
      │    ├── cost: 1399.26877
      │    ├── ordering: +4
      │    └── select
      │         ├── columns: attname:3!null atttypid:4
      │         ├── stats: [rows=20, distinct(3)=2, null(3)=0, distinct(4)=18.2927193, null(4)=0.2]
      │         ├── cost: 1396.73
      │         ├── scan pg_attribute [as=a]
      │         │    ├── columns: attname:3 atttypid:4
      │         │    ├── stats: [rows=1000, distinct(3)=100, null(3)=10, distinct(4)=100, null(4)=10]
      │         │    └── cost: 1386.71
      │         └── filters
      │              └── attname:3 IN ('descriptor_id', 'descriptor_name') [outer=(3), constraints=(/3: [/'descriptor_id' - /'descriptor_id'] [/'descriptor_name' - /'descriptor_name']; tight)]
      └── filters (true)


# A lookup join should be performed with a virtual table if the filter
# is very selective.
opt
SELECT
  a.attname,
  a.atttypid,
  t.typbasetype,
  t.typtype
FROM
  pg_catalog.pg_attribute AS a
  JOIN pg_catalog.pg_type AS t ON (a.atttypid = t.oid)
WHERE
  a.attname = 'descriptor_id'
----
project
 ├── columns: attname:3!null atttypid:4!null typbasetype:51 typtype:33
 ├── stats: [rows=99]
 ├── cost: 2831.38
 ├── fd: ()-->(3)
 └── inner-join (lookup pg_type@secondary [as=t])
      ├── columns: attname:3!null atttypid:4!null oid:27!null typtype:33 typbasetype:51
      ├── key columns: [4] = [27]
      ├── stats: [rows=99, distinct(4)=8.5617925, null(4)=0, distinct(27)=8.5617925, null(27)=0]
      ├── cost: 2830.38
      ├── fd: ()-->(3), (4)==(27), (27)==(4)
      ├── select
      │    ├── columns: attname:3!null atttypid:4
      │    ├── stats: [rows=10, distinct(3)=1, null(3)=0, distinct(4)=9.5617925, null(4)=0.1]
      │    ├── cost: 1396.73
      │    ├── fd: ()-->(3)
      │    ├── scan pg_attribute [as=a]
      │    │    ├── columns: attname:3 atttypid:4
      │    │    ├── stats: [rows=1000, distinct(3)=100, null(3)=10, distinct(4)=100, null(4)=10]
      │    │    └── cost: 1386.71
      │    └── filters
      │         └── attname:3 = 'descriptor_id' [outer=(3), constraints=(/3: [/'descriptor_id' - /'descriptor_id']; tight), fd=()-->(3)]
      └── filters (true)
