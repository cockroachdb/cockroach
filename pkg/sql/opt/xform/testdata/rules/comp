exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----
TABLE a
 ├── k int not null
 ├── i int
 ├── f float
 ├── s string
 ├── j jsonb
 └── INDEX primary
      └── k int not null

# --------------------------------------------------
# NormalizeVarEqNe
# --------------------------------------------------

# Put variables on both sides of comparison operator to avoid matching constant
# patterns.
opt
SELECT * FROM a WHERE 1+i=k AND 2-k<>i
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.k [type=int]
      │    └── plus [type=int]
      │         ├── variable: a.i [type=int]
      │         └── const: 1 [type=int]
      └── ne [type=bool]
           ├── variable: a.i [type=int]
           └── minus [type=int]
                ├── const: 2 [type=int]
                └── variable: a.k [type=int]

# --------------------------------------------------
# NormalizeVarInequality
# --------------------------------------------------

# Put variables on both sides of comparison operator to avoid matching constant
# patterns.
opt
SELECT * FROM a WHERE 1+i<k AND k-1<=i AND i*i>k AND k/2>=i
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── gt [type=bool]
      │    ├── variable: a.k [type=int]
      │    └── plus [type=int]
      │         ├── variable: a.i [type=int]
      │         └── const: 1 [type=int]
      ├── ge [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=int]
      │         ├── variable: a.k [type=int]
      │         └── const: 1 [type=int]
      ├── lt [type=bool]
      │    ├── variable: a.k [type=int]
      │    └── mult [type=int]
      │         ├── variable: a.i [type=int]
      │         └── variable: a.i [type=int]
      └── le [type=bool]
           ├── variable: a.i [type=int]
           └── div [type=decimal]
                ├── variable: a.k [type=int]
                └── const: 2 [type=int]

# --------------------------------------------------
# NormalizeConstEqNe
# --------------------------------------------------
opt
SELECT * FROM a WHERE length('foo')+1=i+k AND length('bar')<>i*2
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── plus [type=int]
      │    │    ├── variable: a.i [type=int]
      │    │    └── variable: a.k [type=int]
      │    └── plus [type=int]
      │         ├── function: length [type=int]
      │         │    └── const: 'foo' [type=string]
      │         └── const: 1 [type=int]
      └── ne [type=bool]
           ├── mult [type=int]
           │    ├── variable: a.i [type=int]
           │    └── const: 2 [type=int]
           └── function: length [type=int]
                └── const: 'bar' [type=string]

# --------------------------------------------------
# NormalizeConstInequality
# --------------------------------------------------
opt
SELECT * FROM a WHERE length('foo')+1<i+k AND length('bar')<=i*2 AND 5>i AND 'foo'>=s
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── gt [type=bool]
      │    ├── plus [type=int]
      │    │    ├── variable: a.i [type=int]
      │    │    └── variable: a.k [type=int]
      │    └── plus [type=int]
      │         ├── function: length [type=int]
      │         │    └── const: 'foo' [type=string]
      │         └── const: 1 [type=int]
      ├── ge [type=bool]
      │    ├── mult [type=int]
      │    │    ├── variable: a.i [type=int]
      │    │    └── const: 2 [type=int]
      │    └── function: length [type=int]
      │         └── const: 'bar' [type=string]
      ├── lt [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── const: 5 [type=int]
      └── le [type=bool]
           ├── variable: a.s [type=string]
           └── const: 'foo' [type=string]

# --------------------------------------------------
# NormalizeCmpPlusConst
# --------------------------------------------------
opt
SELECT *
FROM a
WHERE
    i+1 = 2 AND
    (f+f)+2 < 5 AND
    1::decimal+i <= length('foo') AND
    i+2+2 > 10 AND
    '1:00:00'::time + i::interval >= '2:00:00'::time
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=int]
      │         ├── const: 2 [type=int]
      │         └── const: 1 [type=int]
      ├── lt [type=bool]
      │    ├── plus [type=float]
      │    │    ├── variable: a.f [type=float]
      │    │    └── variable: a.f [type=float]
      │    └── minus [type=float]
      │         ├── const: 5.0 [type=float]
      │         └── const: 2.0 [type=float]
      ├── le [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=decimal]
      │         ├── function: length [type=int]
      │         │    └── const: 'foo' [type=string]
      │         └── const: 1 [type=decimal]
      ├── gt [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=int]
      │         ├── minus [type=int]
      │         │    ├── const: 10 [type=int]
      │         │    └── const: 2 [type=int]
      │         └── const: 2 [type=int]
      └── ge [type=bool]
           ├── cast: interval [type=interval]
           │    └── variable: a.i [type=int]
           └── minus [type=interval]
                ├── const: '02:00:00' [type=time]
                └── const: '01:00:00' [type=time]

# Try case that should not match pattern because Plus overload is not defined.
opt
SELECT * FROM a WHERE s::json - 1 = '[1]'::json
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── eq [type=bool]
      ├── minus [type=jsonb]
      │    ├── cast: jsonb [type=jsonb]
      │    │    └── variable: a.s [type=string]
      │    └── const: 1 [type=int]
      └── const: '[1]' [type=jsonb]

# --------------------------------------------------
# NormalizeCmpMinusConst
# --------------------------------------------------
opt
SELECT *
FROM a
WHERE
    i-1 = 2 AND
    (f+f)-2 < 5 AND
    i-1::decimal <= length('foo') AND
    i-2-2 > 10 AND
    f+i::float-10.0 >= 100.0
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── plus [type=int]
      │         ├── const: 2 [type=int]
      │         └── const: 1 [type=int]
      ├── lt [type=bool]
      │    ├── plus [type=float]
      │    │    ├── variable: a.f [type=float]
      │    │    └── variable: a.f [type=float]
      │    └── plus [type=float]
      │         ├── const: 5.0 [type=float]
      │         └── const: 2.0 [type=float]
      ├── le [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── plus [type=decimal]
      │         ├── function: length [type=int]
      │         │    └── const: 'foo' [type=string]
      │         └── const: 1 [type=decimal]
      ├── gt [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── plus [type=int]
      │         ├── plus [type=int]
      │         │    ├── const: 10 [type=int]
      │         │    └── const: 2 [type=int]
      │         └── const: 2 [type=int]
      └── ge [type=bool]
           ├── plus [type=float]
           │    ├── variable: a.f [type=float]
           │    └── cast: float [type=float]
           │         └── variable: a.i [type=int]
           └── plus [type=float]
                ├── const: 100.0 [type=float]
                └── const: 10.0 [type=float]

# Try case that should not match pattern because Plus overload is not defined.
opt
SELECT * FROM a WHERE s::json - 1 = '[1]'::json
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── eq [type=bool]
      ├── minus [type=jsonb]
      │    ├── cast: jsonb [type=jsonb]
      │    │    └── variable: a.s [type=string]
      │    └── const: 1 [type=int]
      └── const: '[1]' [type=jsonb]

# --------------------------------------------------
# NormalizeCmpConstMinus
# --------------------------------------------------
opt
SELECT *
FROM a
WHERE
    1-i = 2 AND
    2-(f+f) < 5 AND
    1::decimal-i <= length('foo') AND
    2-(2-i) > 10 AND
    10.0-(f+i::float) >= 100.0
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=int]
      │         ├── const: 1 [type=int]
      │         └── const: 2 [type=int]
      ├── gt [type=bool]
      │    ├── plus [type=float]
      │    │    ├── variable: a.f [type=float]
      │    │    └── variable: a.f [type=float]
      │    └── minus [type=float]
      │         ├── const: 2.0 [type=float]
      │         └── const: 5.0 [type=float]
      ├── ge [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=decimal]
      │         ├── const: 1 [type=decimal]
      │         └── function: length [type=int]
      │              └── const: 'foo' [type=string]
      ├── gt [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── minus [type=int]
      │         ├── const: 2 [type=int]
      │         └── minus [type=int]
      │              ├── const: 2 [type=int]
      │              └── const: 10 [type=int]
      └── le [type=bool]
           ├── plus [type=float]
           │    ├── variable: a.f [type=float]
           │    └── cast: float [type=float]
           │         └── variable: a.i [type=int]
           └── minus [type=float]
                ├── const: 10.0 [type=float]
                └── const: 100.0 [type=float]

# Try case that should not match pattern because Minus overload is not defined.
opt
SELECT * FROM a WHERE '[1, 2]'::json - i = '[1]'
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── eq [type=bool]
      ├── minus [type=jsonb]
      │    ├── const: '[1, 2]' [type=jsonb]
      │    └── variable: a.i [type=int]
      └── const: '[1]' [type=jsonb]

# --------------------------------------------------
# NormalizeTupleEquality
# --------------------------------------------------
opt
SELECT * FROM a WHERE (i, f, s) = (1, 3.5, 'foo')
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── const: 1 [type=int]
      ├── eq [type=bool]
      │    ├── variable: a.f [type=float]
      │    └── const: 3.5 [type=float]
      └── eq [type=bool]
           ├── variable: a.s [type=string]
           └── const: 'foo' [type=string]

# --------------------------------------------------
# NormalizeTupleEquality, FlattenAnd
# --------------------------------------------------

# Nested tuples.
opt
SELECT * FROM a WHERE (1, (2, 'foo')) = (k, (i, s))
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── and [type=bool]
      ├── eq [type=bool]
      │    ├── variable: a.k [type=int]
      │    └── const: 1 [type=int]
      ├── eq [type=bool]
      │    ├── variable: a.i [type=int]
      │    └── const: 2 [type=int]
      └── eq [type=bool]
           ├── variable: a.s [type=string]
           └── const: 'foo' [type=string]

# --------------------------------------------------
# FoldNullComparisonLeft, FoldNullComparisonRight
# --------------------------------------------------

# Use null::type to circumvent type checker constant folding.
opt
SELECT *
FROM a
WHERE
    null::int = 1 AND 1 = null::int AND
    null::int <> 1 AND 1 <> null::int AND
    null::int > 1 AND 1 > null::int AND
    null::int >= 1 AND 1 >= null::int AND
    null::int < 1 AND 1 < null::int AND
    null::int <= 1 AND 1 <= null::int AND
    null::string LIKE 'foo' AND 'foo' LIKE null::string AND
    null::string NOT LIKE 'foo' AND 'foo' NOT LIKE null::string AND
    null::string ILIKE 'foo' AND 'foo' ILIKE null::string AND
    null::string NOT ILIKE 'foo' AND 'foo' NOT ILIKE null::string AND
    null::string SIMILAR TO 'foo' AND 'foo' SIMILAR TO null::string AND
    null::string NOT SIMILAR TO 'foo' AND 'foo' NOT SIMILAR TO null::string AND
    null::string ~ 'foo' AND 'foo' ~ null::string AND
    null::string !~ 'foo' AND 'foo' !~ null::string AND
    null::string ~* 'foo' AND 'foo' ~* null::string AND
    null::string !~* 'foo' AND 'foo' !~* null::string
----
select
 ├── columns: k:int:1 i:int:null:2 f:float:null:3 s:string:null:4 j:jsonb:null:5
 ├── scan
 │    └── columns: a.k:int:1 a.i:int:null:2 a.f:float:null:3 a.s:string:null:4 a.j:jsonb:null:5
 └── null [type=bool]
