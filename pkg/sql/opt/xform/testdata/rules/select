exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u(u) STORING (v),
    UNIQUE INDEX v(v) STORING (u)
)
----
TABLE a
 ├── k int not null
 ├── u int
 ├── v int
 ├── INDEX primary
 │    └── k int not null
 ├── INDEX u
 │    ├── u int
 │    ├── k int not null
 │    └── v int (storing)
 └── INDEX v
      ├── v int
      ├── k int not null (storing)
      └── u int (storing)

# --------------------------------------------------
# ConstrainScan
# --------------------------------------------------

opt
SELECT k FROM a WHERE k = 1
----
scan a
 ├── columns: k:1(int!null)
 └── constraint: /1: [/1 - /1]

memo
SELECT k FROM a WHERE k = 1
----
[9: "physical: [presentation: k:1]"]
memo
 ├── G9: (select G8 G5) (scan a,constrained)
 │    └── "physical: [presentation: k:1]" [cost=100.00]
 │         └── best: (scan a,constrained)
 ├── G8: (scan a) (scan a@u) (scan a@v)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G5: (filters G4)
 ├── G4: (eq G2 G3)
 ├── G2: (variable a.k)
 └── G3: (const 1)

opt
SELECT k FROM a WHERE v > 1
----
project
 ├── columns: k:1(int!null)
 ├── scan a@v
 │    ├── columns: a.k:1(int!null) a.v:3(int)
 │    └── constraint: /3: [/2 - ]
 └── projections [outer=(1)]
      └── variable: a.k [type=int, outer=(1)]

memo
SELECT k FROM a WHERE v > 1
----
[11: "physical: [presentation: k:1]"]
memo
 ├── G11: (project G10 G8)
 │    └── "physical: [presentation: k:1]" [cost=100.00]
 │         └── best: (project G10 G8)
 ├── G10: (select G9 G5) (scan a@v,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a@v,constrained)
 ├── G9: (scan a) (scan a@u) (scan a@v)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G5: (filters G4)
 ├── G4: (gt G2 G3)
 ├── G2: (variable a.v)
 ├── G3: (const 1)
 ├── G8: (projections G7)
 └── G7: (variable a.k)

opt
SELECT k FROM a WHERE u = 1 AND k = 5
----
project
 ├── columns: k:1(int!null)
 ├── scan a@u
 │    ├── columns: a.k:1(int!null) a.u:2(int)
 │    └── constraint: /2/1: [/1/5 - /1/5]
 └── projections [outer=(1)]
      └── variable: a.k [type=int, outer=(1)]

memo
SELECT k FROM a WHERE u = 1 AND k = 5
----
[14: "physical: [presentation: k:1]"]
memo
 ├── G14: (project G13 G11)
 │    └── "physical: [presentation: k:1]" [cost=100.00]
 │         └── best: (project G13 G11)
 ├── G13: (select G12 G9) (select G17 G16) (scan a@u,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a@u,constrained)
 ├── G17: (scan a,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a,constrained)
 ├── G16: (filters G4)
 ├── G12: (scan a) (scan a@u) (scan a@v)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G9: (filters G4 G7)
 ├── G4: (eq G2 G3)
 ├── G2: (variable a.u)
 ├── G3: (const 1)
 ├── G7: (eq G5 G6)
 ├── G6: (const 5)
 ├── G11: (projections G5)
 └── G5: (variable a.k)

# Constraint + remaining filter.
opt
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
project
 ├── columns: k:1(int!null)
 ├── select
 │    ├── columns: a.k:1(int!null) a.u:2(int)
 │    ├── scan a@u
 │    │    ├── columns: a.k:1(int!null) a.u:2(int)
 │    │    └── constraint: /2/1: [/1 - /1]
 │    └── filters [type=bool, outer=(1,2)]
 │         └── eq [type=bool, outer=(1,2)]
 │              ├── plus [type=int, outer=(1,2)]
 │              │    ├── variable: a.k [type=int, outer=(1)]
 │              │    └── variable: a.u [type=int, outer=(2)]
 │              └── const: 1 [type=int]
 └── projections [outer=(1)]
      └── variable: a.k [type=int, outer=(1)]

memo
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
[14: "physical: [presentation: k:1]"]
memo
 ├── G14: (project G13 G11)
 │    └── "physical: [presentation: k:1]" [cost=110.00]
 │         └── best: (project G13 G11)
 ├── G13: (select G12 G9) (select G17 G16)
 │    └── "" [cost=110.00]
 │         └── best: (select G17 G16)
 ├── G17: (scan a@u,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a@u,constrained)
 ├── G16: (filters G7)
 ├── G12: (scan a) (scan a@u) (scan a@v)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G9: (filters G4 G7)
 ├── G4: (eq G2 G3)
 ├── G7: (eq G6 G3)
 ├── G6: (plus G5 G2)
 ├── G2: (variable a.u)
 ├── G3: (const 1)
 ├── G11: (projections G5)
 └── G5: (variable a.k)

opt
SELECT k FROM a WHERE u = 1 AND v = 5
----
project
 ├── columns: k:1(int!null)
 ├── select
 │    ├── columns: a.k:1(int!null) a.u:2(int) a.v:3(int)
 │    ├── scan a@u
 │    │    ├── columns: a.k:1(int!null) a.u:2(int) a.v:3(int)
 │    │    └── constraint: /2/1: [/1 - /1]
 │    └── filters [type=bool, outer=(3), constraints=(/3: [/5 - /5]; tight)]
 │         └── eq [type=bool, outer=(3), constraints=(/3: [/5 - /5]; tight)]
 │              ├── variable: a.v [type=int, outer=(3)]
 │              └── const: 5 [type=int]
 └── projections [outer=(1)]
      └── variable: a.k [type=int, outer=(1)]

memo
SELECT k FROM a WHERE u = 1 AND v = 5
----
[13: "physical: [presentation: k:1]"]
memo
 ├── G13: (project G10 G12)
 │    └── "physical: [presentation: k:1]" [cost=110.00]
 │         └── best: (project G10 G12)
 ├── G10: (select G1 G9) (select G16 G15) (select G18 G17)
 │    └── "" [cost=110.00]
 │         └── best: (select G16 G15)
 ├── G18: (scan a@v,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a@v,constrained)
 ├── G17: (filters G4)
 ├── G16: (scan a@u,constrained)
 │    └── "" [cost=100.00]
 │         └── best: (scan a@u,constrained)
 ├── G15: (filters G7)
 ├── G1: (scan a) (scan a@u) (scan a@v)
 │    └── "" [cost=1000.00]
 │         └── best: (scan a)
 ├── G9: (filters G4 G7)
 ├── G4: (eq G2 G3)
 ├── G2: (variable a.u)
 ├── G3: (const 1)
 ├── G7: (eq G5 G6)
 ├── G5: (variable a.v)
 ├── G6: (const 5)
 ├── G12: (projections G11)
 └── G11: (variable a.k)

# No constraint can be derived from filter (nothing should be pushed down).
opt
SELECT k FROM a WHERE u=v
----
project
 ├── columns: k:1(int!null)
 ├── select
 │    ├── columns: a.k:1(int!null) a.u:2(int) a.v:3(int)
 │    ├── scan a@u
 │    │    ├── columns: a.k:1(int!null) a.u:2(int) a.v:3(int)
 │    │    └── constraint: /2/1: (/NULL - ]
 │    └── filters [type=bool, outer=(2,3)]
 │         └── eq [type=bool, outer=(2,3)]
 │              ├── variable: a.u [type=int, outer=(2)]
 │              └── variable: a.v [type=int, outer=(3)]
 └── projections [outer=(1)]
      └── variable: a.k [type=int, outer=(1)]

# Don't push constraint into already limited scan.
opt
SELECT k FROM (SELECT k FROM a ORDER BY u LIMIT 1) a WHERE k = 1
----
select
 ├── columns: k:1(int!null)
 ├── scan a@u
 │    ├── columns: a.k:1(int!null) a.u:2(int)
 │    └── limit: 1
 └── filters [type=bool, outer=(1), constraints=(/1: [/1 - /1]; tight)]
      └── eq [type=bool, outer=(1), constraints=(/1: [/1 - /1]; tight)]
           ├── variable: a.k [type=int, outer=(1)]
           └── const: 1 [type=int]
