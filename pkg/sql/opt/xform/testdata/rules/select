exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u(u) STORING (v),
    UNIQUE INDEX v(v) STORING (u)
)
----

exec-ddl
CREATE TABLE b
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    j JSONB,
    INDEX u(u),
    UNIQUE INDEX v(v),
    INVERTED INDEX inv_idx(j)
)
----

exec-ddl
CREATE TABLE c
(
    k INT PRIMARY KEY,
    a INT[],
    u INT,
    INVERTED INDEX inv_idx(a),
    INDEX u(u)
)
----

exec-ddl
CREATE TABLE d
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE e
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX uw(u, w),
    INDEX vw(v, w)
)
----

exec-ddl
CREATE TABLE f
(
    k INT,
    j INT,
    u INT,
    v INT,
    CONSTRAINT pk PRIMARY KEY (k, j),
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE g
(
    k INT PRIMARY KEY,
    v INT,
    geom GEOMETRY,
    geog GEOGRAPHY,
    INVERTED INDEX geom_idx (geom),
    INVERTED INDEX geog_idx (geog)
)
----

exec-ddl
CREATE TABLE p (
    i INT,
    f FLOAT,
    s STRING,
    b BOOL,
    INDEX if_s (i) STORING (f, s) WHERE s = 'foo'
)
----

exec-ddl
CREATE TABLE q (
    i INT,
    s STRING,
    b BOOL,
    INDEX i (i),
    INDEX i_gt_0 (i) WHERE i > 0,
    INDEX s_eq_foo (s) WHERE s = 'foo'
)
----

exec-ddl
CREATE TABLE no_explicit_primary_key
(
    k INT,
    u INT,
    v INT,
    INDEX u(u),
    INDEX v(v)
)
----

# --------------------------------------------------
# GeneratePartialIndexScans
# --------------------------------------------------

# Generate a lone partial index scan when the index is covering and there are no
# remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo'
----
project
 ├── columns: i:1
 └── scan p@if_s,partial
      ├── columns: i:1 s:3!null
      └── fd: ()-->(3)

# Generate a partial index scan inside a select when the index is covering and
# there are remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: i:1
 └── select
      ├── columns: i:1 f:2 s:3!null
      ├── fd: ()-->(3)
      ├── scan p@if_s,partial
      │    └── columns: i:1 f:2 s:3
      └── filters
           └── (i:1 = 1) OR (f:2 = 2.0) [outer=(1,2)]

# Generate a partial index scan inside an index-join when the index is not
# covering and there no remaining filters.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo'
----
project
 ├── columns: b:4
 └── index-join p
      ├── columns: s:3!null b:4
      ├── fd: ()-->(3)
      └── scan p@if_s,partial
           ├── columns: s:3 rowid:5!null
           ├── key: (5)
           └── fd: (5)-->(3)

# Generate a partial index scan inside a select inside an index-join when the
# index is not covering and there are remaining filters that are covered by the
# index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: b:4
 └── index-join p
      ├── columns: i:1 f:2 s:3!null b:4
      ├── fd: ()-->(3)
      └── select
           ├── columns: i:1 f:2 s:3 rowid:5!null
           ├── key: (5)
           ├── fd: (5)-->(1-3)
           ├── scan p@if_s,partial
           │    ├── columns: i:1 f:2 s:3 rowid:5!null
           │    ├── key: (5)
           │    └── fd: (5)-->(1-3)
           └── filters
                └── (i:1 = 1) OR (f:2 = 2.0) [outer=(1,2)]

# Generate a partial index scan inside an index-join inside a select when the
# index is not covering and the remaining filters are not covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND b
----
project
 ├── columns: b:4!null
 ├── fd: ()-->(4)
 └── select
      ├── columns: s:3!null b:4!null
      ├── fd: ()-->(3,4)
      ├── index-join p
      │    ├── columns: s:3 b:4
      │    └── scan p@if_s,partial
      │         ├── columns: s:3 rowid:5!null
      │         ├── key: (5)
      │         └── fd: (5)-->(3)
      └── filters
           └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

# Generate a partial index scan inside a Select/IndexJoin/Select when the index
# is not covering and the remaining filters are partially covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND i = 1 AND b
----
project
 ├── columns: b:4!null
 ├── fd: ()-->(4)
 └── select
      ├── columns: i:1!null s:3!null b:4!null
      ├── fd: ()-->(1,3,4)
      ├── index-join p
      │    ├── columns: i:1 s:3 b:4
      │    ├── fd: ()-->(1)
      │    └── select
      │         ├── columns: i:1!null s:3 rowid:5!null
      │         ├── key: (5)
      │         ├── fd: ()-->(1), (5)-->(3)
      │         ├── scan p@if_s,partial
      │         │    ├── columns: i:1 s:3 rowid:5!null
      │         │    ├── key: (5)
      │         │    └── fd: (5)-->(1,3)
      │         └── filters
      │              └── i:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
      └── filters
           └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

# Generate multiple partial index scans when there are multiple partial indexes
# that have predicates implied by the filters.
memo expect=GeneratePartialIndexScans
SELECT * FROM q WHERE i > 0 AND s = 'foo'
----
memo (optimized, ~11KB, required=[presentation: i:1,s:2,b:3])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G5)
 │    └── [presentation: i:1,s:2,b:3]
 │         ├── best: (select G6 G7)
 │         └── cost: 51.34
 ├── G2: (scan q,cols=(1-3))
 │    └── []
 │         ├── best: (scan q,cols=(1-3))
 │         └── cost: 1070.02
 ├── G3: (filters G9 G10)
 ├── G4: (index-join G11 q,cols=(1-3))
 │    └── []
 │         ├── best: (index-join G11 q,cols=(1-3))
 │         └── cost: 1706.69
 ├── G5: (filters G10)
 ├── G6: (index-join G12 q,cols=(1-3))
 │    └── []
 │         ├── best: (index-join G12 q,cols=(1-3))
 │         └── cost: 51.22
 ├── G7: (filters G9)
 ├── G8: (index-join G13 q,cols=(1-3))
 │    └── []
 │         ├── best: (index-join G13 q,cols=(1-3))
 │         └── cost: 1706.69
 ├── G9: (gt G14 G15)
 ├── G10: (eq G16 G17)
 ├── G11: (scan q@i_gt_0,partial,cols=(1,4))
 │    └── []
 │         ├── best: (scan q@i_gt_0,partial,cols=(1,4))
 │         └── cost: 346.68
 ├── G12: (scan q@s_eq_foo,partial,cols=(2,4))
 │    └── []
 │         ├── best: (scan q@s_eq_foo,partial,cols=(2,4))
 │         └── cost: 10.41
 ├── G13: (scan q@i,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan q@i,cols=(1,4),constrained)
 │         └── cost: 346.68
 ├── G14: (variable i)
 ├── G15: (const 0)
 ├── G16: (variable s)
 └── G17: (const 'foo')

# Do not generate a partial index scan when the predicate is not implied by the
# filter.
memo
SELECT i FROM p WHERE s = 'bar'
----
memo (optimized, ~5KB, required=[presentation: i:1])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:1]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 1080.15
 ├── G2: (select G4 G5)
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1080.04
 ├── G3: (projections)
 ├── G4: (scan p,cols=(1,3))
 │    └── []
 │         ├── best: (scan p,cols=(1,3))
 │         └── cost: 1070.02
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'bar')

# --------------------------------------------------
# GenerateConstrainedScans
# --------------------------------------------------

opt
SELECT k FROM a WHERE k = 1
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

memo
SELECT k FROM a WHERE k = 1
----
memo (optimized, ~5KB, required=[presentation: k:1])
 ├── G1: (select G2 G3) (scan a,cols=(1),constrained)
 │    └── [presentation: k:1]
 │         ├── best: (scan a,cols=(1),constrained)
 │         └── cost: 1.05
 ├── G2: (scan a,cols=(1)) (scan a@u,cols=(1)) (scan a@v,cols=(1))
 │    └── []
 │         ├── best: (scan a,cols=(1))
 │         └── cost: 1040.02
 ├── G3: (filters G4)
 ├── G4: (eq G5 G6)
 ├── G5: (variable k)
 └── G6: (const 1)

opt
SELECT k FROM a WHERE v > 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan a@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/2 - ]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT k FROM a WHERE v > 1
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 350.17
 ├── G2: (select G4 G5) (scan a@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1,3),constrained)
 │         └── cost: 346.86
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,3)) (scan a@u,cols=(1,3)) (scan a@v,cols=(1,3))
 │    └── []
 │         ├── best: (scan a,cols=(1,3))
 │         └── cost: 1050.02
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable v)
 └── G8: (const 1)

opt
SELECT k FROM a WHERE u = 1 AND k = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/5 - /1/5]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k = 5
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 1.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1050.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 1.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 5)

# Constraint + remaining filter.
opt
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/0 - /1/0]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 1.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1050.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 1.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 0)

opt
SELECT k FROM a WHERE u = 1 AND v = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-3)
      ├── scan a@v
      │    ├── columns: k:1!null u:2 v:3!null
      │    ├── constraint: /3: [/5 - /5]
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    └── fd: ()-->(1-3)
      └── filters
           └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

memo
SELECT k FROM a WHERE u = 1 AND v = 5
----
memo (optimized, ~9KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.12
 ├── G2: (select G4 G5) (select G6 G7) (select G8 G9)
 │    └── []
 │         ├── best: (select G8 G9)
 │         └── cost: 1.10
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1-3)) (scan a@u,cols=(1-3)) (scan a@v,cols=(1-3))
 │    └── []
 │         ├── best: (scan a,cols=(1-3))
 │         └── cost: 1060.02
 ├── G5: (filters G10 G11)
 ├── G6: (scan a@u,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1-3),constrained)
 │         └── cost: 10.61
 ├── G7: (filters G11)
 ├── G8: (scan a@v,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1-3),constrained)
 │         └── cost: 1.07
 ├── G9: (filters G10)
 ├── G10: (eq G12 G13)
 ├── G11: (eq G14 G15)
 ├── G12: (variable u)
 ├── G13: (const 1)
 ├── G14: (variable v)
 └── G15: (const 5)

# Only not-null constraint is pushed down.
opt
SELECT k FROM a WHERE u=v
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)-->(1), (2)==(3), (3)==(2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── constraint: /2/1: (/NULL - ]
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (3)~~>(1,2)
      └── filters
           └── u:2 = v:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]

# Don't push constraint into already limited scan.
opt
SELECT k FROM (SELECT k FROM a ORDER BY u LIMIT 1) a WHERE k = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1,2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2
      │    ├── limit: 1
      │    ├── key: ()
      │    └── fd: ()-->(1,2)
      └── filters
           └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]

# Constraint + index-join, with no remainder filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── cardinality: [0 - 10]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
memo (optimized, ~6KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (index-join G4 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G4 b,cols=(1-4))
 │         └── cost: 51.32
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1080.02
 ├── G3: (filters G5)
 ├── G4: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G5: (range G6)
 ├── G6: (and G7 G8)
 ├── G7: (ge G9 G10)
 ├── G8: (le G9 G11)
 ├── G9: (variable v)
 ├── G10: (const 1)
 └── G11: (const 10)

# Don't choose lookup join if it's not beneficial.
opt
SELECT * FROM b WHERE v > 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── v:3 > 1 [outer=(3), constraints=(/3: [/2 - ]; tight)]

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── select
      ├── columns: k:1!null v:3!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(3), (3)-->(1)
      ├── scan b@v
      │    ├── columns: k:1!null v:3!null
      │    ├── constraint: /3: [/1 - /10]
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    └── fd: (1)-->(3), (3)-->(1)
      └── filters
           └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
memo (optimized, ~8KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G6 b,cols=(1-4))
 │         └── cost: 24.17
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1080.02
 ├── G3: (filters G7 G8)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 360.01
 ├── G5: (filters G7)
 ├── G6: (select G9 G10)
 │    └── []
 │         ├── best: (select G9 G10)
 │         └── cost: 10.53
 ├── G7: (range G11)
 ├── G8: (gt G12 G13)
 ├── G9: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G10: (filters G8)
 ├── G11: (and G14 G15)
 ├── G12: (variable k)
 ├── G13: (const 5)
 ├── G14: (ge G16 G17)
 ├── G15: (le G16 G18)
 ├── G16: (variable v)
 ├── G17: (const 1)
 └── G18: (const 10)

# Ensure the rule doesn't match at all when the first column of the index is
# not in the filter (i.e. the @v index is not matched by ConstrainScans).
exploretrace rule=GenerateConstrainedScans
SELECT k FROM a WHERE u = 1
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── select
        ├── columns: k:1!null u:2!null
        ├── key: (1)
        ├── fd: ()-->(2)
        ├── scan a
        │    ├── columns: k:1!null u:2
        │    ├── key: (1)
        │    └── fd: (1)-->(2)
        └── filters
             └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

New expression 1 of 1:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── scan a@u
        ├── columns: k:1!null u:2!null
        ├── constraint: /2/1: [/1 - /1]
        ├── key: (1)
        └── fd: ()-->(2)
----
----

# Constraint + index join + remaining filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G5)
 │         └── cost: 51.44
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1080.02
 ├── G3: (filters G6 G7)
 ├── G4: (index-join G8 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G8 b,cols=(1-4))
 │         └── cost: 51.32
 ├── G5: (filters G7)
 ├── G6: (range G9)
 ├── G7: (eq G10 G11)
 ├── G8: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G9: (and G12 G13)
 ├── G10: (plus G14 G15)
 ├── G11: (const 1)
 ├── G12: (ge G16 G11)
 ├── G13: (le G16 G17)
 ├── G14: (variable k)
 ├── G15: (variable u)
 ├── G16: (variable v)
 └── G17: (const 10)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── select
 │         ├── columns: k:1!null v:3!null
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(3), (3)-->(1)
 │         ├── scan b@v
 │         │    ├── columns: k:1!null v:3!null
 │         │    ├── constraint: /3: [/1 - /10]
 │         │    ├── cardinality: [0 - 10]
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3), (3)-->(1)
 │         └── filters
 │              └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
memo (optimized, ~10KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G6 G7)
 │         └── cost: 24.23
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1080.02
 ├── G3: (filters G8 G9 G10)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 360.01
 ├── G5: (filters G8 G9)
 ├── G6: (index-join G11 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G11 b,cols=(1-4))
 │         └── cost: 24.17
 ├── G7: (filters G9)
 ├── G8: (range G12)
 ├── G9: (eq G13 G14)
 ├── G10: (gt G15 G16)
 ├── G11: (select G17 G18)
 │    └── []
 │         ├── best: (select G17 G18)
 │         └── cost: 10.53
 ├── G12: (and G19 G20)
 ├── G13: (plus G15 G21)
 ├── G14: (const 1)
 ├── G15: (variable k)
 ├── G16: (const 5)
 ├── G17: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G18: (filters G10)
 ├── G19: (ge G22 G14)
 ├── G20: (le G22 G23)
 ├── G21: (variable u)
 ├── G22: (variable v)
 └── G23: (const 10)

# Constraint + index-join.
opt
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
select
 ├── columns: k:1!null u:2!null v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@u
 │         ├── columns: k:1!null u:2!null
 │         ├── constraint: /2/1: [/1/2 - /8/9]
 │         ├── key: (1)
 │         └── fd: (1)-->(2)
 └── filters
      ├── (u:2, k:1, v:3) > (1, 2, 3) [outer=(1-3), immutable, constraints=(/2/1/3: [/1/2/4 - ]; tight)]
      └── (u:2, k:1, v:3) < (8, 9, 10) [outer=(1-3), immutable, constraints=(/2/1/3: (/NULL - /8/9/9]; tight)]

memo
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G3)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G3)
 │         └── cost: 411.25
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1080.02
 ├── G3: (filters G5 G6)
 ├── G4: (index-join G7 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G7 b,cols=(1-4))
 │         └── cost: 410.42
 ├── G5: (gt G8 G9)
 ├── G6: (lt G8 G10)
 ├── G7: (scan b@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan b@u,cols=(1,2),constrained)
 │         └── cost: 83.21
 ├── G8: (tuple G11)
 ├── G9: (tuple G12)
 ├── G10: (tuple G13)
 ├── G11: (scalar-list G14 G15 G16)
 ├── G12: (scalar-list G17 G18 G19)
 ├── G13: (scalar-list G20 G21 G22)
 ├── G14: (variable u)
 ├── G15: (variable k)
 ├── G16: (variable v)
 ├── G17: (const 1)
 ├── G18: (const 2)
 ├── G19: (const 3)
 ├── G20: (const 8)
 ├── G21: (const 9)
 └── G22: (const 10)

# GenerateConstrainedScans propagates row-level locking information.
opt
SELECT k FROM a WHERE k = 1 FOR UPDATE
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── locking: for-update
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 └── fd: ()-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 FOR UPDATE
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── locking: for-update
      ├── cardinality: [0 - 10]
      ├── volatile
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 FOR UPDATE
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── locking: for-update
 │         ├── cardinality: [0 - 10]
 │         ├── volatile
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

# --------------------------------------------------
# GenerateInvertedIndexScans
# --------------------------------------------------
# TODO(justin): these can be serviced without an index join.
# Query only the primary key with no remaining filter.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── index-join b
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           └── key: (1)

memo
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
memo (optimized, ~7KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 567.81
 ├── G2: (select G4 G5) (index-join G6 b,cols=(1,4))
 │    └── []
 │         ├── best: (index-join G6 b,cols=(1,4))
 │         └── cost: 566.69
 ├── G3: (projections)
 ├── G4: (scan b,cols=(1,4))
 │    └── []
 │         ├── best: (scan b,cols=(1,4))
 │         └── cost: 1060.02
 ├── G5: (filters G7)
 ├── G6: (scan b@inv_idx,cols=(1),constrained)
 │    └── []
 │         ├── best: (scan b@inv_idx,cols=(1),constrained)
 │         └── cost: 114.45
 ├── G7: (contains G8 G9)
 ├── G8: (variable j)
 └── G9: (const '{"a": "b"}')

# Query only the primary key with a remaining filter. 2+ paths in containment
# query should favor zigzag joins.
opt
SELECT k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup b)
      ├── columns: k:1!null j:4
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── inner-join (zigzag b@inv_idx b@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [4] = ['{"a": "b"}']
      │    ├── right fixed columns: [4] = ['{"c": "d"}']
      │    └── filters (true)
      └── filters
           └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable]

# Query requiring an index join with no remaining filter.
opt
SELECT u, k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: u:2 k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── index-join b
      ├── columns: k:1!null u:2 j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           └── key: (1)

opt
SELECT j, k FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: j:4 k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

# Query requiring a zigzag join with a remaining filter.
# TODO(itsbilal): remove filter from index join if zigzag join covers it.
opt
SELECT j, k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
inner-join (lookup b)
 ├── columns: j:4 k:1!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": "b"}']
 │    ├── right fixed columns: [4] = ['{"c": "d"}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '{"a": {"b": "c", "d": "e"}, "f": "g"}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": {"b": "c"}}']
 │    ├── right fixed columns: [4] = ['{"a": {"d": "e"}}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": {"b": "c", "d": "e"}, "f": "g"}' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '{}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{}' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '[]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[]' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '2'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1
      │    ├── [/'2' - /'2']
      │    └── [/'[2]' - /'[2]']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '[{}]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[{}]' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '{"a": {}}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": {}}' [outer=(4), immutable]

opt
SELECT * FROM b WHERE j @> '{"a": []}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": []}' [outer=(4), immutable]

# GenerateInvertedIndexScans propagates row-level locking information.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}' FOR UPDATE
----
project
 ├── columns: k:1!null
 ├── volatile
 ├── key: (1)
 └── index-join b
      ├── columns: k:1!null j:4
      ├── volatile
      ├── key: (1)
      ├── fd: (1)-->(4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           ├── locking: for-update
           ├── volatile
           └── key: (1)

# Tests for array inverted indexes.
opt
SELECT k FROM c WHERE a @> ARRAY[1]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── index-join c
      ├── columns: k:1!null a:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      └── scan c@inv_idx
           ├── columns: k:1!null
           ├── constraint: /2/1: [/ARRAY[1] - /ARRAY[1]]
           └── key: (1)

opt
SELECT k FROM c WHERE a @> ARRAY[1,3,1,5]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup c)
      ├── columns: k:1!null a:2
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── inner-join (zigzag c@inv_idx c@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [ARRAY[1]]
      │    ├── right fixed columns: [2] = [ARRAY[3]]
      │    └── filters (true)
      └── filters
           └── a:2 @> ARRAY[1,3,1,5] [outer=(2), immutable]

opt
SELECT k FROM c WHERE a @> ARRAY[]::INT[]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 @> ARRAY[] [outer=(2), immutable]

opt
SELECT k FROM c WHERE a IS NULL
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

# Tests for geospatial constrained scans.
opt
SELECT k FROM g WHERE ST_Intersects('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable]

# Same test as above, but with commuted arguments.
opt
SELECT k FROM g WHERE ST_Intersects(geog, 'SRID=4326;POINT(-43.23456 72.4567772)'::geography)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_intersects(geog:4, '0101000020E61000009279E40F069E45C0BEE36FD63B1D5240') [outer=(4), immutable]

opt
SELECT k FROM g WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /3
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom:3
      │              ├── inverted constraint: /3/1
      │              │    └── spans
      │              │         ├── ["\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(3)
      └── filters
           └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3) [outer=(3), immutable]

# Same test as above, but with commuted arguments.
opt
SELECT k FROM g WHERE ST_CoveredBy(geom, 'POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /3
      │         │    ├── tight: false
      │         │    └── union spans: ["\x89", "\xfd ")
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom:3
      │              ├── inverted constraint: /3/1
      │              │    └── spans: ["\x89", "\xfd ")
      │              ├── key: (1)
      │              └── fd: (1)-->(3)
      └── filters
           └── st_coveredby(geom:3, '0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000') [outer=(3), immutable]

opt
SELECT k FROM g WHERE ST_DWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /3
      │         │    ├── tight: false
      │         │    └── union spans: ["\x89", "\xfd ")
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom:3
      │              ├── inverted constraint: /3/1
      │              │    └── spans: ["\x89", "\xfd ")
      │              ├── key: (1)
      │              └── fd: (1)-->(3)
      └── filters
           └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable]

opt
SELECT k FROM g WHERE ST_DFullyWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /3
      │         │    ├── tight: false
      │         │    └── union spans: ["\x89", "\xfd ")
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom:3
      │              ├── inverted constraint: /3/1
      │              │    └── spans: ["\x89", "\xfd ")
      │              ├── key: (1)
      │              └── fd: (1)-->(3)
      └── filters
           └── st_dfullywithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable]

opt
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x00", "\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x01", "\xfdF")
      │         │         ├── ["\xfdF\x00\x00\x00\x00\x00\x00\x01", "\xfdH")
      │         │         ├── ["\xfdH\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x01", "\xfdR")
      │         │         ├── ["\xfdR\x00\x00\x00\x00\x00\x00\x01", "\xfdT")
      │         │         ├── ["\xfdT\x00\x00\x00\x00\x00\x00\x00", "\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdZ\x00\x00\x00\x00\x00\x00\x01", "\xfd\\")
      │         │         └── ["\xfd\\\x00\x00\x00\x00\x00\x00\x00", "\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x00", "\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x01", "\xfdF")
      │              │         ├── ["\xfdF\x00\x00\x00\x00\x00\x00\x01", "\xfdH")
      │              │         ├── ["\xfdH\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x01", "\xfdR")
      │              │         ├── ["\xfdR\x00\x00\x00\x00\x00\x00\x01", "\xfdT")
      │              │         ├── ["\xfdT\x00\x00\x00\x00\x00\x00\x00", "\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdZ\x00\x00\x00\x00\x00\x00\x01", "\xfd\\")
      │              │         └── ["\xfd\\\x00\x00\x00\x00\x00\x00\x00", "\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0) [outer=(4), immutable]

opt
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000, false)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x00", "\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x01", "\xfdF")
      │         │         ├── ["\xfdF\x00\x00\x00\x00\x00\x00\x01", "\xfdH")
      │         │         ├── ["\xfdH\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x01", "\xfdR")
      │         │         ├── ["\xfdR\x00\x00\x00\x00\x00\x00\x01", "\xfdT")
      │         │         ├── ["\xfdT\x00\x00\x00\x00\x00\x00\x00", "\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdZ\x00\x00\x00\x00\x00\x00\x01", "\xfd\\")
      │         │         └── ["\xfd\\\x00\x00\x00\x00\x00\x00\x00", "\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x00", "\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x01", "\xfdF")
      │              │         ├── ["\xfdF\x00\x00\x00\x00\x00\x00\x01", "\xfdH")
      │              │         ├── ["\xfdH\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x01", "\xfdR")
      │              │         ├── ["\xfdR\x00\x00\x00\x00\x00\x00\x01", "\xfdT")
      │              │         ├── ["\xfdT\x00\x00\x00\x00\x00\x00\x00", "\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdZ\x00\x00\x00\x00\x00\x00\x01", "\xfd\\")
      │              │         └── ["\xfd\\\x00\x00\x00\x00\x00\x00\x00", "\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0, false) [outer=(4), immutable]


# Multiple geospatial functions.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    ├── union spans: ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false
      │         │         │    └── union spans
      │         │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         └── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── span expression
      │         │              ├── tight: false
      │         │              └── union spans
      │         │                   ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   └── ["\xfdO\x00\x00\x00\x00\x00\x00\x00", "\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable]
           └── st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_CoveredBy('SRID=4326;LINESTRING(-118.4079 33.9434, 2.5559 49.0083)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-44.23836 60.4567772)'::geography, geog))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    ├── union spans
      │         │    │    ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │    │    ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │    │    └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false
      │         │         │    ├── union spans: empty
      │         │         │    └── INTERSECTION
      │         │         │         ├── span expression
      │         │         │         │    ├── tight: false
      │         │         │         │    └── union spans
      │         │         │         │         ├── ["\x80\x90\x00\x00\x00\x00\x00\x00\x00", "\x80\x90\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         ├── ["\x80\x84\x00\x00\x00\x00\x00\x00\x00", "\x80\x84\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         └── ["\x80\x81\x00\x00\x00\x00\x00\x00\x00", "\x80\x81\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         └── span expression
      │         │         │              ├── tight: false
      │         │         │              └── union spans
      │         │         │                   ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   ├── ["\xfdD\x00\x00\x00\x00\x00\x00\x00", "\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   └── ["\xfdG\x00\x00\x00\x00\x00\x00\x00", "\xfdG\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── span expression
      │         │              ├── tight: false
      │         │              └── union spans
      │         │                   ├── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   └── ["\xfdO\x00\x00\x00\x00\x00\x00\x00", "\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_coveredby('0102000020E61000000200000075029A081B9A5DC0F085C954C1F840406DC5FEB27B720440454772F90F814840', geog:4) AND st_coveredby('0101000020E610000058569A94821E46C07BC7DFAC773A4E40', geog:4)) [outer=(4), immutable]

# Multiple geospatial functions on different indexes.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_Overlaps('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /3
      │         │    ├── tight: false
      │         │    └── union spans: ["\x89", "\xfd ")
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom:3
      │              ├── inverted constraint: /3/1
      │              │    └── spans: ["\x89", "\xfd ")
      │              ├── key: (1)
      │              └── fd: (1)-->(3)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable]
           └── st_overlaps('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3), immutable]

# Cannot use either index in this case.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_Touches('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── scan g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    └── fd: (1)-->(3,4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_touches('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3,4), immutable]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_Intersects('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
AND ST_Crosses('LINESTRING ( 0 0, 0 2 )'::geometry, geom))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog:4
      │              ├── inverted constraint: /4/1
      │              │    └── spans
      │              │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_intersects('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) AND st_crosses('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3)) [outer=(3,4), immutable]

# Filters on other columns.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND v = 3 AND k > 100
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null v:2!null geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null v:2 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /4
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │         │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── select
      │              ├── columns: k:1!null geog:4
      │              ├── key: (1)
      │              ├── fd: (1)-->(4)
      │              ├── scan g@geog_idx
      │              │    ├── columns: k:1!null geog:4
      │              │    ├── inverted constraint: /4/1
      │              │    │    └── spans
      │              │    │         ├── ["\xfdL\x00\x00\x00\x00\x00\x00\x00", "\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │    │         ├── ["\xfdN\x00\x00\x00\x00\x00\x00\x01", "\xfdP")
      │              │    │         └── ["\xfdP\x00\x00\x00\x00\x00\x00\x00", "\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │    ├── key: (1)
      │              │    └── fd: (1)-->(4)
      │              └── filters
      │                   └── k:1 > 100 [outer=(1), constraints=(/1: [/101 - ]; tight)]
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable]
           └── v:2 = 3 [outer=(2), constraints=(/2: [/3 - /3]; tight), fd=()-->(2)]


# --------------------------------------------------
# SplitDisjunction
# --------------------------------------------------

# TODO(mgartner): PruneAggCols should be pruning columns from the DistinctOn
# and further down the expression tree, ultimately eliminating the index-joins.
# PruneAggCols does not run in this case because normalization rules do not run
# at the root tree generated by an exploration rule.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT * FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
distinct-on
 ├── columns: k:1!null u:2 v:3 w:4!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3 w:4!null
 │    ├── left columns: k:1!null u:2 v:3 w:4!null
 │    ├── right columns: k:6 u:7 v:8 w:9
 │    ├── select
 │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2,4), (1)-->(3)
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2 v:3 w:4
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── filters
 │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │    └── select
 │         ├── columns: k:6!null u:7 v:8!null w:9!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8,9), (6)-->(7)
 │         ├── index-join d
 │         │    ├── columns: k:6!null u:7 v:8 w:9
 │         │    ├── key: (6)
 │         │    ├── fd: ()-->(8), (6)-->(7,9)
 │         │    └── scan d@v
 │         │         ├── columns: k:6!null v:8!null
 │         │         ├── constraint: /8/6: [/1 - /1]
 │         │         ├── key: (6)
 │         │         └── fd: ()-->(8)
 │         └── filters
 │              └── w:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      ├── const-agg [as=v:3, outer=(3)]
      │    └── v:3
      └── const-agg [as=w:4, outer=(4)]
           └── w:4

opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:6 u:7 v:8
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:6!null u:7!null v:8!null
      │         ├── eq columns: [6] = [6]
      │         ├── left fixed columns: [7] = [10]
      │         ├── right fixed columns: [8] = [2]
      │         ├── key: (6)
      │         ├── fd: ()-->(7,8)
      │         └── filters
      │              ├── v:8 = 2 [outer=(8), constraints=(/8: [/2 - /2]; tight), fd=()-->(8)]
      │              └── u:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT sum(k) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: sum:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── distinct-on
 │    ├── columns: k:1!null u:2 v:3
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── union-all
 │    │    ├── columns: k:1!null u:2 v:3
 │    │    ├── left columns: k:1!null u:2 v:3
 │    │    ├── right columns: k:7 u:8 v:9
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2!null v:3
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── index-join d
 │    │         ├── columns: k:7!null u:8 v:9!null
 │    │         ├── key: (7)
 │    │         ├── fd: ()-->(9), (7)-->(8)
 │    │         └── scan d@v
 │    │              ├── columns: k:7!null v:9!null
 │    │              ├── constraint: /9/7: [/1 - /1]
 │    │              ├── key: (7)
 │    │              └── fd: ()-->(9)
 │    └── aggregations
 │         ├── const-agg [as=u:2, outer=(2)]
 │         │    └── u:2
 │         └── const-agg [as=v:3, outer=(3)]
 │              └── v:3
 └── aggregations
      └── sum [as=sum:6, outer=(1)]
           └── k:1

# Multi-column primary key.
opt expect=SplitDisjunction
SELECT k, j FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: k:1!null j:2!null
 ├── key: (1,2)
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:6 j:7 u:8 v:9
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:6!null j:7!null u:8 v:9!null
      │         ├── key: (6,7)
      │         ├── fd: ()-->(9), (6,7)-->(8)
      │         └── scan f@v
      │              ├── columns: k:6!null j:7!null v:9!null
      │              ├── constraint: /9/6/7: [/2 - /2]
      │              ├── key: (6,7)
      │              └── fd: ()-->(9)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/5 - /8]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunction
SELECT k FROM b WHERE k = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── union-all
      │    ├── columns: k:1!null j:4
      │    ├── left columns: k:1!null j:4
      │    ├── right columns: k:6 j:9
      │    ├── immutable
      │    ├── scan b
      │    │    ├── columns: k:1!null j:4
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,4)
      │    └── index-join b
      │         ├── columns: k:6!null j:9
      │         ├── immutable
      │         ├── key: (6)
      │         ├── fd: (6)-->(9)
      │         └── scan b@inv_idx
      │              ├── columns: k:6!null
      │              ├── constraint: /9/6: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (6)
      └── aggregations
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunction
SELECT k FROM c WHERE k = 1 OR a @> ARRAY[2]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── union-all
      │    ├── columns: k:1!null a:2
      │    ├── left columns: k:1!null a:2
      │    ├── right columns: k:5 a:6
      │    ├── immutable
      │    ├── scan c
      │    │    ├── columns: k:1!null a:2
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,2)
      │    └── index-join c
      │         ├── columns: k:5!null a:6
      │         ├── immutable
      │         ├── key: (5)
      │         ├── fd: (5)-->(6)
      │         └── scan c@inv_idx
      │              ├── columns: k:5!null
      │              ├── constraint: /6/5: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (5)
      └── aggregations
           └── const-agg [as=a:2, outer=(2)]
                └── a:2

# Uncorrelated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:10 d.u:11 d.v:12
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:7 a.v:8
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(7,8)
      │    └── index-join d
      │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         ├── key: (10)
      │         ├── fd: ()-->(12), (10)-->(11)
      │         └── select
      │              ├── columns: d.k:10!null d.v:12!null
      │              ├── key: (10)
      │              ├── fd: ()-->(12)
      │              ├── scan d@v
      │              │    ├── columns: d.k:10!null d.v:12!null
      │              │    ├── constraint: /12/10: [/1 - /1]
      │              │    ├── key: (10)
      │              │    └── fd: ()-->(12)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:7 a.v:8
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(7,8)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2!null d.v:3 a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── key: (1)
           ├── fd: (1)-->(2,3), (2)==(7), (7)==(2)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2,3)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── right columns: d.k:10 d.u:11 d.v:12
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:10!null d.u:11 d.v:12!null
           │    │         ├── key: (10)
           │    │         ├── fd: ()-->(12), (10)-->(11)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:10!null d.v:12!null
           │    │              ├── constraint: /12/10: [/1 - /1]
           │    │              ├── key: (10)
           │    │              └── fd: ()-->(12)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         └── const-agg [as=d.v:3, outer=(3)]
           │              └── d.v:3
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = d.u:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2 d.v:3 w:4!null a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── key: (1)
           ├── fd: (1)-->(2-4), (4)==(7), (7)==(4)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2-4)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── right columns: d.k:10 d.u:11 d.v:12 w:13
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:10!null d.u:11 d.v:12!null w:13
           │    │         ├── key: (10)
           │    │         ├── fd: ()-->(12), (10)-->(11,13)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:10!null d.v:12!null
           │    │              ├── constraint: /12/10: [/1 - /1]
           │    │              ├── key: (10)
           │    │              └── fd: ()-->(12)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         ├── const-agg [as=d.v:3, outer=(3)]
           │         │    └── d.v:3
           │         └── const-agg [as=w:4, outer=(4)]
           │              └── w:4
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = w:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM e WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join e
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan e@uw
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/4/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join e
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8), (6)-->(7)
 │         └── scan e@vw
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/9/6: [/1 - /1]
 │              ├── key: (6)
 │              └── fd: ()-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: k:1!null u:2 v:3
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8,9), (6)-->(7)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/1 - /1]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── w:9 = 3 [outer=(9), constraints=(/9: [/3 - /3]; tight), fd=()-->(9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    └── [/3 - /3]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    └── [/4 - /4]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7,9)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/4 - /4]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── (w:9 = 1) OR (w:9 = 2) [outer=(9), constraints=(/9: [/1 - /1] [/2 - /2]; tight)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4
      │    ├── left columns: k:1!null u:2 v:3 w:4
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7,9)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/4 - /4]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── (u:7 = 1) OR (w:9 = 2) [outer=(7,9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunction
SELECT k, u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: k:1!null u:2 w:4
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan d
 │    ├── columns: k:1!null u:2 w:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries without strict keys.
opt expect-not=SplitDisjunction
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR u = 5
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan d@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1
      │    ├── [/1 - /1]
      │    └── [/5 - /5]
      ├── key: (1)
      └── fd: (1)-->(2)

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunction
SELECT k FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)~~>(1,2)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── constraint: /7: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(5-7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1 opt(2)
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      ├── index-join d
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── key: (1)
      │    ├── fd: ()-->(2), (1)-->(3)
      │    ├── ordering: +1 opt(2) [actual: +1]
      │    └── scan d@u
      │         ├── columns: k:1!null u:2!null
      │         ├── constraint: /2/1: [/2 - /2]
      │         ├── key: (1)
      │         ├── fd: ()-->(2)
      │         └── ordering: +1 opt(2) [actual: +1]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# --------------------------------------------------
# SplitDisjunctionAddKey
# --------------------------------------------------

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT u, v, w FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
project
 ├── columns: u:2 v:3 w:4!null
 ├── fd: ()-->(4)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8,9), (6)-->(7)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/1 - /1]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── w:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:6 u:7 v:8
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:6!null u:7!null v:8!null
      │         ├── eq columns: [6] = [6]
      │         ├── left fixed columns: [7] = [10]
      │         ├── right fixed columns: [8] = [2]
      │         ├── key: (6)
      │         ├── fd: ()-->(7,8)
      │         └── filters
      │              ├── v:8 = 2 [outer=(8), constraints=(/8: [/2 - /2]; tight), fd=()-->(8)]
      │              └── u:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT count(*) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: count:6!null
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── project
 │    ├── columns: u:2 v:3
 │    └── distinct-on
 │         ├── columns: k:1!null u:2 v:3
 │         ├── grouping columns: k:1!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,3)
 │         ├── union-all
 │         │    ├── columns: k:1!null u:2 v:3
 │         │    ├── left columns: k:1!null u:2 v:3
 │         │    ├── right columns: k:7 u:8 v:9
 │         │    ├── index-join d
 │         │    │    ├── columns: k:1!null u:2!null v:3
 │         │    │    ├── key: (1)
 │         │    │    ├── fd: ()-->(2), (1)-->(3)
 │         │    │    └── scan d@u
 │         │    │         ├── columns: k:1!null u:2!null
 │         │    │         ├── constraint: /2/1: [/1 - /1]
 │         │    │         ├── key: (1)
 │         │    │         └── fd: ()-->(2)
 │         │    └── index-join d
 │         │         ├── columns: k:7!null u:8 v:9!null
 │         │         ├── key: (7)
 │         │         ├── fd: ()-->(9), (7)-->(8)
 │         │         └── scan d@v
 │         │              ├── columns: k:7!null v:9!null
 │         │              ├── constraint: /9/7: [/1 - /1]
 │         │              ├── key: (7)
 │         │              └── fd: ()-->(9)
 │         └── aggregations
 │              ├── const-agg [as=u:2, outer=(2)]
 │              │    └── u:2
 │              └── const-agg [as=v:3, outer=(3)]
 │                   └── v:3
 └── aggregations
      └── count-rows [as=count_rows:6]


# Multi-column primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: u:3 v:4
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:6 j:7 u:8 v:9
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:6!null j:7!null u:8 v:9!null
      │         ├── key: (6,7)
      │         ├── fd: ()-->(9), (6,7)-->(8)
      │         └── scan f@v
      │              ├── columns: k:6!null j:7!null v:9!null
      │              ├── constraint: /9/6/7: [/2 - /2]
      │              ├── key: (6,7)
      │              └── fd: ()-->(9)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/5 - /8]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, j FROM b WHERE u = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: u:2 j:4
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null u:2 j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── union-all
      │    ├── columns: k:1!null u:2 j:4
      │    ├── left columns: k:1!null u:2 j:4
      │    ├── right columns: k:6 u:7 j:9
      │    ├── immutable
      │    ├── index-join b
      │    │    ├── columns: k:1!null u:2!null j:4
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(4)
      │    │    └── scan b@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join b
      │         ├── columns: k:6!null u:7 j:9
      │         ├── immutable
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,9)
      │         └── scan b@inv_idx
      │              ├── columns: k:6!null
      │              ├── constraint: /9/6: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (6)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, a FROM c WHERE u = 1 OR a @> ARRAY[2]
----
project
 ├── columns: u:3 a:2
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null a:2 u:3
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 u:3
      │    ├── left columns: k:1!null a:2 u:3
      │    ├── right columns: k:5 a:6 u:7
      │    ├── immutable
      │    ├── index-join c
      │    │    ├── columns: k:1!null a:2 u:3!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(3), (1)-->(2)
      │    │    └── scan c@u
      │    │         ├── columns: k:1!null u:3!null
      │    │         ├── constraint: /3/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(3)
      │    └── index-join c
      │         ├── columns: k:5!null a:6 u:7
      │         ├── immutable
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan c@inv_idx
      │              ├── columns: k:5!null
      │              ├── constraint: /6/5: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (5)
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=u:3, outer=(3)]
                └── u:3

# Uncorrelated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:10 d.u:11 d.v:12
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:7 a.v:8
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(7,8)
      │    └── index-join d
      │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         ├── key: (10)
      │         ├── fd: ()-->(12), (10)-->(11)
      │         └── select
      │              ├── columns: d.k:10!null d.v:12!null
      │              ├── key: (10)
      │              ├── fd: ()-->(12)
      │              ├── scan d@v
      │              │    ├── columns: d.k:10!null d.v:12!null
      │              │    ├── constraint: /12/10: [/1 - /1]
      │              │    ├── key: (10)
      │              │    └── fd: ()-->(12)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:7 a.v:8
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(7,8)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: u:2 v:3
 └── inner-join (hash)
      ├── columns: d.u:2!null d.v:3 a.u:7!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── fd: (2)==(7), (7)==(2)
      ├── project
      │    ├── columns: d.u:2 d.v:3
      │    └── distinct-on
      │         ├── columns: d.k:1!null d.u:2 d.v:3
      │         ├── grouping columns: d.k:1!null
      │         ├── key: (1)
      │         ├── fd: (1)-->(2,3)
      │         ├── union-all
      │         │    ├── columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── right columns: d.k:10 d.u:11 d.v:12
      │         │    ├── index-join d
      │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │         │    │    ├── key: (1)
      │         │    │    ├── fd: ()-->(2), (1)-->(3)
      │         │    │    └── scan d@u
      │         │    │         ├── columns: d.k:1!null d.u:2!null
      │         │    │         ├── constraint: /2/1: [/1 - /1]
      │         │    │         ├── key: (1)
      │         │    │         └── fd: ()-->(2)
      │         │    └── index-join d
      │         │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         │         ├── key: (10)
      │         │         ├── fd: ()-->(12), (10)-->(11)
      │         │         └── scan d@v
      │         │              ├── columns: d.k:10!null d.v:12!null
      │         │              ├── constraint: /12/10: [/1 - /1]
      │         │              ├── key: (10)
      │         │              └── fd: ()-->(12)
      │         └── aggregations
      │              ├── const-agg [as=d.u:2, outer=(2)]
      │              │    └── d.u:2
      │              └── const-agg [as=d.v:3, outer=(3)]
      │                   └── d.v:3
      ├── distinct-on
      │    ├── columns: a.u:7
      │    ├── grouping columns: a.u:7
      │    ├── internal-ordering: +7
      │    ├── key: (7)
      │    └── scan a@u
      │         ├── columns: a.u:7
      │         └── ordering: +7
      └── filters
           └── a.u:7 = d.u:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: d.u:2 d.v:3 w:4
      └── inner-join (hash)
           ├── columns: d.u:2 d.v:3 w:4!null a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── fd: (4)==(7), (7)==(4)
           ├── project
           │    ├── columns: d.u:2 d.v:3 w:4
           │    └── distinct-on
           │         ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         ├── grouping columns: d.k:1!null
           │         ├── key: (1)
           │         ├── fd: (1)-->(2-4)
           │         ├── union-all
           │         │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── right columns: d.k:10 d.u:11 d.v:12 w:13
           │         │    ├── index-join d
           │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │         │    │    ├── key: (1)
           │         │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │         │    │    └── scan d@u
           │         │    │         ├── columns: d.k:1!null d.u:2!null
           │         │    │         ├── constraint: /2/1: [/1 - /1]
           │         │    │         ├── key: (1)
           │         │    │         └── fd: ()-->(2)
           │         │    └── index-join d
           │         │         ├── columns: d.k:10!null d.u:11 d.v:12!null w:13
           │         │         ├── key: (10)
           │         │         ├── fd: ()-->(12), (10)-->(11,13)
           │         │         └── scan d@v
           │         │              ├── columns: d.k:10!null d.v:12!null
           │         │              ├── constraint: /12/10: [/1 - /1]
           │         │              ├── key: (10)
           │         │              └── fd: ()-->(12)
           │         └── aggregations
           │              ├── const-agg [as=d.u:2, outer=(2)]
           │              │    └── d.u:2
           │              ├── const-agg [as=d.v:3, outer=(3)]
           │              │    └── d.v:3
           │              └── const-agg [as=w:4, outer=(4)]
           │                   └── w:4
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = w:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# Use rowid when there is no explicit primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM no_explicit_primary_key WHERE u = 1 OR v = 5
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: u:2 v:3 rowid:4!null
      ├── grouping columns: rowid:4!null
      ├── key: (4)
      ├── fd: (4)-->(2,3)
      ├── union-all
      │    ├── columns: u:2 v:3 rowid:4!null
      │    ├── left columns: u:2 v:3 rowid:4!null
      │    ├── right columns: u:7 v:8 rowid:9
      │    ├── index-join no_explicit_primary_key
      │    │    ├── columns: u:2!null v:3 rowid:4!null
      │    │    ├── key: (4)
      │    │    ├── fd: ()-->(2), (4)-->(3)
      │    │    └── scan no_explicit_primary_key@u
      │    │         ├── columns: u:2!null rowid:4!null
      │    │         ├── constraint: /2/4: [/1 - /1]
      │    │         ├── key: (4)
      │    │         └── fd: ()-->(2)
      │    └── index-join no_explicit_primary_key
      │         ├── columns: u:7 v:8!null rowid:9!null
      │         ├── key: (9)
      │         ├── fd: ()-->(8), (9)-->(7)
      │         └── scan no_explicit_primary_key@v
      │              ├── columns: v:8!null rowid:9!null
      │              ├── constraint: /8/9: [/5 - /5]
      │              ├── key: (9)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM e WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join e
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan e@uw
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/4/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join e
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan e@vw
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/9/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9!null
           │         ├── key: (6)
           │         ├── fd: ()-->(8,9), (6)-->(7)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/1 - /1]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── w:9 = 3 [outer=(9), constraints=(/9: [/3 - /3]; tight), fd=()-->(9)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    └── [/3 - /3]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    └── [/4 - /4]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9!null
           │         ├── key: (6)
           │         ├── fd: ()-->(8), (6)-->(7,9)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/4 - /4]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── (w:9 = 1) OR (w:9 = 2) [outer=(9), constraints=(/9: [/1 - /1] [/2 - /2]; tight)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4
           │    ├── left columns: k:1!null u:2 v:3 w:4
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9
           │         ├── key: (6)
           │         ├── fd: ()-->(8), (6)-->(7,9)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/4 - /4]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── (u:7 = 1) OR (w:9 = 2) [outer=(7,9)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunctionAddKey
SELECT u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: u:2 w:4
 ├── scan d
 │    └── columns: u:2 w:4
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries with strict keys.
opt expect-not=SplitDisjunctionAddKey
SELECT k, u, v FROM d WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8), (6)-->(7)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6: [/1 - /1]
 │              ├── key: (6)
 │              └── fd: ()-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunctionAddKey
SELECT u FROM d WHERE u = 1 OR u = 5
----
scan d@u
 ├── columns: u:2!null
 └── constraint: /2/1
      ├── [/1 - /1]
      └── [/5 - /5]

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 ├── lax-key: (2,3)
 ├── fd: (3)~~>(2)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── constraint: /7: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(5-7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: u:2!null v:3
 ├── fd: ()-->(2)
 └── index-join d
      ├── columns: k:1!null u:2!null v:3
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      └── scan d@u
           ├── columns: k:1!null u:2!null
           ├── constraint: /2/1: [/2 - /2]
           ├── key: (1)
           └── fd: ()-->(2)
