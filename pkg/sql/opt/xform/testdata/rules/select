exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u(u) STORING (v),
    UNIQUE INDEX v(v) STORING (u)
)
----

exec-ddl
CREATE TABLE b
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    j JSONB,
    INDEX u(u),
    UNIQUE INDEX v(v),
    INVERTED INDEX inv_idx(j)
)
----

exec-ddl
CREATE TABLE c
(
    k INT PRIMARY KEY,
    a INT[],
    u INT,
    INVERTED INDEX inv_idx(a),
    INDEX u(u)
)
----

exec-ddl
CREATE TABLE d
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE e
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX uw(u, w),
    INDEX vw(v, w)
)
----

exec-ddl
CREATE TABLE f
(
    k INT,
    j INT,
    u INT,
    v INT,
    CONSTRAINT pk PRIMARY KEY (k, j),
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE no_explicit_primary_key
(
    k INT,
    u INT,
    v INT,
    INDEX u(u),
    INDEX v(v)
)
----

# --------------------------------------------------
# GenerateConstrainedScans
# --------------------------------------------------

opt
SELECT k FROM a WHERE k = 1
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

memo
SELECT k FROM a WHERE k = 1
----
memo (optimized, ~5KB, required=[presentation: k:1])
 ├── G1: (select G2 G3) (scan a,cols=(1),constrained)
 │    └── [presentation: k:1]
 │         ├── best: (scan a,cols=(1),constrained)
 │         └── cost: 1.05
 ├── G2: (scan a,cols=(1)) (scan a@u,cols=(1)) (scan a@v,cols=(1))
 │    └── []
 │         ├── best: (scan a,cols=(1))
 │         └── cost: 1040.02
 ├── G3: (filters G4)
 ├── G4: (eq G5 G6)
 ├── G5: (variable k)
 └── G6: (const 1)

opt
SELECT k FROM a WHERE v > 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan a@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/2 - ]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT k FROM a WHERE v > 1
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 350.17
 ├── G2: (select G4 G5) (scan a@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1,3),constrained)
 │         └── cost: 346.86
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,3)) (scan a@u,cols=(1,3)) (scan a@v,cols=(1,3))
 │    └── []
 │         ├── best: (scan a,cols=(1,3))
 │         └── cost: 1050.02
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable v)
 └── G8: (const 1)

opt
SELECT k FROM a WHERE u = 1 AND k = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/5 - /1/5]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k = 5
----
memo (optimized, ~7KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 1.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1050.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 1.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 5)

# Constraint + remaining filter.
opt
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/0 - /1/0]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 1.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1050.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 1.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 0)

opt
SELECT k FROM a WHERE u = 1 AND v = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-3)
      ├── scan a@v
      │    ├── columns: k:1!null u:2 v:3!null
      │    ├── constraint: /3: [/5 - /5]
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    └── fd: ()-->(1-3)
      └── filters
           └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

memo
SELECT k FROM a WHERE u = 1 AND v = 5
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 1.10
 ├── G2: (select G4 G5) (select G6 G7) (select G8 G9)
 │    └── []
 │         ├── best: (select G8 G9)
 │         └── cost: 1.09
 ├── G3: (projections)
 ├── G4: (scan a) (scan a@u) (scan a@v)
 │    └── []
 │         ├── best: (scan a)
 │         └── cost: 1060.02
 ├── G5: (filters G10 G11)
 ├── G6: (scan a@u,constrained)
 │    └── []
 │         ├── best: (scan a@u,constrained)
 │         └── cost: 10.61
 ├── G7: (filters G11)
 ├── G8: (scan a@v,constrained)
 │    └── []
 │         ├── best: (scan a@v,constrained)
 │         └── cost: 1.07
 ├── G9: (filters G10)
 ├── G10: (eq G12 G13)
 ├── G11: (eq G14 G15)
 ├── G12: (variable u)
 ├── G13: (const 1)
 ├── G14: (variable v)
 └── G15: (const 5)

# Only not-null constraint is pushed down.
opt
SELECT k FROM a WHERE u=v
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)-->(1), (2)==(3), (3)==(2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── constraint: /2/1: (/NULL - ]
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (3)~~>(1,2)
      └── filters
           └── u:2 = v:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]

# Don't push constraint into already limited scan.
opt
SELECT k FROM (SELECT k FROM a ORDER BY u LIMIT 1) a WHERE k = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1,2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2
      │    ├── limit: 1
      │    ├── key: ()
      │    └── fd: ()-->(1,2)
      └── filters
           └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]

# Constraint + index-join, with no remainder filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── cardinality: [0 - 10]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
memo (optimized, ~3KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (index-join G4 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G4 b,cols=(1-4))
 │         └── cost: 51.32
 ├── G2: (scan b)
 │    └── []
 │         ├── best: (scan b)
 │         └── cost: 1080.02
 ├── G3: (filters G5)
 ├── G4: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G5: (range G6)
 ├── G6: (and G7 G8)
 ├── G7: (ge G9 G10)
 ├── G8: (le G9 G11)
 ├── G9: (variable v)
 ├── G10: (const 1)
 └── G11: (const 10)

# Don't choose lookup join if it's not beneficial.
opt
SELECT * FROM b WHERE v > 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── v:3 > 1 [outer=(3), constraints=(/3: [/2 - ]; tight)]

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── select
      ├── columns: k:1!null v:3!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(3), (3)-->(1)
      ├── scan b@v
      │    ├── columns: k:1!null v:3!null
      │    ├── constraint: /3: [/1 - /10]
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    └── fd: (1)-->(3), (3)-->(1)
      └── filters
           └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
memo (optimized, ~6KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G6 b,cols=(1-4))
 │         └── cost: 24.16
 ├── G2: (scan b)
 │    └── []
 │         ├── best: (scan b)
 │         └── cost: 1080.02
 ├── G3: (filters G7 G8)
 ├── G4: (scan b,constrained)
 │    └── []
 │         ├── best: (scan b,constrained)
 │         └── cost: 360.01
 ├── G5: (filters G7)
 ├── G6: (select G9 G10)
 │    └── []
 │         ├── best: (select G9 G10)
 │         └── cost: 10.52
 ├── G7: (range G11)
 ├── G8: (gt G12 G13)
 ├── G9: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G10: (filters G8)
 ├── G11: (and G14 G15)
 ├── G12: (variable k)
 ├── G13: (const 5)
 ├── G14: (ge G16 G17)
 ├── G15: (le G16 G18)
 ├── G16: (variable v)
 ├── G17: (const 1)
 └── G18: (const 10)

# Ensure the rule doesn't match at all when the first column of the index is
# not in the filter (i.e. the @v index is not matched by ConstrainScans).
exploretrace rule=GenerateConstrainedScans
SELECT k FROM a WHERE u = 1
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── select
        ├── columns: k:1!null u:2!null
        ├── key: (1)
        ├── fd: ()-->(2)
        ├── scan a
        │    ├── columns: k:1!null u:2
        │    ├── key: (1)
        │    └── fd: (1)-->(2)
        └── filters
             └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

New expression 1 of 1:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── scan a@u
        ├── columns: k:1!null u:2!null
        ├── constraint: /2/1: [/1 - /1]
        ├── key: (1)
        └── fd: ()-->(2)
----
----

# Constraint + index join + remaining filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
memo (optimized, ~5KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G5)
 │         └── cost: 51.43
 ├── G2: (scan b)
 │    └── []
 │         ├── best: (scan b)
 │         └── cost: 1080.02
 ├── G3: (filters G6 G7)
 ├── G4: (index-join G8 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G8 b,cols=(1-4))
 │         └── cost: 51.32
 ├── G5: (filters G7)
 ├── G6: (range G9)
 ├── G7: (eq G10 G11)
 ├── G8: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G9: (and G12 G13)
 ├── G10: (plus G14 G15)
 ├── G11: (const 1)
 ├── G12: (ge G16 G11)
 ├── G13: (le G16 G17)
 ├── G14: (variable k)
 ├── G15: (variable u)
 ├── G16: (variable v)
 └── G17: (const 10)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── select
 │         ├── columns: k:1!null v:3!null
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(3), (3)-->(1)
 │         ├── scan b@v
 │         │    ├── columns: k:1!null v:3!null
 │         │    ├── constraint: /3: [/1 - /10]
 │         │    ├── cardinality: [0 - 10]
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3), (3)-->(1)
 │         └── filters
 │              └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G6 G7)
 │         └── cost: 24.21
 ├── G2: (scan b)
 │    └── []
 │         ├── best: (scan b)
 │         └── cost: 1080.02
 ├── G3: (filters G8 G9 G10)
 ├── G4: (scan b,constrained)
 │    └── []
 │         ├── best: (scan b,constrained)
 │         └── cost: 360.01
 ├── G5: (filters G8 G9)
 ├── G6: (index-join G11 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G11 b,cols=(1-4))
 │         └── cost: 24.16
 ├── G7: (filters G9)
 ├── G8: (range G12)
 ├── G9: (eq G13 G14)
 ├── G10: (gt G15 G16)
 ├── G11: (select G17 G18)
 │    └── []
 │         ├── best: (select G17 G18)
 │         └── cost: 10.52
 ├── G12: (and G19 G20)
 ├── G13: (plus G15 G21)
 ├── G14: (const 1)
 ├── G15: (variable k)
 ├── G16: (const 5)
 ├── G17: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 10.41
 ├── G18: (filters G10)
 ├── G19: (ge G22 G14)
 ├── G20: (le G22 G23)
 ├── G21: (variable u)
 ├── G22: (variable v)
 └── G23: (const 10)

# Constraint + index-join.
opt
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
select
 ├── columns: k:1!null u:2!null v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@u
 │         ├── columns: k:1!null u:2!null
 │         ├── constraint: /2/1: [/1/2 - /8/9]
 │         ├── key: (1)
 │         └── fd: (1)-->(2)
 └── filters
      ├── (u:2, k:1, v:3) > (1, 2, 3) [outer=(1-3), constraints=(/2/1/3: [/1/2/4 - ]; tight)]
      └── (u:2, k:1, v:3) < (8, 9, 10) [outer=(1-3), constraints=(/2/1/3: (/NULL - /8/9/9]; tight)]

memo
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
memo (optimized, ~5KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G3)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G3)
 │         └── cost: 45.72
 ├── G2: (scan b)
 │    └── []
 │         ├── best: (scan b)
 │         └── cost: 1080.02
 ├── G3: (filters G5 G6)
 ├── G4: (index-join G7 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G7 b,cols=(1-4))
 │         └── cost: 45.62
 ├── G5: (gt G8 G9)
 ├── G6: (lt G8 G10)
 ├── G7: (scan b@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan b@u,cols=(1,2),constrained)
 │         └── cost: 9.25
 ├── G8: (tuple G11)
 ├── G9: (tuple G12)
 ├── G10: (tuple G13)
 ├── G11: (scalar-list G14 G15 G16)
 ├── G12: (scalar-list G17 G18 G19)
 ├── G13: (scalar-list G20 G21 G22)
 ├── G14: (variable u)
 ├── G15: (variable k)
 ├── G16: (variable v)
 ├── G17: (const 1)
 ├── G18: (const 2)
 ├── G19: (const 3)
 ├── G20: (const 8)
 ├── G21: (const 9)
 └── G22: (const 10)

# GenerateConstrainedScans propagates row-level locking information.
opt
SELECT k FROM a WHERE k = 1 FOR UPDATE
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── locking: for-update
 ├── cardinality: [0 - 1]
 ├── side-effects
 ├── key: ()
 └── fd: ()-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 FOR UPDATE
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── side-effects
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── locking: for-update
      ├── cardinality: [0 - 10]
      ├── side-effects
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 FOR UPDATE
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── side-effects
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── side-effects
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── locking: for-update
 │         ├── cardinality: [0 - 10]
 │         ├── side-effects
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2)]

# --------------------------------------------------
# GenerateInvertedIndexScans
# --------------------------------------------------
# TODO(justin): these can be serviced without an index join.
# Query only the primary key with no remaining filter.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── index-join b
      ├── columns: k:1!null j:4
      ├── key: (1)
      ├── fd: (1)-->(4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           └── key: (1)

memo
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 567.81
 ├── G2: (select G4 G5) (index-join G6 b,cols=(1,4))
 │    └── []
 │         ├── best: (index-join G6 b,cols=(1,4))
 │         └── cost: 566.69
 ├── G3: (projections)
 ├── G4: (scan b,cols=(1,4))
 │    └── []
 │         ├── best: (scan b,cols=(1,4))
 │         └── cost: 1060.02
 ├── G5: (filters G7)
 ├── G6: (scan b@inv_idx,cols=(1),constrained)
 │    └── []
 │         ├── best: (scan b@inv_idx,cols=(1),constrained)
 │         └── cost: 114.45
 ├── G7: (contains G8 G9)
 ├── G8: (variable j)
 └── G9: (const '{"a": "b"}')

# Query only the primary key with a remaining filter. 2+ paths in containment
# query should favor zigzag joins.
opt
SELECT k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup b)
      ├── columns: k:1!null j:4
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── inner-join (zigzag b@inv_idx b@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [4] = ['{"a": "b"}']
      │    ├── right fixed columns: [4] = ['{"c": "d"}']
      │    └── filters (true)
      └── filters
           └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4)]

# Query requiring an index join with no remaining filter.
opt
SELECT u, k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: u:2 k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── index-join b
      ├── columns: k:1!null u:2 j:4
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           └── key: (1)

opt
SELECT j, k FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: j:4 k:1!null
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

# Query requiring a zigzag join with a remaining filter.
# TODO(itsbilal): remove filter from index join if zigzag join covers it.
opt
SELECT j, k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
inner-join (lookup b)
 ├── columns: j:4 k:1!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── key: (1)
 ├── fd: (1)-->(4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": "b"}']
 │    ├── right fixed columns: [4] = ['{"c": "d"}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '{"a": {"b": "c", "d": "e"}, "f": "g"}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": {"b": "c"}}']
 │    ├── right fixed columns: [4] = ['{"a": {"d": "e"}}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": {"b": "c", "d": "e"}, "f": "g"}' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '{}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{}' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '[]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[]' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '2'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1
      │    ├── [/'2' - /'2']
      │    └── [/'[2]' - /'[2]']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '[{}]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[{}]' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '{"a": {}}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": {}}' [outer=(4)]

opt
SELECT * FROM b WHERE j @> '{"a": []}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": []}' [outer=(4)]

# GenerateInvertedIndexScans propagates row-level locking information.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}' FOR UPDATE
----
project
 ├── columns: k:1!null
 ├── side-effects
 ├── key: (1)
 └── index-join b
      ├── columns: k:1!null j:4
      ├── side-effects
      ├── key: (1)
      ├── fd: (1)-->(4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           ├── locking: for-update
           ├── side-effects
           └── key: (1)

# Tests for array inverted indexes.
opt
SELECT k FROM c WHERE a @> ARRAY[1]
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── index-join c
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: (1)-->(2)
      └── scan c@inv_idx
           ├── columns: k:1!null
           ├── constraint: /2/1: [/ARRAY[1] - /ARRAY[1]]
           └── key: (1)

opt
SELECT k FROM c WHERE a @> ARRAY[1,3,1,5]
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup c)
      ├── columns: k:1!null a:2
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── inner-join (zigzag c@inv_idx c@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [ARRAY[1]]
      │    ├── right fixed columns: [2] = [ARRAY[3]]
      │    └── filters (true)
      └── filters
           └── a:2 @> ARRAY[1,3,1,5] [outer=(2)]

opt
SELECT k FROM c WHERE a @> ARRAY[]::INT[]
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 @> ARRAY[] [outer=(2)]

opt
SELECT k FROM c WHERE a IS NULL
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]


# --------------------------------------------------
# SplitDisjunction
# --------------------------------------------------

# TODO(mgartner): PruneAggCols should be pruning columns from the DistinctOn
# and further down the expression tree, ultimatly eliminating the index-joins.
# PruneAggCols does not run in this case because normalization rules do not run
# at the root tree generated by an exploration rule.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5: [/1 - /1]
      │              ├── key: (5)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT * FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
distinct-on
 ├── columns: k:1!null u:2 v:3 w:4!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3 w:4!null
 │    ├── left columns: k:1!null u:2 v:3 w:4!null
 │    ├── right columns: k:5 u:6 v:7 w:8
 │    ├── select
 │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2,4), (1)-->(3)
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2 v:3 w:4
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── filters
 │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │    └── select
 │         ├── columns: k:5!null u:6 v:7!null w:8!null
 │         ├── key: (5)
 │         ├── fd: ()-->(7,8), (5)-->(6)
 │         ├── index-join d
 │         │    ├── columns: k:5!null u:6 v:7 w:8
 │         │    ├── key: (5)
 │         │    ├── fd: ()-->(7), (5)-->(6,8)
 │         │    └── scan d@v
 │         │         ├── columns: k:5!null v:7!null
 │         │         ├── constraint: /7/5: [/1 - /1]
 │         │         ├── key: (5)
 │         │         └── fd: ()-->(7)
 │         └── filters
 │              └── w:8 = 1 [outer=(8), constraints=(/8: [/1 - /1]; tight), fd=()-->(8)]
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      ├── const-agg [as=v:3, outer=(3)]
      │    └── v:3
      └── const-agg [as=w:4, outer=(4)]
           └── w:4

opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:5 u:6 v:7
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:5!null u:6!null v:7!null
      │         ├── eq columns: [5] = [5]
      │         ├── left fixed columns: [6] = [10]
      │         ├── right fixed columns: [7] = [2]
      │         ├── key: (5)
      │         ├── fd: ()-->(6,7)
      │         └── filters
      │              ├── v:7 = 2 [outer=(7), constraints=(/7: [/2 - /2]; tight), fd=()-->(7)]
      │              └── u:6 = 10 [outer=(6), constraints=(/6: [/10 - /10]; tight), fd=()-->(6)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT sum(k) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: sum:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── distinct-on
 │    ├── columns: k:1!null u:2 v:3
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── union-all
 │    │    ├── columns: k:1!null u:2 v:3
 │    │    ├── left columns: k:1!null u:2 v:3
 │    │    ├── right columns: k:6 u:7 v:8
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2!null v:3
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── index-join d
 │    │         ├── columns: k:6!null u:7 v:8!null
 │    │         ├── key: (6)
 │    │         ├── fd: ()-->(8), (6)-->(7)
 │    │         └── scan d@v
 │    │              ├── columns: k:6!null v:8!null
 │    │              ├── constraint: /8/6: [/1 - /1]
 │    │              ├── key: (6)
 │    │              └── fd: ()-->(8)
 │    └── aggregations
 │         ├── const-agg [as=u:2, outer=(2)]
 │         │    └── u:2
 │         └── const-agg [as=v:3, outer=(3)]
 │              └── v:3
 └── aggregations
      └── sum [as=sum:5, outer=(1)]
           └── k:1

# Multi-column primary key.
opt expect=SplitDisjunction
SELECT k, j FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: k:1!null j:2!null
 ├── key: (1,2)
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:5 j:6 u:7 v:8
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:5!null j:6!null u:7 v:8!null
      │         ├── key: (5,6)
      │         ├── fd: ()-->(8), (5,6)-->(7)
      │         └── scan f@v
      │              ├── columns: k:5!null j:6!null v:8!null
      │              ├── constraint: /8/5/6: [/2 - /2]
      │              ├── key: (5,6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5: [/5 - /8]
      │              ├── key: (5)
      │              └── fd: (5)-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunction
SELECT k FROM b WHERE k = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null j:4
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── union-all
      │    ├── columns: k:1!null j:4
      │    ├── left columns: k:1!null j:4
      │    ├── right columns: k:5 j:8
      │    ├── scan b
      │    │    ├── columns: k:1!null j:4
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,4)
      │    └── index-join b
      │         ├── columns: k:5!null j:8
      │         ├── key: (5)
      │         ├── fd: (5)-->(8)
      │         └── scan b@inv_idx
      │              ├── columns: k:5!null
      │              ├── constraint: /8/5: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (5)
      └── aggregations
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunction
SELECT k FROM c WHERE k = 1 OR a @> ARRAY[2]
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── union-all
      │    ├── columns: k:1!null a:2
      │    ├── left columns: k:1!null a:2
      │    ├── right columns: k:4 a:5
      │    ├── scan c
      │    │    ├── columns: k:1!null a:2
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,2)
      │    └── index-join c
      │         ├── columns: k:4!null a:5
      │         ├── key: (4)
      │         ├── fd: (4)-->(5)
      │         └── scan c@inv_idx
      │              ├── columns: k:4!null
      │              ├── constraint: /5/4: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (4)
      └── aggregations
           └── const-agg [as=a:2, outer=(2)]
                └── a:2

# Uncorrelated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:8 d.u:9 d.v:10
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:6 a.v:7
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(6,7)
      │    └── index-join d
      │         ├── columns: d.k:8!null d.u:9 d.v:10!null
      │         ├── key: (8)
      │         ├── fd: ()-->(10), (8)-->(9)
      │         └── select
      │              ├── columns: d.k:8!null d.v:10!null
      │              ├── key: (8)
      │              ├── fd: ()-->(10)
      │              ├── scan d@v
      │              │    ├── columns: d.k:8!null d.v:10!null
      │              │    ├── constraint: /10/8: [/1 - /1]
      │              │    ├── key: (8)
      │              │    └── fd: ()-->(10)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:6 a.v:7
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(6,7)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2!null d.v:3 a.u:6!null
           ├── key: (1)
           ├── fd: (1)-->(2,3), (2)==(6), (6)==(2)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2,3)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── right columns: d.k:8 d.u:9 d.v:10
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:8!null d.u:9 d.v:10!null
           │    │         ├── key: (8)
           │    │         ├── fd: ()-->(10), (8)-->(9)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:8!null d.v:10!null
           │    │              ├── constraint: /10/8: [/1 - /1]
           │    │              ├── key: (8)
           │    │              └── fd: ()-->(10)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         └── const-agg [as=d.v:3, outer=(3)]
           │              └── d.v:3
           ├── distinct-on
           │    ├── columns: a.u:6
           │    ├── grouping columns: a.u:6
           │    ├── internal-ordering: +6
           │    ├── key: (6)
           │    └── scan a@u
           │         ├── columns: a.u:6
           │         └── ordering: +6
           └── filters
                └── a.u:6 = d.u:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2 d.v:3 w:4!null a.u:6!null
           ├── key: (1)
           ├── fd: (1)-->(2-4), (4)==(6), (6)==(4)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2-4)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── right columns: d.k:8 d.u:9 d.v:10 w:11
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:8!null d.u:9 d.v:10!null w:11
           │    │         ├── key: (8)
           │    │         ├── fd: ()-->(10), (8)-->(9,11)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:8!null d.v:10!null
           │    │              ├── constraint: /10/8: [/1 - /1]
           │    │              ├── key: (8)
           │    │              └── fd: ()-->(10)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         ├── const-agg [as=d.v:3, outer=(3)]
           │         │    └── d.v:3
           │         └── const-agg [as=w:4, outer=(4)]
           │              └── w:4
           ├── distinct-on
           │    ├── columns: a.u:6
           │    ├── grouping columns: a.u:6
           │    ├── internal-ordering: +6
           │    ├── key: (6)
           │    └── scan a@u
           │         ├── columns: a.u:6
           │         └── ordering: +6
           └── filters
                └── a.u:6 = w:4 [outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM e WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:5 u:6 v:7
 │    ├── index-join e
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan e@uw
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/4/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join e
 │         ├── columns: k:5!null u:6 v:7!null
 │         ├── key: (5)
 │         ├── fd: ()-->(7), (5)-->(6)
 │         └── scan e@vw
 │              ├── columns: k:5!null v:7!null
 │              ├── constraint: /7/8/5: [/1 - /1]
 │              ├── key: (5)
 │              └── fd: ()-->(7)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: k:1!null u:2 v:3
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:5 u:6 v:7 w:8
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:5!null u:6 v:7!null w:8!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7,8), (5)-->(6)
      │         ├── index-join d
      │         │    ├── columns: k:5!null u:6 v:7 w:8
      │         │    ├── key: (5)
      │         │    ├── fd: ()-->(7), (5)-->(6,8)
      │         │    └── scan d@v
      │         │         ├── columns: k:5!null v:7!null
      │         │         ├── constraint: /7/5: [/1 - /1]
      │         │         ├── key: (5)
      │         │         └── fd: ()-->(7)
      │         └── filters
      │              └── w:8 = 3 [outer=(8), constraints=(/8: [/3 - /3]; tight), fd=()-->(8)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:5 u:6 v:7
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    └── [/3 - /3]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:5!null u:6 v:7!null
 │         ├── key: (5)
 │         ├── fd: (5)-->(6,7)
 │         └── scan d@v
 │              ├── columns: k:5!null v:7!null
 │              ├── constraint: /7/5
 │              │    ├── [/2 - /2]
 │              │    └── [/4 - /4]
 │              ├── key: (5)
 │              └── fd: (5)-->(7)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:5 u:6 v:7
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:5!null u:6 v:7!null
 │         ├── key: (5)
 │         ├── fd: (5)-->(6,7)
 │         └── scan d@v
 │              ├── columns: k:5!null v:7!null
 │              ├── constraint: /7/5
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (5)
 │              └── fd: (5)-->(7)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:5 u:6 v:7
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:5!null u:6 v:7!null
 │         ├── key: (5)
 │         ├── fd: (5)-->(6,7)
 │         └── scan d@v
 │              ├── columns: k:5!null v:7!null
 │              ├── constraint: /7/5
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (5)
 │              └── fd: (5)-->(7)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:5 u:6 v:7 w:8
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
      │    └── select
      │         ├── columns: k:5!null u:6 v:7!null w:8!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6,8)
      │         ├── index-join d
      │         │    ├── columns: k:5!null u:6 v:7 w:8
      │         │    ├── key: (5)
      │         │    ├── fd: ()-->(7), (5)-->(6,8)
      │         │    └── scan d@v
      │         │         ├── columns: k:5!null v:7!null
      │         │         ├── constraint: /7/5: [/4 - /4]
      │         │         ├── key: (5)
      │         │         └── fd: ()-->(7)
      │         └── filters
      │              └── (w:8 = 1) OR (w:8 = 2) [outer=(8), constraints=(/8: [/1 - /1] [/2 - /2]; tight)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4
      │    ├── left columns: k:1!null u:2 v:3 w:4
      │    ├── right columns: k:5 u:6 v:7 w:8
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:5!null u:6 v:7!null w:8
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6,8)
      │         ├── index-join d
      │         │    ├── columns: k:5!null u:6 v:7 w:8
      │         │    ├── key: (5)
      │         │    ├── fd: ()-->(7), (5)-->(6,8)
      │         │    └── scan d@v
      │         │         ├── columns: k:5!null v:7!null
      │         │         ├── constraint: /7/5: [/4 - /4]
      │         │         ├── key: (5)
      │         │         └── fd: ()-->(7)
      │         └── filters
      │              └── (u:6 = 1) OR (w:8 = 2) [outer=(6,8)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunction
SELECT k, u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: k:1!null u:2 w:4
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan d
 │    ├── columns: k:1!null u:2 w:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries without strict keys.
opt expect-not=SplitDisjunction
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5: [/1 - /1]
      │              ├── key: (5)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR u = 5
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan d@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1
      │    ├── [/1 - /1]
      │    └── [/5 - /5]
      ├── key: (1)
      └── fd: (1)-->(2)

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunction
SELECT k FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)~~>(1,2)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:4 u:5 v:6
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:4!null u:5 v:6!null
      │         ├── constraint: /6: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(4-6)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1 opt(2)
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      ├── index-join d
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── key: (1)
      │    ├── fd: ()-->(2), (1)-->(3)
      │    ├── ordering: +1 opt(2) [actual: +1]
      │    └── scan d@u
      │         ├── columns: k:1!null u:2!null
      │         ├── constraint: /2/1: [/2 - /2]
      │         ├── key: (1)
      │         ├── fd: ()-->(2)
      │         └── ordering: +1 opt(2) [actual: +1]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# --------------------------------------------------
# SplitDisjunctionAddKey
# --------------------------------------------------

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5: [/1 - /1]
      │              ├── key: (5)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT u, v, w FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
project
 ├── columns: u:2 v:3 w:4!null
 ├── fd: ()-->(4)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:5 u:6 v:7 w:8
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:5!null u:6 v:7!null w:8!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7,8), (5)-->(6)
      │         ├── index-join d
      │         │    ├── columns: k:5!null u:6 v:7 w:8
      │         │    ├── key: (5)
      │         │    ├── fd: ()-->(7), (5)-->(6,8)
      │         │    └── scan d@v
      │         │         ├── columns: k:5!null v:7!null
      │         │         ├── constraint: /7/5: [/1 - /1]
      │         │         ├── key: (5)
      │         │         └── fd: ()-->(7)
      │         └── filters
      │              └── w:8 = 1 [outer=(8), constraints=(/8: [/1 - /1]; tight), fd=()-->(8)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:5 u:6 v:7
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:5!null u:6!null v:7!null
      │         ├── eq columns: [5] = [5]
      │         ├── left fixed columns: [6] = [10]
      │         ├── right fixed columns: [7] = [2]
      │         ├── key: (5)
      │         ├── fd: ()-->(6,7)
      │         └── filters
      │              ├── v:7 = 2 [outer=(7), constraints=(/7: [/2 - /2]; tight), fd=()-->(7)]
      │              └── u:6 = 10 [outer=(6), constraints=(/6: [/10 - /10]; tight), fd=()-->(6)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT count(*) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: count:5!null
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── project
 │    ├── columns: u:2 v:3
 │    └── distinct-on
 │         ├── columns: k:1!null u:2 v:3
 │         ├── grouping columns: k:1!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,3)
 │         ├── union-all
 │         │    ├── columns: k:1!null u:2 v:3
 │         │    ├── left columns: k:1!null u:2 v:3
 │         │    ├── right columns: k:6 u:7 v:8
 │         │    ├── index-join d
 │         │    │    ├── columns: k:1!null u:2!null v:3
 │         │    │    ├── key: (1)
 │         │    │    ├── fd: ()-->(2), (1)-->(3)
 │         │    │    └── scan d@u
 │         │    │         ├── columns: k:1!null u:2!null
 │         │    │         ├── constraint: /2/1: [/1 - /1]
 │         │    │         ├── key: (1)
 │         │    │         └── fd: ()-->(2)
 │         │    └── index-join d
 │         │         ├── columns: k:6!null u:7 v:8!null
 │         │         ├── key: (6)
 │         │         ├── fd: ()-->(8), (6)-->(7)
 │         │         └── scan d@v
 │         │              ├── columns: k:6!null v:8!null
 │         │              ├── constraint: /8/6: [/1 - /1]
 │         │              ├── key: (6)
 │         │              └── fd: ()-->(8)
 │         └── aggregations
 │              ├── const-agg [as=u:2, outer=(2)]
 │              │    └── u:2
 │              └── const-agg [as=v:3, outer=(3)]
 │                   └── v:3
 └── aggregations
      └── count-rows [as=count_rows:5]


# Multi-column primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: u:3 v:4
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:5 j:6 u:7 v:8
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:5!null j:6!null u:7 v:8!null
      │         ├── key: (5,6)
      │         ├── fd: ()-->(8), (5,6)-->(7)
      │         └── scan f@v
      │              ├── columns: k:5!null j:6!null v:8!null
      │              ├── constraint: /8/5/6: [/2 - /2]
      │              ├── key: (5,6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5: [/5 - /8]
      │              ├── key: (5)
      │              └── fd: (5)-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, j FROM b WHERE u = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: u:2 j:4
 └── distinct-on
      ├── columns: k:1!null u:2 j:4
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── union-all
      │    ├── columns: k:1!null u:2 j:4
      │    ├── left columns: k:1!null u:2 j:4
      │    ├── right columns: k:5 u:6 j:8
      │    ├── index-join b
      │    │    ├── columns: k:1!null u:2!null j:4
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(4)
      │    │    └── scan b@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join b
      │         ├── columns: k:5!null u:6 j:8
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,8)
      │         └── scan b@inv_idx
      │              ├── columns: k:5!null
      │              ├── constraint: /8/5: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (5)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, a FROM c WHERE u = 1 OR a @> ARRAY[2]
----
project
 ├── columns: u:3 a:2
 └── distinct-on
      ├── columns: k:1!null a:2 u:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 u:3
      │    ├── left columns: k:1!null a:2 u:3
      │    ├── right columns: k:4 a:5 u:6
      │    ├── index-join c
      │    │    ├── columns: k:1!null a:2 u:3!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(3), (1)-->(2)
      │    │    └── scan c@u
      │    │         ├── columns: k:1!null u:3!null
      │    │         ├── constraint: /3/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(3)
      │    └── index-join c
      │         ├── columns: k:4!null a:5 u:6
      │         ├── key: (4)
      │         ├── fd: (4)-->(5,6)
      │         └── scan c@inv_idx
      │              ├── columns: k:4!null
      │              ├── constraint: /5/4: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (4)
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=u:3, outer=(3)]
                └── u:3

# Uncorrelated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:8 d.u:9 d.v:10
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:6 a.v:7
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(6,7)
      │    └── index-join d
      │         ├── columns: d.k:8!null d.u:9 d.v:10!null
      │         ├── key: (8)
      │         ├── fd: ()-->(10), (8)-->(9)
      │         └── select
      │              ├── columns: d.k:8!null d.v:10!null
      │              ├── key: (8)
      │              ├── fd: ()-->(10)
      │              ├── scan d@v
      │              │    ├── columns: d.k:8!null d.v:10!null
      │              │    ├── constraint: /10/8: [/1 - /1]
      │              │    ├── key: (8)
      │              │    └── fd: ()-->(10)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:6 a.v:7
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(6,7)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: u:2 v:3
 └── inner-join (hash)
      ├── columns: d.u:2!null d.v:3 a.u:6!null
      ├── fd: (2)==(6), (6)==(2)
      ├── project
      │    ├── columns: d.u:2 d.v:3
      │    └── distinct-on
      │         ├── columns: d.k:1!null d.u:2 d.v:3
      │         ├── grouping columns: d.k:1!null
      │         ├── key: (1)
      │         ├── fd: (1)-->(2,3)
      │         ├── union-all
      │         │    ├── columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── right columns: d.k:8 d.u:9 d.v:10
      │         │    ├── index-join d
      │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │         │    │    ├── key: (1)
      │         │    │    ├── fd: ()-->(2), (1)-->(3)
      │         │    │    └── scan d@u
      │         │    │         ├── columns: d.k:1!null d.u:2!null
      │         │    │         ├── constraint: /2/1: [/1 - /1]
      │         │    │         ├── key: (1)
      │         │    │         └── fd: ()-->(2)
      │         │    └── index-join d
      │         │         ├── columns: d.k:8!null d.u:9 d.v:10!null
      │         │         ├── key: (8)
      │         │         ├── fd: ()-->(10), (8)-->(9)
      │         │         └── scan d@v
      │         │              ├── columns: d.k:8!null d.v:10!null
      │         │              ├── constraint: /10/8: [/1 - /1]
      │         │              ├── key: (8)
      │         │              └── fd: ()-->(10)
      │         └── aggregations
      │              ├── const-agg [as=d.u:2, outer=(2)]
      │              │    └── d.u:2
      │              └── const-agg [as=d.v:3, outer=(3)]
      │                   └── d.v:3
      ├── distinct-on
      │    ├── columns: a.u:6
      │    ├── grouping columns: a.u:6
      │    ├── internal-ordering: +6
      │    ├── key: (6)
      │    └── scan a@u
      │         ├── columns: a.u:6
      │         └── ordering: +6
      └── filters
           └── a.u:6 = d.u:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: d.u:2 d.v:3 w:4
      └── inner-join (hash)
           ├── columns: d.u:2 d.v:3 w:4!null a.u:6!null
           ├── fd: (4)==(6), (6)==(4)
           ├── project
           │    ├── columns: d.u:2 d.v:3 w:4
           │    └── distinct-on
           │         ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         ├── grouping columns: d.k:1!null
           │         ├── key: (1)
           │         ├── fd: (1)-->(2-4)
           │         ├── union-all
           │         │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── right columns: d.k:8 d.u:9 d.v:10 w:11
           │         │    ├── index-join d
           │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │         │    │    ├── key: (1)
           │         │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │         │    │    └── scan d@u
           │         │    │         ├── columns: d.k:1!null d.u:2!null
           │         │    │         ├── constraint: /2/1: [/1 - /1]
           │         │    │         ├── key: (1)
           │         │    │         └── fd: ()-->(2)
           │         │    └── index-join d
           │         │         ├── columns: d.k:8!null d.u:9 d.v:10!null w:11
           │         │         ├── key: (8)
           │         │         ├── fd: ()-->(10), (8)-->(9,11)
           │         │         └── scan d@v
           │         │              ├── columns: d.k:8!null d.v:10!null
           │         │              ├── constraint: /10/8: [/1 - /1]
           │         │              ├── key: (8)
           │         │              └── fd: ()-->(10)
           │         └── aggregations
           │              ├── const-agg [as=d.u:2, outer=(2)]
           │              │    └── d.u:2
           │              ├── const-agg [as=d.v:3, outer=(3)]
           │              │    └── d.v:3
           │              └── const-agg [as=w:4, outer=(4)]
           │                   └── w:4
           ├── distinct-on
           │    ├── columns: a.u:6
           │    ├── grouping columns: a.u:6
           │    ├── internal-ordering: +6
           │    ├── key: (6)
           │    └── scan a@u
           │         ├── columns: a.u:6
           │         └── ordering: +6
           └── filters
                └── a.u:6 = w:4 [outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]

# Use rowid when there is no explicit primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM no_explicit_primary_key WHERE u = 1 OR v = 5
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: u:2 v:3 rowid:4!null
      ├── grouping columns: rowid:4!null
      ├── key: (4)
      ├── fd: (4)-->(2,3)
      ├── union-all
      │    ├── columns: u:2 v:3 rowid:4!null
      │    ├── left columns: u:2 v:3 rowid:4!null
      │    ├── right columns: u:6 v:7 rowid:8
      │    ├── index-join no_explicit_primary_key
      │    │    ├── columns: u:2!null v:3 rowid:4!null
      │    │    ├── key: (4)
      │    │    ├── fd: ()-->(2), (4)-->(3)
      │    │    └── scan no_explicit_primary_key@u
      │    │         ├── columns: u:2!null rowid:4!null
      │    │         ├── constraint: /2/4: [/1 - /1]
      │    │         ├── key: (4)
      │    │         └── fd: ()-->(2)
      │    └── index-join no_explicit_primary_key
      │         ├── columns: u:6 v:7!null rowid:8!null
      │         ├── key: (8)
      │         ├── fd: ()-->(7), (8)-->(6)
      │         └── scan no_explicit_primary_key@v
      │              ├── columns: v:7!null rowid:8!null
      │              ├── constraint: /7/8: [/5 - /5]
      │              ├── key: (8)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM e WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join e
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan e@uw
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/4/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join e
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6)
      │         └── scan e@vw
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/8/5: [/1 - /1]
      │              ├── key: (5)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:5 u:6 v:7 w:8
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:5!null u:6 v:7!null w:8!null
           │         ├── key: (5)
           │         ├── fd: ()-->(7,8), (5)-->(6)
           │         ├── index-join d
           │         │    ├── columns: k:5!null u:6 v:7 w:8
           │         │    ├── key: (5)
           │         │    ├── fd: ()-->(7), (5)-->(6,8)
           │         │    └── scan d@v
           │         │         ├── columns: k:5!null v:7!null
           │         │         ├── constraint: /7/5: [/1 - /1]
           │         │         ├── key: (5)
           │         │         └── fd: ()-->(7)
           │         └── filters
           │              └── w:8 = 3 [outer=(8), constraints=(/8: [/3 - /3]; tight), fd=()-->(8)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    └── [/3 - /3]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5
      │              │    ├── [/2 - /2]
      │              │    └── [/4 - /4]
      │              ├── key: (5)
      │              └── fd: (5)-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (5)
      │              └── fd: (5)-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── key: (5)
      │         ├── fd: (5)-->(6,7)
      │         └── scan d@v
      │              ├── columns: k:5!null v:7!null
      │              ├── constraint: /7/5
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (5)
      │              └── fd: (5)-->(7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:5 u:6 v:7 w:8
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
           │    └── select
           │         ├── columns: k:5!null u:6 v:7!null w:8!null
           │         ├── key: (5)
           │         ├── fd: ()-->(7), (5)-->(6,8)
           │         ├── index-join d
           │         │    ├── columns: k:5!null u:6 v:7 w:8
           │         │    ├── key: (5)
           │         │    ├── fd: ()-->(7), (5)-->(6,8)
           │         │    └── scan d@v
           │         │         ├── columns: k:5!null v:7!null
           │         │         ├── constraint: /7/5: [/4 - /4]
           │         │         ├── key: (5)
           │         │         └── fd: ()-->(7)
           │         └── filters
           │              └── (w:8 = 1) OR (w:8 = 2) [outer=(8), constraints=(/8: [/1 - /1] [/2 - /2]; tight)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4
           │    ├── left columns: k:1!null u:2 v:3 w:4
           │    ├── right columns: k:5 u:6 v:7 w:8
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:5!null u:6 v:7!null w:8
           │         ├── key: (5)
           │         ├── fd: ()-->(7), (5)-->(6,8)
           │         ├── index-join d
           │         │    ├── columns: k:5!null u:6 v:7 w:8
           │         │    ├── key: (5)
           │         │    ├── fd: ()-->(7), (5)-->(6,8)
           │         │    └── scan d@v
           │         │         ├── columns: k:5!null v:7!null
           │         │         ├── constraint: /7/5: [/4 - /4]
           │         │         ├── key: (5)
           │         │         └── fd: ()-->(7)
           │         └── filters
           │              └── (u:6 = 1) OR (w:8 = 2) [outer=(6,8)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunctionAddKey
SELECT u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: u:2 w:4
 ├── scan d
 │    └── columns: u:2 w:4
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries with strict keys.
opt expect-not=SplitDisjunctionAddKey
SELECT k, u, v FROM d WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:5 u:6 v:7
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join d
 │         ├── columns: k:5!null u:6 v:7!null
 │         ├── key: (5)
 │         ├── fd: ()-->(7), (5)-->(6)
 │         └── scan d@v
 │              ├── columns: k:5!null v:7!null
 │              ├── constraint: /7/5: [/1 - /1]
 │              ├── key: (5)
 │              └── fd: ()-->(7)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunctionAddKey
SELECT u FROM d WHERE u = 1 OR u = 5
----
scan d@u
 ├── columns: u:2!null
 └── constraint: /2/1
      ├── [/1 - /1]
      └── [/5 - /5]

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 ├── lax-key: (2,3)
 ├── fd: (3)~~>(2)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:4 u:5 v:6
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:4!null u:5 v:6!null
      │         ├── constraint: /6: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(4-6)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: u:2!null v:3
 ├── fd: ()-->(2)
 └── index-join d
      ├── columns: k:1!null u:2!null v:3
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      └── scan d@u
           ├── columns: k:1!null u:2!null
           ├── constraint: /2/1: [/2 - /2]
           ├── key: (1)
           └── fd: ()-->(2)
