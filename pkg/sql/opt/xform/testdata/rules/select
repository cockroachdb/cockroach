exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u(u) STORING (v),
    UNIQUE INDEX v(v) STORING (u)
)
----

exec-ddl
CREATE TABLE b
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    j JSONB,
    INDEX u(u),
    UNIQUE INDEX v(v),
    INVERTED INDEX inv_idx(j)
)
----

exec-ddl
CREATE TABLE c
(
    k INT PRIMARY KEY,
    a INT[],
    u INT,
    INVERTED INDEX inv_idx(a),
    INDEX u(u)
)
----

exec-ddl
CREATE TABLE d
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE e
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX uw(u, w),
    INDEX vw(v, w)
)
----

exec-ddl
CREATE TABLE f
(
    k INT,
    j INT,
    u INT,
    v INT,
    CONSTRAINT pk PRIMARY KEY (k, j),
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE g
(
    k INT PRIMARY KEY,
    v INT,
    geom GEOMETRY,
    geog GEOGRAPHY,
    INVERTED INDEX geom_idx (geom),
    INVERTED INDEX geog_idx (geog)
)
----

exec-ddl
CREATE TABLE p (
    i INT,
    f FLOAT,
    s STRING,
    b BOOL
)
----

exec-ddl
CREATE TABLE no_explicit_primary_key
(
    k INT,
    u INT,
    v INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE computed (
    k INT PRIMARY KEY,
    s STRING,
    l STRING AS (lower(s)) STORED,
    j JSON,
    field JSON AS (j->'foo') STORED,
    fieldstr STRING AS ((j->'foo')::string) STORED,
    INDEX l_idx (l),
    INDEX fieldstr_idx (fieldstr),
    INVERTED INDEX field_inv_idx (field)
)
----

# --------------------------------------------------
# GeneratePartialIndexScans
# --------------------------------------------------

exec-ddl
CREATE INDEX idx ON p (i) STORING (f, s) WHERE s = 'foo'
----

# Generate a lone partial index scan when the index is covering and there are no
# remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo'
----
project
 ├── columns: i:1
 └── scan p@idx,partial
      ├── columns: i:1 s:3!null
      └── fd: ()-->(3)

# Generate a partial index scan inside a select when the index is covering and
# there are remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: i:1
 └── select
      ├── columns: i:1 f:2 s:3!null
      ├── fd: ()-->(3)
      ├── scan p@idx,partial
      │    ├── columns: i:1 f:2 s:3!null
      │    └── fd: ()-->(3)
      └── filters
           └── (i:1 = 1) OR (f:2 = 2.0) [outer=(1,2)]

# Generate a partial index scan inside an index-join when the index is not
# covering and there no remaining filters.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo'
----
project
 ├── columns: b:4
 └── index-join p
      ├── columns: s:3!null b:4
      ├── fd: ()-->(3)
      └── scan p@idx,partial
           ├── columns: s:3!null rowid:5!null
           ├── key: (5)
           └── fd: ()-->(3)

# Generate a partial index scan inside a select inside an index-join when the
# index is not covering and there are remaining filters that are covered by the
# index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: b:4
 └── index-join p
      ├── columns: i:1 f:2 s:3!null b:4
      ├── fd: ()-->(3)
      └── select
           ├── columns: i:1 f:2 s:3!null rowid:5!null
           ├── key: (5)
           ├── fd: ()-->(3), (5)-->(1,2)
           ├── scan p@idx,partial
           │    ├── columns: i:1 f:2 s:3!null rowid:5!null
           │    ├── key: (5)
           │    └── fd: ()-->(3), (5)-->(1,2)
           └── filters
                └── (i:1 = 1) OR (f:2 = 2.0) [outer=(1,2)]

# Generate a partial index scan inside an index-join inside a select when the
# index is not covering and the remaining filters are not covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND b
----
project
 ├── columns: b:4!null
 ├── fd: ()-->(4)
 └── select
      ├── columns: s:3!null b:4!null
      ├── fd: ()-->(3,4)
      ├── index-join p
      │    ├── columns: s:3 b:4
      │    ├── fd: ()-->(3)
      │    └── scan p@idx,partial
      │         ├── columns: s:3!null rowid:5!null
      │         ├── key: (5)
      │         └── fd: ()-->(3)
      └── filters
           └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

# Generate a partial index scan inside a Select/IndexJoin/Select when the index
# is not covering and the remaining filters are partially covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND f = 1 AND b
----
project
 ├── columns: b:4!null
 ├── fd: ()-->(4)
 └── select
      ├── columns: f:2!null s:3!null b:4!null
      ├── fd: ()-->(2-4)
      ├── index-join p
      │    ├── columns: f:2 s:3 b:4
      │    ├── fd: ()-->(2,3)
      │    └── select
      │         ├── columns: f:2!null s:3!null rowid:5!null
      │         ├── key: (5)
      │         ├── fd: ()-->(2,3)
      │         ├── scan p@idx,partial
      │         │    ├── columns: f:2 s:3!null rowid:5!null
      │         │    ├── key: (5)
      │         │    └── fd: ()-->(3), (5)-->(2)
      │         └── filters
      │              └── f:2 = 1.0 [outer=(2), constraints=(/2: [/1.0 - /1.0]; tight), fd=()-->(2)]
      └── filters
           └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

# Generate multiple partial index scans when there are multiple partial indexes
# that have predicates implied by the filters.

exec-ddl
CREATE INDEX idx2 ON p (s) WHERE i > 0
----

memo expect=GeneratePartialIndexScans
SELECT * FROM p WHERE i > 0 AND s = 'foo'
----
memo (optimized, ~13KB, required=[presentation: i:1,f:2,s:3,b:4])
 ├── G1: (select G2 G3) (index-join G4 p,cols=(1-4)) (index-join G5 p,cols=(1-4)) (index-join G6 p,cols=(1-4)) (index-join G7 p,cols=(1-4))
 │    └── [presentation: i:1,f:2,s:3,b:4]
 │         ├── best: (index-join G4 p,cols=(1-4))
 │         └── cost: 49.00
 ├── G2: (scan p,cols=(1-4))
 │    └── []
 │         ├── best: (scan p,cols=(1-4))
 │         └── cost: 1094.02
 ├── G3: (filters G8 G9)
 ├── G4: (select G10 G11)
 │    └── []
 │         ├── best: (select G10 G11)
 │         └── cost: 14.93
 ├── G5: (select G12 G13)
 │    └── []
 │         ├── best: (select G12 G13)
 │         └── cost: 354.03
 ├── G6: (scan p@idx,partial,cols=(1-3,5),constrained)
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1-3,5),constrained)
 │         └── cost: 14.09
 ├── G7: (scan p@idx2,partial,cols=(3,5),constrained)
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(3,5),constrained)
 │         └── cost: 13.72
 ├── G8: (gt G14 G15)
 ├── G9: (eq G16 G17)
 ├── G10: (scan p@idx,partial,cols=(1-3,5))
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1-3,5))
 │         └── cost: 14.81
 ├── G11: (filters G8)
 ├── G12: (scan p@idx2,partial,cols=(3,5))
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(3,5))
 │         └── cost: 350.68
 ├── G13: (filters G9)
 ├── G14: (variable i)
 ├── G15: (const 0)
 ├── G16: (variable s)
 └── G17: (const 'foo')

# Do not generate a partial index scan when the predicate is not implied by the
# filter.
memo expect-not=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'bar'
----
memo (optimized, ~8KB, required=[presentation: i:1])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:1]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 1084.15
 ├── G2: (select G4 G5)
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1084.04
 ├── G3: (projections)
 ├── G4: (scan p,cols=(1,3))
 │    └── []
 │         ├── best: (scan p,cols=(1,3))
 │         └── cost: 1074.02
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'bar')

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

# --------------------------------------------------
# GenerateConstrainedScans
# --------------------------------------------------

opt
SELECT k FROM a WHERE k = 1
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

memo
SELECT k FROM a WHERE k = 1
----
memo (optimized, ~5KB, required=[presentation: k:1])
 ├── G1: (select G2 G3) (scan a,cols=(1),constrained)
 │    └── [presentation: k:1]
 │         ├── best: (scan a,cols=(1),constrained)
 │         └── cost: 5.05
 ├── G2: (scan a,cols=(1)) (scan a@u,cols=(1)) (scan a@v,cols=(1))
 │    └── []
 │         ├── best: (scan a,cols=(1))
 │         └── cost: 1044.02
 ├── G3: (filters G4)
 ├── G4: (eq G5 G6)
 ├── G5: (variable k)
 └── G6: (const 1)

opt
SELECT k FROM a WHERE v > 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan a@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/2 - ]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT k FROM a WHERE v > 1
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 354.17
 ├── G2: (select G4 G5) (scan a@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1,3),constrained)
 │         └── cost: 350.86
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,3)) (scan a@u,cols=(1,3)) (scan a@v,cols=(1,3))
 │    └── []
 │         ├── best: (scan a,cols=(1,3))
 │         └── cost: 1054.02
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable v)
 └── G8: (const 1)

opt
SELECT k FROM a WHERE u = 1 AND k = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/5 - /1/5]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k = 5
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 5.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1054.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 5)

# Constraint + remaining filter.
opt
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/0 - /1/0]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.07
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 5.05
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1054.02
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 0)

opt
SELECT k FROM a WHERE u = 1 AND v = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-3)
      ├── scan a@v
      │    ├── columns: k:1!null u:2 v:3!null
      │    ├── constraint: /3: [/5 - /5]
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    └── fd: ()-->(1-3)
      └── filters
           └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

memo
SELECT k FROM a WHERE u = 1 AND v = 5
----
memo (optimized, ~9KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.12
 ├── G2: (select G4 G5) (select G6 G7) (select G8 G9)
 │    └── []
 │         ├── best: (select G8 G9)
 │         └── cost: 5.10
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1-3)) (scan a@u,cols=(1-3)) (scan a@v,cols=(1-3))
 │    └── []
 │         ├── best: (scan a,cols=(1-3))
 │         └── cost: 1064.02
 ├── G5: (filters G10 G11)
 ├── G6: (scan a@u,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1-3),constrained)
 │         └── cost: 14.61
 ├── G7: (filters G11)
 ├── G8: (scan a@v,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1-3),constrained)
 │         └── cost: 5.07
 ├── G9: (filters G10)
 ├── G10: (eq G12 G13)
 ├── G11: (eq G14 G15)
 ├── G12: (variable u)
 ├── G13: (const 1)
 ├── G14: (variable v)
 └── G15: (const 5)

# Only not-null constraint is pushed down.
opt
SELECT k FROM a WHERE u=v
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)-->(1), (2)==(3), (3)==(2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── constraint: /2/1: (/NULL - ]
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (3)~~>(1,2)
      └── filters
           └── u:2 = v:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]

# Don't push constraint into already limited scan.
opt
SELECT k FROM (SELECT k FROM a ORDER BY u LIMIT 1) a WHERE k = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1,2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2
      │    ├── limit: 1
      │    ├── key: ()
      │    └── fd: ()-->(1,2)
      └── filters
           └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]

# Constraint + index-join, with no remainder filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── cardinality: [0 - 10]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
memo (optimized, ~6KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (index-join G4 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G4 b,cols=(1-4))
 │         └── cost: 75.12
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1084.02
 ├── G3: (filters G5)
 ├── G4: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G5: (range G6)
 ├── G6: (and G7 G8)
 ├── G7: (ge G9 G10)
 ├── G8: (le G9 G11)
 ├── G9: (variable v)
 ├── G10: (const 1)
 └── G11: (const 10)

# Don't choose lookup join if it's not beneficial.
opt
SELECT * FROM b WHERE v > 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── v:3 > 1 [outer=(3), constraints=(/3: [/2 - ]; tight)]

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── select
      ├── columns: k:1!null v:3!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(3), (3)-->(1)
      ├── scan b@v
      │    ├── columns: k:1!null v:3!null
      │    ├── constraint: /3: [/1 - /10]
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    └── fd: (1)-->(3), (3)-->(1)
      └── filters
           └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
memo (optimized, ~8KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G6 b,cols=(1-4))
 │         └── cost: 47.19
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1084.02
 ├── G3: (filters G7 G8)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 364.01
 ├── G5: (filters G7)
 ├── G6: (select G9 G10)
 │    └── []
 │         ├── best: (select G9 G10)
 │         └── cost: 14.53
 ├── G7: (range G11)
 ├── G8: (gt G12 G13)
 ├── G9: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G10: (filters G8)
 ├── G11: (and G14 G15)
 ├── G12: (variable k)
 ├── G13: (const 5)
 ├── G14: (ge G16 G17)
 ├── G15: (le G16 G18)
 ├── G16: (variable v)
 ├── G17: (const 1)
 └── G18: (const 10)

# Ensure the rule doesn't match at all when the first column of the index is
# not in the filter (i.e. the @v index is not matched by ConstrainScans).
exploretrace rule=GenerateConstrainedScans
SELECT k FROM a WHERE u = 1
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── select
        ├── columns: k:1!null u:2!null
        ├── key: (1)
        ├── fd: ()-->(2)
        ├── scan a
        │    ├── columns: k:1!null u:2
        │    ├── key: (1)
        │    └── fd: (1)-->(2)
        └── filters
             └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

New expression 1 of 1:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── scan a@u
        ├── columns: k:1!null u:2!null
        ├── constraint: /2/1: [/1 - /1]
        ├── key: (1)
        └── fd: ()-->(2)
----
----

# Constraint + index join + remaining filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G5)
 │         └── cost: 75.24
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1084.02
 ├── G3: (filters G6 G7)
 ├── G4: (index-join G8 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G8 b,cols=(1-4))
 │         └── cost: 75.12
 ├── G5: (filters G7)
 ├── G6: (range G9)
 ├── G7: (eq G10 G11)
 ├── G8: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G9: (and G12 G13)
 ├── G10: (plus G14 G15)
 ├── G11: (const 1)
 ├── G12: (ge G16 G11)
 ├── G13: (le G16 G17)
 ├── G14: (variable k)
 ├── G15: (variable u)
 ├── G16: (variable v)
 └── G17: (const 10)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── select
 │         ├── columns: k:1!null v:3!null
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(3), (3)-->(1)
 │         ├── scan b@v
 │         │    ├── columns: k:1!null v:3!null
 │         │    ├── constraint: /3: [/1 - /10]
 │         │    ├── cardinality: [0 - 10]
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3), (3)-->(1)
 │         └── filters
 │              └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
memo (optimized, ~9KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G6 G7)
 │         └── cost: 34.83
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1084.02
 ├── G3: (filters G8 G9 G10)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 364.01
 ├── G5: (filters G8 G9)
 ├── G6: (index-join G11 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G11 b,cols=(1-4))
 │         └── cost: 34.77
 ├── G7: (filters G9)
 ├── G8: (range G12)
 ├── G9: (eq G13 G14)
 ├── G10: (gt G15 G16)
 ├── G11: (select G17 G18)
 │    └── []
 │         ├── best: (select G17 G18)
 │         └── cost: 14.53
 ├── G12: (and G19 G20)
 ├── G13: (plus G15 G21)
 ├── G14: (const 1)
 ├── G15: (variable k)
 ├── G16: (const 5)
 ├── G17: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G18: (filters G10)
 ├── G19: (ge G22 G14)
 ├── G20: (le G22 G23)
 ├── G21: (variable u)
 ├── G22: (variable v)
 └── G23: (const 10)

# Constraint + index-join.
opt
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
select
 ├── columns: k:1!null u:2!null v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@u
 │         ├── columns: k:1!null u:2!null
 │         ├── constraint: /2/1: [/1/2 - /8/9]
 │         ├── key: (1)
 │         └── fd: (1)-->(2)
 └── filters
      ├── (u:2, k:1, v:3) > (1, 2, 3) [outer=(1-3), immutable, constraints=(/2/1/3: [/1/2/4 - ]; tight)]
      └── (u:2, k:1, v:3) < (8, 9, 10) [outer=(1-3), immutable, constraints=(/2/1/3: (/NULL - /8/9/9]; tight)]

memo
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G3)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G3)
 │         └── cost: 573.65
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1084.02
 ├── G3: (filters G5 G6)
 ├── G4: (index-join G7 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G7 b,cols=(1-4))
 │         └── cost: 572.82
 ├── G5: (gt G8 G9)
 ├── G6: (lt G8 G10)
 ├── G7: (scan b@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan b@u,cols=(1,2),constrained)
 │         └── cost: 87.21
 ├── G8: (tuple G11)
 ├── G9: (tuple G12)
 ├── G10: (tuple G13)
 ├── G11: (scalar-list G14 G15 G16)
 ├── G12: (scalar-list G17 G18 G19)
 ├── G13: (scalar-list G20 G21 G22)
 ├── G14: (variable u)
 ├── G15: (variable k)
 ├── G16: (variable v)
 ├── G17: (const 1)
 ├── G18: (const 2)
 ├── G19: (const 3)
 ├── G20: (const 8)
 ├── G21: (const 9)
 └── G22: (const 10)

# GenerateConstrainedScans propagates row-level locking information.
opt
SELECT k FROM a WHERE k = 1 FOR UPDATE
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── locking: for-update
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 └── fd: ()-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 FOR UPDATE
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── locking: for-update
      ├── cardinality: [0 - 10]
      ├── volatile
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 FOR UPDATE
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── locking: for-update
 │         ├── cardinality: [0 - 10]
 │         ├── volatile
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

exec-ddl
CREATE TABLE kifs
(
    k INT PRIMARY KEY,
    i INT,
    f FLOAT,
    s STRING,
    j JSON,
    INDEX s_idx (s) STORING (i, f),
    INDEX si_idx (s DESC, i DESC) STORING (j)
)
----

# Constrain the kifs@si_idx so that an index join is generated.
exploretrace rule=GenerateConstrainedScans
SELECT s, i, f FROM kifs WHERE s='foo' ORDER BY s, k, i
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  select
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   ├── ordering: +1 opt(4) [actual: +1]
   ├── scan kifs@s_idx
   │    ├── columns: k:1!null i:2 f:3 s:4
   │    ├── key: (1)
   │    ├── fd: (1)-->(2-4)
   │    └── ordering: +1 opt(4) [actual: +4,+1]
   └── filters
        └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

New expression 1 of 2:
  scan kifs@s_idx
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── constraint: /4/1: [/'foo' - /'foo']
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   └── ordering: +1 opt(4) [actual: +1]

New expression 2 of 2:
  sort
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   ├── ordering: +1 opt(4) [actual: +1]
   └── index-join kifs
        ├── columns: k:1!null i:2 f:3 s:4!null
        ├── key: (1)
        ├── fd: ()-->(4), (1)-->(2,3)
        └── scan kifs@si_idx
             ├── columns: k:1!null i:2 s:4!null
             ├── constraint: /-4/-2/1: [/'foo' - /'foo']
             ├── key: (1)
             └── fd: ()-->(4), (1)-->(2)
----
----

memo
SELECT s, i, f FROM kifs WHERE s='foo' ORDER BY s DESC, i
----
memo (optimized, ~6KB, required=[presentation: s:4,i:2,f:3] [ordering: +2 opt(4)])
 ├── G1: (select G2 G3) (scan kifs@s_idx,cols=(2-4),constrained) (index-join G4 kifs,cols=(2-4))
 │    ├── [presentation: s:4,i:2,f:3] [ordering: +2 opt(4)]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 15.58
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(2-4),constrained)
 │         └── cost: 14.71
 ├── G2: (scan kifs,cols=(2-4)) (scan kifs@s_idx,cols=(2-4))
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.35
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(2-4))
 │         └── cost: 1074.02
 ├── G3: (filters G5)
 ├── G4: (scan kifs@si_idx,cols=(1,2,4),constrained)
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (scan kifs@si_idx,rev,cols=(1,2,4),constrained)
 │    │    └── cost: 15.04
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(1,2,4),constrained)
 │         └── cost: 14.71
 ├── G5: (eq G6 G7)
 ├── G6: (variable s)
 └── G7: (const 'foo')

memo
SELECT j FROM kifs WHERE s = 'foo'
----
memo (optimized, ~7KB, required=[presentation: j:5])
 ├── G1: (project G2 G3 j)
 │    └── [presentation: j:5]
 │         ├── best: (project G2 G3 j)
 │         └── cost: 14.72
 ├── G2: (select G4 G5) (index-join G6 kifs,cols=(4,5)) (scan kifs@si_idx,cols=(4,5),constrained)
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(4,5),constrained)
 │         └── cost: 14.61
 ├── G3: (projections)
 ├── G4: (scan kifs,cols=(4,5)) (scan kifs@si_idx,cols=(4,5))
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(4,5))
 │         └── cost: 1064.02
 ├── G5: (filters G7)
 ├── G6: (scan kifs@s_idx,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,4),constrained)
 │         └── cost: 14.61
 ├── G7: (eq G8 G9)
 ├── G8: (variable s)
 └── G9: (const 'foo')

memo
SELECT i, k FROM kifs WHERE s >= 'foo'
----
memo (optimized, ~6KB, required=[presentation: i:2,k:1])
 ├── G1: (project G2 G3 k i)
 │    └── [presentation: i:2,k:1]
 │         ├── best: (project G2 G3 k i)
 │         └── cost: 364.02
 ├── G2: (select G4 G5) (scan kifs@s_idx,cols=(1,2,4),constrained) (scan kifs@si_idx,cols=(1,2,4),constrained)
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,2,4),constrained)
 │         └── cost: 360.68
 ├── G3: (projections)
 ├── G4: (scan kifs,cols=(1,2,4)) (scan kifs@s_idx,cols=(1,2,4)) (scan kifs@si_idx,cols=(1,2,4))
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,2,4))
 │         └── cost: 1074.02
 ├── G5: (filters G6)
 ├── G6: (ge G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'foo')

# Collated strings are treated properly.
exec-ddl
CREATE TABLE x (s STRING COLLATE en_u_ks_level1 PRIMARY KEY)
----

opt
SELECT s FROM x WHERE s < 'hello' COLLATE en_u_ks_level1
----
scan x
 ├── columns: s:1!null
 ├── constraint: /1: [ - /'hello' COLLATE en_u_ks_level1)
 └── key: (1)

opt
SELECT s FROM x WHERE s = 'hello' COLLATE en_u_ks_level1
----
scan x
 ├── columns: s:1!null
 ├── constraint: /1: [/'hello' COLLATE en_u_ks_level1 - /'hello' COLLATE en_u_ks_level1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

# Can't generate spans for other collations.
opt
SELECT s FROM x WHERE s COLLATE en = 'hello' COLLATE en
----
select
 ├── columns: s:1!null
 ├── key: (1)
 ├── scan x
 │    ├── columns: s:1!null
 │    └── key: (1)
 └── filters
      └── s:1 COLLATE en = 'hello' COLLATE en [outer=(1)]

# Realistic example where using constraints as filters help.
# An even more realistic example would have a creation timestamp instead of a
# seq_num integer, but that makes the plans much more cluttered.
exec-ddl
CREATE TABLE "orders" (
  region STRING NOT NULL,
  id INT NOT NULL,
  total DECIMAL NOT NULL,
  seq_num INT NOT NULL,
  PRIMARY KEY (region, id),
  UNIQUE INDEX orders_by_seq_num (region, seq_num, id) STORING (total),
  CHECK (region IN ('us-east1', 'us-west1', 'europe-west2'))
)
----

exec-ddl
ALTER TABLE "orders" INJECT STATISTICS '[
  {
    "columns": ["region"],
    "distinct_count": 3,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["id"],
    "distinct_count": 100,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["total"],
    "distinct_count": 100,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["seq_num"],
    "distinct_count": 50,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  }
]'
----

opt
SELECT sum(total) FROM orders WHERE seq_num >= 10 AND seq_num < 20
----
scalar-group-by
 ├── columns: sum:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan orders@orders_by_seq_num
 │    ├── columns: total:3!null seq_num:4!null
 │    └── constraint: /1/4/2
 │         ├── [/'europe-west2'/10 - /'europe-west2'/19]
 │         ├── [/'us-east1'/10 - /'us-east1'/19]
 │         └── [/'us-west1'/10 - /'us-west1'/19]
 └── aggregations
      └── sum [as=sum:6, outer=(3)]
           └── total:3

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT NOT NULL,
  z STRING NOT NULL,
  CHECK (x < 10 AND x > 1),
  CHECK (y < 10 AND y > 1),
  CHECK (z in ('first', 'second')),
  INDEX secondary (y, x),
  INDEX tertiary (z, y, x))
----

opt
SELECT x, y  FROM xyz WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan xyz@tertiary
 │    ├── columns: x:1!null y:2!null
 │    ├── constraint: /3/2/1
 │    │    ├── [/'first'/2/6 - /'first'/9/9]
 │    │    └── [/'second'/2/6 - /'second'/9/9]
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# TODO(ridwanmsharif): Confirm if this makes sense. I would've expected that the primary index
#  would be used here. But it isn't the plan being picked. Curious.
opt
SELECT * FROM xyz WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null z:3!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── scan xyz@tertiary
 │    ├── columns: x:1!null y:2!null z:3!null
 │    ├── constraint: /3/2/1
 │    │    ├── [/'first'/2/6 - /'first'/9/9]
 │    │    └── [/'second'/2/6 - /'second'/9/9]
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3)
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# Check constraint used only for the non nullable column. Constraints on x are ignored.
exec-ddl
CREATE TABLE xy (
  x INT,
  y INT NOT NULL,
  CHECK (x < 10 AND x > 1),
  CHECK (y < 10 AND y > 1),
  INDEX secondary (y, x))
----

opt
SELECT x, y FROM xy WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null
 ├── scan xy@secondary
 │    ├── columns: x:1 y:2!null
 │    └── constraint: /2/1/3: [/2/6 - /9]
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# Check constraints that can evaluate to NULL are ignored.
exec-ddl
CREATE TABLE null_constraint (
  y INT NOT NULL,
  CHECK (y IN (1, 2, NULL)),
  INDEX index_1 (y))
----

opt
SELECT y FROM null_constraint WHERE y > 0
----
scan null_constraint@index_1
 ├── columns: y:1!null
 └── constraint: /1/2: [/1 - ]

exec-ddl
CREATE TABLE null_constraint_2 (
  y INT NOT NULL,
  CHECK ((y IN (1, 2, NULL)) AND (y > 10)),
  CHECK (y < 15),
  INDEX index_1 (y))
----

opt
SELECT y FROM null_constraint_2 WHERE y > 0
----
scan null_constraint_2@index_1
 ├── columns: y:1!null
 └── constraint: /1/2: [/1 - /14]

# Unvalidated constraints are ignored.
exec-ddl
CREATE TABLE check_constraint_validity (
 a int NOT NULL,
 INDEX secondary (a),
 CONSTRAINT "check:unvalidated" CHECK (a < 10),
 CONSTRAINT "check:validated" CHECK (a < 20))
----

opt
SELECT * FROM check_constraint_validity WHERE a > 6
----
scan check_constraint_validity@secondary
 ├── columns: a:1!null
 └── constraint: /1/2: [/7 - /19]

# Test that we can constrain indexes using the results of now().
exec-ddl
CREATE TABLE with_time_index (k INT PRIMARY KEY, time TIMESTAMP, INDEX(time))
----

opt
SELECT * FROM with_time_index WHERE time > now() - INTERVAL '1 hour'
----
scan with_time_index@secondary
 ├── columns: k:1!null time:2!null
 ├── constraint: /2/1: [/'2017-05-10 12:00:00.000001' - ]
 ├── key: (1)
 └── fd: (1)-->(2)

opt
SELECT * FROM with_time_index WHERE time >= 'today'
----
scan with_time_index@secondary
 ├── columns: k:1!null time:2!null
 ├── constraint: /2/1: [/'2017-05-10 00:00:00' - ]
 ├── key: (1)
 └── fd: (1)-->(2)

# Constrained partial index scan.

exec-ddl
CREATE INDEX idx ON p (i) STORING (f, s) WHERE s = 'foo'
----

opt
SELECT i FROM p WHERE s = 'foo' AND i > 5 AND i < 10
----
project
 ├── columns: i:1!null
 └── scan p@idx,partial
      ├── columns: i:1!null s:3!null
      ├── constraint: /1/5: [/6 - /9]
      └── fd: ()-->(3)

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with indexed column in predicate.

exec-ddl
CREATE INDEX idx ON p (i) WHERE i > 0
----

opt
SELECT i FROM p WHERE i > 10 AND i < 20
----
scan p@idx,partial
 ├── columns: i:1!null
 └── constraint: /1/5: [/11 - /19]

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with index-join.

exec-ddl
CREATE INDEX idx ON p (i) WHERE s = 'foo'
----

opt
SELECT * FROM p WHERE s = 'foo' AND i > 5 AND i < 10
----
index-join p
 ├── columns: i:1!null f:2 s:3!null b:4
 ├── fd: ()-->(3)
 └── scan p@idx,partial
      ├── columns: i:1!null rowid:5!null
      ├── constraint: /1/5: [/6 - /9]
      ├── key: (5)
      └── fd: (5)-->(1)

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with additional filter.

exec-ddl
CREATE INDEX idx ON p (i) WHERE i > 0
----

opt
SELECT i FROM p WHERE i > 10 AND i < 20 AND b
----
project
 ├── columns: i:1!null
 └── select
      ├── columns: i:1!null b:4!null
      ├── fd: ()-->(4)
      ├── index-join p
      │    ├── columns: i:1 b:4
      │    └── scan p@idx,partial
      │         ├── columns: i:1!null rowid:5!null
      │         ├── constraint: /1/5: [/11 - /19]
      │         ├── key: (5)
      │         └── fd: (5)-->(1)
      └── filters
           └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with additional filters before and after an
# index-join.

exec-ddl
CREATE INDEX idx ON p (i) STORING (s) where i > 0
----

opt
SELECT * FROM p WHERE i > 10 AND i < 20 AND s = 'bar' AND b
----
select
 ├── columns: i:1!null f:2 s:3!null b:4!null
 ├── fd: ()-->(3,4)
 ├── index-join p
 │    ├── columns: i:1 f:2 s:3 b:4
 │    ├── fd: ()-->(3)
 │    └── select
 │         ├── columns: i:1!null s:3!null rowid:5!null
 │         ├── key: (5)
 │         ├── fd: ()-->(3), (5)-->(1)
 │         ├── scan p@idx,partial
 │         │    ├── columns: i:1!null s:3 rowid:5!null
 │         │    ├── constraint: /1/5: [/11 - /19]
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(1,3)
 │         └── filters
 │              └── s:3 = 'bar' [outer=(3), constraints=(/3: [/'bar' - /'bar']; tight), fd=()-->(3)]
 └── filters
      └── b:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]

exec-ddl
DROP INDEX idx
----

# Generate multiple partial index scans in the memo when the filter implies
# multiple partial index predicates.

exec-ddl
CREATE INDEX idx ON p (s) WHERE i > 0
----

exec-ddl
CREATE INDEX idx2 ON p (i) WHERE s = 'foo'
----

memo
SELECT i FROM p WHERE i = 3 AND s = 'foo'
----
memo (optimized, ~17KB, required=[presentation: i:1])
 ├── G1: (project G2 G3 i) (project G4 G3 i) (project G5 G3 i)
 │    └── [presentation: i:1]
 │         ├── best: (project G5 G3 i)
 │         └── cost: 14.33
 ├── G2: (select G6 G7) (select G8 G9) (index-join G4 p,cols=(1,3)) (select G10 G9) (index-join G5 p,cols=(1,3))
 │    └── []
 │         ├── best: (index-join G4 p,cols=(1,3))
 │         └── cost: 21.05
 ├── G3: (projections)
 ├── G4: (select G11 G9)
 │    └── []
 │         ├── best: (select G11 G9)
 │         └── cost: 14.53
 ├── G5: (scan p@idx2,partial,cols=(1,5),constrained)
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(1,5),constrained)
 │         └── cost: 14.31
 ├── G6: (scan p,cols=(1,3))
 │    └── []
 │         ├── best: (scan p,cols=(1,3))
 │         └── cost: 1074.02
 ├── G7: (filters G12 G13)
 ├── G8: (index-join G14 p,cols=(1,3))
 │    └── []
 │         ├── best: (index-join G14 p,cols=(1,3))
 │         └── cost: 374.63
 ├── G9: (filters G12)
 ├── G10: (index-join G15 p,cols=(1,3))
 │    └── []
 │         ├── best: (index-join G15 p,cols=(1,3))
 │         └── cost: 70.38
 ├── G11: (scan p@idx2,partial,cols=(1,5))
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(1,5))
 │         └── cost: 14.41
 ├── G12: (eq G16 G17)
 ├── G13: (eq G18 G19)
 ├── G14: (select G20 G21)
 │    └── []
 │         ├── best: (select G20 G21)
 │         └── cost: 354.03
 ├── G15: (scan p@idx,partial,cols=(3,5),constrained)
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(3,5),constrained)
 │         └── cost: 13.72
 ├── G16: (variable i)
 ├── G17: (const 3)
 ├── G18: (variable s)
 ├── G19: (const 'foo')
 ├── G20: (scan p@idx,partial,cols=(3,5))
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(3,5))
 │         └── cost: 350.68
 └── G21: (filters G13)

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

# Do not use partial indexes when the predicate is not implied by the filter.

exec-ddl
CREATE INDEX idx ON p (i) WHERE s = 'foo'
----

memo expect-not=GenerateConstrainedScans
SELECT i FROM p WHERE s = 'bar' AND i = 5
----
memo (optimized, ~7KB, required=[presentation: i:1])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:1]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 1084.07
 ├── G2: (select G4 G5)
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1084.05
 ├── G3: (projections)
 ├── G4: (scan p,cols=(1,3))
 │    └── []
 │         ├── best: (scan p,cols=(1,3))
 │         └── cost: 1074.02
 ├── G5: (filters G6 G7)
 ├── G6: (eq G8 G9)
 ├── G7: (eq G10 G11)
 ├── G8: (variable s)
 ├── G9: (const 'bar')
 ├── G10: (variable i)
 └── G11: (const 5)

exec-ddl
DROP INDEX idx
----

# Regression test for #55387. GenerateConstrainedScans should not reduce the
# input filters when proving partial index implication.

exec-ddl
CREATE TABLE t55387 (
    k INT PRIMARY KEY,
    a INT,
    b INT,
    INDEX (a) WHERE a > 1,
    INDEX (b) WHERE b > 2
)
----

opt
SELECT k FROM t55387 WHERE a > 1 AND b > 3
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2!null b:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── index-join t55387
      │    ├── columns: k:1!null a:2 b:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,3)
      │    └── select
      │         ├── columns: k:1!null b:3!null
      │         ├── key: (1)
      │         ├── fd: (1)-->(3)
      │         ├── scan t55387@secondary,partial
      │         │    ├── columns: k:1!null b:3!null
      │         │    ├── key: (1)
      │         │    └── fd: (1)-->(3)
      │         └── filters
      │              └── b:3 > 3 [outer=(3), constraints=(/3: [/4 - ]; tight)]
      └── filters
           └── a:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]

# Check that we can generate constraints by recognizing computed column
# expressions.
opt
SELECT k FROM computed WHERE lower(s) = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@l_idx
      ├── columns: k:1!null
      ├── constraint: /3/1: [/'foo' - /'foo']
      └── key: (1)

opt
SELECT k FROM computed WHERE (j->'foo')::string LIKE 'bar%'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@fieldstr_idx
      ├── columns: k:1!null
      ├── constraint: /6/1: [/'bar' - /'bas')
      └── key: (1)

# --------------------------------------------------
# GenerateInvertedIndexScans
# --------------------------------------------------

# Query only the primary key with no remaining filter.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

memo
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
memo (optimized, ~7KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k) (project G4 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G4 G3 k)
 │         └── cost: 118.42
 ├── G2: (select G5 G6) (index-join G4 b,cols=(1,4))
 │    └── []
 │         ├── best: (index-join G4 b,cols=(1,4))
 │         └── cost: 783.92
 ├── G3: (projections)
 ├── G4: (scan b@inv_idx,cols=(1),constrained)
 │    └── []
 │         ├── best: (scan b@inv_idx,cols=(1),constrained)
 │         └── cost: 117.31
 ├── G5: (scan b,cols=(1,4))
 │    └── []
 │         ├── best: (scan b,cols=(1,4))
 │         └── cost: 1064.02
 ├── G6: (filters G7)
 ├── G7: (contains G8 G9)
 ├── G8: (variable j)
 └── G9: (const '{"a": "b"}')

# Query requiring an index join with no remaining filter.
opt
SELECT u, k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: u:2 k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── index-join b
      ├── columns: k:1!null u:2 j:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      └── scan b@inv_idx
           ├── columns: k:1!null
           ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
           └── key: (1)

opt
SELECT j, k FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: j:4!null k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '{}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '[]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[]' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '2'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1
      │    ├── [/'2' - /'2']
      │    └── [/'[2]' - /'[2]']
      └── key: (1)

opt
SELECT * FROM b WHERE j @> '[{}]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '[{}]' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '{"a": {}}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": {}}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '{"a": []}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── j:4 @> '{"a": []}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '{"a":[[{"b":{"c":[{"d":"e"}]}}]]}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": [[{"b": {"c": [{"d": "e"}]}}]]}' - /'{"a": [[{"b": {"c": [{"d": "e"}]}}]]}']
      └── key: (1)

# GenerateInvertedIndexScans propagates row-level locking information.
opt
SELECT k FROM b WHERE j @> '{"a": "b"}' FOR UPDATE
----
project
 ├── columns: k:1!null
 ├── volatile
 ├── key: (1)
 └── scan b@inv_idx
      ├── columns: k:1!null
      ├── constraint: /4/1: [/'{"a": "b"}' - /'{"a": "b"}']
      ├── locking: for-update
      ├── volatile
      └── key: (1)

# Tests for array inverted indexes.
opt
SELECT k FROM c WHERE a @> ARRAY[1]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan c@inv_idx
      ├── columns: k:1!null
      ├── constraint: /2/1: [/ARRAY[1] - /ARRAY[1]]
      └── key: (1)

opt
SELECT k FROM c WHERE a @> ARRAY[]::INT[]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 @> ARRAY[] [outer=(2), immutable, constraints=(/2: (/NULL - ])]

opt
SELECT k FROM c WHERE a IS NULL
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

# Tests for geospatial constrained scans.
opt
SELECT k FROM g WHERE ST_Intersects('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Same test as above, but with commuted arguments.
opt
SELECT k FROM g WHERE ST_Intersects(geog, 'SRID=4326;POINT(-43.23456 72.4567772)'::geography)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_intersects(geog:4, '0101000020E61000009279E40F069E45C0BEE36FD63B1D5240') [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Same test as above, but with commuted arguments.
opt
SELECT k FROM g WHERE ST_CoveredBy(geom, 'POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_covers('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_coveredby(geom:3, '0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000') [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_DWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_DFullyWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dfullywithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_dfullywithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000, false)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0, false)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0, false) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Test for ST_DWithinExclusive
opt
SELECT k FROM g WHERE ST_DWithinExclusive('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_dwithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Commuted version of previous test.
opt
SELECT k FROM g WHERE ST_DWithinExclusive(geom, 'POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_dwithinexclusive(geom:3, '0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt
SELECT k FROM g WHERE ST_DFullyWithinExclusive('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dfullywithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── st_dfullywithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Multiple geospatial functions.
# NB: the union spans for the following query are a subset of the spans. This is a
# consequence of how intersectSpanExpression does simplification.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdO\x00\x00\x00\x00\x00\x00\x00", "B\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_CoveredBy('SRID=4326;LINESTRING(-118.4079 33.9434, 2.5559 49.0083)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-44.23836 60.4567772)'::geography, geog))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    ├── union spans
      │         │    │    ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │    │    ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │    │    └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false
      │         │         │    ├── union spans: empty
      │         │         │    └── INTERSECTION
      │         │         │         ├── span expression
      │         │         │         │    ├── tight: false
      │         │         │         │    └── union spans
      │         │         │         │         ├── ["B\xfd\x81\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x81\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         ├── ["B\xfd\x84\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x84\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         └── ["B\xfd\x90\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x90\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         └── span expression
      │         │         │              ├── tight: false
      │         │         │              └── union spans
      │         │         │                   ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   ├── ["B\xfdG\x00\x00\x00\x00\x00\x00\x00", "B\xfdG\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── span expression
      │         │              ├── tight: false
      │         │              └── union spans
      │         │                   ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   ├── ["B\xfdO\x00\x00\x00\x00\x00\x00\x00", "B\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdG\x00\x00\x00\x00\x00\x00\x00", "B\xfdG\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              │         ├── ["B\xfd\x81\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x81\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x84\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x84\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x90\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x90\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_coveredby('0102000020E61000000200000075029A081B9A5DC0F085C954C1F840406DC5FEB27B720440454772F90F814840', geog:4) AND st_coveredby('0101000020E610000058569A94821E46C07BC7DFAC773A4E40', geog:4)) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Multiple geospatial functions on different indexes.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_Overlaps('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_overlaps('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── st_overlaps('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Cannot use either index in this case.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_Touches('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── scan g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    └── fd: (1)-->(3,4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_touches('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3,4), immutable]

opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_Intersects('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
AND ST_Crosses('LINESTRING ( 0 0, 0 2 )'::geometry, geom))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_intersects('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) AND st_crosses('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3)) [outer=(3,4), immutable, constraints=(/4: (/NULL - ])]

# Filters on other columns.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND v = 3 AND k > 100
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null v:2!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null v:2 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── select
      │              ├── columns: k:1!null geog_inverted_key:7!null
      │              ├── key: (1)
      │              ├── fd: (1)-->(7)
      │              ├── scan g@geog_idx
      │              │    ├── columns: k:1!null geog_inverted_key:7!null
      │              │    ├── inverted constraint: /7/1
      │              │    │    └── spans
      │              │    │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │    │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │    │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │    ├── key: (1)
      │              │    └── fd: (1)-->(7)
      │              └── filters
      │                   └── k:1 > 100 [outer=(1), constraints=(/1: [/101 - ]; tight)]
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── v:2 = 3 [outer=(2), constraints=(/2: [/3 - /3]; tight), fd=()-->(2)]

# Bounding box operations.
opt
SELECT k FROM g WHERE 'BOX(1 2, 3 4)'::box2d ~ geom
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x18\x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_covers('01030000000100000005000000000000000000F03F0000000000000040000000000000F03F00000000000010400000000000000840000000000000104000000000000008400000000000000040000000000000F03F0000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x18\x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── 'BOX(1 2,3 4)' ~ geom:3 [outer=(3), immutable]

opt
SELECT k FROM g WHERE geom ~ 'BOX(1 2, 3 4)'::box2d
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('01030000000100000005000000000000000000F03F0000000000000040000000000000F03F00000000000010400000000000000840000000000000104000000000000008400000000000000040000000000000F03F0000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── geom:3 ~ 'BOX(1 2,3 4)' [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt
SELECT k FROM g WHERE geom ~ 'MULTIPOINT((2.2 2.2), (3.0 3.0))'::geometry
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /6
      │         │    ├── tight: false
      │         │    ├── union spans
      │         │    │    ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │    │    └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false
      │         │         │    └── union spans: ["B\xfd\x15\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x15\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── span expression
      │         │              ├── tight: false
      │         │              └── union spans: ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('01040000000200000001010000009A999999999901409A99999999990140010100000000000000000008400000000000000840', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:6!null
      │              ├── inverted constraint: /6/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x15\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x15\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(6)
      └── filters
           └── geom:3 ~ '01040000000200000001010000009A999999999901409A99999999990140010100000000000000000008400000000000000840' [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Tests for partial inverted indexes.

exec-ddl
CREATE TABLE pi (
    k INT PRIMARY KEY,
    s STRING,
    j JSON
)
----

# Partial inverted index scan.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s = 'foo'
----

opt
SELECT k FROM pi WHERE j @> '{"a": "b"}' AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── constraint: /3/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with indexed column in predicate.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE j @> '{"group": 1}'
----

opt
SELECT k FROM pi WHERE j @> '{"a": "b"}' AND j @> '{"group": 1}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── constraint: /3/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with index-join.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s = 'foo'
----

opt
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'foo'
----
index-join pi
 ├── columns: k:1!null s:2!null j:3!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── constraint: /3/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with additional filters.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

opt
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND j @> '{"group": 1}' AND s = 'foo'
----
select
 ├── columns: k:1!null s:2!null j:3!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3)
 ├── index-join pi
 │    ├── columns: k:1!null s:2 j:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── scan pi@idx,partial
 │         ├── columns: k:1!null
 │         ├── constraint: /3/1: [/'{"a": "b"}' - /'{"a": "b"}']
 │         └── key: (1)
 └── filters
      ├── j:3 @> '{"group": 1}' [outer=(3), immutable, constraints=(/3: (/NULL - ])]
      └── s:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]

exec-ddl
DROP INDEX idx
----

# Generate multiple partial inverted index scans in the memo when the filter
# implies multiple partial index predicates.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

exec-ddl
CREATE INVERTED INDEX idx2 ON pi (j) WHERE s = 'bar'
----

memo
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'bar'
----
memo (optimized, ~10KB, required=[presentation: k:1,s:2,j:3])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 pi,cols=(1-3))
 │    └── [presentation: k:1,s:2,j:3]
 │         ├── best: (index-join G6 pi,cols=(1-3))
 │         └── cost: 11.82
 ├── G2: (scan pi,cols=(1-3))
 │    └── []
 │         ├── best: (scan pi,cols=(1-3))
 │         └── cost: 1064.02
 ├── G3: (filters G7 G8)
 ├── G4: (index-join G9 pi,cols=(1-3))
 │    └── []
 │         ├── best: (index-join G9 pi,cols=(1-3))
 │         └── cost: 19.62
 ├── G5: (filters G8)
 ├── G6: (scan pi@idx2,partial,cols=(1),constrained)
 │    └── []
 │         ├── best: (scan pi@idx2,partial,cols=(1),constrained)
 │         └── cost: 5.14
 ├── G7: (contains G10 G11)
 ├── G8: (eq G12 G13)
 ├── G9: (scan pi@idx,partial,cols=(1),constrained)
 │    └── []
 │         ├── best: (scan pi@idx,partial,cols=(1),constrained)
 │         └── cost: 6.28
 ├── G10: (variable j)
 ├── G11: (const '{"a": "b"}')
 ├── G12: (variable s)
 └── G13: (const 'bar')

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

# Do not generate a partial inverted index scan when the predicate is not
# implied by the filter.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

memo expect-not=GenerateInvertedIndexScans
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'baz'
----
memo (optimized, ~6KB, required=[presentation: k:1,s:2,j:3])
 ├── G1: (select G2 G3)
 │    └── [presentation: k:1,s:2,j:3]
 │         ├── best: (select G2 G3)
 │         └── cost: 1074.05
 ├── G2: (scan pi,cols=(1-3))
 │    └── []
 │         ├── best: (scan pi,cols=(1-3))
 │         └── cost: 1064.02
 ├── G3: (filters G4 G5)
 ├── G4: (contains G6 G7)
 ├── G5: (eq G8 G9)
 ├── G6: (variable j)
 ├── G7: (const '{"a": "b"}')
 ├── G8: (variable s)
 └── G9: (const 'baz')

exec-ddl
DROP INDEX idx
----

# Check that we can generate constraints by recognizing computed column
# expressions.
opt
SELECT k FROM computed WHERE (j->'foo') @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@field_inv_idx
      ├── columns: k:1!null
      ├── constraint: /5/1: [/'{"a": "b"}' - /'{"a": "b"}']
      └── key: (1)

# Tests for multi-column inverted indexes.

exec-ddl
CREATE TABLE m (
  k INT PRIMARY KEY,
  a STRING,
  b STRING,
  geom GEOMETRY,
  INVERTED INDEX multicol (a, geom)
)
----

# Constrain a single prefix column to one value.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3,4)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /6
 │         │    ├── tight: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:6!null
 │              ├── constraint: /2: [/'foo' - /'foo']
 │              ├── inverted constraint: /6/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(6)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Constrain a single prefix column to multiple point values.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a IN ('foo', 'bar') AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /6
 │         │    ├── tight: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:6!null
 │              ├── constraint: /2
 │              │    ├── [/'bar' - /'bar']
 │              │    └── [/'foo' - /'foo']
 │              ├── inverted constraint: /6/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(6)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Do not generate an inverted index scan when a single prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a > 'x' AND a < 'y' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters
      ├── (a:2 > 'x') AND (a:2 < 'y') [outer=(2), constraints=(/2: [/e'x\x00' - /'y'); tight)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

exec-ddl
DROP INDEX multicol
----

exec-ddl
CREATE INVERTED INDEX multicol ON m (a, b, geom)
----

# Constrain multiple prefix columns to one value.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND b = 'bar' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2,3), (1)-->(4)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:7!null
 │              ├── constraint: /2/3: [/'foo'/'bar' - /'foo'/'bar']
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Constrain multiple prefix columns to multiple point values.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a IN ('foo', 'bar') AND b IN ('baz', 'bob') AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:7!null
 │              ├── constraint: /2/3
 │              │    ├── [/'bar'/'baz' - /'bar'/'baz']
 │              │    ├── [/'bar'/'bob' - /'bar'/'bob']
 │              │    ├── [/'foo'/'baz' - /'foo'/'baz']
 │              │    └── [/'foo'/'bob' - /'foo'/'bob']
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]


# Do not generate an inverted index scan when the first prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a > 'x' AND a < 'y' AND b = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(3), (1)-->(2,4)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters
      ├── (a:2 > 'x') AND (a:2 < 'y') [outer=(2), constraints=(/2: [/e'x\x00' - /'y'); tight)]
      ├── b:3 = 'foo' [outer=(3), constraints=(/3: [/'foo' - /'foo']; tight), fd=()-->(3)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Do not generate an inverted index scan when the second prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND b > 'x' AND b < 'y' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3,4)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters
      ├── (b:3 > 'x') AND (b:3 < 'y') [outer=(3), constraints=(/3: [/e'x\x00' - /'y'); tight)]
      ├── a:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Do not generate an inverted index scan when neither prefix column is constrained.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2 b:3 geom:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 geom:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# --------------------------------------------------
# GenerateZigzagJoins
# --------------------------------------------------

exec-ddl
CREATE TABLE pqr
(
    p INT PRIMARY KEY,
    q INT,
    r INT,
    s STRING,
    t STRING,
    INDEX q (q),
    INDEX r (r),
    INDEX s (s) STORING (r),
    INDEX rs (r,s),
    INDEX ts (t,s)
)
----

exec-ddl
CREATE TABLE zz (
    a INT8 PRIMARY KEY,
    b INT8 NULL,
    c INT8 NULL,
    INDEX idx_b (b ASC),
    CONSTRAINT idx_c UNIQUE (c)
)
----

exec-ddl
CREATE TABLE zz_redundant (
    a INT8 PRIMARY KEY,
    b INT8 NULL,
    c INT8 NULL,
    INDEX idx_u (b ASC, c ASC),
    INDEX idx_v (b ASC, c ASC)
)
----

# Simple zigzag case - where all requested columns are in the indexes being
# joined.
opt
SELECT q,r FROM pqr WHERE q = 1 AND r = 2
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [2]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

opt
SELECT q,r FROM pqr WHERE q = 1 AND r IS NULL
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [NULL]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── r:3 IS NULL [outer=(3), constraints=(/3: [/NULL - /NULL]; tight), fd=()-->(3)]

memo
SELECT q,r FROM pqr WHERE q = 1 AND r = 2
----
memo (optimized, ~13KB, required=[presentation: q:2,r:3])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G7) (zigzag-join G3 pqr@q pqr@r)
 │    └── [presentation: q:2,r:3]
 │         ├── best: (zigzag-join G3 pqr@q pqr@r)
 │         └── cost: 1.93
 ├── G2: (scan pqr,cols=(2,3))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,3))
 │         └── cost: 1074.02
 ├── G3: (filters G9 G10)
 ├── G4: (index-join G11 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,3))
 │         └── cost: 75.12
 ├── G5: (filters G10)
 ├── G6: (index-join G12 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G12 pqr,cols=(2,3))
 │         └── cost: 75.12
 ├── G7: (filters G9)
 ├── G8: (index-join G13 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(2,3))
 │         └── cost: 75.22
 ├── G9: (eq G14 G15)
 ├── G10: (eq G16 G17)
 ├── G11: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 14.41
 ├── G12: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G13: (scan pqr@rs,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3),constrained)
 │         └── cost: 14.51
 ├── G14: (variable q)
 ├── G15: (const 1)
 ├── G16: (variable r)
 └── G17: (const 2)

# Case where the fixed columns are extracted from a complicated expression.
opt
SELECT q,r FROM pqr WHERE q = 1 AND ((r < 1 AND r > 1) OR (r >= 2 AND r <= 2))
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [2]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── ((r:3 < 1) AND (r:3 > 1)) OR ((r:3 >= 2) AND (r:3 <= 2)) [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

# Nested zigzag case - zigzag join needs to be wrapped in a lookup join to
# satisfy required columns.
opt
SELECT q,r,s FROM pqr WHERE q = 1 AND r = 2
----
inner-join (lookup pqr)
 ├── columns: q:2!null r:3!null s:4
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── fd: ()-->(2,3)
 ├── inner-join (zigzag pqr@q pqr@r)
 │    ├── columns: p:1!null q:2!null r:3!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [2] = [1]
 │    ├── right fixed columns: [3] = [2]
 │    ├── fd: ()-->(2,3)
 │    └── filters
 │         ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 │         └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]
 └── filters (true)

memo
SELECT q,r,s FROM pqr WHERE q = 1 AND r = 2
----
memo (optimized, ~15KB, required=[presentation: q:2,r:3,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G7) (lookup-join G9 G10 pqr,keyCols=[1],outCols=(2-4))
 │    └── [presentation: q:2,r:3,s:4]
 │         ├── best: (lookup-join G9 G10 pqr,keyCols=[1],outCols=(2-4))
 │         └── cost: 7.48
 ├── G2: (scan pqr,cols=(2-4))
 │    └── []
 │         ├── best: (scan pqr,cols=(2-4))
 │         └── cost: 1084.02
 ├── G3: (filters G11 G12)
 ├── G4: (index-join G13 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(2-4))
 │         └── cost: 75.22
 ├── G5: (filters G12)
 ├── G6: (index-join G14 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G14 pqr,cols=(2-4))
 │         └── cost: 75.22
 ├── G7: (filters G11)
 ├── G8: (index-join G15 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G15 pqr,cols=(2-4))
 │         └── cost: 75.32
 ├── G9: (zigzag-join G3 pqr@q pqr@r)
 │    └── []
 │         ├── best: (zigzag-join G3 pqr@q pqr@r)
 │         └── cost: 1.94
 ├── G10: (filters)
 ├── G11: (eq G16 G17)
 ├── G12: (eq G18 G19)
 ├── G13: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 14.41
 ├── G14: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G15: (scan pqr@rs,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3,4),constrained)
 │         └── cost: 14.61
 ├── G16: (variable q)
 ├── G17: (const 1)
 ├── G18: (variable r)
 └── G19: (const 2)

# Zigzag with fixed columns of different types.
opt
SELECT q,s FROM pqr WHERE q = 1 AND s = 'foo'
----
inner-join (zigzag pqr@q pqr@s)
 ├── columns: q:2!null s:4!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [4] = ['foo']
 ├── fd: ()-->(2,4)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

memo
SELECT q,s FROM pqr WHERE q = 1 AND s = 'foo'
----
memo (optimized, ~11KB, required=[presentation: q:2,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (zigzag-join G3 pqr@q pqr@s)
 │    └── [presentation: q:2,s:4]
 │         ├── best: (zigzag-join G3 pqr@q pqr@s)
 │         └── cost: 1.94
 ├── G2: (scan pqr,cols=(2,4))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,4))
 │         └── cost: 1074.02
 ├── G3: (filters G8 G9)
 ├── G4: (index-join G10 pqr,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G10 pqr,cols=(2,4))
 │         └── cost: 75.12
 ├── G5: (filters G9)
 ├── G6: (index-join G11 pqr,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,4))
 │         └── cost: 75.22
 ├── G7: (filters G8)
 ├── G8: (eq G12 G13)
 ├── G9: (eq G14 G15)
 ├── G10: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 14.41
 ├── G11: (scan pqr@s,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@s,cols=(1,4),constrained)
 │         └── cost: 14.51
 ├── G12: (variable q)
 ├── G13: (const 1)
 ├── G14: (variable s)
 └── G15: (const 'foo')

# Zigzag with implicit equality column in addition to primary key:
# indexes on (r,s) and (t,s) should be chosen even though s is not being fixed
# in the ON clause.
opt
SELECT r,t FROM pqr WHERE r = 1 AND t = 'foo'
----
inner-join (zigzag pqr@rs pqr@ts)
 ├── columns: r:3!null t:5!null
 ├── eq columns: [4 1] = [4 1]
 ├── left fixed columns: [3] = [1]
 ├── right fixed columns: [5] = ['foo']
 ├── fd: ()-->(3,5)
 └── filters
      ├── r:3 = 1 [outer=(3), constraints=(/3: [/1 - /1]; tight), fd=()-->(3)]
      └── t:5 = 'foo' [outer=(5), constraints=(/5: [/'foo' - /'foo']; tight), fd=()-->(5)]

memo
SELECT r,t FROM pqr WHERE r = 1 AND t = 'foo'
----
memo (optimized, ~13KB, required=[presentation: r:3,t:5])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G5) (select G7 G8) (zigzag-join G3 pqr@rs pqr@ts)
 │    └── [presentation: r:3,t:5]
 │         ├── best: (zigzag-join G3 pqr@rs pqr@ts)
 │         └── cost: 1.95
 ├── G2: (scan pqr,cols=(3,5))
 │    └── []
 │         ├── best: (scan pqr,cols=(3,5))
 │         └── cost: 1074.02
 ├── G3: (filters G9 G10)
 ├── G4: (index-join G11 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(3,5))
 │         └── cost: 75.12
 ├── G5: (filters G10)
 ├── G6: (index-join G12 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G12 pqr,cols=(3,5))
 │         └── cost: 75.22
 ├── G7: (index-join G13 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(3,5))
 │         └── cost: 75.22
 ├── G8: (filters G9)
 ├── G9: (eq G14 G15)
 ├── G10: (eq G16 G17)
 ├── G11: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G12: (scan pqr@rs,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3),constrained)
 │         └── cost: 14.51
 ├── G13: (scan pqr@ts,cols=(1,5),constrained)
 │    └── []
 │         ├── best: (scan pqr@ts,cols=(1,5),constrained)
 │         └── cost: 14.51
 ├── G14: (variable r)
 ├── G15: (const 1)
 ├── G16: (variable t)
 └── G17: (const 'foo')

# Zigzag with choice between indexes for multiple equality predicates.
opt
SELECT p,q,r,s FROM pqr WHERE q = 1 AND r = 1 AND s = 'foo'
----
inner-join (zigzag pqr@q pqr@s)
 ├── columns: p:1!null q:2!null r:3!null s:4!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [4] = ['foo']
 ├── key: (1)
 ├── fd: ()-->(2-4)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      ├── r:3 = 1 [outer=(3), constraints=(/3: [/1 - /1]; tight), fd=()-->(3)]
      └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

# Tests for zigzag joins over partial indexes.

exec-ddl
CREATE TABLE zz_partial (
    k INT PRIMARY KEY,
    i INT,
    j INT,
    b1 BOOL,
    b2 BOOL,
    s STRING
)
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE b1
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE b2
----

# Generate a zigzag join over two partial indexes.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20 AND b2
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null b2:5!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-5)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j,partial)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag join when the first index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b2
----
project
 └── select
      ├── index-join zz_partial
      │    └── select
      │         ├── scan zz_partial@j,partial
      │         └── filters
      │              └── j = 20
      └── filters
           └── i = 10

# Don't generate a zigzag join when the second index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── select
      │         ├── scan zz_partial@i,partial
      │         └── filters
      │              └── i = 10
      └── filters
           └── j = 20

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# Generate a zigzag join over one partial and one non-partial index.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag join when the partial index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@j
      │         └── constraint: /3/1: [/20 - /20]
      └── filters
           └── i = 10

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE i = 10
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# Don't generate a zigzag join when the expression that fixes the left columns
# is removed during partial index implication of the left index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@i,partial
      └── filters
           └── j = 20

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i)
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE j = 20
----

# Don't generate a zigzag join when the expression that fixes the right columns
# is removed during partial index implication of the right index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@j,partial
      └── filters
           └── i = 10

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX zz_partial_s ON zz_partial (s)
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE s = 'foo'
----

# Don't generate a zigzag join when the expression that fixes the left columns
# is removed during partial index implication of the right index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE s = 'foo' AND j = 20
----
project
 └── scan zz_partial@j,partial
      └── constraint: /3/1: [/20 - /20]

exec-ddl
DROP INDEX zz_partial_s
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE s = 'foo'
----

exec-ddl
CREATE INDEX zz_partial_s ON zz_partial (s)
----

# Don't generate a zigzag join when the expression that fixes the right columns
# is removed during partial index implication of the left index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND s = 'foo'
----
project
 └── scan zz_partial@i,partial
      └── constraint: /2/1: [/10 - /10]

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX zz_partial_s
----

exec-ddl
CREATE INDEX i ON zz_partial (i)
----

exec-ddl
CREATE INDEX b1 ON zz_partial (b1) WHERE s = 'foo'
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# The filters should be reset during each iteration over the left and right
# indexes if they are reduced while proving partial index implication. In this
# test, (s = 'foo') must be applied after the zigzag join.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b1 AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null s:6!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4,6)
      ├── inner-join (zigzag zz_partial@i zz_partial@j)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters
           ├── b1:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]
           └── s:6 = 'foo' [outer=(6), constraints=(/6: [/'foo' - /'foo']; tight), fd=()-->(6)]

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX b1
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE b1
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE b1
----

# Generate a zigzag join on two partial indexes with the same predicate.
opt
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j,partial)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag which has the PK as its equality columns against
# nullable unique indexes where the primary key is not part of the indexed
# columns.

# Regression test for #36051: prior to fixing this, we would try to use the PK
# as the equality column here, but it's not actually part of the key so we
# can't zigzag on it.
opt expect-not=GenerateZigzagJoins
SELECT * FROM zz WHERE b IS NULL AND c = 2
----
select
 ├── columns: a:1!null b:2 c:3!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-3)
 ├── index-join zz
 │    ├── columns: a:1!null b:2 c:3
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-3)
 │    └── scan zz@idx_c
 │         ├── columns: a:1!null c:3!null
 │         ├── constraint: /3: [/2 - /2]
 │         ├── cardinality: [0 - 1]
 │         ├── key: ()
 │         └── fd: ()-->(1,3)
 └── filters
      └── b:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

memo
SELECT p,q,r,s FROM pqr WHERE q = 1 AND r = 1 AND s = 'foo'
----
memo (optimized, ~31KB, required=[presentation: p:1,q:2,r:3,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G9) (select G10 G9) (lookup-join G11 G12 pqr,keyCols=[1],outCols=(1-4)) (zigzag-join G3 pqr@q pqr@s) (zigzag-join G3 pqr@q pqr@rs) (lookup-join G13 G9 pqr,keyCols=[1],outCols=(1-4))
 │    └── [presentation: p:1,q:2,r:3,s:4]
 │         ├── best: (zigzag-join G3 pqr@q pqr@s)
 │         └── cost: 1.95
 ├── G2: (scan pqr,cols=(1-4))
 │    └── []
 │         ├── best: (scan pqr,cols=(1-4))
 │         └── cost: 1094.02
 ├── G3: (filters G14 G15 G16)
 ├── G4: (index-join G17 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G17 pqr,cols=(1-4))
 │         └── cost: 75.22
 ├── G5: (filters G15 G16)
 ├── G6: (index-join G18 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G18 pqr,cols=(1-4))
 │         └── cost: 75.22
 ├── G7: (filters G14 G16)
 ├── G8: (index-join G19 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G19 pqr,cols=(1-4))
 │         └── cost: 21.76
 ├── G9: (filters G14)
 ├── G10: (index-join G20 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G20 pqr,cols=(1-4))
 │         └── cost: 10.51
 ├── G11: (zigzag-join G21 pqr@q pqr@r)
 │    └── []
 │         ├── best: (zigzag-join G21 pqr@q pqr@r)
 │         └── cost: 1.94
 ├── G12: (filters G16)
 ├── G13: (zigzag-join G5 pqr@r pqr@s)
 │    └── []
 │         ├── best: (zigzag-join G5 pqr@r pqr@s)
 │         └── cost: 1.95
 ├── G14: (eq G22 G23)
 ├── G15: (eq G24 G23)
 ├── G16: (eq G25 G26)
 ├── G17: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 14.41
 ├── G18: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G19: (select G27 G28)
 │    └── []
 │         ├── best: (select G27 G28)
 │         └── cost: 14.73
 ├── G20: (scan pqr@rs,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3,4),constrained)
 │         └── cost: 4.98
 ├── G21: (filters G14 G15)
 ├── G22: (variable q)
 ├── G23: (const 1)
 ├── G24: (variable r)
 ├── G25: (variable s)
 ├── G26: (const 'foo')
 ├── G27: (scan pqr@s,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@s,cols=(1,3,4),constrained)
 │         └── cost: 14.61
 └── G28: (filters G15)

# Zigzag joins cannot be planned for indexes where equality columns do not
# immediately follow fixed columns. Here, the only index on t is (t,s,p) and
# s is not a fixed or equal column, so a zigzag join shouldn't be planned.
opt
SELECT q,t FROM pqr WHERE q = 1 AND t = 'foo'
----
select
 ├── columns: q:2!null t:5!null
 ├── fd: ()-->(2,5)
 ├── index-join pqr
 │    ├── columns: q:2 t:5
 │    ├── fd: ()-->(2)
 │    └── scan pqr@q
 │         ├── columns: p:1!null q:2!null
 │         ├── constraint: /2/1: [/1 - /1]
 │         ├── key: (1)
 │         └── fd: ()-->(2)
 └── filters
      └── t:5 = 'foo' [outer=(5), constraints=(/5: [/'foo' - /'foo']; tight), fd=()-->(5)]

memo
SELECT q,t FROM pqr WHERE q = 1 AND t = 'foo'
----
memo (optimized, ~9KB, required=[presentation: q:2,t:5])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: q:2,t:5]
 │         ├── best: (select G4 G5)
 │         └── cost: 75.24
 ├── G2: (scan pqr,cols=(2,5))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,5))
 │         └── cost: 1074.02
 ├── G3: (filters G8 G9)
 ├── G4: (index-join G10 pqr,cols=(2,5))
 │    └── []
 │         ├── best: (index-join G10 pqr,cols=(2,5))
 │         └── cost: 75.12
 ├── G5: (filters G9)
 ├── G6: (index-join G11 pqr,cols=(2,5))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,5))
 │         └── cost: 75.22
 ├── G7: (filters G8)
 ├── G8: (eq G12 G13)
 ├── G9: (eq G14 G15)
 ├── G10: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 14.41
 ├── G11: (scan pqr@ts,cols=(1,5),constrained)
 │    └── []
 │         ├── best: (scan pqr@ts,cols=(1,5),constrained)
 │         └── cost: 14.51
 ├── G12: (variable q)
 ├── G13: (const 1)
 ├── G14: (variable t)
 └── G15: (const 'foo')

# Don't zigzag on two identical indexes.
memo
SELECT c FROM zz_redundant WHERE b = 1
----
memo (optimized, ~6KB, required=[presentation: c:3])
 ├── G1: (project G2 G3 c)
 │    └── [presentation: c:3]
 │         ├── best: (project G2 G3 c)
 │         └── cost: 14.62
 ├── G2: (select G4 G5) (scan zz_redundant@idx_u,cols=(2,3),constrained) (scan zz_redundant@idx_v,cols=(2,3),constrained)
 │    └── []
 │         ├── best: (scan zz_redundant@idx_u,cols=(2,3),constrained)
 │         └── cost: 14.51
 ├── G3: (projections)
 ├── G4: (scan zz_redundant,cols=(2,3)) (scan zz_redundant@idx_u,cols=(2,3)) (scan zz_redundant@idx_v,cols=(2,3))
 │    └── []
 │         ├── best: (scan zz_redundant,cols=(2,3))
 │         └── cost: 1054.02
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable b)
 └── G8: (const 1)

# GenerateZigzagJoins is disabled in the presence of a row-level locking clause.
opt
SELECT q,r FROM pqr WHERE q = 1 AND r = 2 FOR UPDATE
----
select
 ├── columns: q:2!null r:3!null
 ├── volatile
 ├── fd: ()-->(2,3)
 ├── index-join pqr
 │    ├── columns: q:2 r:3
 │    ├── volatile
 │    ├── fd: ()-->(2)
 │    └── scan pqr@q
 │         ├── columns: p:1!null q:2!null
 │         ├── constraint: /2/1: [/1 - /1]
 │         ├── locking: for-update
 │         ├── volatile
 │         ├── key: (1)
 │         └── fd: ()-->(2)
 └── filters
      └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

# --------------------------------------------------
# GenerateInvertedIndexZigzagJoins
# --------------------------------------------------

# Query only the primary key with a remaining filter. 2+ paths in containment
# query should favor zigzag joins.
opt
SELECT k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup b)
      ├── columns: k:1!null j:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── inner-join (zigzag b@inv_idx b@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [4] = ['{"a": "b"}']
      │    ├── right fixed columns: [4] = ['{"c": "d"}']
      │    └── filters (true)
      └── filters
           └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Query requiring a zigzag join with a remaining filter.
# TODO(itsbilal): remove filter from index join if zigzag join covers it.
opt
SELECT j, k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
inner-join (lookup b)
 ├── columns: j:4!null k:1!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": "b"}']
 │    ├── right fixed columns: [4] = ['{"c": "d"}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT * FROM b WHERE j @> '{"a": {"b": "c", "d": "e"}, "f": "g"}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": {"b": "c"}}']
 │    ├── right fixed columns: [4] = ['{"a": {"d": "e"}}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": {"b": "c", "d": "e"}, "f": "g"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Three or more paths. Should generate zigzag joins.
opt
SELECT * FROM b WHERE j @> '{"a":[{"b":"c", "d":3}, 5]}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@inv_idx b@inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [4] = ['{"a": [{"b": "c"}]}']
 │    ├── right fixed columns: [4] = ['{"a": [{"d": 3}]}']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": [{"b": "c", "d": 3}, 5]}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt
SELECT k FROM c WHERE a @> ARRAY[1,3,1,5]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup c)
      ├── columns: k:1!null a:2!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── inner-join (zigzag c@inv_idx c@inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [ARRAY[1]]
      │    ├── right fixed columns: [2] = [ARRAY[3]]
      │    └── filters (true)
      └── filters
           └── a:2 @> ARRAY[1,3,1,5] [outer=(2), immutable, constraints=(/2: (/NULL - ])]

# GenerateInvertedIndexZigzagJoins is disabled in the presence of a row-level
# locking clause.
opt expect-not=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '{"a":1, "c":2}' FOR UPDATE
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@inv_idx
 │         ├── columns: k:1!null
 │         ├── constraint: /4/1: [/'{"a": 1}' - /'{"a": 1}']
 │         ├── locking: for-update
 │         ├── volatile
 │         └── key: (1)
 └── filters
      └── j:4 @> '{"a": 1, "c": 2}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

exec-ddl
CREATE TABLE inv_zz_partial (
    k INT PRIMARY KEY,
    j JSON,
    b BOOL,
    s STRING
)
----

exec-ddl
CREATE INVERTED INDEX zz_idx ON inv_zz_partial (j) WHERE b
----

# Generate a zigzag join on a single index with no remaining filter.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}' AND b
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup inv_zz_partial)
      ├── columns: k:1!null j:2!null b:3!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(3), (1)-->(2)
      ├── inner-join (zigzag inv_zz_partial@zz_idx,partial inv_zz_partial@zz_idx,partial)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = ['{"a": 1}']
      │    ├── right fixed columns: [2] = ['{"b": 2}']
      │    └── filters (true)
      └── filters
           └── j:2 @> '{"a": 1, "b": 2}' [outer=(2), immutable, constraints=(/2: (/NULL - ])]

# Generate a zigzag join on a single index with a remaining filter.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}' AND b AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup inv_zz_partial)
      ├── columns: k:1!null j:2!null b:3!null s:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(3,4), (1)-->(2)
      ├── inner-join (zigzag inv_zz_partial@zz_idx,partial inv_zz_partial@zz_idx,partial)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = ['{"a": 1}']
      │    ├── right fixed columns: [2] = ['{"b": 2}']
      │    └── filters (true)
      └── filters
           ├── j:2 @> '{"a": 1, "b": 2}' [outer=(2), immutable, constraints=(/2: (/NULL - ])]
           └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

# Don't generate a zigzag join when the predicate is not implied.
opt expect-not=GenerateInvertedIndexZigzagJoins format=hide-all
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}'
----
project
 └── select
      ├── scan inv_zz_partial
      │    └── partial index predicates
      │         └── zz_idx: filters
      │              └── b
      └── filters
           └── j @> '{"a": 1, "b": 2}'

exec-ddl
DROP INDEX zz_idx
----

exec-ddl
CREATE INVERTED INDEX zz_idx ON inv_zz_partial (j) WHERE j->'a' = '1'
----

# Don't generate a zigzag join when one of the the expressions that fixes the
# columns is removed while proving partial index implication.
opt expect-not=GenerateInvertedIndexZigzagJoins format=hide-all
SELECT k FROM inv_zz_partial WHERE j->'a' = '1' AND j->'b' = '2'
----
project
 └── scan inv_zz_partial@zz_idx,partial
      └── constraint: /2/1: [/'{"b": 2}' - /'{"b": 2}']

# --------------------------------------------------
# SplitDisjunction
# --------------------------------------------------

# TODO(mgartner): PruneAggCols should be pruning columns from the DistinctOn
# and further down the expression tree, ultimately eliminating the index-joins.
# PruneAggCols does not run in this case because normalization rules do not run
# at the root tree generated by an exploration rule.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT * FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
distinct-on
 ├── columns: k:1!null u:2 v:3 w:4!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3 w:4!null
 │    ├── left columns: k:1!null u:2 v:3 w:4!null
 │    ├── right columns: k:6 u:7 v:8 w:9
 │    ├── select
 │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2,4), (1)-->(3)
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2 v:3 w:4
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── filters
 │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │    └── select
 │         ├── columns: k:6!null u:7 v:8!null w:9!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8,9), (6)-->(7)
 │         ├── index-join d
 │         │    ├── columns: k:6!null u:7 v:8 w:9
 │         │    ├── key: (6)
 │         │    ├── fd: ()-->(8), (6)-->(7,9)
 │         │    └── scan d@v
 │         │         ├── columns: k:6!null v:8!null
 │         │         ├── constraint: /8/6: [/1 - /1]
 │         │         ├── key: (6)
 │         │         └── fd: ()-->(8)
 │         └── filters
 │              └── w:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      ├── const-agg [as=v:3, outer=(3)]
      │    └── v:3
      └── const-agg [as=w:4, outer=(4)]
           └── w:4

opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:6 u:7 v:8
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:6!null u:7!null v:8!null
      │         ├── eq columns: [6] = [6]
      │         ├── left fixed columns: [7] = [10]
      │         ├── right fixed columns: [8] = [2]
      │         ├── key: (6)
      │         ├── fd: ()-->(7,8)
      │         └── filters
      │              ├── v:8 = 2 [outer=(8), constraints=(/8: [/2 - /2]; tight), fd=()-->(8)]
      │              └── u:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT sum(k) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: sum:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── distinct-on
 │    ├── columns: k:1!null u:2 v:3
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── union-all
 │    │    ├── columns: k:1!null u:2 v:3
 │    │    ├── left columns: k:1!null u:2 v:3
 │    │    ├── right columns: k:7 u:8 v:9
 │    │    ├── index-join d
 │    │    │    ├── columns: k:1!null u:2!null v:3
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:1!null u:2!null
 │    │    │         ├── constraint: /2/1: [/1 - /1]
 │    │    │         ├── key: (1)
 │    │    │         └── fd: ()-->(2)
 │    │    └── index-join d
 │    │         ├── columns: k:7!null u:8 v:9!null
 │    │         ├── key: (7)
 │    │         ├── fd: ()-->(9), (7)-->(8)
 │    │         └── scan d@v
 │    │              ├── columns: k:7!null v:9!null
 │    │              ├── constraint: /9/7: [/1 - /1]
 │    │              ├── key: (7)
 │    │              └── fd: ()-->(9)
 │    └── aggregations
 │         ├── const-agg [as=u:2, outer=(2)]
 │         │    └── u:2
 │         └── const-agg [as=v:3, outer=(3)]
 │              └── v:3
 └── aggregations
      └── sum [as=sum:6, outer=(1)]
           └── k:1

# Multi-column primary key.
opt expect=SplitDisjunction
SELECT k, j FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: k:1!null j:2!null
 ├── key: (1,2)
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:6 j:7 u:8 v:9
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:6!null j:7!null u:8 v:9!null
      │         ├── key: (6,7)
      │         ├── fd: ()-->(9), (6,7)-->(8)
      │         └── scan f@v
      │              ├── columns: k:6!null j:7!null v:9!null
      │              ├── constraint: /9/6/7: [/2 - /2]
      │              ├── key: (6,7)
      │              └── fd: ()-->(9)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/5 - /8]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunction
SELECT k FROM b WHERE k = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── union-all
      │    ├── columns: k:1!null j:4
      │    ├── left columns: k:1!null j:4
      │    ├── right columns: k:7 j:10
      │    ├── immutable
      │    ├── scan b
      │    │    ├── columns: k:1!null j:4
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,4)
      │    └── index-join b
      │         ├── columns: k:7!null j:10!null
      │         ├── immutable
      │         ├── key: (7)
      │         ├── fd: (7)-->(10)
      │         └── scan b@inv_idx
      │              ├── columns: k:7!null
      │              ├── constraint: /10/7: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (7)
      └── aggregations
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunction
SELECT k FROM c WHERE k = 1 OR a @> ARRAY[2]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── union-all
      │    ├── columns: k:1!null a:2
      │    ├── left columns: k:1!null a:2
      │    ├── right columns: k:6 a:7
      │    ├── immutable
      │    ├── scan c
      │    │    ├── columns: k:1!null a:2
      │    │    ├── constraint: /1: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1,2)
      │    └── index-join c
      │         ├── columns: k:6!null a:7!null
      │         ├── immutable
      │         ├── key: (6)
      │         ├── fd: (6)-->(7)
      │         └── scan c@inv_idx
      │              ├── columns: k:6!null
      │              ├── constraint: /7/6: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (6)
      └── aggregations
           └── const-agg [as=a:2, outer=(2)]
                └── a:2

# Uncorrelated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:10 d.u:11 d.v:12
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:7 a.v:8
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(7,8)
      │    └── index-join d
      │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         ├── key: (10)
      │         ├── fd: ()-->(12), (10)-->(11)
      │         └── select
      │              ├── columns: d.k:10!null d.v:12!null
      │              ├── key: (10)
      │              ├── fd: ()-->(12)
      │              ├── scan d@v
      │              │    ├── columns: d.k:10!null d.v:12!null
      │              │    ├── constraint: /12/10: [/1 - /1]
      │              │    ├── key: (10)
      │              │    └── fd: ()-->(12)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:7 a.v:8
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(7,8)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2!null d.v:3 a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── key: (1)
           ├── fd: (1)-->(2,3), (2)==(7), (7)==(2)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2,3)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3
           │    │    ├── right columns: d.k:10 d.u:11 d.v:12
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:10!null d.u:11 d.v:12!null
           │    │         ├── key: (10)
           │    │         ├── fd: ()-->(12), (10)-->(11)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:10!null d.v:12!null
           │    │              ├── constraint: /12/10: [/1 - /1]
           │    │              ├── key: (10)
           │    │              └── fd: ()-->(12)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         └── const-agg [as=d.v:3, outer=(3)]
           │              └── d.v:3
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = d.u:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── project
      ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      └── inner-join (hash)
           ├── columns: d.k:1!null d.u:2 d.v:3 w:4!null a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── key: (1)
           ├── fd: (1)-->(2-4), (4)==(7), (7)==(4)
           ├── distinct-on
           │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    ├── grouping columns: d.k:1!null
           │    ├── key: (1)
           │    ├── fd: (1)-->(2-4)
           │    ├── union-all
           │    │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │    │    ├── right columns: d.k:10 d.u:11 d.v:12 w:13
           │    │    ├── index-join d
           │    │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: d.k:1!null d.u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── index-join d
           │    │         ├── columns: d.k:10!null d.u:11 d.v:12!null w:13
           │    │         ├── key: (10)
           │    │         ├── fd: ()-->(12), (10)-->(11,13)
           │    │         └── scan d@v
           │    │              ├── columns: d.k:10!null d.v:12!null
           │    │              ├── constraint: /12/10: [/1 - /1]
           │    │              ├── key: (10)
           │    │              └── fd: ()-->(12)
           │    └── aggregations
           │         ├── const-agg [as=d.u:2, outer=(2)]
           │         │    └── d.u:2
           │         ├── const-agg [as=d.v:3, outer=(3)]
           │         │    └── d.v:3
           │         └── const-agg [as=w:4, outer=(4)]
           │              └── w:4
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = w:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM e WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join e
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan e@uw
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/4/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join e
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8), (6)-->(7)
 │         └── scan e@vw
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/9/6: [/1 - /1]
 │              ├── key: (6)
 │              └── fd: ()-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: k:1!null u:2 v:3
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8,9), (6)-->(7)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/1 - /1]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── w:9 = 3 [outer=(9), constraints=(/9: [/3 - /3]; tight), fd=()-->(9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    └── [/3 - /3]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    └── [/4 - /4]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/1 - /1]
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: (6)-->(7,8)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (6)
 │              └── fd: (6)-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7,9)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/4 - /4]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── (w:9 = 1) OR (w:9 = 2) [outer=(9), constraints=(/9: [/1 - /1] [/2 - /2]; tight)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4
      │    ├── left columns: k:1!null u:2 v:3 w:4
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/3 - /3]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7,9)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/4 - /4]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── (u:7 = 1) OR (w:9 = 2) [outer=(7,9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunction
SELECT k, u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: k:1!null u:2 w:4
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan d
 │    ├── columns: k:1!null u:2 w:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries without strict keys.
opt expect-not=SplitDisjunction
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR u = 5
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan d@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1
      │    ├── [/1 - /1]
      │    └── [/5 - /5]
      ├── key: (1)
      └── fd: (1)-->(2)

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunction
SELECT k FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)~~>(1,2)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── constraint: /7: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(5-7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1 opt(2)
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      ├── index-join d
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── key: (1)
      │    ├── fd: ()-->(2), (1)-->(3)
      │    ├── ordering: +1 opt(2) [actual: +1]
      │    └── scan d@u
      │         ├── columns: k:1!null u:2!null
      │         ├── constraint: /2/1: [/2 - /2]
      │         ├── key: (1)
      │         ├── fd: ()-->(2)
      │         └── ordering: +1 opt(2) [actual: +1]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Regression test for #52207. Partial index predicates in TableMeta must be
# duplicated when TableMeta is duplicated.
exec-ddl
CREATE TABLE t52207 (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  INDEX idx_a (a) WHERE a > 0,
  INDEX idx_b (b) WHERE b > 0
)
----

opt expect=SplitDisjunction
SELECT k FROM t52207 WHERE a = 1 OR b = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2 b:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 b:3
      │    ├── left columns: k:1!null a:2 b:3
      │    ├── right columns: k:5 a:6 b:7
      │    ├── index-join t52207
      │    │    ├── columns: k:1!null a:2!null b:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan t52207@idx_a,partial
      │    │         ├── columns: k:1!null a:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join t52207
      │         ├── columns: k:5!null a:6 b:7!null
      │         ├── key: (5)
      │         ├── fd: ()-->(7), (5)-->(6)
      │         └── scan t52207@idx_b,partial
      │              ├── columns: k:5!null b:7!null
      │              ├── constraint: /7/5: [/1 - /1]
      │              ├── key: (5)
      │              └── fd: ()-->(7)
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=b:3, outer=(3)]
                └── b:3

# --------------------------------------------------
# SplitDisjunctionAddKey
# --------------------------------------------------

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT u, v, w FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
project
 ├── columns: u:2 v:3 w:4!null
 ├── fd: ()-->(4)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:1!null u:2 v:3 w:4!null
      │    ├── right columns: k:6 u:7 v:8 w:9
      │    ├── select
      │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,4), (1)-->(3)
      │    │    ├── index-join d
      │    │    │    ├── columns: k:1!null u:2 v:3 w:4
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:1!null u:2!null
      │    │    │         ├── constraint: /2/1: [/1 - /1]
      │    │    │         ├── key: (1)
      │    │    │         └── fd: ()-->(2)
      │    │    └── filters
      │    │         └── w:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
      │    └── select
      │         ├── columns: k:6!null u:7 v:8!null w:9!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8,9), (6)-->(7)
      │         ├── index-join d
      │         │    ├── columns: k:6!null u:7 v:8 w:9
      │         │    ├── key: (6)
      │         │    ├── fd: ()-->(8), (6)-->(7,9)
      │         │    └── scan d@v
      │         │         ├── columns: k:6!null v:8!null
      │         │         ├── constraint: /8/6: [/1 - /1]
      │         │         ├── key: (6)
      │         │         └── fd: ()-->(8)
      │         └── filters
      │              └── w:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:1!null u:2!null v:3!null
      │    ├── right columns: k:6 u:7 v:8
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:1!null u:2!null v:3!null
      │    │    ├── eq columns: [1] = [1]
      │    │    ├── left fixed columns: [2] = [1]
      │    │    ├── right fixed columns: [3] = [20]
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2,3)
      │    │    └── filters
      │    │         ├── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      │    │         └── v:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:6!null u:7!null v:8!null
      │         ├── eq columns: [6] = [6]
      │         ├── left fixed columns: [7] = [10]
      │         ├── right fixed columns: [8] = [2]
      │         ├── key: (6)
      │         ├── fd: ()-->(7,8)
      │         └── filters
      │              ├── v:8 = 2 [outer=(8), constraints=(/8: [/2 - /2]; tight), fd=()-->(8)]
      │              └── u:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT count(*) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: count:6!null
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── project
 │    ├── columns: u:2 v:3
 │    └── distinct-on
 │         ├── columns: k:1!null u:2 v:3
 │         ├── grouping columns: k:1!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,3)
 │         ├── union-all
 │         │    ├── columns: k:1!null u:2 v:3
 │         │    ├── left columns: k:1!null u:2 v:3
 │         │    ├── right columns: k:7 u:8 v:9
 │         │    ├── index-join d
 │         │    │    ├── columns: k:1!null u:2!null v:3
 │         │    │    ├── key: (1)
 │         │    │    ├── fd: ()-->(2), (1)-->(3)
 │         │    │    └── scan d@u
 │         │    │         ├── columns: k:1!null u:2!null
 │         │    │         ├── constraint: /2/1: [/1 - /1]
 │         │    │         ├── key: (1)
 │         │    │         └── fd: ()-->(2)
 │         │    └── index-join d
 │         │         ├── columns: k:7!null u:8 v:9!null
 │         │         ├── key: (7)
 │         │         ├── fd: ()-->(9), (7)-->(8)
 │         │         └── scan d@v
 │         │              ├── columns: k:7!null v:9!null
 │         │              ├── constraint: /9/7: [/1 - /1]
 │         │              ├── key: (7)
 │         │              └── fd: ()-->(9)
 │         └── aggregations
 │              ├── const-agg [as=u:2, outer=(2)]
 │              │    └── u:2
 │              └── const-agg [as=v:3, outer=(3)]
 │                   └── v:3
 └── aggregations
      └── count-rows [as=count_rows:6]

# Multi-column primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: u:3 v:4
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:1!null j:2!null u:3 v:4
      │    ├── right columns: k:6 j:7 u:8 v:9
      │    ├── index-join f
      │    │    ├── columns: k:1!null j:2!null u:3!null v:4
      │    │    ├── key: (1,2)
      │    │    ├── fd: ()-->(3), (1,2)-->(4)
      │    │    └── scan f@u
      │    │         ├── columns: k:1!null j:2!null u:3!null
      │    │         ├── constraint: /3/1/2: [/1 - /1]
      │    │         ├── key: (1,2)
      │    │         └── fd: ()-->(3)
      │    └── index-join f
      │         ├── columns: k:6!null j:7!null u:8 v:9!null
      │         ├── key: (6,7)
      │         ├── fd: ()-->(9), (6,7)-->(8)
      │         └── scan f@v
      │              ├── columns: k:6!null j:7!null v:9!null
      │              ├── constraint: /9/6/7: [/2 - /2]
      │              ├── key: (6,7)
      │              └── fd: ()-->(9)
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /4]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6: [/5 - /8]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, j FROM b WHERE u = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: u:2 j:4
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null u:2 j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── union-all
      │    ├── columns: k:1!null u:2 j:4
      │    ├── left columns: k:1!null u:2 j:4
      │    ├── right columns: k:7 u:8 j:10
      │    ├── immutable
      │    ├── index-join b
      │    │    ├── columns: k:1!null u:2!null j:4
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(4)
      │    │    └── scan b@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join b
      │         ├── columns: k:7!null u:8 j:10!null
      │         ├── immutable
      │         ├── key: (7)
      │         ├── fd: (7)-->(8,10)
      │         └── scan b@inv_idx
      │              ├── columns: k:7!null
      │              ├── constraint: /10/7: [/'{"foo": "bar"}' - /'{"foo": "bar"}']
      │              └── key: (7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, a FROM c WHERE u = 1 OR a @> ARRAY[2]
----
project
 ├── columns: u:3 a:2
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null a:2 u:3
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 u:3
      │    ├── left columns: k:1!null a:2 u:3
      │    ├── right columns: k:6 a:7 u:8
      │    ├── immutable
      │    ├── index-join c
      │    │    ├── columns: k:1!null a:2 u:3!null
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(3), (1)-->(2)
      │    │    └── scan c@u
      │    │         ├── columns: k:1!null u:3!null
      │    │         ├── constraint: /3/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(3)
      │    └── index-join c
      │         ├── columns: k:6!null a:7!null u:8
      │         ├── immutable
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan c@inv_idx
      │              ├── columns: k:6!null
      │              ├── constraint: /7/6: [/ARRAY[2] - /ARRAY[2]]
      │              └── key: (6)
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=u:3, outer=(3)]
                └── u:3

# Uncorrelated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │    ├── right columns: d.k:10 d.u:11 d.v:12
      │    ├── index-join d
      │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── select
      │    │         ├── columns: d.k:1!null d.u:2!null
      │    │         ├── key: (1)
      │    │         ├── fd: ()-->(2)
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:1!null d.u:2!null
      │    │         │    ├── constraint: /2/1: [/1 - /1]
      │    │         │    ├── key: (1)
      │    │         │    └── fd: ()-->(2)
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:7 a.v:8
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(7,8)
      │    └── index-join d
      │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         ├── key: (10)
      │         ├── fd: ()-->(12), (10)-->(11)
      │         └── select
      │              ├── columns: d.k:10!null d.v:12!null
      │              ├── key: (10)
      │              ├── fd: ()-->(12)
      │              ├── scan d@v
      │              │    ├── columns: d.k:10!null d.v:12!null
      │              │    ├── constraint: /12/10: [/1 - /1]
      │              │    ├── key: (10)
      │              │    └── fd: ()-->(12)
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:7 a.v:8
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(7,8)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: u:2 v:3
 └── inner-join (hash)
      ├── columns: d.u:2!null d.v:3 a.u:7!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── fd: (2)==(7), (7)==(2)
      ├── project
      │    ├── columns: d.u:2 d.v:3
      │    └── distinct-on
      │         ├── columns: d.k:1!null d.u:2 d.v:3
      │         ├── grouping columns: d.k:1!null
      │         ├── key: (1)
      │         ├── fd: (1)-->(2,3)
      │         ├── union-all
      │         │    ├── columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── left columns: d.k:1!null d.u:2 d.v:3
      │         │    ├── right columns: d.k:10 d.u:11 d.v:12
      │         │    ├── index-join d
      │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3
      │         │    │    ├── key: (1)
      │         │    │    ├── fd: ()-->(2), (1)-->(3)
      │         │    │    └── scan d@u
      │         │    │         ├── columns: d.k:1!null d.u:2!null
      │         │    │         ├── constraint: /2/1: [/1 - /1]
      │         │    │         ├── key: (1)
      │         │    │         └── fd: ()-->(2)
      │         │    └── index-join d
      │         │         ├── columns: d.k:10!null d.u:11 d.v:12!null
      │         │         ├── key: (10)
      │         │         ├── fd: ()-->(12), (10)-->(11)
      │         │         └── scan d@v
      │         │              ├── columns: d.k:10!null d.v:12!null
      │         │              ├── constraint: /12/10: [/1 - /1]
      │         │              ├── key: (10)
      │         │              └── fd: ()-->(12)
      │         └── aggregations
      │              ├── const-agg [as=d.u:2, outer=(2)]
      │              │    └── d.u:2
      │              └── const-agg [as=d.v:3, outer=(3)]
      │                   └── d.v:3
      ├── distinct-on
      │    ├── columns: a.u:7
      │    ├── grouping columns: a.u:7
      │    ├── internal-ordering: +7
      │    ├── key: (7)
      │    └── scan a@u
      │         ├── columns: a.u:7
      │         └── ordering: +7
      └── filters
           └── a.u:7 = d.u:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: d.u:2 d.v:3 w:4
      └── inner-join (hash)
           ├── columns: d.u:2 d.v:3 w:4!null a.u:7!null
           ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
           ├── fd: (4)==(7), (7)==(4)
           ├── project
           │    ├── columns: d.u:2 d.v:3 w:4
           │    └── distinct-on
           │         ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         ├── grouping columns: d.k:1!null
           │         ├── key: (1)
           │         ├── fd: (1)-->(2-4)
           │         ├── union-all
           │         │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── left columns: d.k:1!null d.u:2 d.v:3 w:4
           │         │    ├── right columns: d.k:10 d.u:11 d.v:12 w:13
           │         │    ├── index-join d
           │         │    │    ├── columns: d.k:1!null d.u:2!null d.v:3 w:4
           │         │    │    ├── key: (1)
           │         │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │         │    │    └── scan d@u
           │         │    │         ├── columns: d.k:1!null d.u:2!null
           │         │    │         ├── constraint: /2/1: [/1 - /1]
           │         │    │         ├── key: (1)
           │         │    │         └── fd: ()-->(2)
           │         │    └── index-join d
           │         │         ├── columns: d.k:10!null d.u:11 d.v:12!null w:13
           │         │         ├── key: (10)
           │         │         ├── fd: ()-->(12), (10)-->(11,13)
           │         │         └── scan d@v
           │         │              ├── columns: d.k:10!null d.v:12!null
           │         │              ├── constraint: /12/10: [/1 - /1]
           │         │              ├── key: (10)
           │         │              └── fd: ()-->(12)
           │         └── aggregations
           │              ├── const-agg [as=d.u:2, outer=(2)]
           │              │    └── d.u:2
           │              ├── const-agg [as=d.v:3, outer=(3)]
           │              │    └── d.v:3
           │              └── const-agg [as=w:4, outer=(4)]
           │                   └── w:4
           ├── distinct-on
           │    ├── columns: a.u:7
           │    ├── grouping columns: a.u:7
           │    ├── internal-ordering: +7
           │    ├── key: (7)
           │    └── scan a@u
           │         ├── columns: a.u:7
           │         └── ordering: +7
           └── filters
                └── a.u:7 = w:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# Use rowid when there is no explicit primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM no_explicit_primary_key WHERE u = 1 OR v = 5
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: u:2 v:3 rowid:4!null
      ├── grouping columns: rowid:4!null
      ├── key: (4)
      ├── fd: (4)-->(2,3)
      ├── union-all
      │    ├── columns: u:2 v:3 rowid:4!null
      │    ├── left columns: u:2 v:3 rowid:4!null
      │    ├── right columns: u:7 v:8 rowid:9
      │    ├── index-join no_explicit_primary_key
      │    │    ├── columns: u:2!null v:3 rowid:4!null
      │    │    ├── key: (4)
      │    │    ├── fd: ()-->(2), (4)-->(3)
      │    │    └── scan no_explicit_primary_key@u
      │    │         ├── columns: u:2!null rowid:4!null
      │    │         ├── constraint: /2/4: [/1 - /1]
      │    │         ├── key: (4)
      │    │         └── fd: ()-->(2)
      │    └── index-join no_explicit_primary_key
      │         ├── columns: u:7 v:8!null rowid:9!null
      │         ├── key: (9)
      │         ├── fd: ()-->(8), (9)-->(7)
      │         └── scan no_explicit_primary_key@v
      │              ├── columns: v:8!null rowid:9!null
      │              ├── constraint: /8/9: [/5 - /5]
      │              ├── key: (9)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM e WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join e
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: ()-->(2), (1)-->(3)
      │    │    └── scan e@uw
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/4/1: [/1 - /1]
      │    │         ├── key: (1)
      │    │         └── fd: ()-->(2)
      │    └── index-join e
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: ()-->(8), (6)-->(7)
      │         └── scan e@vw
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/9/6: [/1 - /1]
      │              ├── key: (6)
      │              └── fd: ()-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/1 - /1]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9!null
           │         ├── key: (6)
           │         ├── fd: ()-->(8,9), (6)-->(7)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/1 - /1]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── w:9 = 3 [outer=(9), constraints=(/9: [/3 - /3]; tight), fd=()-->(9)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    └── [/3 - /3]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    └── [/4 - /4]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/1 - /1]
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:6 u:7 v:8
      │    ├── index-join d
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3)
      │    │    └── scan d@u
      │    │         ├── columns: k:1!null u:2!null
      │    │         ├── constraint: /2/1
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── index-join d
      │         ├── columns: k:6!null u:7 v:8!null
      │         ├── key: (6)
      │         ├── fd: (6)-->(7,8)
      │         └── scan d@v
      │              ├── columns: k:6!null v:8!null
      │              ├── constraint: /8/6
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (6)
      │              └── fd: (6)-->(8)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:1!null u:2 v:3 w:4!null
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── (w:4 = 1) OR (w:4 = 2) [outer=(4), constraints=(/4: [/1 - /1] [/2 - /2]; tight)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9!null
           │         ├── key: (6)
           │         ├── fd: ()-->(8), (6)-->(7,9)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/4 - /4]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── (w:9 = 1) OR (w:9 = 2) [outer=(9), constraints=(/9: [/1 - /1] [/2 - /2]; tight)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4
           ├── grouping columns: k:1!null
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4
           │    ├── left columns: k:1!null u:2 v:3 w:4
           │    ├── right columns: k:6 u:7 v:8 w:9
           │    ├── select
           │    │    ├── columns: k:1!null u:2!null v:3 w:4!null
           │    │    ├── key: (1)
           │    │    ├── fd: ()-->(2,4), (1)-->(3)
           │    │    ├── index-join d
           │    │    │    ├── columns: k:1!null u:2 v:3 w:4
           │    │    │    ├── key: (1)
           │    │    │    ├── fd: ()-->(2), (1)-->(3,4)
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:1!null u:2!null
           │    │    │         ├── constraint: /2/1: [/3 - /3]
           │    │    │         ├── key: (1)
           │    │    │         └── fd: ()-->(2)
           │    │    └── filters
           │    │         └── w:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]
           │    └── select
           │         ├── columns: k:6!null u:7 v:8!null w:9
           │         ├── key: (6)
           │         ├── fd: ()-->(8), (6)-->(7,9)
           │         ├── index-join d
           │         │    ├── columns: k:6!null u:7 v:8 w:9
           │         │    ├── key: (6)
           │         │    ├── fd: ()-->(8), (6)-->(7,9)
           │         │    └── scan d@v
           │         │         ├── columns: k:6!null v:8!null
           │         │         ├── constraint: /8/6: [/4 - /4]
           │         │         ├── key: (6)
           │         │         └── fd: ()-->(8)
           │         └── filters
           │              └── (u:7 = 1) OR (w:9 = 2) [outer=(7,9)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunctionAddKey
SELECT u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: u:2 w:4
 ├── scan d
 │    └── columns: u:2 w:4
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries with strict keys.
opt expect-not=SplitDisjunctionAddKey
SELECT k, u, v FROM d WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:1!null u:2 v:3
 │    ├── right columns: k:6 u:7 v:8
 │    ├── index-join d
 │    │    ├── columns: k:1!null u:2!null v:3
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(3)
 │    │    └── scan d@u
 │    │         ├── columns: k:1!null u:2!null
 │    │         ├── constraint: /2/1: [/1 - /1]
 │    │         ├── key: (1)
 │    │         └── fd: ()-->(2)
 │    └── index-join d
 │         ├── columns: k:6!null u:7 v:8!null
 │         ├── key: (6)
 │         ├── fd: ()-->(8), (6)-->(7)
 │         └── scan d@v
 │              ├── columns: k:6!null v:8!null
 │              ├── constraint: /8/6: [/1 - /1]
 │              ├── key: (6)
 │              └── fd: ()-->(8)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunctionAddKey
SELECT u FROM d WHERE u = 1 OR u = 5
----
scan d@u
 ├── columns: u:2!null
 └── constraint: /2/1
      ├── [/1 - /1]
      └── [/5 - /5]

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 ├── lax-key: (2,3)
 ├── fd: (3)~~>(2)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:1!null u:2 v:3
      │    ├── right columns: k:5 u:6 v:7
      │    ├── scan a@u
      │    │    ├── columns: k:1!null u:2!null v:3
      │    │    ├── constraint: /2/1: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(2), (1)-->(3), (3)~~>(1)
      │    └── scan a@v
      │         ├── columns: k:5!null u:6 v:7!null
      │         ├── constraint: /7: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(5-7)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: u:2!null v:3
 ├── fd: ()-->(2)
 └── index-join d
      ├── columns: k:1!null u:2!null v:3
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      └── scan d@u
           ├── columns: k:1!null u:2!null
           ├── constraint: /2/1: [/2 - /2]
           ├── key: (1)
           └── fd: ()-->(2)

exec-ddl
CREATE INDEX idx_i ON p (i)
----

exec-ddl
CREATE INDEX idx_f ON p (f) WHERE s IN ('foo', 'bar', 'baz')
----

# Apply when one side of the disjunction can be "constrained" by an
# unconstrained partial index scan with no remaining filters.
opt expect=SplitDisjunctionAddKey
SELECT * FROM p WHERE i = 10 OR s IN ('foo', 'bar', 'baz')
----
project
 ├── columns: i:1 f:2 s:3 b:4
 └── distinct-on
      ├── columns: i:1 f:2 s:3 b:4 rowid:5!null
      ├── grouping columns: rowid:5!null
      ├── key: (5)
      ├── fd: (5)-->(1-4)
      ├── union-all
      │    ├── columns: i:1 f:2 s:3 b:4 rowid:5!null
      │    ├── left columns: i:1 f:2 s:3 b:4 rowid:5!null
      │    ├── right columns: i:7 f:8 s:9 b:10 rowid:11
      │    ├── index-join p
      │    │    ├── columns: i:1!null f:2 s:3 b:4 rowid:5!null
      │    │    ├── key: (5)
      │    │    ├── fd: ()-->(1), (5)-->(2-4)
      │    │    └── scan p@idx_i
      │    │         ├── columns: i:1!null rowid:5!null
      │    │         ├── constraint: /1/5: [/10 - /10]
      │    │         ├── key: (5)
      │    │         └── fd: ()-->(1)
      │    └── index-join p
      │         ├── columns: i:7 f:8 s:9!null b:10 rowid:11!null
      │         ├── key: (11)
      │         ├── fd: (11)-->(7-10)
      │         └── scan p@idx_f,partial
      │              ├── columns: f:8 rowid:11!null
      │              ├── key: (11)
      │              └── fd: (11)-->(8)
      └── aggregations
           ├── const-agg [as=i:1, outer=(1)]
           │    └── i:1
           ├── const-agg [as=f:2, outer=(2)]
           │    └── f:2
           ├── const-agg [as=s:3, outer=(3)]
           │    └── s:3
           └── const-agg [as=b:4, outer=(4)]
                └── b:4

# Apply when one side of the disjunction can be "constrained" by an
# unconstrained partial index scan with remaining filters.
opt expect=SplitDisjunctionAddKey
SELECT * FROM p WHERE i = 10 OR s = 'foo'
----
project
 ├── columns: i:1 f:2 s:3 b:4
 └── distinct-on
      ├── columns: i:1 f:2 s:3 b:4 rowid:5!null
      ├── grouping columns: rowid:5!null
      ├── key: (5)
      ├── fd: (5)-->(1-4)
      ├── union-all
      │    ├── columns: i:1 f:2 s:3 b:4 rowid:5!null
      │    ├── left columns: i:1 f:2 s:3 b:4 rowid:5!null
      │    ├── right columns: i:7 f:8 s:9 b:10 rowid:11
      │    ├── index-join p
      │    │    ├── columns: i:1!null f:2 s:3 b:4 rowid:5!null
      │    │    ├── key: (5)
      │    │    ├── fd: ()-->(1), (5)-->(2-4)
      │    │    └── scan p@idx_i
      │    │         ├── columns: i:1!null rowid:5!null
      │    │         ├── constraint: /1/5: [/10 - /10]
      │    │         ├── key: (5)
      │    │         └── fd: ()-->(1)
      │    └── select
      │         ├── columns: i:7 f:8 s:9!null b:10 rowid:11!null
      │         ├── key: (11)
      │         ├── fd: ()-->(9), (11)-->(7,8,10)
      │         ├── index-join p
      │         │    ├── columns: i:7 f:8 s:9 b:10 rowid:11!null
      │         │    ├── key: (11)
      │         │    ├── fd: (11)-->(7-10)
      │         │    └── scan p@idx_f,partial
      │         │         ├── columns: f:8 rowid:11!null
      │         │         ├── key: (11)
      │         │         └── fd: (11)-->(8)
      │         └── filters
      │              └── s:9 = 'foo' [outer=(9), constraints=(/9: [/'foo' - /'foo']; tight), fd=()-->(9)]
      └── aggregations
           ├── const-agg [as=i:1, outer=(1)]
           │    └── i:1
           ├── const-agg [as=f:2, outer=(2)]
           │    └── f:2
           ├── const-agg [as=s:3, outer=(3)]
           │    └── s:3
           └── const-agg [as=b:4, outer=(4)]
                └── b:4
