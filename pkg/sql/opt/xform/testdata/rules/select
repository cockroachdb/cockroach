exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    INDEX u(u) STORING (v),
    UNIQUE INDEX v(v) STORING (u)
)
----

exec-ddl
CREATE TABLE b
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    j JSONB,
    INDEX u(u),
    UNIQUE INDEX v(v),
    INVERTED INDEX j_inv_idx(j)
)
----

exec-ddl
CREATE TABLE c
(
    k INT PRIMARY KEY,
    a INT[],
    u INT,
    INVERTED INDEX a_inv_idx(a),
    INDEX u(u)
)
----

exec-ddl
CREATE TABLE d
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE e
(
    k INT PRIMARY KEY,
    u INT,
    v INT,
    w INT,
    INDEX uw(u, w),
    INDEX vw(v, w)
)
----

exec-ddl
CREATE TABLE f
(
    k INT,
    j INT,
    u INT,
    v INT,
    CONSTRAINT pk PRIMARY KEY (k, j),
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE g
(
    k INT PRIMARY KEY,
    v INT,
    geom GEOMETRY,
    geog GEOGRAPHY,
    INVERTED INDEX geom_idx (geom),
    INVERTED INDEX geog_idx (geog)
)
----

exec-ddl
CREATE TABLE p (
    k INT PRIMARY KEY,
    i INT,
    f FLOAT,
    s STRING,
    b BOOL
)
----

exec-ddl
CREATE TABLE no_explicit_primary_key
(
    k INT,
    u INT,
    v INT,
    INDEX u(u),
    INDEX v(v)
)
----

exec-ddl
CREATE TABLE computed (
    k INT PRIMARY KEY,
    s STRING,
    l STRING AS (lower(s)) STORED,
    j JSON,
    field JSON AS (j->'foo') STORED,
    fieldstr STRING AS ((j->'foo')::string) STORED,
    INDEX l_idx (l),
    INDEX fieldstr_idx (fieldstr),
    INVERTED INDEX field_inv_idx (field)
)
----

exec-ddl
CREATE TABLE virtual (
    k INT PRIMARY KEY,
    a INT,
    b INT,
    c INT AS (b + 10) VIRTUAL,
    s STRING,
    lower_s STRING AS (lower(s)) VIRTUAL,
    upper_s STRING AS (upper(s)) VIRTUAL,
    INDEX (a) WHERE c IN (10, 20, 30),
    INDEX (lower_s),
    INDEX (a) WHERE upper_s = 'FOO',
    INDEX (c) WHERE c > 100
)
----

# --------------------------------------------------
# GeneratePartialIndexScans
# --------------------------------------------------

exec-ddl
CREATE INDEX idx ON p (i) STORING (f, s) WHERE s = 'foo'
----

# Generate a lone partial index scan when the index is covering and there are no
# remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo'
----
project
 ├── columns: i:2
 └── scan p@idx,partial
      ├── columns: i:2 s:4!null
      └── fd: ()-->(4)

# Generate a partial index scan inside a select when the index is covering and
# there are remaining filters.
opt expect=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: i:2
 └── select
      ├── columns: i:2 f:3 s:4!null
      ├── fd: ()-->(4)
      ├── scan p@idx,partial
      │    ├── columns: i:2 f:3 s:4!null
      │    └── fd: ()-->(4)
      └── filters
           └── (i:2 = 1) OR (f:3 = 2.0) [outer=(2,3)]

# Generate a partial index scan inside an index-join when the index is not
# covering and there no remaining filters.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo'
----
project
 ├── columns: b:5
 └── index-join p
      ├── columns: s:4!null b:5
      ├── fd: ()-->(4)
      └── scan p@idx,partial
           ├── columns: k:1!null s:4!null
           ├── key: (1)
           └── fd: ()-->(4)

# Generate a partial index scan inside a select inside an index-join when the
# index is not covering and there are remaining filters that are covered by the
# index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND (i = 1 OR f = 2.0)
----
project
 ├── columns: b:5
 └── index-join p
      ├── columns: i:2 f:3 s:4!null b:5
      ├── fd: ()-->(4)
      └── select
           ├── columns: k:1!null i:2 f:3 s:4!null
           ├── key: (1)
           ├── fd: ()-->(4), (1)-->(2,3)
           ├── scan p@idx,partial
           │    ├── columns: k:1!null i:2 f:3 s:4!null
           │    ├── key: (1)
           │    └── fd: ()-->(4), (1)-->(2,3)
           └── filters
                └── (i:2 = 1) OR (f:3 = 2.0) [outer=(2,3)]

# Generate a partial index scan inside an index-join inside a select when the
# index is not covering and the remaining filters are not covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND b
----
project
 ├── columns: b:5!null
 ├── fd: ()-->(5)
 └── select
      ├── columns: s:4!null b:5!null
      ├── fd: ()-->(4,5)
      ├── index-join p
      │    ├── columns: s:4 b:5
      │    ├── fd: ()-->(4)
      │    └── scan p@idx,partial
      │         ├── columns: k:1!null s:4!null
      │         ├── key: (1)
      │         └── fd: ()-->(4)
      └── filters
           └── b:5 [outer=(5), constraints=(/5: [/true - /true]; tight), fd=()-->(5)]

# Generate a partial index scan inside a Select/IndexJoin/Select when the index
# is not covering and the remaining filters are partially covered by the index.
opt expect=GeneratePartialIndexScans
SELECT b FROM p WHERE s = 'foo' AND f = 1 AND b
----
project
 ├── columns: b:5!null
 ├── fd: ()-->(5)
 └── select
      ├── columns: f:3!null s:4!null b:5!null
      ├── fd: ()-->(3-5)
      ├── index-join p
      │    ├── columns: f:3 s:4 b:5
      │    ├── fd: ()-->(3,4)
      │    └── select
      │         ├── columns: k:1!null f:3!null s:4!null
      │         ├── key: (1)
      │         ├── fd: ()-->(3,4)
      │         ├── scan p@idx,partial
      │         │    ├── columns: k:1!null f:3 s:4!null
      │         │    ├── key: (1)
      │         │    └── fd: ()-->(4), (1)-->(3)
      │         └── filters
      │              └── f:3 = 1.0 [outer=(3), constraints=(/3: [/1.0 - /1.0]; tight), fd=()-->(3)]
      └── filters
           └── b:5 [outer=(5), constraints=(/5: [/true - /true]; tight), fd=()-->(5)]

# Generate multiple partial index scans when there are multiple partial indexes
# that have predicates implied by the filters.

exec-ddl
CREATE INDEX idx2 ON p (s) WHERE i > 0
----

memo expect=GeneratePartialIndexScans
SELECT * FROM p WHERE i > 0 AND s = 'foo'
----
memo (optimized, ~14KB, required=[presentation: k:1,i:2,f:3,s:4,b:5])
 ├── G1: (select G2 G3) (index-join G4 p,cols=(1-5)) (index-join G5 p,cols=(1-5)) (index-join G6 p,cols=(1-5)) (index-join G7 p,cols=(1-5))
 │    └── [presentation: k:1,i:2,f:3,s:4,b:5]
 │         ├── best: (index-join G4 p,cols=(1-5))
 │         └── cost: 59.80
 ├── G2: (scan p,cols=(1-5))
 │    └── []
 │         ├── best: (scan p,cols=(1-5))
 │         └── cost: 1126.01
 ├── G3: (filters G8 G9)
 ├── G4: (select G10 G11)
 │    └── []
 │         ├── best: (select G10 G11)
 │         └── cost: 25.73
 ├── G5: (select G12 G13)
 │    └── []
 │         ├── best: (select G12 G13)
 │         └── cost: 364.43
 ├── G6: (scan p@idx,partial,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1-4),constrained)
 │         └── cost: 24.89
 ├── G7: (scan p@idx2,partial,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(1,4),constrained)
 │         └── cost: 24.12
 ├── G8: (gt G14 G15)
 ├── G9: (eq G16 G17)
 ├── G10: (scan p@idx,partial,cols=(1-4))
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1-4))
 │         └── cost: 25.61
 ├── G11: (filters G8)
 ├── G12: (scan p@idx2,partial,cols=(1,4))
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(1,4))
 │         └── cost: 361.08
 ├── G13: (filters G9)
 ├── G14: (variable i)
 ├── G15: (const 0)
 ├── G16: (variable s)
 └── G17: (const 'foo')

# Do not generate a partial index scan when the predicate is not implied by the
# filter.
memo expect-not=GeneratePartialIndexScans
SELECT i FROM p WHERE s = 'bar'
----
memo (optimized, ~8KB, required=[presentation: i:2])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:2]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 1105.54
 ├── G2: (select G4 G5)
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1105.43
 ├── G3: (projections)
 ├── G4: (scan p,cols=(2,4))
 │    └── []
 │         ├── best: (scan p,cols=(2,4))
 │         └── cost: 1095.41
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'bar')

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

exec-ddl
CREATE INDEX idx ON p (b) WHERE s IS NULL AND i = 0
----

# Project constant columns in a partial index predicate rather than performing
# an index join.
opt expect=GeneratePartialIndexScans
SELECT k, b, s, i FROM p WHERE s IS NULL AND i = 0
----
project
 ├── columns: k:1!null b:5 s:4 i:2!null
 ├── key: (1)
 ├── fd: ()-->(2,4), (1)-->(5)
 ├── scan p@idx,partial
 │    ├── columns: k:1!null b:5
 │    ├── key: (1)
 │    └── fd: (1)-->(5)
 └── projections
      ├── 0 [as=i:2]
      └── CAST(NULL AS STRING) [as=s:4]

# Do not project constant columns in a partial index predicate when an index
# join must be performed to fetch other columns.
opt expect=GeneratePartialIndexScans
SELECT k, b, s, i, f FROM p WHERE s IS NULL AND i = 0
----
index-join p
 ├── columns: k:1!null b:5 s:4 i:2!null f:3
 ├── key: (1)
 ├── fd: ()-->(2,4), (1)-->(3,5)
 └── scan p@idx,partial
      ├── columns: k:1!null b:5
      ├── key: (1)
      └── fd: (1)-->(5)

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (b) STORING (i) WHERE s IS NULL
----

# Project constant columns in a partial index predicate and apply a filter.
opt expect=GeneratePartialIndexScans
SELECT k, b, s FROM p WHERE s IS NULL AND i = 0
----
project
 ├── columns: k:1!null b:5 s:4
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(5)
 └── select
      ├── columns: k:1!null i:2!null s:4 b:5
      ├── key: (1)
      ├── fd: ()-->(2,4), (1)-->(5)
      ├── project
      │    ├── columns: s:4 k:1!null i:2 b:5
      │    ├── key: (1)
      │    ├── fd: ()-->(4), (1)-->(2,5)
      │    ├── scan p@idx,partial
      │    │    ├── columns: k:1!null i:2 b:5
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2,5)
      │    └── projections
      │         └── CAST(NULL AS STRING) [as=s:4]
      └── filters
           └── i:2 = 0 [outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (f, s) STORING (b) WHERE s IS NULL AND b AND i = 0
----

# Project only constant columns in the partial index predicate that do not exist
# in the index.
opt expect=GeneratePartialIndexScans
SELECT * FROM p WHERE s IS NULL AND b AND i = 0
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 b:5!null
 ├── key: (1)
 ├── fd: ()-->(2,4,5), (1)-->(3)
 ├── scan p@idx,partial
 │    ├── columns: k:1!null f:3 s:4 b:5!null
 │    ├── key: (1)
 │    └── fd: ()-->(4,5), (1)-->(3)
 └── projections
      └── 0 [as=i:2]

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (i) WHERE f = 1.0
----

# Do not project constant columns with composite key encodings.
opt expect=GeneratePartialIndexScans
SELECT i, f FROM p WHERE f = 1.0
----
index-join p
 ├── columns: i:2 f:3!null
 ├── fd: ()-->(3)
 └── scan p@idx,partial
      ├── columns: k:1!null i:2
      ├── key: (1)
      └── fd: (1)-->(2)

exec-ddl
DROP INDEX idx
----

opt
SELECT k FROM virtual WHERE c IN (10, 20, 30)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan virtual@secondary,partial
      ├── columns: k:1!null
      └── key: (1)

# TODO(mgartner): The normalization of the query filter from (c = 20) to ((b +
# 10) = 20) to (b = 10) and the lack of constraints for the partial index
# predicate ((b + 10) IN (10, 20, 30)) prevents implication from being proven. A
# normalization rule similar to NormalizeCmpPlusConst, but that applies to an IN
# expression might resolve this specific issue. However, there could be many
# more combinations of filters and predicates that make partial index
# implication difficult or impossible.
opt
SELECT k FROM virtual WHERE c = 20
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null b:3!null
      ├── key: (1)
      ├── fd: ()-->(3)
      ├── scan virtual
      │    ├── columns: k:1!null b:3
      │    ├── computed column expressions
      │    │    ├── c:4
      │    │    │    └── b:3 + 10
      │    │    ├── lower_s:6
      │    │    │    └── lower(s:5)
      │    │    └── upper_s:7
      │    │         └── upper(s:5)
      │    ├── partial index predicates
      │    │    ├── secondary: filters
      │    │    │    └── (b:3 + 10) IN (10, 20, 30) [outer=(3), immutable]
      │    │    ├── secondary: filters
      │    │    │    └── upper(s:5) = 'FOO' [outer=(5), immutable]
      │    │    └── secondary: filters
      │    │         └── b:3 > 90 [outer=(3), constraints=(/3: [/91 - ]; tight)]
      │    ├── key: (1)
      │    └── fd: (1)-->(3)
      └── filters
           └── b:3 = 10 [outer=(3), constraints=(/3: [/10 - /10]; tight), fd=()-->(3)]

opt
SELECT k FROM virtual WHERE (b + 10) IN (10, 20, 30)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan virtual@secondary,partial
      ├── columns: k:1!null
      └── key: (1)

# --------------------------------------------------
# GenerateConstrainedScans
# --------------------------------------------------

opt
SELECT k FROM a WHERE k = 1
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

memo
SELECT k FROM a WHERE k = 1
----
memo (optimized, ~5KB, required=[presentation: k:1])
 ├── G1: (select G2 G3) (scan a,cols=(1),constrained)
 │    └── [presentation: k:1]
 │         ├── best: (scan a,cols=(1),constrained)
 │         └── cost: 5.05
 ├── G2: (scan a,cols=(1)) (scan a@u,cols=(1)) (scan a@v,cols=(1))
 │    └── []
 │         ├── best: (scan a,cols=(1))
 │         └── cost: 1064.81
 ├── G3: (filters G4)
 ├── G4: (eq G5 G6)
 ├── G5: (variable k)
 └── G6: (const 1)

opt
SELECT k FROM a WHERE v > 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan a@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/2 - ]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT k FROM a WHERE v > 1
----
memo (optimized, ~6KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 364.67
 ├── G2: (select G4 G5) (scan a@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1,3),constrained)
 │         └── cost: 361.36
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,3)) (scan a@u,cols=(1,3)) (scan a@v,cols=(1,3))
 │    └── []
 │         ├── best: (scan a,cols=(1,3))
 │         └── cost: 1075.01
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable v)
 └── G8: (const 1)

opt
SELECT k FROM a WHERE u = 1 AND k = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/5 - /1/5]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k = 5
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.08
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1075.01
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 5)

# Constraint + remaining filter.
opt
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan a@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1: [/1/0 - /1/0]
      ├── cardinality: [0 - 1]
      ├── key: ()
      └── fd: ()-->(1,2)

memo
SELECT k FROM a WHERE u = 1 AND k+u = 1
----
memo (optimized, ~8KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.08
 ├── G2: (select G4 G5) (select G6 G7) (scan a@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1,2)) (scan a@u,cols=(1,2)) (scan a@v,cols=(1,2))
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1075.01
 ├── G5: (filters G8 G9)
 ├── G6: (scan a,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan a,cols=(1,2),constrained)
 │         └── cost: 5.06
 ├── G7: (filters G8)
 ├── G8: (eq G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (variable u)
 ├── G11: (const 1)
 ├── G12: (variable k)
 └── G13: (const 0)

opt
SELECT k FROM a WHERE u = 1 AND v = 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-3)
      ├── scan a@v
      │    ├── columns: k:1!null u:2 v:3!null
      │    ├── constraint: /3: [/5 - /5]
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    └── fd: ()-->(1-3)
      └── filters
           └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

memo
SELECT k FROM a WHERE u = 1 AND v = 5
----
memo (optimized, ~9KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G2 G3 k)
 │         └── cost: 5.12
 ├── G2: (select G4 G5) (select G6 G7) (select G8 G9)
 │    └── []
 │         ├── best: (select G8 G9)
 │         └── cost: 5.10
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1-3)) (scan a@u,cols=(1-3)) (scan a@v,cols=(1-3))
 │    └── []
 │         ├── best: (scan a,cols=(1-3))
 │         └── cost: 1085.21
 ├── G5: (filters G10 G11)
 ├── G6: (scan a@u,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@u,cols=(1-3),constrained)
 │         └── cost: 25.21
 ├── G7: (filters G11)
 ├── G8: (scan a@v,cols=(1-3),constrained)
 │    └── []
 │         ├── best: (scan a@v,cols=(1-3),constrained)
 │         └── cost: 5.07
 ├── G9: (filters G10)
 ├── G10: (eq G12 G13)
 ├── G11: (eq G14 G15)
 ├── G12: (variable u)
 ├── G13: (const 1)
 ├── G14: (variable v)
 └── G15: (const 5)

# Only not-null constraint is pushed down.
opt
SELECT k FROM a WHERE u=v
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null u:2!null v:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)-->(1), (2)==(3), (3)==(2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── constraint: /2/1: (/NULL - ]
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (3)~~>(1,2)
      └── filters
           └── u:2 = v:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]

# Don't push constraint into already limited scan.
opt
SELECT k FROM (SELECT k FROM a ORDER BY u LIMIT 1) a WHERE k = 1
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: k:1!null u:2
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1,2)
      ├── scan a@u
      │    ├── columns: k:1!null u:2
      │    ├── limit: 1
      │    ├── key: ()
      │    └── fd: ()-->(1,2)
      └── filters
           └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]

# Constraint + index-join, with no remainder filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── cardinality: [0 - 10]
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10
----
memo (optimized, ~6KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (index-join G4 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G4 b,cols=(1-4))
 │         └── cost: 75.12
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G5)
 ├── G4: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G5: (range G6)
 ├── G6: (and G7 G8)
 ├── G7: (ge G9 G10)
 ├── G8: (le G9 G11)
 ├── G9: (variable v)
 ├── G10: (const 1)
 └── G11: (const 10)

# Don't choose lookup join if it's not beneficial.
opt
SELECT * FROM b WHERE v > 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── scan b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── filters
      └── v:3 > 1 [outer=(3), constraints=(/3: [/2 - ]; tight)]

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── select
      ├── columns: k:1!null v:3!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(3), (3)-->(1)
      ├── scan b@v
      │    ├── columns: k:1!null v:3!null
      │    ├── constraint: /3: [/1 - /10]
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    └── fd: (1)-->(3), (3)-->(1)
      └── filters
           └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k > 5
----
memo (optimized, ~8KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 b,cols=(1-4))
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (index-join G6 b,cols=(1-4))
 │         └── cost: 47.19
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G7 G8)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 374.81
 ├── G5: (filters G7)
 ├── G6: (select G9 G10)
 │    └── []
 │         ├── best: (select G9 G10)
 │         └── cost: 14.53
 ├── G7: (range G11)
 ├── G8: (gt G12 G13)
 ├── G9: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G10: (filters G8)
 ├── G11: (and G14 G15)
 ├── G12: (variable k)
 ├── G13: (const 5)
 ├── G14: (ge G16 G17)
 ├── G15: (le G16 G18)
 ├── G16: (variable v)
 ├── G17: (const 1)
 └── G18: (const 10)

# Ensure the rule doesn't match at all when the first column of the index is
# not in the filter (i.e. the @v index is not matched by ConstrainScans).
exploretrace rule=GenerateConstrainedScans
SELECT k FROM a WHERE u = 1
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── select
        ├── columns: k:1!null u:2!null
        ├── key: (1)
        ├── fd: ()-->(2)
        ├── scan a
        │    ├── columns: k:1!null u:2
        │    ├── key: (1)
        │    └── fd: (1)-->(2)
        └── filters
             └── u:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

New expression 1 of 1:
  project
   ├── columns: k:1!null
   ├── key: (1)
   └── scan a@u
        ├── columns: k:1!null u:2!null
        ├── constraint: /2/1: [/1 - /1]
        ├── key: (1)
        └── fd: ()-->(2)
----
----

# Constraint + index join + remaining filter.
opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G5)
 │         └── cost: 75.24
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G6 G7)
 ├── G4: (index-join G8 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G8 b,cols=(1-4))
 │         └── cost: 75.12
 ├── G5: (filters G7)
 ├── G6: (range G9)
 ├── G7: (eq G10 G11)
 ├── G8: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G9: (and G12 G13)
 ├── G10: (plus G14 G15)
 ├── G11: (const 1)
 ├── G12: (ge G16 G11)
 ├── G13: (le G16 G17)
 ├── G14: (variable k)
 ├── G15: (variable u)
 ├── G16: (variable v)
 └── G17: (const 10)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── select
 │         ├── columns: k:1!null v:3!null
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(3), (3)-->(1)
 │         ├── scan b@v
 │         │    ├── columns: k:1!null v:3!null
 │         │    ├── constraint: /3: [/1 - /10]
 │         │    ├── cardinality: [0 - 10]
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3), (3)-->(1)
 │         └── filters
 │              └── k:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

memo
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 AND k > 5
----
memo (optimized, ~9KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G6 G7)
 │         └── cost: 34.83
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G8 G9 G10)
 ├── G4: (scan b,cols=(1-4),constrained)
 │    └── []
 │         ├── best: (scan b,cols=(1-4),constrained)
 │         └── cost: 374.81
 ├── G5: (filters G8 G9)
 ├── G6: (index-join G11 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G11 b,cols=(1-4))
 │         └── cost: 34.77
 ├── G7: (filters G9)
 ├── G8: (range G12)
 ├── G9: (eq G13 G14)
 ├── G10: (gt G15 G16)
 ├── G11: (select G17 G18)
 │    └── []
 │         ├── best: (select G17 G18)
 │         └── cost: 14.53
 ├── G12: (and G19 G20)
 ├── G13: (plus G15 G21)
 ├── G14: (const 1)
 ├── G15: (variable k)
 ├── G16: (const 5)
 ├── G17: (scan b@v,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan b@v,cols=(1,3),constrained)
 │         └── cost: 14.41
 ├── G18: (filters G10)
 ├── G19: (ge G22 G14)
 ├── G20: (le G22 G23)
 ├── G21: (variable u)
 ├── G22: (variable v)
 └── G23: (const 10)

# Constraint + index-join.
opt
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
select
 ├── columns: k:1!null u:2!null v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@u
 │         ├── columns: k:1!null u:2!null
 │         ├── constraint: /2/1: [/1/2 - /8/9]
 │         ├── key: (1)
 │         └── fd: (1)-->(2)
 └── filters
      ├── (u:2, k:1, v:3) > (1, 2, 3) [outer=(1-3), immutable, constraints=(/2/1/3: [/1/2/4 - ]; tight)]
      └── (u:2, k:1, v:3) < (8, 9, 10) [outer=(1-3), immutable, constraints=(/2/1/3: (/NULL - /8/9/9]; tight)]

memo
SELECT * FROM b WHERE (u, k, v) > (1, 2, 3) AND (u, k, v) < (8, 9, 10)
----
memo (optimized, ~7KB, required=[presentation: k:1,u:2,v:3,j:4])
 ├── G1: (select G2 G3) (select G4 G3)
 │    └── [presentation: k:1,u:2,v:3,j:4]
 │         ├── best: (select G4 G3)
 │         └── cost: 584.05
 ├── G2: (scan b,cols=(1-4))
 │    └── []
 │         ├── best: (scan b,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G5 G6)
 ├── G4: (index-join G7 b,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G7 b,cols=(1-4))
 │         └── cost: 583.22
 ├── G5: (gt G8 G9)
 ├── G6: (lt G8 G10)
 ├── G7: (scan b@u,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan b@u,cols=(1,2),constrained)
 │         └── cost: 97.61
 ├── G8: (tuple G11)
 ├── G9: (tuple G12)
 ├── G10: (tuple G13)
 ├── G11: (scalar-list G14 G15 G16)
 ├── G12: (scalar-list G17 G18 G19)
 ├── G13: (scalar-list G20 G21 G22)
 ├── G14: (variable u)
 ├── G15: (variable k)
 ├── G16: (variable v)
 ├── G17: (const 1)
 ├── G18: (const 2)
 ├── G19: (const 3)
 ├── G20: (const 8)
 ├── G21: (const 9)
 └── G22: (const 10)

# GenerateConstrainedScans propagates row-level locking information.
opt
SELECT k FROM a WHERE k = 1 FOR UPDATE
----
scan a
 ├── columns: k:1!null
 ├── constraint: /1: [/1 - /1]
 ├── locking: for-update
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 └── fd: ()-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 FOR UPDATE
----
index-join b
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 └── scan b@v
      ├── columns: k:1!null v:3!null
      ├── constraint: /3: [/1 - /10]
      ├── locking: for-update
      ├── cardinality: [0 - 10]
      ├── volatile
      ├── key: (1)
      └── fd: (1)-->(3), (3)-->(1)

opt
SELECT * FROM b WHERE v >= 1 AND v <= 10 AND k+u = 1 FOR UPDATE
----
select
 ├── columns: k:1!null u:2 v:3!null j:4
 ├── cardinality: [0 - 10]
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── cardinality: [0 - 10]
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(1), (3)~~>(1,2,4)
 │    └── scan b@v
 │         ├── columns: k:1!null v:3!null
 │         ├── constraint: /3: [/1 - /10]
 │         ├── locking: for-update
 │         ├── cardinality: [0 - 10]
 │         ├── volatile
 │         ├── key: (1)
 │         └── fd: (1)-->(3), (3)-->(1)
 └── filters
      └── (k:1 + u:2) = 1 [outer=(1,2), immutable]

exec-ddl
CREATE TABLE kifs
(
    k INT PRIMARY KEY,
    i INT,
    f FLOAT,
    s STRING,
    j JSON,
    INDEX s_idx (s) STORING (i, f),
    INDEX si_idx (s DESC, i DESC) STORING (j)
)
----

# Constrain the kifs@si_idx so that an index join is generated.
exploretrace rule=GenerateConstrainedScans
SELECT s, i, f FROM kifs WHERE s='foo' ORDER BY s, k, i
----
----
================================================================================
GenerateConstrainedScans
================================================================================
Source expression:
  sort
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   ├── ordering: +1 opt(4) [actual: +1]
   └── select
        ├── columns: k:1!null i:2 f:3 s:4!null
        ├── key: (1)
        ├── fd: ()-->(4), (1)-->(2,3)
        ├── scan kifs@s_idx
        │    ├── columns: k:1!null i:2 f:3 s:4
        │    ├── key: (1)
        │    └── fd: (1)-->(2-4)
        └── filters
             └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

New expression 1 of 2:
  scan kifs@s_idx
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── constraint: /4/1: [/'foo' - /'foo']
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   └── ordering: +1 opt(4) [actual: +1]

New expression 2 of 2:
  index-join kifs
   ├── columns: s:4!null i:2 f:3  [hidden: k:1!null]
   ├── key: (1)
   ├── fd: ()-->(4), (1)-->(2,3)
   ├── ordering: +1 opt(4) [actual: +1]
   └── sort
        ├── columns: k:1!null i:2 s:4!null
        ├── key: (1)
        ├── fd: ()-->(4), (1)-->(2)
        ├── ordering: +1 opt(4) [actual: +1]
        └── scan kifs@si_idx
             ├── columns: k:1!null i:2 s:4!null
             ├── constraint: /-4/-2/1: [/'foo' - /'foo']
             ├── key: (1)
             └── fd: ()-->(4), (1)-->(2)
----
----

memo
SELECT s, i, f FROM kifs WHERE s='foo' ORDER BY s DESC, i
----
memo (optimized, ~6KB, required=[presentation: s:4,i:2,f:3] [ordering: +2 opt(4)])
 ├── G1: (select G2 G3) (scan kifs@s_idx,cols=(2-4),constrained) (index-join G4 kifs,cols=(2-4))
 │    ├── [presentation: s:4,i:2,f:3] [ordering: +2 opt(4)]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 26.58
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(2-4),constrained)
 │         └── cost: 25.41
 ├── G2: (scan kifs,cols=(2-4)) (scan kifs@s_idx,cols=(2-4))
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1178.64
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kifs@s_idx,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (filters G5)
 ├── G4: (scan kifs@si_idx,cols=(1,2,4),constrained)
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (scan kifs@si_idx,rev,cols=(1,2,4),constrained)
 │    │    └── cost: 26.07
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(1,2,4),constrained)
 │         └── cost: 25.41
 ├── G5: (eq G6 G7)
 ├── G6: (variable s)
 └── G7: (const 'foo')

memo
SELECT j FROM kifs WHERE s = 'foo'
----
memo (optimized, ~7KB, required=[presentation: j:5])
 ├── G1: (project G2 G3 j)
 │    └── [presentation: j:5]
 │         ├── best: (project G2 G3 j)
 │         └── cost: 25.32
 ├── G2: (select G4 G5) (index-join G6 kifs,cols=(4,5)) (scan kifs@si_idx,cols=(4,5),constrained)
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(4,5),constrained)
 │         └── cost: 25.21
 ├── G3: (projections)
 ├── G4: (scan kifs,cols=(4,5)) (scan kifs@si_idx,cols=(4,5))
 │    └── []
 │         ├── best: (scan kifs@si_idx,cols=(4,5))
 │         └── cost: 1085.21
 ├── G5: (filters G7)
 ├── G6: (scan kifs@s_idx,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,4),constrained)
 │         └── cost: 25.21
 ├── G7: (eq G8 G9)
 ├── G8: (variable s)
 └── G9: (const 'foo')

memo
SELECT i, k FROM kifs WHERE s >= 'foo'
----
memo (optimized, ~6KB, required=[presentation: i:2,k:1])
 ├── G1: (project G2 G3 k i)
 │    └── [presentation: i:2,k:1]
 │         ├── best: (project G2 G3 k i)
 │         └── cost: 374.72
 ├── G2: (select G4 G5) (scan kifs@s_idx,cols=(1,2,4),constrained) (scan kifs@si_idx,cols=(1,2,4),constrained)
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,2,4),constrained)
 │         └── cost: 371.38
 ├── G3: (projections)
 ├── G4: (scan kifs,cols=(1,2,4)) (scan kifs@s_idx,cols=(1,2,4)) (scan kifs@si_idx,cols=(1,2,4))
 │    └── []
 │         ├── best: (scan kifs@s_idx,cols=(1,2,4))
 │         └── cost: 1095.41
 ├── G5: (filters G6)
 ├── G6: (ge G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'foo')

# Collated strings are treated properly.
exec-ddl
CREATE TABLE x (s STRING COLLATE en_u_ks_level1 PRIMARY KEY)
----

opt
SELECT s FROM x WHERE s < 'hello' COLLATE en_u_ks_level1
----
scan x
 ├── columns: s:1!null
 ├── constraint: /1: [ - /'hello' COLLATE en_u_ks_level1)
 └── key: (1)

opt
SELECT s FROM x WHERE s = 'hello' COLLATE en_u_ks_level1
----
scan x
 ├── columns: s:1!null
 ├── constraint: /1: [/'hello' COLLATE en_u_ks_level1 - /'hello' COLLATE en_u_ks_level1]
 ├── cardinality: [0 - 1]
 ├── key: ()
 └── fd: ()-->(1)

# Can't generate spans for other collations.
opt
SELECT s FROM x WHERE s COLLATE en = 'hello' COLLATE en
----
select
 ├── columns: s:1!null
 ├── key: (1)
 ├── scan x
 │    ├── columns: s:1!null
 │    └── key: (1)
 └── filters
      └── s:1 COLLATE en = 'hello' COLLATE en [outer=(1)]

# Realistic example where using constraints as filters help.
# An even more realistic example would have a creation timestamp instead of a
# seq_num integer, but that makes the plans much more cluttered.
exec-ddl
CREATE TABLE "orders" (
  region STRING NOT NULL,
  id INT NOT NULL,
  total DECIMAL NOT NULL,
  seq_num INT NOT NULL,
  PRIMARY KEY (region, id),
  UNIQUE INDEX orders_by_seq_num (region, seq_num, id) STORING (total),
  CHECK (region IN ('us-east1', 'us-west1', 'europe-west2'))
)
----

exec-ddl
ALTER TABLE "orders" INJECT STATISTICS '[
  {
    "columns": ["region"],
    "distinct_count": 3,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["id"],
    "distinct_count": 100,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["total"],
    "distinct_count": 100,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["seq_num"],
    "distinct_count": 50,
    "null_count": 0,
    "row_count": 100,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  }
]'
----

opt
SELECT sum(total) FROM orders WHERE seq_num >= 10 AND seq_num < 20
----
scalar-group-by
 ├── columns: sum:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan orders@orders_by_seq_num
 │    ├── columns: total:3!null seq_num:4!null
 │    └── constraint: /1/4/2
 │         ├── [/'europe-west2'/10 - /'europe-west2'/19]
 │         ├── [/'us-east1'/10 - /'us-east1'/19]
 │         └── [/'us-west1'/10 - /'us-west1'/19]
 └── aggregations
      └── sum [as=sum:7, outer=(3)]
           └── total:3

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT NOT NULL,
  z STRING NOT NULL,
  CHECK (x < 10 AND x > 1),
  CHECK (y < 10 AND y > 1),
  CHECK (z in ('first', 'second')),
  INDEX secondary (y, x),
  INDEX tertiary (z, y, x))
----

opt
SELECT x, y  FROM xyz WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan xyz@tertiary
 │    ├── columns: x:1!null y:2!null
 │    ├── constraint: /3/2/1
 │    │    ├── [/'first'/2/6 - /'first'/9/9]
 │    │    └── [/'second'/2/6 - /'second'/9/9]
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# TODO(ridwanmsharif): Confirm if this makes sense. I would've expected that the primary index
#  would be used here. But it isn't the plan being picked. Curious.
opt
SELECT * FROM xyz WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null z:3!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── scan xyz@tertiary
 │    ├── columns: x:1!null y:2!null z:3!null
 │    ├── constraint: /3/2/1
 │    │    ├── [/'first'/2/6 - /'first'/9/9]
 │    │    └── [/'second'/2/6 - /'second'/9/9]
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3)
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# Check constraint used only for the non nullable column. Constraints on x are ignored.
exec-ddl
CREATE TABLE xy (
  x INT,
  y INT NOT NULL,
  CHECK (x < 10 AND x > 1),
  CHECK (y < 10 AND y > 1),
  INDEX secondary (y, x))
----

opt
SELECT x, y FROM xy WHERE x > 5
----
select
 ├── columns: x:1!null y:2!null
 ├── scan xy@secondary
 │    ├── columns: x:1 y:2!null
 │    └── constraint: /2/1/3: [/2/6 - /9]
 └── filters
      └── x:1 > 5 [outer=(1), constraints=(/1: [/6 - ]; tight)]

# Check constraints that can evaluate to NULL are ignored.
exec-ddl
CREATE TABLE null_constraint (
  y INT NOT NULL,
  CHECK (y IN (1, 2, NULL)),
  INDEX index_1 (y))
----

opt
SELECT y FROM null_constraint WHERE y > 0
----
scan null_constraint@index_1
 ├── columns: y:1!null
 └── constraint: /1/2: [/1 - ]

exec-ddl
CREATE TABLE null_constraint_2 (
  y INT NOT NULL,
  CHECK ((y IN (1, 2, NULL)) AND (y > 10)),
  CHECK (y < 15),
  INDEX index_1 (y))
----

opt
SELECT y FROM null_constraint_2 WHERE y > 0
----
scan null_constraint_2@index_1
 ├── columns: y:1!null
 └── constraint: /1/2: [/1 - /14]

# Unvalidated constraints are ignored.
exec-ddl
CREATE TABLE check_constraint_validity (
 a int NOT NULL,
 INDEX secondary (a),
 CONSTRAINT "check:unvalidated" CHECK (a < 10),
 CONSTRAINT "check:validated" CHECK (a < 20))
----

opt
SELECT * FROM check_constraint_validity WHERE a > 6
----
scan check_constraint_validity@secondary
 ├── columns: a:1!null
 └── constraint: /1/2: [/7 - /19]

# Test that we can constrain indexes using the results of now().
exec-ddl
CREATE TABLE with_time_index (k INT PRIMARY KEY, time TIMESTAMP, INDEX(time))
----

opt
SELECT * FROM with_time_index WHERE time > now() - INTERVAL '1 hour'
----
scan with_time_index@secondary
 ├── columns: k:1!null time:2!null
 ├── constraint: /2/1: [/'2017-05-10 12:00:00.000001' - ]
 ├── key: (1)
 └── fd: (1)-->(2)

opt
SELECT * FROM with_time_index WHERE time >= 'today'
----
scan with_time_index@secondary
 ├── columns: k:1!null time:2!null
 ├── constraint: /2/1: [/'2017-05-10 00:00:00' - ]
 ├── key: (1)
 └── fd: (1)-->(2)

# Test that we can constrain an index on a virtual column with a function in the
# expression.
opt expect=GenerateConstrainedScans
SELECT k FROM virtual WHERE lower_s = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan virtual@secondary
      ├── columns: k:1!null
      ├── constraint: /6/1: [/'foo' - /'foo']
      └── key: (1)

# Constrained partial index scan.

exec-ddl
CREATE INDEX idx ON p (i) STORING (f, s) WHERE s = 'foo'
----

opt
SELECT i FROM p WHERE s = 'foo' AND i > 5 AND i < 10
----
project
 ├── columns: i:2!null
 └── scan p@idx,partial
      ├── columns: i:2!null s:4!null
      ├── constraint: /2/1: [/6 - /9]
      └── fd: ()-->(4)

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with indexed column in predicate.

exec-ddl
CREATE INDEX idx ON p (i) WHERE i > 0
----

opt
SELECT i FROM p WHERE i > 10 AND i < 20
----
scan p@idx,partial
 ├── columns: i:2!null
 └── constraint: /2/1: [/11 - /19]

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with index-join.

exec-ddl
CREATE INDEX idx ON p (i) WHERE s = 'foo'
----

opt
SELECT * FROM p WHERE s = 'foo' AND i > 5 AND i < 10
----
index-join p
 ├── columns: k:1!null i:2!null f:3 s:4!null b:5
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 └── scan p@idx,partial
      ├── columns: k:1!null i:2!null
      ├── constraint: /2/1: [/6 - /9]
      ├── key: (1)
      └── fd: (1)-->(2)

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with additional filter.

exec-ddl
CREATE INDEX idx ON p (i) WHERE i > 0
----

opt
SELECT i FROM p WHERE i > 10 AND i < 20 AND b
----
project
 ├── columns: i:2!null
 └── select
      ├── columns: i:2!null b:5!null
      ├── fd: ()-->(5)
      ├── index-join p
      │    ├── columns: i:2 b:5
      │    └── scan p@idx,partial
      │         ├── columns: k:1!null i:2!null
      │         ├── constraint: /2/1: [/11 - /19]
      │         ├── key: (1)
      │         └── fd: (1)-->(2)
      └── filters
           └── b:5 [outer=(5), constraints=(/5: [/true - /true]; tight), fd=()-->(5)]

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with additional filters before and after an
# index-join.

exec-ddl
CREATE INDEX idx ON p (i) STORING (s) where i > 0
----

opt
SELECT * FROM p WHERE i > 10 AND i < 20 AND s = 'bar' AND b
----
select
 ├── columns: k:1!null i:2!null f:3 s:4!null b:5!null
 ├── key: (1)
 ├── fd: ()-->(4,5), (1)-->(2,3)
 ├── index-join p
 │    ├── columns: k:1!null i:2 f:3 s:4 b:5
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    └── select
 │         ├── columns: k:1!null i:2!null s:4!null
 │         ├── key: (1)
 │         ├── fd: ()-->(4), (1)-->(2)
 │         ├── scan p@idx,partial
 │         │    ├── columns: k:1!null i:2!null s:4
 │         │    ├── constraint: /2/1: [/11 - /19]
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2,4)
 │         └── filters
 │              └── s:4 = 'bar' [outer=(4), constraints=(/4: [/'bar' - /'bar']; tight), fd=()-->(4)]
 └── filters
      └── b:5 [outer=(5), constraints=(/5: [/true - /true]; tight), fd=()-->(5)]

exec-ddl
DROP INDEX idx
----

# Generate multiple partial index scans in the memo when the filter implies
# multiple partial index predicates.

exec-ddl
CREATE INDEX idx ON p (s) WHERE i > 0
----

exec-ddl
CREATE INDEX idx2 ON p (i) WHERE s = 'foo'
----

memo
SELECT i FROM p WHERE i = 3 AND s = 'foo'
----
memo (optimized, ~18KB, required=[presentation: i:2])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:2]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 15.30
 ├── G2: (select G4 G5) (select G6 G7) (select G8 G7) (select G9 G7) (project G10 G11 i)
 │    └── []
 │         ├── best: (project G10 G11 i)
 │         └── cost: 15.28
 ├── G3: (projections)
 ├── G4: (scan p,cols=(2,4))
 │    └── []
 │         ├── best: (scan p,cols=(2,4))
 │         └── cost: 1095.41
 ├── G5: (filters G12 G13)
 ├── G6: (index-join G14 p,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G14 p,cols=(2,4))
 │         └── cost: 385.03
 ├── G7: (filters G12)
 ├── G8: (project G15 G11 i)
 │    └── []
 │         ├── best: (project G15 G11 i)
 │         └── cost: 24.82
 ├── G9: (index-join G16 p,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G16 p,cols=(2,4))
 │         └── cost: 80.78
 ├── G10: (scan p@idx2,partial,cols=(2),constrained)
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(2),constrained)
 │         └── cost: 15.25
 ├── G11: (projections G17)
 ├── G12: (eq G18 G19)
 ├── G13: (eq G20 G17)
 ├── G14: (select G21 G22)
 │    └── []
 │         ├── best: (select G21 G22)
 │         └── cost: 364.43
 ├── G15: (scan p@idx2,partial,cols=(2))
 │    └── []
 │         ├── best: (scan p@idx2,partial,cols=(2))
 │         └── cost: 24.61
 ├── G16: (scan p@idx,partial,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1,4),constrained)
 │         └── cost: 24.12
 ├── G17: (const 'foo')
 ├── G18: (variable i)
 ├── G19: (const 3)
 ├── G20: (variable s)
 ├── G21: (scan p@idx,partial,cols=(1,4))
 │    └── []
 │         ├── best: (scan p@idx,partial,cols=(1,4))
 │         └── cost: 361.08
 └── G22: (filters G13)

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

# Do not use partial indexes when the predicate is not implied by the filter.

exec-ddl
CREATE INDEX idx ON p (i) WHERE s = 'foo'
----

memo expect-not=GenerateConstrainedScans
SELECT i FROM p WHERE s = 'bar' AND i = 5
----
memo (optimized, ~7KB, required=[presentation: i:2])
 ├── G1: (project G2 G3 i)
 │    └── [presentation: i:2]
 │         ├── best: (project G2 G3 i)
 │         └── cost: 1105.46
 ├── G2: (select G4 G5)
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1105.44
 ├── G3: (projections)
 ├── G4: (scan p,cols=(2,4))
 │    └── []
 │         ├── best: (scan p,cols=(2,4))
 │         └── cost: 1095.41
 ├── G5: (filters G6 G7)
 ├── G6: (eq G8 G9)
 ├── G7: (eq G10 G11)
 ├── G8: (variable s)
 ├── G9: (const 'bar')
 ├── G10: (variable i)
 └── G11: (const 5)

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (b) WHERE s IS NULL AND i = 0
----

# Project constant columns in a partial index predicate rather than performing
# an index join.
opt expect=GenerateConstrainedScans
SELECT k, b, s, i FROM p WHERE b AND s IS NULL AND i = 0
----
project
 ├── columns: k:1!null b:5!null s:4 i:2!null
 ├── key: (1)
 ├── fd: ()-->(2,4,5)
 ├── scan p@idx,partial
 │    ├── columns: k:1!null b:5!null
 │    ├── constraint: /5/1: [/true - /true]
 │    ├── key: (1)
 │    └── fd: ()-->(5)
 └── projections
      ├── 0 [as=i:2]
      └── CAST(NULL AS STRING) [as=s:4]

# Do not project constant columns in a partial index predicate when an index
# join must be performed to fetch other columns.
opt expect=GenerateConstrainedScans
SELECT k, b, s, i, f FROM p WHERE b AND s IS NULL AND i = 0
----
index-join p
 ├── columns: k:1!null b:5!null s:4 i:2!null f:3
 ├── key: (1)
 ├── fd: ()-->(2,4,5), (1)-->(3)
 └── scan p@idx,partial
      ├── columns: k:1!null b:5!null
      ├── constraint: /5/1: [/true - /true]
      ├── key: (1)
      └── fd: ()-->(5)

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (b) STORING (i) WHERE s IS NULL
----

# Project constant columns in a partial index predicate and apply a filter.
opt expect=GenerateConstrainedScans
SELECT k, b, s FROM p WHERE b AND s IS NULL AND i = 0
----
project
 ├── columns: k:1!null b:5!null s:4
 ├── key: (1)
 ├── fd: ()-->(4,5)
 └── select
      ├── columns: k:1!null i:2!null s:4 b:5!null
      ├── key: (1)
      ├── fd: ()-->(2,4,5)
      ├── project
      │    ├── columns: s:4 k:1!null i:2 b:5!null
      │    ├── key: (1)
      │    ├── fd: ()-->(4,5), (1)-->(2)
      │    ├── scan p@idx,partial
      │    │    ├── columns: k:1!null i:2 b:5!null
      │    │    ├── constraint: /5/1: [/true - /true]
      │    │    ├── key: (1)
      │    │    └── fd: ()-->(5), (1)-->(2)
      │    └── projections
      │         └── CAST(NULL AS STRING) [as=s:4]
      └── filters
           └── i:2 = 0 [outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (f, s) STORING (b) WHERE s IS NULL AND b AND i = 0
----

# Project only constant columns in the partial index predicate that do not exist
# in the index.
opt expect=GenerateConstrainedScans
SELECT * FROM p WHERE f > 1.0 AND s IS NULL AND b AND i = 0
----
project
 ├── columns: k:1!null i:2!null f:3!null s:4 b:5!null
 ├── key: (1)
 ├── fd: ()-->(2,4,5), (1)-->(3)
 ├── scan p@idx,partial
 │    ├── columns: k:1!null f:3!null s:4 b:5!null
 │    ├── constraint: /3/4/1: [/1.0000000000000002 - ]
 │    ├── key: (1)
 │    └── fd: ()-->(4,5), (1)-->(3)
 └── projections
      └── 0 [as=i:2]

exec-ddl
DROP INDEX idx
----

exec-ddl
CREATE INDEX idx ON p (i) WHERE f = 1.0
----

# Do not project constant columns with composite key encodings.
opt expect=GenerateConstrainedScans
SELECT i, f FROM p WHERE i = 0 AND f = 1.0
----
index-join p
 ├── columns: i:2!null f:3!null
 ├── fd: ()-->(2,3)
 └── scan p@idx,partial
      ├── columns: k:1!null i:2!null
      ├── constraint: /2/1: [/0 - /0]
      ├── key: (1)
      └── fd: ()-->(2)

exec-ddl
DROP INDEX idx
----

# Constrained partial index scan with a virtual computed column in the
# predicate.
opt
SELECT k FROM virtual WHERE a > 10 AND a < 20 AND c IN (10, 20, 30)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan virtual@secondary,partial
      ├── columns: k:1!null a:2!null
      ├── constraint: /2/1: [/11 - /19]
      ├── key: (1)
      └── fd: (1)-->(2)

# TODO(mgartner): The normalization of the query filter from (c = 20) to ((b +
# 10) = 20) to (b = 10) and the lack of constraints for the partial index
# predicate ((b + 10) IN (10, 20, 30)) prevents implication from being proven. A
# normalization rule similar to NormalizeCmpPlusConst, but that applies to an IN
# expression might resolve this specific issue. However, there could be many
# more combinations of filters and predicates that make partial index
# implication difficult or impossible.
opt
SELECT k FROM virtual WHERE a > 10 AND a < 20 AND c = 20
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2!null b:3!null
      ├── key: (1)
      ├── fd: ()-->(3), (1)-->(2)
      ├── scan virtual
      │    ├── columns: k:1!null a:2 b:3
      │    ├── computed column expressions
      │    │    ├── c:4
      │    │    │    └── b:3 + 10
      │    │    ├── lower_s:6
      │    │    │    └── lower(s:5)
      │    │    └── upper_s:7
      │    │         └── upper(s:5)
      │    ├── partial index predicates
      │    │    ├── secondary: filters
      │    │    │    └── (b:3 + 10) IN (10, 20, 30) [outer=(3), immutable]
      │    │    ├── secondary: filters
      │    │    │    └── upper(s:5) = 'FOO' [outer=(5), immutable]
      │    │    └── secondary: filters
      │    │         └── b:3 > 90 [outer=(3), constraints=(/3: [/91 - ]; tight)]
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3)
      └── filters
           ├── (a:2 > 10) AND (a:2 < 20) [outer=(2), constraints=(/2: [/11 - /19]; tight)]
           └── b:3 = 10 [outer=(3), constraints=(/3: [/10 - /10]; tight), fd=()-->(3)]

# Test that we can constrain a partial index with a virtual column in the
# predicate.
opt expect=GenerateConstrainedScans
SELECT k FROM virtual WHERE a > 1 AND a < 10 AND upper_s = 'FOO'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan virtual@secondary,partial
      ├── columns: k:1!null a:2!null
      ├── constraint: /2/1: [/2 - /9]
      ├── key: (1)
      └── fd: (1)-->(2)

# Constrained partial index scan with an indexed virtual computed column also in
# the predicate.
# TODO(mgartner): Teach indexConstraintCtx.simplifyFilter to remove b=140 from
# the remaining filters after the index constraint is built. This will eliminate
# the unnecessary index-join and select expressions.
opt
SELECT k FROM virtual WHERE c = 150
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null b:3!null
      ├── key: (1)
      ├── fd: ()-->(3)
      ├── index-join virtual
      │    ├── columns: k:1!null b:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── scan virtual@secondary,partial
      │         ├── columns: k:1!null
      │         ├── constraint: /4/1: [/150 - /150]
      │         └── key: (1)
      └── filters
           └── b:3 = 140 [outer=(3), constraints=(/3: [/140 - /140]; tight), fd=()-->(3)]

# Constrain a scan on a partial index on virtual column c constraining the
# dependent column b.
# TODO(mgartner): Teach indexConstraintCtx.simplifyFilter to remove b=140 from
# the remaining filters after the index constraint is built. This will eliminate
# the unnecessary index-join and select expressions.
opt
SELECT k FROM virtual WHERE b = 140
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null b:3!null
      ├── key: (1)
      ├── fd: ()-->(3)
      ├── index-join virtual
      │    ├── columns: k:1!null b:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── scan virtual@secondary,partial
      │         ├── columns: k:1!null
      │         ├── constraint: /4/1: [/150 - /150]
      │         └── key: (1)
      └── filters
           └── b:3 = 140 [outer=(3), constraints=(/3: [/140 - /140]; tight), fd=()-->(3)]

# Regression test for #55387. GenerateConstrainedScans should not reduce the
# input filters when proving partial index implication.
exec-ddl
CREATE TABLE t55387 (
    k INT PRIMARY KEY,
    a INT,
    b INT,
    INDEX (a) WHERE a > 1,
    INDEX (b) WHERE b > 2
)
----

opt
SELECT k FROM t55387 WHERE a > 1 AND b > 3
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2!null b:3!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── index-join t55387
      │    ├── columns: k:1!null a:2 b:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,3)
      │    └── select
      │         ├── columns: k:1!null b:3!null
      │         ├── key: (1)
      │         ├── fd: (1)-->(3)
      │         ├── scan t55387@secondary,partial
      │         │    ├── columns: k:1!null b:3!null
      │         │    ├── key: (1)
      │         │    └── fd: (1)-->(3)
      │         └── filters
      │              └── b:3 > 3 [outer=(3), constraints=(/3: [/4 - ]; tight)]
      └── filters
           └── a:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]

# Check that we can generate constraints by recognizing computed column
# expressions.
opt
SELECT k FROM computed WHERE lower(s) = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@l_idx
      ├── columns: k:1!null
      ├── constraint: /3/1: [/'foo' - /'foo']
      └── key: (1)

opt
SELECT k FROM computed WHERE (j->'foo')::string LIKE 'bar%'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@fieldstr_idx
      ├── columns: k:1!null
      ├── constraint: /6/1: [/'bar' - /'bas')
      └── key: (1)

# --------------------------------------------------
# GenerateInvertedIndexScans
# --------------------------------------------------

# Query only the primary key with no remaining filter.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

memo expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j @> '{"a": "b"}'
----
memo (optimized, ~7KB, required=[presentation: k:1])
 ├── G1: (project G2 G3 k) (project G4 G3 k)
 │    └── [presentation: k:1]
 │         ├── best: (project G4 G3 k)
 │         └── cost: 129.86
 ├── G2: (select G5 G6) (index-join G4 b,cols=(1,4))
 │    └── []
 │         ├── best: (index-join G4 b,cols=(1,4))
 │         └── cost: 799.81
 ├── G3: (projections)
 ├── G4: (scan b@j_inv_idx,cols=(1),constrained inverted)
 │    └── []
 │         ├── best: (scan b@j_inv_idx,cols=(1),constrained inverted)
 │         └── cost: 128.75
 ├── G5: (scan b,cols=(1,4))
 │    └── []
 │         ├── best: (scan b,cols=(1,4))
 │         └── cost: 1085.21
 ├── G6: (filters G7)
 ├── G7: (contains G8 G9)
 ├── G8: (variable j)
 └── G9: (const '{"a": "b"}')

# Query requiring an index join with no remaining filter.
opt expect=GenerateInvertedIndexScans
SELECT u, k FROM b WHERE j @> '{"a": "b"}'
----
project
 ├── columns: u:2 k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── index-join b
      ├── columns: k:1!null u:2 j:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      └── scan b@j_inv_idx
           ├── columns: k:1!null
           ├── inverted constraint: /7/1
           │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           └── key: (1)

opt expect=GenerateInvertedIndexScans
SELECT j, k FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: j:4!null k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '{"a": "b"}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '2'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans
      │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
      │         └── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
      └── key: (1)

# Disjunction.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j @> '2' OR j @> '1'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
      │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
      │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
      │         └── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
           │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
           │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
           │         └── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Disjunction with non-tight predicate.
opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '[[1, 2]]' OR j @> '[[3, 4]]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false, unique: false
 │         │    ├── union spans: empty
 │         │    └── UNION
 │         │         ├── span expression
 │         │         │    ├── tight: false, unique: true
 │         │         │    ├── union spans: empty
 │         │         │    └── INTERSECTION
 │         │         │         ├── span expression
 │         │         │         │    ├── tight: true, unique: true
 │         │         │         │    └── union spans: ["7\x00\x03\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x03\x00\x01*\x02\x00"]
 │         │         │         └── span expression
 │         │         │              ├── tight: true, unique: true
 │         │         │              └── union spans: ["7\x00\x03\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x03\x00\x01*\x04\x00"]
 │         │         └── span expression
 │         │              ├── tight: false, unique: true
 │         │              ├── union spans: empty
 │         │              └── INTERSECTION
 │         │                   ├── span expression
 │         │                   │    ├── tight: true, unique: true
 │         │                   │    └── union spans: ["7\x00\x03\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x03\x00\x01*\x06\x00"]
 │         │                   └── span expression
 │         │                        ├── tight: true, unique: true
 │         │                        └── union spans: ["7\x00\x03\x00\x03\x00\x01*\b\x00", "7\x00\x03\x00\x03\x00\x01*\b\x00"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:7!null
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["7\x00\x03\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x03\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x03\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x03\x00\x01*\x04\x00"]
 │              │         ├── ["7\x00\x03\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x03\x00\x01*\x06\x00"]
 │              │         └── ["7\x00\x03\x00\x03\x00\x01*\b\x00", "7\x00\x03\x00\x03\x00\x01*\b\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── (j:4 @> '[[1, 2]]') OR (j:4 @> '[[3, 4]]') [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '[{}]'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7\x00\x03\x00\x019", "7\x00\x03\x00\x019"]
      │         └── ["7\x00\x03\x00\xff", "7\x00\x04")
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7\x00\x03\x00\x019", "7\x00\x03\x00\x019"]
           │         └── ["7\x00\x03\x00\xff", "7\x00\x04")
           ├── key: (1)
           └── fd: (1)-->(7)

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '{"a": {}}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x019", "7a\x00\x019"]
      │         └── ["7a\x00\x02\x00\xff", "7a\x00\x03")
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x019", "7a\x00\x019"]
           │         └── ["7a\x00\x02\x00\xff", "7a\x00\x03")
           ├── key: (1)
           └── fd: (1)-->(7)

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '{"a": []}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x018", "7a\x00\x018"]
      │         └── ["7a\x00\x02\x00\x03", "7a\x00\x02\x00\x03"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x018", "7a\x00\x018"]
           │         └── ["7a\x00\x02\x00\x03", "7a\x00\x02\x00\x03"]
           ├── key: (1)
           └── fd: (1)-->(7)

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '{"a":[[{"b":{"c":[{"d":"e"}]}}]]}'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x02\x00\x03\x00\x03b\x00\x02c\x00\x02\x00\x03d\x00\x01\x12e\x00\x01", "7a\x00\x02\x00\x03\x00\x03b\x00\x02c\x00\x02\x00\x03d\x00\x01\x12e\x00\x01"]
      └── key: (1)

# Query using the contained by operator.
opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '1'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@j_inv_idx
 │         ├── columns: k:1!null
 │         ├── inverted constraint: /7/1
 │         │    └── spans: ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │         └── key: (1)
 └── filters
      └── j:4 <@ '1' [outer=(4), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '{}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@j_inv_idx
 │         ├── columns: k:1!null
 │         ├── inverted constraint: /7/1
 │         │    └── spans: ["7\x00\x019", "7\x00\x019"]
 │         └── key: (1)
 └── filters
      └── j:4 <@ '{}' [outer=(4), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '[]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── scan b@j_inv_idx
 │         ├── columns: k:1!null
 │         ├── inverted constraint: /7/1
 │         │    └── spans: ["7\x00\x018", "7\x00\x018"]
 │         └── key: (1)
 └── filters
      └── j:4 <@ '[]' [outer=(4), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '{"a": []}'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["7\x00\x019", "7\x00\x019"]
 │         │         └── ["7a\x00\x018", "7a\x00\x018"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:7!null
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["7\x00\x019", "7\x00\x019"]
 │              │         └── ["7a\x00\x018", "7a\x00\x018"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── j:4 <@ '{"a": []}' [outer=(4), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '[{"a": {"d": true}}, 1, "b"]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["7\x00\x01\x12b\x00\x01", "7\x00\x01\x12b\x00\x01"]
 │         │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │         │         ├── ["7\x00\x018", "7\x00\x018"]
 │         │         ├── ["7\x00\x03\x00\x01\x12b\x00\x01", "7\x00\x03\x00\x01\x12b\x00\x01"]
 │         │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │         │         ├── ["7\x00\x03\x00\x019", "7\x00\x03\x00\x019"]
 │         │         ├── ["7\x00\x03a\x00\x019", "7\x00\x03a\x00\x019"]
 │         │         └── ["7\x00\x03a\x00\x02d\x00\x01\n", "7\x00\x03a\x00\x02d\x00\x01\n"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:7!null
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["7\x00\x01\x12b\x00\x01", "7\x00\x01\x12b\x00\x01"]
 │              │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x018", "7\x00\x018"]
 │              │         ├── ["7\x00\x03\x00\x01\x12b\x00\x01", "7\x00\x03\x00\x01\x12b\x00\x01"]
 │              │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x03\x00\x019", "7\x00\x03\x00\x019"]
 │              │         ├── ["7\x00\x03a\x00\x019", "7\x00\x03a\x00\x019"]
 │              │         └── ["7\x00\x03a\x00\x02d\x00\x01\n", "7\x00\x03a\x00\x02d\x00\x01\n"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── j:4 <@ '[{"a": {"d": true}}, 1, "b"]' [outer=(4), immutable]

# Disjunction using the contained by operator.
opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '{"a": [3]}' OR j <@ '[1, 2, 3]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │         │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
 │         │         ├── ["7\x00\x01*\x06\x00", "7\x00\x01*\x06\x00"]
 │         │         ├── ["7\x00\x018", "7\x00\x01:")
 │         │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │         │         ├── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
 │         │         ├── ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │         │         ├── ["7a\x00\x018", "7a\x00\x018"]
 │         │         └── ["7a\x00\x02\x00\x03\x00\x01*\x06\x00", "7a\x00\x02\x00\x03\x00\x01*\x06\x00"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:7!null
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
 │              │         ├── ["7\x00\x01*\x06\x00", "7\x00\x01*\x06\x00"]
 │              │         ├── ["7\x00\x018", "7\x00\x01:")
 │              │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
 │              │         ├── ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │              │         ├── ["7a\x00\x018", "7a\x00\x018"]
 │              │         └── ["7a\x00\x02\x00\x03\x00\x01*\x06\x00", "7a\x00\x02\x00\x03\x00\x01*\x06\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      └── (j:4 <@ '{"a": [3]}') OR (j:4 <@ '[1, 2, 3]') [outer=(4), immutable]

# Conjunction using the contained by operator.
opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j <@ '{"a": [3]}' AND j <@ '[1, 2, 3]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /7
 │         │    ├── tight: false, unique: false
 │         │    ├── union spans: empty
 │         │    └── INTERSECTION
 │         │         ├── span expression
 │         │         │    ├── tight: false, unique: false
 │         │         │    └── union spans
 │         │         │         ├── ["7\x00\x019", "7\x00\x019"]
 │         │         │         ├── ["7a\x00\x018", "7a\x00\x018"]
 │         │         │         └── ["7a\x00\x02\x00\x03\x00\x01*\x06\x00", "7a\x00\x02\x00\x03\x00\x01*\x06\x00"]
 │         │         └── span expression
 │         │              ├── tight: false, unique: false
 │         │              └── union spans
 │         │                   ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │         │                   ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
 │         │                   ├── ["7\x00\x01*\x06\x00", "7\x00\x01*\x06\x00"]
 │         │                   ├── ["7\x00\x018", "7\x00\x018"]
 │         │                   ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │         │                   ├── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
 │         │                   └── ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:7!null
 │              ├── inverted constraint: /7/1
 │              │    └── spans
 │              │         ├── ["7\x00\x01*\x02\x00", "7\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x01*\x04\x00", "7\x00\x01*\x04\x00"]
 │              │         ├── ["7\x00\x01*\x06\x00", "7\x00\x01*\x06\x00"]
 │              │         ├── ["7\x00\x018", "7\x00\x01:")
 │              │         ├── ["7\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x01*\x02\x00"]
 │              │         ├── ["7\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x01*\x04\x00"]
 │              │         ├── ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │              │         ├── ["7a\x00\x018", "7a\x00\x018"]
 │              │         └── ["7a\x00\x02\x00\x03\x00\x01*\x06\x00", "7a\x00\x02\x00\x03\x00\x01*\x06\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(7)
 └── filters
      ├── j:4 <@ '{"a": [3]}' [outer=(4), immutable]
      └── j:4 <@ '[1, 2, 3]' [outer=(4), immutable]

# Query using the fetch val and equality operators.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' = '"b"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

# Chained fetch val operators.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a'->'b' = '"c"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
      └── key: (1)

# Do not generate an inverted scan when the fetch val and equality operators are
# wrapped in a NOT operator. The -> operator returns NULL if the key does not
# exist in the JSON object, so (NOT j->'a' = '"b"') is not equivalent to the
# inverse of the existence of the key/value pair {"a": "b"} in the inverted
# index. See #49143 and #55316.
opt expect-not=GenerateInvertedIndexScans
SELECT k FROM b WHERE NOT j->'a' = '"b"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── scan b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    └── fd: (1)-->(4)
      └── filters
           └── (j:4->'a') != '"b"' [outer=(4), immutable]

# Do not generate an inverted scan when the index of the fetch val operator is
# not a string.
opt expect-not=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->0 = '"b"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── scan b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    └── fd: (1)-->(4)
      └── filters
           └── (j:4->0) = '"b"' [outer=(4), immutable]

# Generate an inverted scan when right side of the equality is an array.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' = '["b"]'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── scan b@j_inv_idx
      │         ├── columns: k:1!null
      │         ├── inverted constraint: /7/1
      │         │    └── spans: ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │         └── key: (1)
      └── filters
           └── (j:4->'a') = '["b"]' [outer=(4), immutable]

# Generate an inverted scan when right side of the equality is an object.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' = '{"b": "c"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── scan b@j_inv_idx
      │         ├── columns: k:1!null
      │         ├── inverted constraint: /7/1
      │         │    └── spans: ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
      │         └── key: (1)
      └── filters
           └── (j:4->'a') = '{"b": "c"}' [outer=(4), immutable]

# Query using the fetch val and equality operators in a conjunction.
opt expect=GenerateInvertedIndexScans disable=GenerateInvertedIndexZigzagJoins
SELECT k FROM b WHERE j->'a' = '"b"' AND j->'c' = '"d"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: true
      │    ├── union spans: empty
      │    └── INTERSECTION
      │         ├── span expression
      │         │    ├── tight: true, unique: true
      │         │    └── union spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         └── span expression
      │              ├── tight: true, unique: true
      │              └── union spans: ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Query using the fetch val and equality operators in a disjunction.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' = '"b"' OR j->'c' = '"d"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Query using the fetch val and equality operators in a disjunction with a
# contains operator.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' = '"b"' OR j @> '{"c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Query using the fetch val and containment operators.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' @> '"b"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         └── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         └── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' <@ '"b"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["7\x00\x019", "7\x00\x019"]
      │         │         └── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         ├── key: (1)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:1!null j_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["7\x00\x019", "7\x00\x019"]
      │              │         └── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── (j:4->'a') <@ '"b"' [outer=(4), immutable]

# Chained fetch val operators and containment operator.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a'->'b' @> '"c"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
      │         └── ["7a\x00\x02b\x00\x02\x00\x03\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x02\x00\x03\x00\x01\x12c\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
           │         └── ["7a\x00\x02b\x00\x02\x00\x03\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x02\x00\x03\x00\x01\x12c\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a'->'b' <@ '"c"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["7\x00\x019", "7\x00\x019"]
      │         │         ├── ["7a\x00\x019", "7a\x00\x019"]
      │         │         └── ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
      │         ├── key: (1)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:1!null j_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["7\x00\x019", "7\x00\x019"]
      │              │         ├── ["7a\x00\x019", "7a\x00\x019"]
      │              │         └── ["7a\x00\x02b\x00\x01\x12c\x00\x01", "7a\x00\x02b\x00\x01\x12c\x00\x01"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── ((j:4->'a')->'b') <@ '"c"' [outer=(4), immutable]

# Query using the fetch val and equality operators in a disjunction.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' @> '"b"' OR j->'c' @> '"d"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │         ├── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │         └── ["7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01", "7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
           │         ├── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
           │         └── ["7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01", "7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Query using the fetch val and contains operators in a disjunction with a
# contained by operator.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' @> '["b"]' OR j <@ '{"c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["7\x00\x019", "7\x00\x019"]
      │         │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │         │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │         ├── key: (1)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:1!null j_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["7\x00\x019", "7\x00\x019"]
      │              │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │              │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── ((j:4->'a') @> '["b"]') OR (j:4 <@ '{"c": "d"}') [outer=(4), immutable]

# Query using the fetch val and equality operators in a conjunction.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' @> '"b"' AND j->'c' @> '"d"'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: false
      │    ├── union spans: empty
      │    └── INTERSECTION
      │         ├── span expression
      │         │    ├── tight: true, unique: false
      │         │    └── union spans
      │         │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      │         │         └── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │         └── span expression
      │              ├── tight: true, unique: false
      │              └── union spans
      │                   ├── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │                   └── ["7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01", "7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
           │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
           │         ├── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
           │         └── ["7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01", "7c\x00\x02\x00\x03\x00\x01\x12d\x00\x01"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Query using the fetch val and contains operators in conjunction with a
# contained by operator.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j->'a' @> '["b"]' AND j <@ '{"c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null j:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join b
      │    ├── columns: k:1!null j:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    ├── union spans: empty
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: true, unique: true
      │         │         │    └── union spans: ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │         │         └── span expression
      │         │              ├── tight: false, unique: false
      │         │              └── union spans
      │         │                   ├── ["7\x00\x019", "7\x00\x019"]
      │         │                   └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │         ├── key: (1)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:1!null j_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["7\x00\x019", "7\x00\x019"]
      │              │         ├── ["7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01", "7a\x00\x02\x00\x03\x00\x01\x12b\x00\x01"]
      │              │         └── ["7c\x00\x01\x12d\x00\x01", "7c\x00\x01\x12d\x00\x01"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── j:4 <@ '{"c": "d"}' [outer=(4), immutable]

# GenerateInvertedIndexScans propagates row-level locking information.
opt expect=GenerateInvertedIndexScans
SELECT k FROM b WHERE j @> '{"a": "b"}' FOR UPDATE
----
project
 ├── columns: k:1!null
 ├── volatile
 ├── key: (1)
 └── scan b@j_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      ├── locking: for-update
      ├── volatile
      └── key: (1)

# Tests for array inverted indexes.
opt expect=GenerateInvertedIndexScans
SELECT k FROM c WHERE a @> ARRAY[1]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan c@a_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /6/1
      │    └── spans: ["\x89", "\x89"]
      └── key: (1)

# Disjunction.
opt expect=GenerateInvertedIndexScans
SELECT k FROM c WHERE a @> ARRAY[1] OR a @> ARRAY[2]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /6
      │    ├── tight: true, unique: false
      │    └── union spans: ["\x89", "\x8b")
      ├── key: (1)
      └── scan c@a_inv_idx
           ├── columns: k:1!null a_inverted_key:6!null
           ├── inverted constraint: /6/1
           │    └── spans: ["\x89", "\x8b")
           ├── key: (1)
           └── fd: (1)-->(6)

opt expect=GenerateInvertedIndexScans
SELECT k FROM c WHERE a @> ARRAY[]::INT[]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /6
      │    ├── tight: true, unique: false
      │    └── union spans: ["", ""]
      ├── key: (1)
      └── scan c@a_inv_idx
           ├── columns: k:1!null a_inverted_key:6!null
           ├── inverted constraint: /6/1
           │    └── spans: ["", ""]
           ├── key: (1)
           └── fd: (1)-->(6)

opt expect-not=GenerateInvertedIndexScans
SELECT k FROM c WHERE a IS NULL
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null a:2
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan c
      │    ├── columns: k:1!null a:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ ARRAY[1]
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── index-join c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /6
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["C", "C"]
 │         │         └── ["\x89", "\x89"]
 │         ├── key: (1)
 │         └── scan c@a_inv_idx
 │              ├── columns: k:1!null a_inverted_key:6!null
 │              ├── inverted constraint: /6/1
 │              │    └── spans
 │              │         ├── ["C", "C"]
 │              │         └── ["\x89", "\x89"]
 │              ├── key: (1)
 │              └── fd: (1)-->(6)
 └── filters
      └── a:2 <@ ARRAY[1] [outer=(2), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ ARRAY[]::INT[]
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── index-join c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── scan c@a_inv_idx
 │         ├── columns: k:1!null
 │         ├── inverted constraint: /6/1
 │         │    └── spans: ["C", "C"]
 │         └── key: (1)
 └── filters
      └── a:2 <@ ARRAY[] [outer=(2), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ ARRAY[NULL]::INT[]
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── index-join c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── scan c@a_inv_idx
 │         ├── columns: k:1!null
 │         ├── inverted constraint: /6/1
 │         │    └── spans: ["C", "C"]
 │         └── key: (1)
 └── filters
      └── a:2 <@ ARRAY[NULL] [outer=(2), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ ARRAY[1] OR a <@ ARRAY[2]
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── index-join c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /6
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["C", "C"]
 │         │         └── ["\x89", "\x8b")
 │         ├── key: (1)
 │         └── scan c@a_inv_idx
 │              ├── columns: k:1!null a_inverted_key:6!null
 │              ├── inverted constraint: /6/1
 │              │    └── spans
 │              │         ├── ["C", "C"]
 │              │         └── ["\x89", "\x8b")
 │              ├── key: (1)
 │              └── fd: (1)-->(6)
 └── filters
      └── (a:2 <@ ARRAY[1]) OR (a:2 <@ ARRAY[2]) [outer=(2), immutable]

opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ ARRAY[1] AND a <@ ARRAY[2]
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── index-join c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /6
 │         │    ├── tight: false, unique: false
 │         │    ├── union spans: ["C", "C"]
 │         │    └── INTERSECTION
 │         │         ├── span expression
 │         │         │    ├── tight: false, unique: false
 │         │         │    └── union spans: ["\x89", "\x89"]
 │         │         └── span expression
 │         │              ├── tight: false, unique: false
 │         │              └── union spans: ["\x8a", "\x8a"]
 │         ├── key: (1)
 │         └── scan c@a_inv_idx
 │              ├── columns: k:1!null a_inverted_key:6!null
 │              ├── inverted constraint: /6/1
 │              │    └── spans
 │              │         ├── ["C", "C"]
 │              │         └── ["\x89", "\x8b")
 │              ├── key: (1)
 │              └── fd: (1)-->(6)
 └── filters
      ├── a:2 <@ ARRAY[1] [outer=(2), immutable]
      └── a:2 <@ ARRAY[2] [outer=(2), immutable]

# Tests for indexes with older descriptor versions.

exec-ddl
DROP INDEX j_inv_idx
----

exec-ddl
DROP INDEX a_inv_idx
----

exec-ddl index-version=1
CREATE INVERTED INDEX j_inv_idx ON b (j)
----

exec-ddl index-version=1
CREATE INVERTED INDEX a_inv_idx ON c (a)
----

# Verify that we do not plan an inverted index scan with an empty array if the
# index has version SecondaryIndexFamilyFormatVersion, since it does not contain
# keys for empty arrays.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM c WHERE a @> '{}'
----
select
 ├── columns: k:1!null a:2!null u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── scan c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3)
 └── filters
      └── a:2 @> ARRAY[] [outer=(2), immutable, constraints=(/2: (/NULL - ])]

# We should still plan an inverted index scan with a non-empty array even
# if the index version is SecondaryIndexFamilyFormatVersion.
opt expect=GenerateInvertedIndexScans
SELECT * FROM c WHERE a @> '{1}'
----
index-join c
 ├── columns: k:1!null a:2!null u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── scan c@a_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["\x89", "\x89"]
      └── key: (1)

# We should still plan an inverted index scan with an empty JSON array even
# if the index version is SecondaryIndexFamilyFormatVersion.
opt expect=GenerateInvertedIndexScans
SELECT * FROM b WHERE j @> '[]'
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /8
      │    ├── tight: true, unique: false
      │    └── union spans
      │         ├── ["7\x00\x018", "7\x00\x018"]
      │         └── ["7\x00\x03", "7\x00\x03"]
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:8!null
           ├── inverted constraint: /8/1
           │    └── spans
           │         ├── ["7\x00\x018", "7\x00\x018"]
           │         └── ["7\x00\x03", "7\x00\x03"]
           ├── key: (1)
           └── fd: (1)-->(8)

# The inverted index will never be used for <@ expressions if the index version
# does not have empty arrays in the inverted index.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM c WHERE a <@ '{2}'
----
select
 ├── columns: k:1!null a:2 u:3
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── scan c
 │    ├── columns: k:1!null a:2 u:3
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3)
 └── filters
      └── a:2 <@ ARRAY[2] [outer=(2), immutable]

exec-ddl
DROP INDEX j_inv_idx
----

exec-ddl
DROP INDEX a_inv_idx
----

exec-ddl
CREATE INVERTED INDEX j_inv_idx ON b (j)
----

exec-ddl
CREATE INVERTED INDEX a_inv_idx ON c (a)
----

# Tests for geospatial constrained scans.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_Intersects('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Same test as above, but with commuted arguments.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_Intersects(geog, 'SRID=4326;POINT(-43.23456 72.4567772)'::geography)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_intersects('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_intersects(geog:4, '0101000020E61000009279E40F069E45C0BEE36FD63B1D5240') [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Same test as above, but with commuted arguments.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_CoveredBy(geom, 'POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_covers('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_coveredby(geom:3, '0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000') [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DFullyWithin('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dfullywithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dfullywithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DWithin('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog, 2000, false)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │         │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0, false)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x01", "B\xfdF\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdF\x00\x00\x00\x00\x00\x00\x01", "B\xfdH\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdH\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdP\x00\x00\x00\x00\x00\x00\x01", "B\xfdR\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdR\x00\x00\x00\x00\x00\x00\x01", "B\xfdT\x00\x00\x00\x00\x00\x00\x00")
      │              │         ├── ["B\xfdT\x00\x00\x00\x00\x00\x00\x00", "B\xfdT\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdZ\x00\x00\x00\x00\x00\x00\x01", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00")
      │              │         └── ["B\xfd\\\x00\x00\x00\x00\x00\x00\x00", "B\xfd\\\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_dwithin('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4, 2000.0, false) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Test for ST_DWithinExclusive
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DWithinExclusive('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dwithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Commuted version of previous test.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DWithinExclusive(geom, 'POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dwithin('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dwithinexclusive(geom:3, '0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE ST_DFullyWithinExclusive('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom, 2)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_dfullywithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── st_dfullywithinexclusive('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:3, 2.0) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Multiple geospatial functions.
# NB: the union spans for the following query are a subset of the spans. This is a
# consequence of how intersectSpanExpression does simplification.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdO\x00\x00\x00\x00\x00\x00\x00", "B\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdO\x00\x00\x00\x00\x00\x00\x00", "B\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_CoveredBy('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_coveredby('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_CoveredBy('SRID=4326;LINESTRING(-118.4079 33.9434, 2.5559 49.0083)'::geography, geog)
AND ST_CoveredBy('SRID=4326;POINT(-44.23836 60.4567772)'::geography, geog))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    ├── union spans
      │         │    │    ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │    │    ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │    │    └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false, unique: false
      │         │         │    ├── union spans: empty
      │         │         │    └── INTERSECTION
      │         │         │         ├── span expression
      │         │         │         │    ├── tight: false, unique: false
      │         │         │         │    └── union spans
      │         │         │         │         ├── ["B\xfd\x81\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x81\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         ├── ["B\xfd\x84\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x84\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         │         └── ["B\xfd\x90\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x90\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │         └── span expression
      │         │         │              ├── tight: false, unique: false
      │         │         │              └── union spans
      │         │         │                   ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   ├── ["B\xfdG\x00\x00\x00\x00\x00\x00\x00", "B\xfdG\x00\x00\x00\x00\x00\x00\x00"]
      │         │         │                   └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── span expression
      │         │              ├── tight: false, unique: false
      │         │              └── union spans
      │         │                   ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   ├── ["B\xfdO\x00\x00\x00\x00\x00\x00\x00", "B\xfdO\x00\x00\x00\x00\x00\x00\x00"]
      │         │                   └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdD\x00\x00\x00\x00\x00\x00\x00", "B\xfdD\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdG\x00\x00\x00\x00\x00\x00\x00", "B\xfdG\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              │         ├── ["B\xfd\x81\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x81\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x84\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x84\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x90\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x90\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_coveredby('0102000020E61000000200000075029A081B9A5DC0F085C954C1F840406DC5FEB27B720440454772F90F814840', geog:4) AND st_coveredby('0101000020E610000058569A94821E46C07BC7DFAC773A4E40', geog:4)) [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Multiple geospatial functions on different indexes.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND ST_Overlaps('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_overlaps('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans: ["B\x89", "B\xfd \x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── st_overlaps('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Cannot use either index in this case.
opt
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR ST_Touches('LINESTRING ( 0 0, 0 2 )'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── scan g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    └── fd: (1)-->(3,4)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR st_touches('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3) [outer=(3,4), immutable]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
OR (ST_Intersects('SRID=4326;POINT(-40.23456 70.4567772)'::geography, geog)
AND ST_Crosses('LINESTRING ( 0 0, 0 2 )'::geometry, geom))
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3 geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3,4)
      ├── index-join g
      │    ├── columns: k:1!null geom:3 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │         ├── key: (1)
      │         └── scan g@geog_idx
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── inverted constraint: /8/1
      │              │    └── spans
      │              │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x01")
      │              ├── key: (1)
      │              └── fd: (1)-->(8)
      └── filters
           └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) OR (st_intersects('0101000020E61000009279E40F061E44C0BEE36FD63B9D5140', geog:4) AND st_crosses('0102000000020000000000000000000000000000000000000000000000000000000000000000000040', geom:3)) [outer=(3,4), immutable, constraints=(/4: (/NULL - ])]

# Filters on other columns.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g
WHERE ST_Covers('SRID=4326;POINT(-43.23456 72.4567772)'::geography, geog)
AND v = 3 AND k > 100
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null v:2!null geog:4!null
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(4)
      ├── index-join g
      │    ├── columns: k:1!null v:2 geog:4
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /8
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │         │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4)
      │         ├── key: (1)
      │         └── select
      │              ├── columns: k:1!null geog_inverted_key:8!null
      │              ├── key: (1)
      │              ├── fd: (1)-->(8)
      │              ├── scan g@geog_idx
      │              │    ├── columns: k:1!null geog_inverted_key:8!null
      │              │    ├── inverted constraint: /8/1
      │              │    │    └── spans
      │              │    │         ├── ["B\xfdL\x00\x00\x00\x00\x00\x00\x00", "B\xfdL\x00\x00\x00\x00\x00\x00\x00"]
      │              │    │         ├── ["B\xfdN\x00\x00\x00\x00\x00\x00\x01", "B\xfdP\x00\x00\x00\x00\x00\x00\x00")
      │              │    │         └── ["B\xfdP\x00\x00\x00\x00\x00\x00\x00", "B\xfdP\x00\x00\x00\x00\x00\x00\x00"]
      │              │    ├── key: (1)
      │              │    └── fd: (1)-->(8)
      │              └── filters
      │                   └── k:1 > 100 [outer=(1), constraints=(/1: [/101 - ]; tight)]
      └── filters
           ├── st_covers('0101000020E61000009279E40F069E45C0BEE36FD63B1D5240', geog:4) [outer=(4), immutable, constraints=(/4: (/NULL - ])]
           └── v:2 = 3 [outer=(2), constraints=(/2: [/3 - /3]; tight), fd=()-->(2)]

# Bounding box operations.
opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE 'BOX(1 2, 3 4)'::box2d ~ geom
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x18\x00\x00\x00\x00\x00\x00\x00")
      │         ├── pre-filterer expression
      │         │    └── st_covers('01030000000100000005000000000000000000F03F0000000000000040000000000000F03F00000000000010400000000000000840000000000000104000000000000008400000000000000040000000000000F03F0000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x18\x00\x00\x00\x00\x00\x00\x00")
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── 'BOX(1 2,3 4)' ~ geom:3 [outer=(3), immutable]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE geom ~ 'BOX(1 2, 3 4)'::box2d
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('01030000000100000005000000000000000000F03F0000000000000040000000000000F03F00000000000010400000000000000840000000000000104000000000000008400000000000000040000000000000F03F0000000000000040', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── geom:3 ~ 'BOX(1 2,3 4)' [outer=(3), immutable, constraints=(/3: (/NULL - ])]

opt expect=GenerateInvertedIndexScans
SELECT k FROM g WHERE geom ~ 'MULTIPOINT((2.2 2.2), (3.0 3.0))'::geometry
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null geom:3!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(3)
      ├── index-join g
      │    ├── columns: k:1!null geom:3
      │    ├── key: (1)
      │    ├── fd: (1)-->(3)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /7
      │         │    ├── tight: false, unique: false
      │         │    ├── union spans
      │         │    │    ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │    │    └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         │    └── INTERSECTION
      │         │         ├── span expression
      │         │         │    ├── tight: false, unique: false
      │         │         │    └── union spans: ["B\xfd\x15\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x15\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── span expression
      │         │              ├── tight: false, unique: false
      │         │              └── union spans: ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('01040000000200000001010000009A999999999901409A99999999990140010100000000000000000008400000000000000840', geom:3)
      │         ├── key: (1)
      │         └── scan g@geom_idx
      │              ├── columns: k:1!null geom_inverted_key:7!null
      │              ├── inverted constraint: /7/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x15\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x15\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(7)
      └── filters
           └── geom:3 ~ '01040000000200000001010000009A999999999901409A99999999990140010100000000000000000008400000000000000840' [outer=(3), immutable, constraints=(/3: (/NULL - ])]

# Tests for partial inverted indexes.

exec-ddl
CREATE TABLE pi (
    k INT PRIMARY KEY,
    s STRING,
    j JSON
)
----

# Partial inverted index scan.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s = 'foo'
----

opt expect=GenerateInvertedIndexScans
SELECT k FROM pi WHERE j @> '{"a": "b"}' AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── inverted constraint: /6/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with indexed column in predicate.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE j @> '{"group": 1}'
----

opt expect=GenerateInvertedIndexScans
SELECT k FROM pi WHERE j @> '{"a": "b"}' AND j @> '{"group": 1}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── inverted constraint: /7/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with index-join.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s = 'foo'
----

opt expect=GenerateInvertedIndexScans
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'foo'
----
index-join pi
 ├── columns: k:1!null s:2!null j:3!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3)
 └── scan pi@idx,partial
      ├── columns: k:1!null
      ├── inverted constraint: /8/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

exec-ddl
DROP INDEX idx
----

# Partial inverted index scan with additional filters.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

opt expect=GenerateInvertedIndexScans
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND j @> '{"group": 1}' AND s = 'foo'
----
select
 ├── columns: k:1!null s:2!null j:3!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3)
 ├── index-join pi
 │    ├── columns: k:1!null s:2 j:3
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /9
 │         │    ├── tight: false, unique: true
 │         │    ├── union spans: empty
 │         │    └── INTERSECTION
 │         │         ├── span expression
 │         │         │    ├── tight: true, unique: true
 │         │         │    └── union spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
 │         │         └── span expression
 │         │              ├── tight: true, unique: true
 │         │              └── union spans: ["7group\x00\x01*\x02\x00", "7group\x00\x01*\x02\x00"]
 │         ├── key: (1)
 │         └── scan pi@idx,partial
 │              ├── columns: k:1!null j_inverted_key:9!null
 │              ├── inverted constraint: /9/1
 │              │    └── spans
 │              │         ├── ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
 │              │         └── ["7group\x00\x01*\x02\x00", "7group\x00\x01*\x02\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(9)
 └── filters
      └── s:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]

exec-ddl
DROP INDEX idx
----

# Generate multiple partial inverted index scans in the memo when the filter
# implies multiple partial index predicates.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

exec-ddl
CREATE INVERTED INDEX idx2 ON pi (j) WHERE s = 'bar'
----

memo expect=GenerateInvertedIndexScans
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'bar'
----
memo (optimized, ~11KB, required=[presentation: k:1,s:2,j:3])
 ├── G1: (select G2 G3) (select G4 G5) (index-join G6 pi,cols=(1-3))
 │    └── [presentation: k:1,s:2,j:3]
 │         ├── best: (index-join G6 pi,cols=(1-3))
 │         └── cost: 22.17
 ├── G2: (scan pi,cols=(1-3))
 │    └── []
 │         ├── best: (scan pi,cols=(1-3))
 │         └── cost: 1085.21
 ├── G3: (filters G7 G8)
 ├── G4: (index-join G9 pi,cols=(1-3))
 │    └── []
 │         ├── best: (index-join G9 pi,cols=(1-3))
 │         └── cost: 30.08
 ├── G5: (filters G8)
 ├── G6: (scan pi@idx2,partial,cols=(1),constrained inverted)
 │    └── []
 │         ├── best: (scan pi@idx2,partial,cols=(1),constrained inverted)
 │         └── cost: 15.45
 ├── G7: (contains G10 G11)
 ├── G8: (eq G12 G13)
 ├── G9: (scan pi@idx,partial,cols=(1),constrained inverted)
 │    └── []
 │         ├── best: (scan pi@idx,partial,cols=(1),constrained inverted)
 │         └── cost: 16.60
 ├── G10: (variable j)
 ├── G11: (const '{"a": "b"}')
 ├── G12: (variable s)
 └── G13: (const 'bar')

exec-ddl
DROP INDEX idx
----

exec-ddl
DROP INDEX idx2
----

# Do not generate a partial inverted index scan when the predicate is not
# implied by the filter.

exec-ddl
CREATE INVERTED INDEX idx ON pi (j) WHERE s IN ('foo', 'bar')
----

memo expect-not=GenerateInvertedIndexScans
SELECT * FROM pi WHERE j @> '{"a": "b"}' AND s = 'baz'
----
memo (optimized, ~7KB, required=[presentation: k:1,s:2,j:3])
 ├── G1: (select G2 G3)
 │    └── [presentation: k:1,s:2,j:3]
 │         ├── best: (select G2 G3)
 │         └── cost: 1095.24
 ├── G2: (scan pi,cols=(1-3))
 │    └── []
 │         ├── best: (scan pi,cols=(1-3))
 │         └── cost: 1085.21
 ├── G3: (filters G4 G5)
 ├── G4: (contains G6 G7)
 ├── G5: (eq G8 G9)
 ├── G6: (variable j)
 ├── G7: (const '{"a": "b"}')
 ├── G8: (variable s)
 └── G9: (const 'baz')

exec-ddl
DROP INDEX idx
----

# Check that we can generate constraints by recognizing computed column
# expressions.
opt expect=GenerateInvertedIndexScans
SELECT k FROM computed WHERE (j->'foo') @> '{"a": "b"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@field_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /9/1
      │    └── spans: ["7a\x00\x01\x12b\x00\x01", "7a\x00\x01\x12b\x00\x01"]
      └── key: (1)

opt expect=GenerateInvertedIndexScans
SELECT k FROM computed WHERE (j->'foo')->'a' = '1'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── scan computed@field_inv_idx
      ├── columns: k:1!null
      ├── inverted constraint: /9/1
      │    └── spans: ["7a\x00\x01*\x02\x00", "7a\x00\x01*\x02\x00"]
      └── key: (1)

# Tests for multi-column inverted indexes.

exec-ddl
CREATE TABLE m (
  k INT PRIMARY KEY,
  a STRING,
  b STRING,
  i INT,
  geom GEOMETRY,
  INVERTED INDEX multicol (a, geom)
)
----

# Constrain a single prefix column to one value.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /8
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:8!null
 │              ├── constraint: /2: [/'foo' - /'foo']
 │              ├── inverted constraint: /8/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(8)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Constrain a single prefix column to multiple point values.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a IN ('foo', 'bar') AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /8
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:8!null
 │              ├── constraint: /2
 │              │    ├── [/'bar' - /'bar']
 │              │    └── [/'foo' - /'foo']
 │              ├── inverted constraint: /8/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(8)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when the first prefix column is not
# constrained.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2 b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when a single prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a > 'x' AND a < 'y' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (a:2 > 'x') AND (a:2 < 'y') [outer=(2), constraints=(/2: [/e'x\x00' - /'y'); tight)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
DROP INDEX multicol
----

exec-ddl
CREATE INVERTED INDEX multicol ON m (a, b, geom)
----

# Constrain multiple prefix columns to one value.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND b = 'bar' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2,3), (1)-->(4,5)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /9
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:9!null
 │              ├── constraint: /2/3: [/'foo'/'bar' - /'foo'/'bar']
 │              ├── inverted constraint: /9/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(9)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Constrain multiple prefix columns to multiple point values.
opt expect=GenerateInvertedIndexScans
SELECT * FROM m WHERE a IN ('foo', 'bar') AND b IN ('baz', 'bob') AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── index-join m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /9
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan m@multicol
 │              ├── columns: k:1!null geom_inverted_key:9!null
 │              ├── constraint: /2/3
 │              │    ├── [/'bar'/'baz' - /'bar'/'baz']
 │              │    ├── [/'bar'/'bob' - /'bar'/'bob']
 │              │    ├── [/'foo'/'baz' - /'foo'/'baz']
 │              │    └── [/'foo'/'bob' - /'foo'/'bob']
 │              ├── inverted constraint: /9/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(9)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when the first prefix column is not
# constrained.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE b = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2 b:3!null i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(3), (1)-->(2,4,5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── b:3 = 'foo' [outer=(3), constraints=(/3: [/'foo' - /'foo']; tight), fd=()-->(3)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when the second prefix column is not
# constrained.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── a:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when the first prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a > 'x' AND a < 'y' AND b = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(3), (1)-->(2,4,5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (a:2 > 'x') AND (a:2 < 'y') [outer=(2), constraints=(/2: [/e'x\x00' - /'y'); tight)]
      ├── b:3 = 'foo' [outer=(3), constraints=(/3: [/'foo' - /'foo']; tight), fd=()-->(3)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when the second prefix column is
# constrained to a range.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE a = 'foo' AND b > 'x' AND b < 'y' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (b:3 > 'x') AND (b:3 < 'y') [outer=(3), constraints=(/3: [/e'x\x00' - /'y'); tight)]
      ├── a:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Do not generate an inverted index scan when neither prefix column is constrained.
opt expect-not=GenerateInvertedIndexScans
SELECT * FROM m WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2 b:3 i:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan m
 │    ├── columns: k:1!null a:2 b:3 i:4 geom:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
DROP INDEX multicol
----

exec-ddl
CREATE INVERTED INDEX multicol ON m (i, geom)
----

# Generate an inverted index scan when the prefix column is constrained to a
# contiguous range.
opt expect=GenerateInvertedIndexScans
SELECT k FROM m WHERE i IN (1, 2, 3) AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: k:1!null i:4!null geom:5!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4,5)
      ├── index-join m
      │    ├── columns: k:1!null i:4 geom:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(4,5)
      │    └── inverted-filter
      │         ├── columns: k:1!null
      │         ├── inverted expression: /10
      │         │    ├── tight: false, unique: false
      │         │    └── union spans
      │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │         ├── pre-filterer expression
      │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
      │         ├── key: (1)
      │         └── scan m@multicol
      │              ├── columns: k:1!null geom_inverted_key:10!null
      │              ├── constraint: /4
      │              │    ├── [/1 - /1]
      │              │    ├── [/2 - /2]
      │              │    └── [/3 - /3]
      │              ├── inverted constraint: /10/1
      │              │    └── spans
      │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
      │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
      │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
      │              ├── key: (1)
      │              └── fd: (1)-->(10)
      └── filters
           └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
CREATE TABLE mc (
  k INT PRIMARY KEY,
  a STRING NOT NULL,
  b STRING NOT NULL,
  c STRING AS (upper(a)) STORED,
  geom GEOMETRY,
  CHECK (b IN ('foo', 'bar', 'baz'))
)
----

exec-ddl
CREATE INVERTED INDEX mc_idx ON mc (b, geom)
----

# Constrain the first prefix column with a CHECK constraint.
opt expect=GenerateInvertedIndexScans
SELECT * FROM mc WHERE ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null c:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5), (2)-->(4)
 ├── index-join mc
 │    ├── columns: k:1!null a:2!null b:3!null c:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), (2)-->(4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /8
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan mc@mc_idx
 │              ├── columns: k:1!null geom_inverted_key:8!null
 │              ├── constraint: /3
 │              │    ├── [/'bar' - /'bar']
 │              │    ├── [/'baz' - /'baz']
 │              │    └── [/'foo' - /'foo']
 │              ├── inverted constraint: /8/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(8)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
DROP INDEX mc_idx
----

exec-ddl
CREATE INVERTED INDEX mc_idx ON mc (a, b, geom)
----

# Constrain the second prefix column with a CHECK constraint.
opt expect=GenerateInvertedIndexScans
SELECT * FROM mc WHERE a = 'x' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null c:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2,4), (1)-->(3,5)
 ├── index-join mc
 │    ├── columns: k:1!null a:2!null b:3!null c:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), (2)-->(4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /9
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan mc@mc_idx
 │              ├── columns: k:1!null geom_inverted_key:9!null
 │              ├── constraint: /2/3
 │              │    ├── [/'x'/'bar' - /'x'/'bar']
 │              │    ├── [/'x'/'baz' - /'x'/'baz']
 │              │    └── [/'x'/'foo' - /'x'/'foo']
 │              ├── inverted constraint: /9/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(9)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
DROP INDEX mc_idx
----

exec-ddl
CREATE INVERTED INDEX mc_idx ON mc (c, geom)
----

# Constrain a prefix column that is computed from a column with a constant
# filter.
opt expect=GenerateInvertedIndexScans
SELECT * FROM mc WHERE a = 'foo' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null c:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: ()-->(2,4), (1)-->(3,5)
 ├── index-join mc
 │    ├── columns: k:1!null a:2!null b:3!null c:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), (2)-->(4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /10
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan mc@mc_idx
 │              ├── columns: k:1!null geom_inverted_key:10!null
 │              ├── constraint: /4: [/'FOO' - /'FOO']
 │              ├── inverted constraint: /10/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(10)
 └── filters
      ├── a:2 = 'foo' [outer=(2), constraints=(/2: [/'foo' - /'foo']; tight), fd=()-->(2)]
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

# Constrain a prefix computed column when the computed expression matches a
# filter expression.
opt expect=GenerateInvertedIndexScans
SELECT * FROM mc WHERE upper(a) = 'FOO' AND ST_CoveredBy('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))'::geometry, geom)
----
select
 ├── columns: k:1!null a:2!null b:3!null c:4 geom:5!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5), (2)-->(4)
 ├── index-join mc
 │    ├── columns: k:1!null a:2!null b:3!null c:4 geom:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), (2)-->(4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /10
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         ├── pre-filterer expression
 │         │    └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5)
 │         ├── key: (1)
 │         └── scan mc@mc_idx
 │              ├── columns: k:1!null geom_inverted_key:10!null
 │              ├── constraint: /4: [/'FOO' - /'FOO']
 │              ├── inverted constraint: /10/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x11\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x11\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(10)
 └── filters
      └── st_coveredby('0103000000010000000500000000000000000000000000000000000000000000000000F03F0000000000000000000000000000F03F000000000000F03F0000000000000000000000000000F03F00000000000000000000000000000000', geom:5) [outer=(5), immutable, constraints=(/5: (/NULL - ])]

exec-ddl
DROP INDEX mc_idx
----

# Regression test for #59702. Do not panic when empty index spans are generated
# from a filter on an inverted column.
exec-ddl
CREATE TABLE t59702 (
  k INT PRIMARY KEY,
  g GEOGRAPHY,
  INVERTED INDEX (g)
)
----

opt
SELECT * FROM t59702 WHERE st_intersects(g, st_buffer(st_makepoint(1, 1)::GEOGRAPHY, 0))
----
select
 ├── columns: k:1!null g:2!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan t59702
 │    ├── columns: k:1!null g:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      └── st_intersects(g:2, '0103000020E610000000000000') [outer=(2), immutable, constraints=(/2: (/NULL - ])]

# Regression test for #60527. Do not panic when a geospatial function has a NULL
# GEOMETRY/GEOGRAPHY argument.
exec-ddl
CREATE TABLE t60527 (
  g GEOGRAPHY,
  INVERTED INDEX (g)
)
----

# FoldFunctionWithNullArg is disabled to prevent the expression from being
# normalized to an empty Values expression and avoiding
# GenerateInvertedIndexScans altogether.
opt disable=FoldFunctionWithNullArg
SELECT * FROM t60527 WHERE (ST_Covers(NULL::GEOGRAPHY, g) AND ST_DWithin(NULL::GEOGRAPHY, g, 1))
----
select
 ├── columns: g:1!null
 ├── immutable
 ├── scan t60527
 │    └── columns: g:1
 └── filters
      ├── st_covers(CAST(NULL AS GEOGRAPHY), g:1) [outer=(1), immutable, constraints=(/1: (/NULL - ])]
      └── st_dwithin(CAST(NULL AS GEOGRAPHY), g:1, 1.0) [outer=(1), immutable, constraints=(/1: (/NULL - ])]

# Regression test for #62686. Do not panic when a geospatial function has a NULL
# additional argument.
exec-ddl
CREATE TABLE t62686 (
  c GEOMETRY NULL,
  INVERTED INDEX (c ASC)
)
----

# FoldFunctionWithNullArg is disabled to prevent the expression from being
# normalized to an empty Values expression and avoiding
# GenerateInvertedIndexScans altogether.
opt disable=FoldFunctionWithNullArg
SELECT * FROM t62686 WHERE ST_DFullyWithin(c, ST_GeomFromText('POINT(1 1)'), NULL::FLOAT8)
----
select
 ├── columns: c:1!null
 ├── immutable
 ├── scan t62686
 │    └── columns: c:1
 └── filters
      └── st_dfullywithin(c:1, '0101000000000000000000F03F000000000000F03F', CAST(NULL AS FLOAT8)) [outer=(1), immutable, constraints=(/1: (/NULL - ])]

# Regression test for #63180. Ensure that we only scan spans needed by the
# inverted filter.
exec-ddl
CREATE TABLE t63180 (
  j JSON,
  INVERTED INDEX j_idx (j)
)
----

opt expect=GenerateInvertedIndexScans
SELECT j FROM t63180@j_idx WHERE j @> '{"a": "c"}' AND (j @> '{"a": "b"}' OR j @> '{"a": "c"}');
----
index-join t63180
 ├── columns: j:1!null
 ├── immutable
 └── inverted-filter
      ├── columns: rowid:2!null
      ├── inverted expression: /5
      │    ├── tight: true, unique: false
      │    └── union spans: ["7a\x00\x01\x12c\x00\x01", "7a\x00\x01\x12c\x00\x01"]
      ├── key: (2)
      └── scan t63180@j_idx
           ├── columns: rowid:2!null j_inverted_key:5!null
           ├── inverted constraint: /5/2
           │    └── spans: ["7a\x00\x01\x12c\x00\x01", "7a\x00\x01\x12c\x00\x01"]
           ├── flags: force-index=j_idx
           ├── key: (2)
           └── fd: (2)-->(5)

# --------------------------------------------------
# GenerateZigzagJoins
# --------------------------------------------------

exec-ddl
CREATE TABLE pqr
(
    p INT PRIMARY KEY,
    q INT,
    r INT,
    s STRING,
    t STRING,
    INDEX q (q),
    INDEX r (r),
    INDEX s (s) STORING (r),
    INDEX rs (r,s),
    INDEX ts (t,s)
)
----

exec-ddl
ALTER TABLE pqr INJECT STATISTICS '[
  {
    "columns": ["r"],
    "distinct_count": 100,
    "null_count": 0,
    "row_count": 10000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["s"],
    "distinct_count": 10,
    "null_count": 0,
    "row_count": 10000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  }
]'
----

exec-ddl
CREATE TABLE zz (
    a INT8 PRIMARY KEY,
    b INT8 NULL,
    c INT8 NULL,
    INDEX idx_b (b ASC),
    CONSTRAINT idx_c UNIQUE (c)
)
----

exec-ddl
CREATE TABLE zz_redundant (
    a INT8 PRIMARY KEY,
    b INT8 NULL,
    c INT8 NULL,
    INDEX idx_u (b ASC, c ASC),
    INDEX idx_v (b ASC, c ASC)
)
----

# Simple zigzag case - where all requested columns are in the indexes being
# joined.
opt
SELECT q,r FROM pqr WHERE q = 1 AND r = 2
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [2]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

opt
SELECT q,r FROM pqr WHERE q = 1 AND r IS NULL
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [NULL]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── r:3 IS NULL [outer=(3), constraints=(/3: [/NULL - /NULL]; tight), fd=()-->(3)]

memo
SELECT q,r FROM pqr WHERE q = 1 AND r = 2
----
memo (optimized, ~13KB, required=[presentation: q:2,r:3])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G7) (zigzag-join G3 pqr@q pqr@r)
 │    └── [presentation: q:2,r:3]
 │         ├── best: (zigzag-join G3 pqr@q pqr@r)
 │         └── cost: 22.83
 ├── G2: (scan pqr,cols=(2,3))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,3))
 │         └── cost: 10725.41
 ├── G3: (filters G9 G10)
 ├── G4: (index-join G11 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,3))
 │         └── cost: 84.88
 ├── G5: (filters G10)
 ├── G6: (index-join G12 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G12 pqr,cols=(2,3))
 │         └── cost: 725.42
 ├── G7: (filters G9)
 ├── G8: (index-join G13 pqr,cols=(2,3))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(2,3))
 │         └── cost: 726.52
 ├── G9: (eq G14 G15)
 ├── G10: (eq G16 G17)
 ├── G11: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 24.72
 ├── G12: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 118.41
 ├── G13: (scan pqr@rs,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3),constrained)
 │         └── cost: 119.51
 ├── G14: (variable q)
 ├── G15: (const 1)
 ├── G16: (variable r)
 └── G17: (const 2)

# Case where the fixed columns are extracted from a complicated expression.
opt
SELECT q,r FROM pqr WHERE q = 1 AND ((r < 1 AND r > 1) OR (r >= 2 AND r <= 2))
----
inner-join (zigzag pqr@q pqr@r)
 ├── columns: q:2!null r:3!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [3] = [2]
 ├── fd: ()-->(2,3)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── ((r:3 < 1) AND (r:3 > 1)) OR ((r:3 >= 2) AND (r:3 <= 2)) [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

# Nested zigzag case - zigzag join needs to be wrapped in a lookup join to
# satisfy required columns.
opt
SELECT q,r,s FROM pqr WHERE q = 1 AND r = 2
----
inner-join (lookup pqr)
 ├── columns: q:2!null r:3!null s:4
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── fd: ()-->(2,3)
 ├── inner-join (zigzag pqr@q pqr@r)
 │    ├── columns: p:1!null q:2!null r:3!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [2] = [1]
 │    ├── right fixed columns: [3] = [2]
 │    ├── fd: ()-->(2,3)
 │    └── filters
 │         ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 │         └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]
 └── filters (true)

memo
SELECT q,r,s FROM pqr WHERE q = 1 AND r = 2
----
memo (optimized, ~15KB, required=[presentation: q:2,r:3,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G7) (lookup-join G9 G10 pqr,keyCols=[1],outCols=(2-4))
 │    └── [presentation: q:2,r:3,s:4]
 │         ├── best: (lookup-join G9 G10 pqr,keyCols=[1],outCols=(2-4))
 │         └── cost: 28.47
 ├── G2: (scan pqr,cols=(2-4))
 │    └── []
 │         ├── best: (scan pqr,cols=(2-4))
 │         └── cost: 10825.61
 ├── G3: (filters G11 G12)
 ├── G4: (index-join G13 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(2-4))
 │         └── cost: 84.98
 ├── G5: (filters G12)
 ├── G6: (index-join G14 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G14 pqr,cols=(2-4))
 │         └── cost: 726.42
 ├── G7: (filters G11)
 ├── G8: (index-join G15 pqr,cols=(2-4))
 │    └── []
 │         ├── best: (index-join G15 pqr,cols=(2-4))
 │         └── cost: 727.62
 ├── G9: (zigzag-join G3 pqr@q pqr@r)
 │    └── []
 │         ├── best: (zigzag-join G3 pqr@q pqr@r)
 │         └── cost: 22.94
 ├── G10: (filters)
 ├── G11: (eq G16 G17)
 ├── G12: (eq G18 G19)
 ├── G13: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 24.72
 ├── G14: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 118.41
 ├── G15: (scan pqr@rs,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3,4),constrained)
 │         └── cost: 120.61
 ├── G16: (variable q)
 ├── G17: (const 1)
 ├── G18: (variable r)
 └── G19: (const 2)

# Zigzag with fixed columns of different types.
opt
SELECT q,s FROM pqr WHERE q = 1 AND s = 'foo'
----
inner-join (zigzag pqr@q pqr@s)
 ├── columns: q:2!null s:4!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [4] = ['foo']
 ├── fd: ()-->(2,4)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

memo
SELECT q,s FROM pqr WHERE q = 1 AND s = 'foo'
----
memo (optimized, ~11KB, required=[presentation: q:2,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (zigzag-join G3 pqr@q pqr@s)
 │    └── [presentation: q:2,s:4]
 │         ├── best: (zigzag-join G3 pqr@q pqr@s)
 │         └── cost: 23.13
 ├── G2: (scan pqr,cols=(2,4))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,4))
 │         └── cost: 10725.41
 ├── G3: (filters G8 G9)
 ├── G4: (index-join G10 pqr,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G10 pqr,cols=(2,4))
 │         └── cost: 84.88
 ├── G5: (filters G9)
 ├── G6: (index-join G11 pqr,cols=(2,4))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,4))
 │         └── cost: 7134.52
 ├── G7: (filters G8)
 ├── G8: (eq G12 G13)
 ├── G9: (eq G14 G15)
 ├── G10: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 24.72
 ├── G11: (scan pqr@s,cols=(1,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@s,cols=(1,4),constrained)
 │         └── cost: 1064.51
 ├── G12: (variable q)
 ├── G13: (const 1)
 ├── G14: (variable s)
 └── G15: (const 'foo')

# Zigzag with implicit equality column in addition to primary key:
# indexes on (r,s) and (t,s) should be chosen even though s is not being fixed
# in the ON clause.
opt
SELECT r,t FROM pqr WHERE r = 1 AND t = 'foo'
----
inner-join (zigzag pqr@rs pqr@ts)
 ├── columns: r:3!null t:5!null
 ├── eq columns: [4 1] = [4 1]
 ├── left fixed columns: [3] = [1]
 ├── right fixed columns: [5] = ['foo']
 ├── fd: ()-->(3,5)
 └── filters
      ├── r:3 = 1 [outer=(3), constraints=(/3: [/1 - /1]; tight), fd=()-->(3)]
      └── t:5 = 'foo' [outer=(5), constraints=(/5: [/'foo' - /'foo']; tight), fd=()-->(5)]

memo
SELECT r,t FROM pqr WHERE r = 1 AND t = 'foo'
----
memo (optimized, ~13KB, required=[presentation: r:3,t:5])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G5) (select G7 G8) (zigzag-join G3 pqr@rs pqr@ts)
 │    └── [presentation: r:3,t:5]
 │         ├── best: (zigzag-join G3 pqr@rs pqr@ts)
 │         └── cost: 23.05
 ├── G2: (scan pqr,cols=(3,5))
 │    └── []
 │         ├── best: (scan pqr,cols=(3,5))
 │         └── cost: 10725.41
 ├── G3: (filters G9 G10)
 ├── G4: (index-join G11 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(3,5))
 │         └── cost: 725.42
 ├── G5: (filters G10)
 ├── G6: (index-join G12 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G12 pqr,cols=(3,5))
 │         └── cost: 726.52
 ├── G7: (index-join G13 pqr,cols=(3,5))
 │    └── []
 │         ├── best: (index-join G13 pqr,cols=(3,5))
 │         └── cost: 85.08
 ├── G8: (filters G9)
 ├── G9: (eq G14 G15)
 ├── G10: (eq G16 G17)
 ├── G11: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 118.41
 ├── G12: (scan pqr@rs,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3),constrained)
 │         └── cost: 119.51
 ├── G13: (scan pqr@ts,cols=(1,5),constrained)
 │    └── []
 │         ├── best: (scan pqr@ts,cols=(1,5),constrained)
 │         └── cost: 24.92
 ├── G14: (variable r)
 ├── G15: (const 1)
 ├── G16: (variable t)
 └── G17: (const 'foo')

# Zigzag with choice between indexes for multiple equality predicates.
opt
SELECT p,q,r,s FROM pqr WHERE q = 1 AND r = 1 AND s = 'foo'
----
inner-join (zigzag pqr@q pqr@s)
 ├── columns: p:1!null q:2!null r:3!null s:4!null
 ├── eq columns: [1] = [1]
 ├── left fixed columns: [2] = [1]
 ├── right fixed columns: [4] = ['foo']
 ├── key: (1)
 ├── fd: ()-->(2-4)
 └── filters
      ├── q:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
      ├── r:3 = 1 [outer=(3), constraints=(/3: [/1 - /1]; tight), fd=()-->(3)]
      └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

# Tests for zigzag joins over partial indexes.

exec-ddl
CREATE TABLE zz_partial (
    k INT PRIMARY KEY,
    i INT,
    j INT,
    b1 BOOL,
    b2 BOOL,
    s STRING
)
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE b1
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE b2
----

# Generate a zigzag join over two partial indexes.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20 AND b2
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null b2:5!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-5)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j,partial)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag join when the first index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b2
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@j,partial
      │         └── constraint: /3/1: [/20 - /20]
      └── filters
           └── i = 10

# Don't generate a zigzag join when the second index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@i,partial
      │         └── constraint: /2/1: [/10 - /10]
      └── filters
           └── j = 20

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# Generate a zigzag join over one partial and one non-partial index.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND b1 AND j = 20
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag join when the partial index predicate is not implied.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@j
      │         └── constraint: /3/1: [/20 - /20]
      └── filters
           └── i = 10

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE i = 10
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# Don't generate a zigzag join when the expression that fixes the left columns
# is removed during partial index implication of the left index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@i,partial
      └── filters
           └── j = 20

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i)
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE j = 20
----

# Don't generate a zigzag join when the expression that fixes the right columns
# is removed during partial index implication of the right index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND j = 20
----
project
 └── select
      ├── index-join zz_partial
      │    └── scan zz_partial@j,partial
      └── filters
           └── i = 10

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX zz_partial_s ON zz_partial (s)
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE s = 'foo'
----

# Don't generate a zigzag join when the expression that fixes the left columns
# is removed during partial index implication of the right index.
# TODO(mgartner): Once again, we find ourselves with a suboptimal query plan
# with an unnecessary Project that projects s='foo' which is not needed by the
# parent expression. This is the result of GenerateConstrainedScans replacing
# the matched Select with a Project that is required to produce all the columns
# that the Select produced. One way to fix this would be to add a new
# exploration rule that can remove these unnecessary Projects, similar to
# EliminateIndexJoinInsideProject.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE s = 'foo' AND j = 20
----
project
 └── project
      ├── scan zz_partial@j,partial
      │    └── constraint: /3/1: [/20 - /20]
      └── projections
           └── 'foo'

exec-ddl
DROP INDEX zz_partial_s
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE s = 'foo'
----

exec-ddl
CREATE INDEX zz_partial_s ON zz_partial (s)
----

# Don't generate a zigzag join when the expression that fixes the right columns
# is removed during partial index implication of the left index.
opt expect-not=GenerateZigzagJoins format=hide-all
SELECT k FROM zz_partial WHERE i = 10 AND s = 'foo'
----
project
 └── project
      ├── scan zz_partial@i,partial
      │    └── constraint: /2/1: [/10 - /10]
      └── projections
           └── 'foo'

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX zz_partial_s
----

exec-ddl
CREATE INDEX i ON zz_partial (i)
----

exec-ddl
CREATE INDEX b1 ON zz_partial (b1) WHERE s = 'foo'
----

exec-ddl
CREATE INDEX j ON zz_partial (j)
----

# The filters should be reset during each iteration over the left and right
# indexes if they are reduced while proving partial index implication. In this
# test, (s = 'foo') must be applied after the zigzag join.
opt expect=GenerateZigzagJoins
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b1 AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null s:6!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4,6)
      ├── inner-join (zigzag zz_partial@i zz_partial@j)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters
           ├── b1:4 [outer=(4), constraints=(/4: [/true - /true]; tight), fd=()-->(4)]
           └── s:6 = 'foo' [outer=(6), constraints=(/6: [/'foo' - /'foo']; tight), fd=()-->(6)]

exec-ddl
DROP INDEX i
----

exec-ddl
DROP INDEX b1
----

exec-ddl
DROP INDEX j
----

exec-ddl
CREATE INDEX i ON zz_partial (i) WHERE b1
----

exec-ddl
CREATE INDEX j ON zz_partial (j) WHERE b1
----

# Generate a zigzag join on two partial indexes with the same predicate.
opt
SELECT k FROM zz_partial WHERE i = 10 AND j = 20 AND b1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── inner-join (lookup zz_partial)
      ├── columns: k:1!null i:2!null j:3!null b1:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── key: (1)
      ├── fd: ()-->(2-4)
      ├── inner-join (zigzag zz_partial@i,partial zz_partial@j,partial)
      │    ├── columns: k:1!null i:2!null j:3!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [2] = [10]
      │    ├── right fixed columns: [3] = [20]
      │    ├── fd: ()-->(2,3)
      │    └── filters
      │         ├── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
      │         └── j:3 = 20 [outer=(3), constraints=(/3: [/20 - /20]; tight), fd=()-->(3)]
      └── filters (true)

# Don't generate a zigzag which has the PK as its equality columns against
# nullable unique indexes where the primary key is not part of the indexed
# columns.

# Regression test for #36051: prior to fixing this, we would try to use the PK
# as the equality column here, but it's not actually part of the key so we
# can't zigzag on it.
opt expect-not=GenerateZigzagJoins
SELECT * FROM zz WHERE b IS NULL AND c = 2
----
select
 ├── columns: a:1!null b:2 c:3!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-3)
 ├── index-join zz
 │    ├── columns: a:1!null b:2 c:3
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-3)
 │    └── scan zz@idx_c
 │         ├── columns: a:1!null c:3!null
 │         ├── constraint: /3: [/2 - /2]
 │         ├── cardinality: [0 - 1]
 │         ├── key: ()
 │         └── fd: ()-->(1,3)
 └── filters
      └── b:2 IS NULL [outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

memo
SELECT p,q,r,s FROM pqr WHERE q = 1 AND r = 1 AND s = 'foo'
----
memo (optimized, ~31KB, required=[presentation: p:1,q:2,r:3,s:4])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7) (select G8 G9) (select G10 G9) (lookup-join G11 G12 pqr,keyCols=[1],outCols=(1-4)) (zigzag-join G3 pqr@q pqr@s) (zigzag-join G3 pqr@q pqr@rs) (lookup-join G13 G9 pqr,keyCols=[1],outCols=(1-4))
 │    └── [presentation: p:1,q:2,r:3,s:4]
 │         ├── best: (zigzag-join G3 pqr@q pqr@s)
 │         └── cost: 23.15
 ├── G2: (scan pqr,cols=(1-4))
 │    └── []
 │         ├── best: (scan pqr,cols=(1-4))
 │         └── cost: 10925.81
 ├── G3: (filters G14 G15 G16)
 ├── G4: (index-join G17 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G17 pqr,cols=(1-4))
 │         └── cost: 84.98
 ├── G5: (filters G15 G16)
 ├── G6: (index-join G18 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G18 pqr,cols=(1-4))
 │         └── cost: 726.42
 ├── G7: (filters G14 G16)
 ├── G8: (index-join G19 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G19 pqr,cols=(1-4))
 │         └── cost: 1145.34
 ├── G9: (filters G14)
 ├── G10: (index-join G20 pqr,cols=(1-4))
 │    └── []
 │         ├── best: (index-join G20 pqr,cols=(1-4))
 │         └── cost: 85.92
 ├── G11: (zigzag-join G21 pqr@q pqr@r)
 │    └── []
 │         ├── best: (zigzag-join G21 pqr@q pqr@r)
 │         └── cost: 22.94
 ├── G12: (filters G16)
 ├── G13: (zigzag-join G5 pqr@r pqr@s)
 │    └── []
 │         ├── best: (zigzag-join G5 pqr@r pqr@s)
 │         └── cost: 42.23
 ├── G14: (eq G22 G23)
 ├── G15: (eq G24 G23)
 ├── G16: (eq G25 G26)
 ├── G17: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 24.72
 ├── G18: (scan pqr@r,cols=(1,3),constrained)
 │    └── []
 │         ├── best: (scan pqr@r,cols=(1,3),constrained)
 │         └── cost: 118.41
 ├── G19: (select G27 G28)
 │    └── []
 │         ├── best: (select G27 G28)
 │         └── cost: 1084.63
 ├── G20: (scan pqr@rs,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@rs,cols=(1,3,4),constrained)
 │         └── cost: 25.21
 ├── G21: (filters G14 G15)
 ├── G22: (variable q)
 ├── G23: (const 1)
 ├── G24: (variable r)
 ├── G25: (variable s)
 ├── G26: (const 'foo')
 ├── G27: (scan pqr@s,cols=(1,3,4),constrained)
 │    └── []
 │         ├── best: (scan pqr@s,cols=(1,3,4),constrained)
 │         └── cost: 1074.61
 └── G28: (filters G15)

# Zigzag joins cannot be planned for indexes where equality columns do not
# immediately follow fixed columns. Here, the only index on t is (t,s,p) and
# s is not a fixed or equal column, so a zigzag join shouldn't be planned.
opt
SELECT q,t FROM pqr WHERE q = 1 AND t = 'foo'
----
select
 ├── columns: q:2!null t:5!null
 ├── fd: ()-->(2,5)
 ├── index-join pqr
 │    ├── columns: q:2 t:5
 │    ├── fd: ()-->(2)
 │    └── scan pqr@q
 │         ├── columns: p:1!null q:2!null
 │         ├── constraint: /2/1: [/1 - /1]
 │         ├── key: (1)
 │         └── fd: ()-->(2)
 └── filters
      └── t:5 = 'foo' [outer=(5), constraints=(/5: [/'foo' - /'foo']; tight), fd=()-->(5)]

memo
SELECT q,t FROM pqr WHERE q = 1 AND t = 'foo'
----
memo (optimized, ~9KB, required=[presentation: q:2,t:5])
 ├── G1: (select G2 G3) (select G4 G5) (select G6 G7)
 │    └── [presentation: q:2,t:5]
 │         ├── best: (select G4 G5)
 │         └── cost: 85.00
 ├── G2: (scan pqr,cols=(2,5))
 │    └── []
 │         ├── best: (scan pqr,cols=(2,5))
 │         └── cost: 10725.41
 ├── G3: (filters G8 G9)
 ├── G4: (index-join G10 pqr,cols=(2,5))
 │    └── []
 │         ├── best: (index-join G10 pqr,cols=(2,5))
 │         └── cost: 84.88
 ├── G5: (filters G9)
 ├── G6: (index-join G11 pqr,cols=(2,5))
 │    └── []
 │         ├── best: (index-join G11 pqr,cols=(2,5))
 │         └── cost: 85.08
 ├── G7: (filters G8)
 ├── G8: (eq G12 G13)
 ├── G9: (eq G14 G15)
 ├── G10: (scan pqr@q,cols=(1,2),constrained)
 │    └── []
 │         ├── best: (scan pqr@q,cols=(1,2),constrained)
 │         └── cost: 24.72
 ├── G11: (scan pqr@ts,cols=(1,5),constrained)
 │    └── []
 │         ├── best: (scan pqr@ts,cols=(1,5),constrained)
 │         └── cost: 24.92
 ├── G12: (variable q)
 ├── G13: (const 1)
 ├── G14: (variable t)
 └── G15: (const 'foo')

# Don't zigzag on two identical indexes.
memo
SELECT c FROM zz_redundant WHERE b = 1
----
memo (optimized, ~6KB, required=[presentation: c:3])
 ├── G1: (project G2 G3 c)
 │    └── [presentation: c:3]
 │         ├── best: (project G2 G3 c)
 │         └── cost: 25.12
 ├── G2: (select G4 G5) (scan zz_redundant@idx_u,cols=(2,3),constrained) (scan zz_redundant@idx_v,cols=(2,3),constrained)
 │    └── []
 │         ├── best: (scan zz_redundant@idx_u,cols=(2,3),constrained)
 │         └── cost: 25.01
 ├── G3: (projections)
 ├── G4: (scan zz_redundant,cols=(2,3)) (scan zz_redundant@idx_u,cols=(2,3)) (scan zz_redundant@idx_v,cols=(2,3))
 │    └── []
 │         ├── best: (scan zz_redundant,cols=(2,3))
 │         └── cost: 1075.01
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable b)
 └── G8: (const 1)

# GenerateZigzagJoins is disabled in the presence of a row-level locking clause.
opt
SELECT q,r FROM pqr WHERE q = 1 AND r = 2 FOR UPDATE
----
select
 ├── columns: q:2!null r:3!null
 ├── volatile
 ├── fd: ()-->(2,3)
 ├── index-join pqr
 │    ├── columns: q:2 r:3
 │    ├── volatile
 │    ├── fd: ()-->(2)
 │    └── scan pqr@q
 │         ├── columns: p:1!null q:2!null
 │         ├── constraint: /2/1: [/1 - /1]
 │         ├── locking: for-update
 │         ├── volatile
 │         ├── key: (1)
 │         └── fd: ()-->(2)
 └── filters
      └── r:3 = 2 [outer=(3), constraints=(/3: [/2 - /2]; tight), fd=()-->(3)]

# --------------------------------------------------
# GenerateInvertedIndexZigzagJoins
# --------------------------------------------------

# Query only the primary key with a remaining filter. 2+ paths in containment
# query should favor zigzag joins.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup b)
      ├── columns: k:1!null j:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── inner-join (zigzag b@j_inv_idx b@j_inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [9] = ['\x3761000112620001']
      │    ├── right fixed columns: [9] = ['\x3763000112640001']
      │    └── filters (true)
      └── filters
           └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Query requiring a zigzag join with a remaining filter.
# TODO(itsbilal): remove filter from index join if zigzag join covers it.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT j, k FROM b WHERE j @> '{"a": "b", "c": "d"}'
----
inner-join (lookup b)
 ├── columns: j:4!null k:1!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(4)
 ├── inner-join (zigzag b@j_inv_idx b@j_inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [9] = ['\x3761000112620001']
 │    ├── right fixed columns: [9] = ['\x3763000112640001']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": "b", "c": "d"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '{"a": {"b": "c", "d": "e"}, "f": "g"}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@j_inv_idx b@j_inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [9] = ['\x3761000262000112630001']
 │    ├── right fixed columns: [9] = ['\x3761000264000112650001']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": {"b": "c", "d": "e"}, "f": "g"}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# Three or more paths. Should generate zigzag joins.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '{"a":[{"b":"c", "d":3}, 5]}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@j_inv_idx b@j_inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [9] = ['\x37610002000362000112630001']
 │    ├── right fixed columns: [9] = ['\x3761000200036400012a0600']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": [{"b": "c", "d": 3}, 5]}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM c WHERE a @> ARRAY[1,3,1,5]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup c)
      ├── columns: k:1!null a:2!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── inner-join (zigzag c@a_inv_idx c@a_inv_idx)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [8] = ['\x89']
      │    ├── right fixed columns: [8] = ['\x8b']
      │    └── filters (true)
      └── filters
           └── a:2 @> ARRAY[1,3,1,5] [outer=(2), immutable, constraints=(/2: (/NULL - ])]

# The first path can't be used for a zigzag join, but the second two can.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '{"a":{}, "b":2, "c":3}'
----
inner-join (lookup b)
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── key columns: [1] = [1]
 ├── lookup columns are key
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── inner-join (zigzag b@j_inv_idx b@j_inv_idx)
 │    ├── columns: k:1!null
 │    ├── eq columns: [1] = [1]
 │    ├── left fixed columns: [9] = ['\x376200012a0400']
 │    ├── right fixed columns: [9] = ['\x376300012a0600']
 │    └── filters (true)
 └── filters
      └── j:4 @> '{"a": {}, "b": 2, "c": 3}' [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# We can't build a zigzag join over a disjunction.
opt expect-not=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '[3]' OR j @> '[[1, 2]]'
----
select
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 ├── index-join b
 │    ├── columns: k:1!null u:2 v:3 j:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 │    └── inverted-filter
 │         ├── columns: k:1!null
 │         ├── inverted expression: /9
 │         │    ├── tight: false, unique: false
 │         │    ├── union spans: ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │         │    └── INTERSECTION
 │         │         ├── span expression
 │         │         │    ├── tight: true, unique: true
 │         │         │    └── union spans: ["7\x00\x03\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x03\x00\x01*\x02\x00"]
 │         │         └── span expression
 │         │              ├── tight: true, unique: true
 │         │              └── union spans: ["7\x00\x03\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x03\x00\x01*\x04\x00"]
 │         ├── key: (1)
 │         └── scan b@j_inv_idx
 │              ├── columns: k:1!null j_inverted_key:9!null
 │              ├── inverted constraint: /9/1
 │              │    └── spans
 │              │         ├── ["7\x00\x03\x00\x01*\x06\x00", "7\x00\x03\x00\x01*\x06\x00"]
 │              │         ├── ["7\x00\x03\x00\x03\x00\x01*\x02\x00", "7\x00\x03\x00\x03\x00\x01*\x02\x00"]
 │              │         └── ["7\x00\x03\x00\x03\x00\x01*\x04\x00", "7\x00\x03\x00\x03\x00\x01*\x04\x00"]
 │              ├── key: (1)
 │              └── fd: (1)-->(9)
 └── filters
      └── (j:4 @> '[3]') OR (j:4 @> '[[1, 2]]') [outer=(4), immutable, constraints=(/4: (/NULL - ])]

# GenerateInvertedIndexZigzagJoins is disabled in the presence of a row-level
# locking clause.
opt expect-not=GenerateInvertedIndexZigzagJoins
SELECT * FROM b WHERE j @> '{"a":1, "c":2}' FOR UPDATE
----
index-join b
 ├── columns: k:1!null u:2 v:3 j:4!null
 ├── volatile
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)~~>(1,2,4)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /9
      │    ├── tight: true, unique: true
      │    ├── union spans: empty
      │    └── INTERSECTION
      │         ├── span expression
      │         │    ├── tight: true, unique: true
      │         │    └── union spans: ["7a\x00\x01*\x02\x00", "7a\x00\x01*\x02\x00"]
      │         └── span expression
      │              ├── tight: true, unique: true
      │              └── union spans: ["7c\x00\x01*\x04\x00", "7c\x00\x01*\x04\x00"]
      ├── volatile
      ├── key: (1)
      └── scan b@j_inv_idx
           ├── columns: k:1!null j_inverted_key:9!null
           ├── inverted constraint: /9/1
           │    └── spans
           │         ├── ["7a\x00\x01*\x02\x00", "7a\x00\x01*\x02\x00"]
           │         └── ["7c\x00\x01*\x04\x00", "7c\x00\x01*\x04\x00"]
           ├── locking: for-update
           ├── volatile
           ├── key: (1)
           └── fd: (1)-->(9)

exec-ddl
CREATE TABLE inv_zz_partial (
    k INT PRIMARY KEY,
    j JSON,
    b BOOL,
    s STRING
)
----

exec-ddl
CREATE INVERTED INDEX zz_idx ON inv_zz_partial (j) WHERE b
----

# Generate a zigzag join on a single index with no remaining filter.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}' AND b
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inverted-filter
      ├── columns: k:1!null
      ├── inverted expression: /7
      │    ├── tight: true, unique: true
      │    ├── union spans: empty
      │    └── INTERSECTION
      │         ├── span expression
      │         │    ├── tight: true, unique: true
      │         │    └── union spans: ["7a\x00\x01*\x02\x00", "7a\x00\x01*\x02\x00"]
      │         └── span expression
      │              ├── tight: true, unique: true
      │              └── union spans: ["7b\x00\x01*\x04\x00", "7b\x00\x01*\x04\x00"]
      ├── key: (1)
      └── scan inv_zz_partial@zz_idx,partial
           ├── columns: k:1!null j_inverted_key:7!null
           ├── inverted constraint: /7/1
           │    └── spans
           │         ├── ["7a\x00\x01*\x02\x00", "7a\x00\x01*\x02\x00"]
           │         └── ["7b\x00\x01*\x04\x00", "7b\x00\x01*\x04\x00"]
           ├── key: (1)
           └── fd: (1)-->(7)

# Generate a zigzag join on a single index with a remaining filter.
opt expect=GenerateInvertedIndexZigzagJoins
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}' AND b AND s = 'foo'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── inner-join (lookup inv_zz_partial)
      ├── columns: k:1!null j:2!null b:3!null s:4!null
      ├── key columns: [1] = [1]
      ├── lookup columns are key
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(3,4), (1)-->(2)
      ├── inner-join (zigzag inv_zz_partial@zz_idx,partial inv_zz_partial@zz_idx,partial)
      │    ├── columns: k:1!null
      │    ├── eq columns: [1] = [1]
      │    ├── left fixed columns: [7] = ['\x376100012a0200']
      │    ├── right fixed columns: [7] = ['\x376200012a0400']
      │    └── filters (true)
      └── filters
           ├── j:2 @> '{"a": 1, "b": 2}' [outer=(2), immutable, constraints=(/2: (/NULL - ])]
           └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

# Don't generate a zigzag join when the predicate is not implied.
opt expect-not=GenerateInvertedIndexZigzagJoins format=hide-all
SELECT k FROM inv_zz_partial WHERE j @> '{"a": 1, "b": 2}'
----
project
 └── select
      ├── scan inv_zz_partial
      │    └── partial index predicates
      │         └── zz_idx: filters
      │              └── b
      └── filters
           └── j @> '{"a": 1, "b": 2}'

exec-ddl
DROP INDEX zz_idx
----

exec-ddl
CREATE INVERTED INDEX zz_idx ON inv_zz_partial (j) WHERE j->'a' = '1'
----

# Don't generate a zigzag join when one of the the expressions that fixes the
# columns is removed while proving partial index implication.
opt expect-not=GenerateInvertedIndexZigzagJoins format=hide-all
SELECT k FROM inv_zz_partial WHERE j->'a' = '1' AND j->'b' = '2'
----
project
 └── scan inv_zz_partial@zz_idx,partial
      └── inverted constraint: /8/1
           └── spans: ["7b\x00\x01*\x04\x00", "7b\x00\x01*\x04\x00"]

# --------------------------------------------------
# SplitDisjunction
# --------------------------------------------------

# TODO(mgartner): PruneAggCols should be pruning columns from the DistinctOn
# and further down the expression tree, ultimately eliminating the index-joins.
# PruneAggCols does not run in this case because normalization rules do not run
# at the root tree generated by an exploration rule.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── ordering: +1
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9)
      │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/1 - /1]
      │    │         ├── key: (7)
      │    │         ├── fd: ()-->(8)
      │    │         └── ordering: +7 opt(8) [actual: +7]
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14)
      │         ├── ordering: +13 opt(15) [actual: +13]
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13: [/1 - /1]
      │              ├── key: (13)
      │              ├── fd: ()-->(15)
      │              └── ordering: +13 opt(15) [actual: +13]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT * FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
distinct-on
 ├── columns: k:1!null u:2 v:3 w:4!null
 ├── grouping columns: k:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3 w:4!null
 │    ├── left columns: k:7 u:8 v:9 w:10
 │    ├── right columns: k:13 u:14 v:15 w:16
 │    ├── ordering: +1
 │    ├── select
 │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
 │    │    ├── key: (7)
 │    │    ├── fd: ()-->(8,10), (7)-->(9)
 │    │    ├── ordering: +7 opt(8,10) [actual: +7]
 │    │    ├── index-join d
 │    │    │    ├── columns: k:7!null u:8 v:9 w:10
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
 │    │    │    ├── ordering: +7 opt(8) [actual: +7]
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:7!null u:8!null
 │    │    │         ├── constraint: /8/7: [/1 - /1]
 │    │    │         ├── key: (7)
 │    │    │         ├── fd: ()-->(8)
 │    │    │         └── ordering: +7 opt(8) [actual: +7]
 │    │    └── filters
 │    │         └── w:10 = 1 [outer=(10), constraints=(/10: [/1 - /1]; tight), fd=()-->(10)]
 │    └── select
 │         ├── columns: k:13!null u:14 v:15!null w:16!null
 │         ├── key: (13)
 │         ├── fd: ()-->(15,16), (13)-->(14)
 │         ├── ordering: +13 opt(15,16) [actual: +13]
 │         ├── index-join d
 │         │    ├── columns: k:13!null u:14 v:15 w:16
 │         │    ├── key: (13)
 │         │    ├── fd: ()-->(15), (13)-->(14,16)
 │         │    ├── ordering: +13 opt(15) [actual: +13]
 │         │    └── scan d@v
 │         │         ├── columns: k:13!null v:15!null
 │         │         ├── constraint: /15/13: [/1 - /1]
 │         │         ├── key: (13)
 │         │         ├── fd: ()-->(15)
 │         │         └── ordering: +13 opt(15) [actual: +13]
 │         └── filters
 │              └── w:16 = 1 [outer=(16), constraints=(/16: [/1 - /1]; tight), fd=()-->(16)]
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      ├── const-agg [as=v:3, outer=(3)]
      │    └── v:3
      └── const-agg [as=w:4, outer=(4)]
           └── w:4

opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:7!null u:8!null v:9!null
      │    │    ├── eq columns: [7] = [7]
      │    │    ├── left fixed columns: [8] = [1]
      │    │    ├── right fixed columns: [9] = [20]
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,9)
      │    │    └── filters
      │    │         ├── u:8 = 1 [outer=(8), constraints=(/8: [/1 - /1]; tight), fd=()-->(8)]
      │    │         └── v:9 = 20 [outer=(9), constraints=(/9: [/20 - /20]; tight), fd=()-->(9)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:13!null u:14!null v:15!null
      │         ├── eq columns: [13] = [13]
      │         ├── left fixed columns: [14] = [10]
      │         ├── right fixed columns: [15] = [2]
      │         ├── key: (13)
      │         ├── fd: ()-->(14,15)
      │         └── filters
      │              ├── v:15 = 2 [outer=(15), constraints=(/15: [/2 - /2]; tight), fd=()-->(15)]
      │              └── u:14 = 10 [outer=(14), constraints=(/14: [/10 - /10]; tight), fd=()-->(14)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunction
SELECT sum(k) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: sum:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── distinct-on
 │    ├── columns: k:1!null u:2 v:3
 │    ├── grouping columns: k:1!null
 │    ├── internal-ordering: +1
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── union-all
 │    │    ├── columns: k:1!null u:2 v:3
 │    │    ├── left columns: k:8 u:9 v:10
 │    │    ├── right columns: k:14 u:15 v:16
 │    │    ├── ordering: +1
 │    │    ├── index-join d
 │    │    │    ├── columns: k:8!null u:9!null v:10
 │    │    │    ├── key: (8)
 │    │    │    ├── fd: ()-->(9), (8)-->(10)
 │    │    │    ├── ordering: +8 opt(9) [actual: +8]
 │    │    │    └── scan d@u
 │    │    │         ├── columns: k:8!null u:9!null
 │    │    │         ├── constraint: /9/8: [/1 - /1]
 │    │    │         ├── key: (8)
 │    │    │         ├── fd: ()-->(9)
 │    │    │         └── ordering: +8 opt(9) [actual: +8]
 │    │    └── index-join d
 │    │         ├── columns: k:14!null u:15 v:16!null
 │    │         ├── key: (14)
 │    │         ├── fd: ()-->(16), (14)-->(15)
 │    │         ├── ordering: +14 opt(16) [actual: +14]
 │    │         └── scan d@v
 │    │              ├── columns: k:14!null v:16!null
 │    │              ├── constraint: /16/14: [/1 - /1]
 │    │              ├── key: (14)
 │    │              ├── fd: ()-->(16)
 │    │              └── ordering: +14 opt(16) [actual: +14]
 │    └── aggregations
 │         ├── const-agg [as=u:2, outer=(2)]
 │         │    └── u:2
 │         └── const-agg [as=v:3, outer=(3)]
 │              └── v:3
 └── aggregations
      └── sum [as=sum:7, outer=(1)]
           └── k:1

# Multi-column primary key.
opt expect=SplitDisjunction
SELECT k, j FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: k:1!null j:2!null
 ├── key: (1,2)
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── internal-ordering: +1,+2
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:7 j:8 u:9 v:10
      │    ├── right columns: k:13 j:14 u:15 v:16
      │    ├── ordering: +1,+2
      │    ├── index-join f
      │    │    ├── columns: k:7!null j:8!null u:9!null v:10
      │    │    ├── key: (7,8)
      │    │    ├── fd: ()-->(9), (7,8)-->(10)
      │    │    ├── ordering: +7,+8 opt(9) [actual: +7,+8]
      │    │    └── scan f@u
      │    │         ├── columns: k:7!null j:8!null u:9!null
      │    │         ├── constraint: /9/7/8: [/1 - /1]
      │    │         ├── key: (7,8)
      │    │         ├── fd: ()-->(9)
      │    │         └── ordering: +7,+8 opt(9) [actual: +7,+8]
      │    └── index-join f
      │         ├── columns: k:13!null j:14!null u:15 v:16!null
      │         ├── key: (13,14)
      │         ├── fd: ()-->(16), (13,14)-->(15)
      │         ├── ordering: +13,+14 opt(16) [actual: +13,+14]
      │         └── scan f@v
      │              ├── columns: k:13!null j:14!null v:16!null
      │              ├── constraint: /16/13/14: [/2 - /2]
      │              ├── key: (13,14)
      │              ├── fd: ()-->(16)
      │              └── ordering: +13,+14 opt(16) [actual: +13,+14]
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/1 - /4]
      │    │         ├── key: (7)
      │    │         └── fd: (7)-->(8)
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: (13)-->(14,15)
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13: [/5 - /8]
      │              ├── key: (13)
      │              └── fd: (13)-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunction
SELECT k FROM b WHERE k = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(4)
      ├── union-all
      │    ├── columns: k:1!null j:4
      │    ├── left columns: k:10 j:13
      │    ├── right columns: k:19 j:22
      │    ├── immutable
      │    ├── scan b
      │    │    ├── columns: k:10!null j:13
      │    │    ├── constraint: /10: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(10,13)
      │    └── index-join b
      │         ├── columns: k:19!null j:22!null
      │         ├── immutable
      │         ├── key: (19)
      │         ├── fd: (19)-->(22)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:19!null
      │              ├── inverted constraint: /27/19
      │              │    └── spans: ["7foo\x00\x01\x12bar\x00\x01", "7foo\x00\x01\x12bar\x00\x01"]
      │              └── key: (19)
      └── aggregations
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunction
SELECT k FROM c WHERE k = 1 OR a @> ARRAY[2]
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── union-all
      │    ├── columns: k:1!null a:2
      │    ├── left columns: k:9 a:10
      │    ├── right columns: k:17 a:18
      │    ├── immutable
      │    ├── scan c
      │    │    ├── columns: k:9!null a:10
      │    │    ├── constraint: /9: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(9,10)
      │    └── index-join c
      │         ├── columns: k:17!null a:18!null
      │         ├── immutable
      │         ├── key: (17)
      │         ├── fd: (17)-->(18)
      │         └── scan c@a_inv_idx
      │              ├── columns: k:17!null
      │              ├── inverted constraint: /24/17
      │              │    └── spans: ["\x8a", "\x8a"]
      │              └── key: (17)
      └── aggregations
           └── const-agg [as=a:2, outer=(2)]
                └── a:2

# Uncorrelated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:12 d.u:13 d.v:14
      │    ├── right columns: d.k:18 d.u:19 d.v:20
      │    ├── ordering: +1
      │    ├── index-join d
      │    │    ├── columns: d.k:12!null d.u:13!null d.v:14
      │    │    ├── key: (12)
      │    │    ├── fd: ()-->(13), (12)-->(14)
      │    │    ├── ordering: +12 opt(13) [actual: +12]
      │    │    └── select
      │    │         ├── columns: d.k:12!null d.u:13!null
      │    │         ├── key: (12)
      │    │         ├── fd: ()-->(13)
      │    │         ├── ordering: +12 opt(13) [actual: +12]
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:12!null d.u:13!null
      │    │         │    ├── constraint: /13/12: [/1 - /1]
      │    │         │    ├── key: (12)
      │    │         │    ├── fd: ()-->(13)
      │    │         │    └── ordering: +12 opt(13) [actual: +12]
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:8 a.v:9
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(8,9)
      │    └── index-join d
      │         ├── columns: d.k:18!null d.u:19 d.v:20!null
      │         ├── key: (18)
      │         ├── fd: ()-->(20), (18)-->(19)
      │         ├── ordering: +18 opt(20) [actual: +18]
      │         └── select
      │              ├── columns: d.k:18!null d.v:20!null
      │              ├── key: (18)
      │              ├── fd: ()-->(20)
      │              ├── ordering: +18 opt(20) [actual: +18]
      │              ├── scan d@v
      │              │    ├── columns: d.k:18!null d.v:20!null
      │              │    ├── constraint: /20/18: [/1 - /1]
      │              │    ├── key: (18)
      │              │    ├── fd: ()-->(20)
      │              │    └── ordering: +18 opt(20) [actual: +18]
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:8 a.v:9
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(8,9)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── semi-join (lookup a@u)
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── key columns: [2] = [8]
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── distinct-on
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── grouping columns: d.k:1!null
      │    ├── internal-ordering: +1
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,3)
      │    ├── union-all
      │    │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    │    ├── left columns: d.k:12 d.u:13 d.v:14
      │    │    ├── right columns: d.k:18 d.u:19 d.v:20
      │    │    ├── ordering: +1
      │    │    ├── index-join d
      │    │    │    ├── columns: d.k:12!null d.u:13!null d.v:14
      │    │    │    ├── key: (12)
      │    │    │    ├── fd: ()-->(13), (12)-->(14)
      │    │    │    ├── ordering: +12 opt(13) [actual: +12]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: d.k:12!null d.u:13!null
      │    │    │         ├── constraint: /13/12: [/1 - /1]
      │    │    │         ├── key: (12)
      │    │    │         ├── fd: ()-->(13)
      │    │    │         └── ordering: +12 opt(13) [actual: +12]
      │    │    └── index-join d
      │    │         ├── columns: d.k:18!null d.u:19 d.v:20!null
      │    │         ├── key: (18)
      │    │         ├── fd: ()-->(20), (18)-->(19)
      │    │         ├── ordering: +18 opt(20) [actual: +18]
      │    │         └── scan d@v
      │    │              ├── columns: d.k:18!null d.v:20!null
      │    │              ├── constraint: /20/18: [/1 - /1]
      │    │              ├── key: (18)
      │    │              ├── fd: ()-->(20)
      │    │              └── ordering: +18 opt(20) [actual: +18]
      │    └── aggregations
      │         ├── const-agg [as=d.u:2, outer=(2)]
      │         │    └── d.u:2
      │         └── const-agg [as=d.v:3, outer=(3)]
      │              └── d.v:3
      └── filters (true)

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── semi-join (lookup a@u)
      ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      ├── key columns: [4] = [8]
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── distinct-on
      │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      │    ├── grouping columns: d.k:1!null
      │    ├── internal-ordering: +1
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4)
      │    ├── union-all
      │    │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      │    │    ├── left columns: d.k:12 d.u:13 d.v:14 w:15
      │    │    ├── right columns: d.k:18 d.u:19 d.v:20 w:21
      │    │    ├── ordering: +1
      │    │    ├── index-join d
      │    │    │    ├── columns: d.k:12!null d.u:13!null d.v:14 w:15
      │    │    │    ├── key: (12)
      │    │    │    ├── fd: ()-->(13), (12)-->(14,15)
      │    │    │    ├── ordering: +12 opt(13) [actual: +12]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: d.k:12!null d.u:13!null
      │    │    │         ├── constraint: /13/12: [/1 - /1]
      │    │    │         ├── key: (12)
      │    │    │         ├── fd: ()-->(13)
      │    │    │         └── ordering: +12 opt(13) [actual: +12]
      │    │    └── index-join d
      │    │         ├── columns: d.k:18!null d.u:19 d.v:20!null w:21
      │    │         ├── key: (18)
      │    │         ├── fd: ()-->(20), (18)-->(19,21)
      │    │         ├── ordering: +18 opt(20) [actual: +18]
      │    │         └── scan d@v
      │    │              ├── columns: d.k:18!null d.v:20!null
      │    │              ├── constraint: /20/18: [/1 - /1]
      │    │              ├── key: (18)
      │    │              ├── fd: ()-->(20)
      │    │              └── ordering: +18 opt(20) [actual: +18]
      │    └── aggregations
      │         ├── const-agg [as=d.u:2, outer=(2)]
      │         │    └── d.u:2
      │         ├── const-agg [as=d.v:3, outer=(3)]
      │         │    └── d.v:3
      │         └── const-agg [as=w:4, outer=(4)]
      │              └── w:4
      └── filters (true)

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM e WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:7 u:8 v:9
 │    ├── right columns: k:13 u:14 v:15
 │    ├── index-join e
 │    │    ├── columns: k:7!null u:8!null v:9
 │    │    ├── key: (7)
 │    │    ├── fd: ()-->(8), (7)-->(9)
 │    │    └── scan e@uw
 │    │         ├── columns: k:7!null u:8!null
 │    │         ├── constraint: /8/10/7: [/1 - /1]
 │    │         ├── key: (7)
 │    │         └── fd: ()-->(8)
 │    └── index-join e
 │         ├── columns: k:13!null u:14 v:15!null
 │         ├── key: (13)
 │         ├── fd: ()-->(15), (13)-->(14)
 │         └── scan e@vw
 │              ├── columns: k:13!null v:15!null
 │              ├── constraint: /15/16/13: [/1 - /1]
 │              ├── key: (13)
 │              └── fd: ()-->(15)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: k:1!null u:2 v:3
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:7 u:8 v:9 w:10
      │    ├── right columns: k:13 u:14 v:15 w:16
      │    ├── ordering: +1
      │    ├── select
      │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,10), (7)-->(9)
      │    │    ├── ordering: +7 opt(8,10) [actual: +7]
      │    │    ├── index-join d
      │    │    │    ├── columns: k:7!null u:8 v:9 w:10
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:7!null u:8!null
      │    │    │         ├── constraint: /8/7: [/1 - /1]
      │    │    │         ├── key: (7)
      │    │    │         ├── fd: ()-->(8)
      │    │    │         └── ordering: +7 opt(8) [actual: +7]
      │    │    └── filters
      │    │         └── w:10 = 2 [outer=(10), constraints=(/10: [/2 - /2]; tight), fd=()-->(10)]
      │    └── select
      │         ├── columns: k:13!null u:14 v:15!null w:16!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15,16), (13)-->(14)
      │         ├── ordering: +13 opt(15,16) [actual: +13]
      │         ├── index-join d
      │         │    ├── columns: k:13!null u:14 v:15 w:16
      │         │    ├── key: (13)
      │         │    ├── fd: ()-->(15), (13)-->(14,16)
      │         │    ├── ordering: +13 opt(15) [actual: +13]
      │         │    └── scan d@v
      │         │         ├── columns: k:13!null v:15!null
      │         │         ├── constraint: /15/13: [/1 - /1]
      │         │         ├── key: (13)
      │         │         ├── fd: ()-->(15)
      │         │         └── ordering: +13 opt(15) [actual: +13]
      │         └── filters
      │              └── w:16 = 3 [outer=(16), constraints=(/16: [/3 - /3]; tight), fd=()-->(16)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: k:1!null u:2 v:3
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:7 u:8 v:9 w:10
      │    ├── right columns: k:13 u:14 v:15 w:16
      │    ├── ordering: +1
      │    ├── select
      │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,10), (7)-->(9)
      │    │    ├── ordering: +7 opt(8,10) [actual: +7]
      │    │    ├── index-join d
      │    │    │    ├── columns: k:7!null u:8 v:9 w:10
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:7!null u:8!null
      │    │    │         ├── constraint: /8/7: [/1 - /1]
      │    │    │         ├── key: (7)
      │    │    │         ├── fd: ()-->(8)
      │    │    │         └── ordering: +7 opt(8) [actual: +7]
      │    │    └── filters
      │    │         └── w:10 = 2 [outer=(10), constraints=(/10: [/2 - /2]; tight), fd=()-->(10)]
      │    └── select
      │         ├── columns: k:13!null u:14 v:15!null w:16!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15,16), (13)-->(14)
      │         ├── ordering: +13 opt(15,16) [actual: +13]
      │         ├── index-join d
      │         │    ├── columns: k:13!null u:14 v:15 w:16
      │         │    ├── key: (13)
      │         │    ├── fd: ()-->(15), (13)-->(14,16)
      │         │    ├── ordering: +13 opt(15) [actual: +13]
      │         │    └── scan d@v
      │         │         ├── columns: k:13!null v:15!null
      │         │         ├── constraint: /15/13: [/1 - /1]
      │         │         ├── key: (13)
      │         │         ├── fd: ()-->(15)
      │         │         └── ordering: +13 opt(15) [actual: +13]
      │         └── filters
      │              └── w:16 = 3 [outer=(16), constraints=(/16: [/3 - /3]; tight), fd=()-->(16)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:7 u:8 v:9
 │    ├── right columns: k:13 u:14 v:15
 │    ├── index-join d
 │    │    ├── columns: k:7!null u:8!null v:9
 │    │    ├── key: (7)
 │    │    ├── fd: (7)-->(8,9)
 │    │    └── scan d@u
 │    │         ├── columns: k:7!null u:8!null
 │    │         ├── constraint: /8/7
 │    │         │    ├── [/1 - /1]
 │    │         │    └── [/3 - /3]
 │    │         ├── key: (7)
 │    │         └── fd: (7)-->(8)
 │    └── index-join d
 │         ├── columns: k:13!null u:14 v:15!null
 │         ├── key: (13)
 │         ├── fd: (13)-->(14,15)
 │         └── scan d@v
 │              ├── columns: k:13!null v:15!null
 │              ├── constraint: /15/13
 │              │    ├── [/2 - /2]
 │              │    └── [/4 - /4]
 │              ├── key: (13)
 │              └── fd: (13)-->(15)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:7 u:8 v:9
 │    ├── right columns: k:13 u:14 v:15
 │    ├── index-join d
 │    │    ├── columns: k:7!null u:8!null v:9
 │    │    ├── key: (7)
 │    │    ├── fd: (7)-->(8,9)
 │    │    └── scan d@u
 │    │         ├── columns: k:7!null u:8!null
 │    │         ├── constraint: /8/7
 │    │         │    ├── [/1 - /1]
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (7)
 │    │         └── fd: (7)-->(8)
 │    └── index-join d
 │         ├── columns: k:13!null u:14 v:15!null
 │         ├── key: (13)
 │         ├── fd: (13)-->(14,15)
 │         └── scan d@v
 │              ├── columns: k:13!null v:15!null
 │              ├── constraint: /15/13
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (13)
 │              └── fd: (13)-->(15)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunction
SELECT k, u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:7 u:8 v:9
 │    ├── right columns: k:13 u:14 v:15
 │    ├── index-join d
 │    │    ├── columns: k:7!null u:8!null v:9
 │    │    ├── key: (7)
 │    │    ├── fd: (7)-->(8,9)
 │    │    └── scan d@u
 │    │         ├── columns: k:7!null u:8!null
 │    │         ├── constraint: /8/7
 │    │         │    ├── [/3 - /3]
 │    │         │    └── [/5 - /5]
 │    │         ├── key: (7)
 │    │         └── fd: (7)-->(8)
 │    └── index-join d
 │         ├── columns: k:13!null u:14 v:15!null
 │         ├── key: (13)
 │         ├── fd: (13)-->(14,15)
 │         └── scan d@v
 │              ├── columns: k:13!null v:15!null
 │              ├── constraint: /15/13
 │              │    ├── [/2 - /2]
 │              │    ├── [/4 - /4]
 │              │    └── [/6 - /6]
 │              ├── key: (13)
 │              └── fd: (13)-->(15)
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:7 u:8 v:9 w:10
      │    ├── right columns: k:13 u:14 v:15 w:16
      │    ├── ordering: +1
      │    ├── select
      │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    ├── index-join d
      │    │    │    ├── columns: k:7!null u:8 v:9 w:10
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:7!null u:8!null
      │    │    │         ├── constraint: /8/7: [/3 - /3]
      │    │    │         ├── key: (7)
      │    │    │         ├── fd: ()-->(8)
      │    │    │         └── ordering: +7 opt(8) [actual: +7]
      │    │    └── filters
      │    │         └── (w:10 = 1) OR (w:10 = 2) [outer=(10), constraints=(/10: [/1 - /1] [/2 - /2]; tight)]
      │    └── select
      │         ├── columns: k:13!null u:14 v:15!null w:16!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14,16)
      │         ├── ordering: +13 opt(15) [actual: +13]
      │         ├── index-join d
      │         │    ├── columns: k:13!null u:14 v:15 w:16
      │         │    ├── key: (13)
      │         │    ├── fd: ()-->(15), (13)-->(14,16)
      │         │    ├── ordering: +13 opt(15) [actual: +13]
      │         │    └── scan d@v
      │         │         ├── columns: k:13!null v:15!null
      │         │         ├── constraint: /15/13: [/4 - /4]
      │         │         ├── key: (13)
      │         │         ├── fd: ()-->(15)
      │         │         └── ordering: +13 opt(15) [actual: +13]
      │         └── filters
      │              └── (w:16 = 1) OR (w:16 = 2) [outer=(16), constraints=(/16: [/1 - /1] [/2 - /2]; tight)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4
      │    ├── left columns: k:7 u:8 v:9 w:10
      │    ├── right columns: k:13 u:14 v:15 w:16
      │    ├── ordering: +1
      │    ├── select
      │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,10), (7)-->(9)
      │    │    ├── ordering: +7 opt(8,10) [actual: +7]
      │    │    ├── index-join d
      │    │    │    ├── columns: k:7!null u:8 v:9 w:10
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:7!null u:8!null
      │    │    │         ├── constraint: /8/7: [/3 - /3]
      │    │    │         ├── key: (7)
      │    │    │         ├── fd: ()-->(8)
      │    │    │         └── ordering: +7 opt(8) [actual: +7]
      │    │    └── filters
      │    │         └── w:10 = 2 [outer=(10), constraints=(/10: [/2 - /2]; tight), fd=()-->(10)]
      │    └── select
      │         ├── columns: k:13!null u:14 v:15!null w:16
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14,16)
      │         ├── ordering: +13 opt(15) [actual: +13]
      │         ├── index-join d
      │         │    ├── columns: k:13!null u:14 v:15 w:16
      │         │    ├── key: (13)
      │         │    ├── fd: ()-->(15), (13)-->(14,16)
      │         │    ├── ordering: +13 opt(15) [actual: +13]
      │         │    └── scan d@v
      │         │         ├── columns: k:13!null v:15!null
      │         │         ├── constraint: /15/13: [/4 - /4]
      │         │         ├── key: (13)
      │         │         ├── fd: ()-->(15)
      │         │         └── ordering: +13 opt(15) [actual: +13]
      │         └── filters
      │              └── (u:14 = 1) OR (w:16 = 2) [outer=(14,16)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunction
SELECT k, u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: k:1!null u:2 w:4
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan d
 │    ├── columns: k:1!null u:2 w:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries without strict keys.
opt expect-not=SplitDisjunction
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── ordering: +1
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9)
      │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/1 - /1]
      │    │         ├── key: (7)
      │    │         ├── fd: ()-->(8)
      │    │         └── ordering: +7 opt(8) [actual: +7]
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14)
      │         ├── ordering: +13 opt(15) [actual: +13]
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13: [/1 - /1]
      │              ├── key: (13)
      │              ├── fd: ()-->(15)
      │              └── ordering: +13 opt(15) [actual: +13]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunction
SELECT k FROM d WHERE u = 1 OR u = 5
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── scan d@u
      ├── columns: k:1!null u:2!null
      ├── constraint: /2/1
      │    ├── [/1 - /1]
      │    └── [/5 - /5]
      ├── key: (1)
      └── fd: (1)-->(2)

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunction
SELECT k FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3), (3)~~>(1,2)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:6 u:7 v:8
      │    ├── right columns: k:11 u:12 v:13
      │    ├── ordering: +1
      │    ├── scan a@u
      │    │    ├── columns: k:6!null u:7!null v:8
      │    │    ├── constraint: /7/6: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (6)
      │    │    ├── fd: ()-->(7), (6)-->(8), (8)~~>(6)
      │    │    └── ordering: +6 opt(7) [actual: +6]
      │    └── scan a@v
      │         ├── columns: k:11!null u:12 v:13!null
      │         ├── constraint: /13: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(11-13)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunction
SELECT k FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1 opt(2)
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      ├── project
      │    ├── columns: k:1!null u:2!null v:3
      │    ├── key: (1)
      │    ├── fd: ()-->(2), (1)-->(3)
      │    ├── ordering: +1 opt(2) [actual: +1]
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9)
      │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/2 - /2]
      │    │         ├── key: (7)
      │    │         ├── fd: ()-->(8)
      │    │         └── ordering: +7 opt(8) [actual: +7]
      │    └── projections
      │         ├── k:7 [as=k:1, outer=(7)]
      │         ├── u:8 [as=u:2, outer=(8)]
      │         └── v:9 [as=v:3, outer=(9)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllRight is applied.
opt expect=SplitDisjunction
SELECT k FROM d WHERE (u = 2 AND u = 4) OR v = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3!null
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1 opt(3)
      ├── key: (1)
      ├── fd: ()-->(3), (1)-->(2)
      ├── project
      │    ├── columns: k:1!null u:2 v:3!null
      │    ├── key: (1)
      │    ├── fd: ()-->(3), (1)-->(2)
      │    ├── ordering: +1 opt(3) [actual: +1]
      │    ├── index-join d
      │    │    ├── columns: k:13!null u:14 v:15!null
      │    │    ├── key: (13)
      │    │    ├── fd: ()-->(15), (13)-->(14)
      │    │    ├── ordering: +13 opt(15) [actual: +13]
      │    │    └── scan d@v
      │    │         ├── columns: k:13!null v:15!null
      │    │         ├── constraint: /15/13: [/1 - /1]
      │    │         ├── key: (13)
      │    │         ├── fd: ()-->(15)
      │    │         └── ordering: +13 opt(15) [actual: +13]
      │    └── projections
      │         ├── k:13 [as=k:1, outer=(13)]
      │         ├── u:14 [as=u:2, outer=(14)]
      │         └── v:15 [as=v:3, outer=(15)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Regression test for #52207. Partial index predicates in TableMeta must be
# duplicated when TableMeta is duplicated.
exec-ddl
CREATE TABLE t52207 (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  INDEX idx_a (a) WHERE a > 0,
  INDEX idx_b (b) WHERE b > 0
)
----

opt expect=SplitDisjunction
SELECT k FROM t52207 WHERE a = 1 OR b = 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── distinct-on
      ├── columns: k:1!null a:2 b:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 b:3
      │    ├── left columns: k:6 a:7 b:8
      │    ├── right columns: k:11 a:12 b:13
      │    ├── ordering: +1
      │    ├── index-join t52207
      │    │    ├── columns: k:6!null a:7!null b:8
      │    │    ├── key: (6)
      │    │    ├── fd: ()-->(7), (6)-->(8)
      │    │    ├── ordering: +6 opt(7) [actual: +6]
      │    │    └── scan t52207@idx_a,partial
      │    │         ├── columns: k:6!null a:7!null
      │    │         ├── constraint: /7/6: [/1 - /1]
      │    │         ├── key: (6)
      │    │         ├── fd: ()-->(7)
      │    │         └── ordering: +6 opt(7) [actual: +6]
      │    └── index-join t52207
      │         ├── columns: k:11!null a:12 b:13!null
      │         ├── key: (11)
      │         ├── fd: ()-->(13), (11)-->(12)
      │         ├── ordering: +11 opt(13) [actual: +11]
      │         └── scan t52207@idx_b,partial
      │              ├── columns: k:11!null b:13!null
      │              ├── constraint: /13/11: [/1 - /1]
      │              ├── key: (11)
      │              ├── fd: ()-->(13)
      │              └── ordering: +11 opt(13) [actual: +11]
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=b:3, outer=(3)]
                └── b:3

# Regression test for #58390. SplitDisjunction must not generate a cycle in the
# memo when there is a partial index with a predicate identical to the
# disjunction in the query filter.
exec-ddl
CREATE TABLE t58390 (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  c INT,
  INDEX (c) WHERE a > 1 OR b > 1
)
----

memo
SELECT * FROM t58390 WHERE a > 1 OR b > 1
----
memo (optimized, ~19KB, required=[presentation: k:1,a:2,b:3,c:4])
 ├── G1: (select G2 G3) (index-join G4 t58390,cols=(1-4)) (distinct-on G5 G6 cols=(1)) (distinct-on G5 G6 cols=(1),ordering=+1)
 │    └── [presentation: k:1,a:2,b:3,c:4]
 │         ├── best: (select G2 G3)
 │         └── cost: 1115.63
 ├── G2: (scan t58390,cols=(1-4))
 │    └── []
 │         ├── best: (scan t58390,cols=(1-4))
 │         └── cost: 1105.61
 ├── G3: (filters G7)
 ├── G4: (scan t58390@secondary,partial,cols=(1,4))
 │    └── []
 │         ├── best: (scan t58390@secondary,partial,cols=(1,4))
 │         └── cost: 707.74
 ├── G5: (union-all G8 G9)
 │    ├── [ordering: +1]
 │    │    ├── best: (union-all G8="[ordering: +7]" G9="[ordering: +13]")
 │    │    └── cost: 2237.94
 │    └── []
 │         ├── best: (union-all G8 G9)
 │         └── cost: 2237.94
 ├── G6: (aggregations G10 G11 G12)
 ├── G7: (or G13 G14)
 ├── G8: (select G15 G16) (select G17 G16)
 │    ├── [ordering: +7]
 │    │    ├── best: (select G15="[ordering: +7]" G16)
 │    │    └── cost: 1115.63
 │    └── []
 │         ├── best: (select G15 G16)
 │         └── cost: 1115.63
 ├── G9: (select G18 G19) (select G20 G19)
 │    ├── [ordering: +13]
 │    │    ├── best: (select G18="[ordering: +13]" G19)
 │    │    └── cost: 1115.63
 │    └── []
 │         ├── best: (select G18 G19)
 │         └── cost: 1115.63
 ├── G10: (const-agg G21)
 ├── G11: (const-agg G22)
 ├── G12: (const-agg G23)
 ├── G13: (gt G21 G24)
 ├── G14: (gt G22 G24)
 ├── G15: (scan t58390,cols=(7-10))
 │    ├── [ordering: +7]
 │    │    ├── best: (scan t58390,cols=(7-10))
 │    │    └── cost: 1105.61
 │    └── []
 │         ├── best: (scan t58390,cols=(7-10))
 │         └── cost: 1105.61
 ├── G16: (filters G25)
 ├── G17: (index-join G26 t58390,cols=(7-10))
 │    ├── [ordering: +7]
 │    │    ├── best: (index-join G26="[ordering: +7]" t58390,cols=(7-10))
 │    │    └── cost: 4906.24
 │    └── []
 │         ├── best: (index-join G26 t58390,cols=(7-10))
 │         └── cost: 4754.42
 ├── G18: (scan t58390,cols=(13-16))
 │    ├── [ordering: +13]
 │    │    ├── best: (scan t58390,cols=(13-16))
 │    │    └── cost: 1105.61
 │    └── []
 │         ├── best: (scan t58390,cols=(13-16))
 │         └── cost: 1105.61
 ├── G19: (filters G27)
 ├── G20: (index-join G28 t58390,cols=(13-16))
 │    ├── [ordering: +13]
 │    │    ├── best: (index-join G28="[ordering: +13]" t58390,cols=(13-16))
 │    │    └── cost: 4906.24
 │    └── []
 │         ├── best: (index-join G28 t58390,cols=(13-16))
 │         └── cost: 4754.42
 ├── G21: (variable a)
 ├── G22: (variable b)
 ├── G23: (variable c)
 ├── G24: (const 1)
 ├── G25: (gt G29 G24)
 ├── G26: (scan t58390@secondary,partial,cols=(7,10))
 │    ├── [ordering: +7]
 │    │    ├── best: (sort G26)
 │    │    └── cost: 859.56
 │    └── []
 │         ├── best: (scan t58390@secondary,partial,cols=(7,10))
 │         └── cost: 707.74
 ├── G27: (gt G30 G24)
 ├── G28: (scan t58390@secondary,partial,cols=(13,16))
 │    ├── [ordering: +13]
 │    │    ├── best: (sort G28)
 │    │    └── cost: 859.56
 │    └── []
 │         ├── best: (scan t58390@secondary,partial,cols=(13,16))
 │         └── cost: 707.74
 ├── G29: (variable a)
 └── G30: (variable b)

# Regression test for #61795. Equivalence dependencies are propagated to
# UnionAll expressions generated by SplitDisjunction, preventing failed
# test-build assertions in ordering.checkRequired that require that ordering
# column groups contain columns that are known to be equivalent.
exec-ddl
CREATE TABLE t61795 (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  UNIQUE (b)
)
----

memo expect=SplitDisjunction
SELECT t1.a
FROM t61795 AS t1
JOIN t61795 AS t2 ON t1.c = t1.b AND t1.b = t2.b
WHERE t1.a = 10 OR t2.b != abs(t2.b)
ORDER BY t1.b ASC
----
memo (optimized, ~28KB, required=[presentation: a:1] [ordering: +2])
 ├── G1: (project G2 G3 a b)
 │    ├── [presentation: a:1] [ordering: +2]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1095.28
 │    └── []
 │         ├── best: (project G2 G3 a b)
 │         └── cost: 1095.25
 ├── G2: (select G4 G5) (select G6 G7) (distinct-on G8 G9 cols=(1)) (distinct-on G8 G9 cols=(1),ordering=+1)
 │    ├── [ordering: +(2|3)]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1095.27
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1095.24
 ├── G3: (projections)
 ├── G4: (scan t61795 [as=t1],cols=(1-3))
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1334.68
 │    └── []
 │         ├── best: (scan t61795 [as=t1],cols=(1-3))
 │         └── cost: 1085.21
 ├── G5: (filters G10 G11)
 ├── G6: (index-join G12 t61795,cols=(1-3))
 │    ├── [ordering: +2]
 │    │    ├── best: (index-join G12="[ordering: +2]" t61795,cols=(1-3))
 │    │    └── cost: 3050.44
 │    └── []
 │         ├── best: (index-join G12 t61795,cols=(1-3))
 │         └── cost: 3050.44
 ├── G7: (filters G10)
 ├── G8: (union-all G13 G14)
 │    ├── [ordering: +(2|3)]
 │    │    ├── best: (union-all G13 G14="[ordering: +(17|18)]")
 │    │    └── cost: 1100.39
 │    ├── [ordering: +1]
 │    │    ├── best: (union-all G13 G14="[ordering: +16]")
 │    │    └── cost: 1100.36
 │    └── []
 │         ├── best: (union-all G13 G14)
 │         └── cost: 1100.36
 ├── G9: (aggregations G15 G16)
 ├── G10: (eq G17 G18)
 ├── G11: (or G19 G20)
 ├── G12: (select G21 G22)
 │    ├── [ordering: +2]
 │    │    ├── best: (select G21="[ordering: +2]" G22)
 │    │    └── cost: 1053.93
 │    └── []
 │         ├── best: (select G21 G22)
 │         └── cost: 1053.93
 ├── G13: (select G23 G24) (select G25 G26) (select G27 G26)
 │    └── []
 │         ├── best: (select G25 G26)
 │         └── cost: 5.10
 ├── G14: (select G28 G29) (select G30 G31)
 │    ├── [ordering: +(17|18)]
 │    │    ├── best: (sort G14)
 │    │    └── cost: 1095.27
 │    ├── [ordering: +16]
 │    │    ├── best: (select G28="[ordering: +16]" G29)
 │    │    └── cost: 1095.24
 │    └── []
 │         ├── best: (select G28 G29)
 │         └── cost: 1095.24
 ├── G15: (const-agg G18)
 ├── G16: (const-agg G17)
 ├── G17: (variable t1.c)
 ├── G18: (variable t1.b)
 ├── G19: (eq G32 G33)
 ├── G20: (ne G18 G34)
 ├── G21: (scan t61795@secondary [as=t1],cols=(1,2),constrained)
 │    ├── [ordering: +2]
 │    │    ├── best: (scan t61795@secondary [as=t1],cols=(1,2),constrained)
 │    │    └── cost: 1044.01
 │    └── []
 │         ├── best: (scan t61795@secondary [as=t1],cols=(1,2),constrained)
 │         └── cost: 1044.01
 ├── G22: (filters G11)
 ├── G23: (scan t61795 [as=t1],cols=(11-13))
 │    └── []
 │         ├── best: (scan t61795 [as=t1],cols=(11-13))
 │         └── cost: 1085.21
 ├── G24: (filters G35 G36)
 ├── G25: (scan t61795 [as=t1],cols=(11-13),constrained)
 │    └── []
 │         ├── best: (scan t61795 [as=t1],cols=(11-13),constrained)
 │         └── cost: 5.07
 ├── G26: (filters G35)
 ├── G27: (index-join G37 t61795,cols=(11-13))
 │    └── []
 │         ├── best: (index-join G37 t61795,cols=(11-13))
 │         └── cost: 1059.99
 ├── G28: (scan t61795 [as=t1],cols=(16-18))
 │    ├── [ordering: +16]
 │    │    ├── best: (scan t61795 [as=t1],cols=(16-18))
 │    │    └── cost: 1085.21
 │    ├── [ordering: +17]
 │    │    ├── best: (sort G28)
 │    │    └── cost: 1334.68
 │    └── []
 │         ├── best: (scan t61795 [as=t1],cols=(16-18))
 │         └── cost: 1085.21
 ├── G29: (filters G38 G39)
 ├── G30: (index-join G40 t61795,cols=(16-18))
 │    ├── [ordering: +16]
 │    │    ├── best: (index-join G40="[ordering: +16]" t61795,cols=(16-18))
 │    │    └── cost: 3118.88
 │    ├── [ordering: +17]
 │    │    ├── best: (index-join G40="[ordering: +17]" t61795,cols=(16-18))
 │    │    └── cost: 3050.44
 │    └── []
 │         ├── best: (index-join G40 t61795,cols=(16-18))
 │         └── cost: 3050.44
 ├── G31: (filters G38)
 ├── G32: (variable t1.a)
 ├── G33: (const 10)
 ├── G34: (function G41 abs)
 ├── G35: (eq G42 G43)
 ├── G36: (eq G44 G33)
 ├── G37: (select G45 G46)
 │    └── []
 │         ├── best: (select G45 G46)
 │         └── cost: 1053.93
 ├── G38: (eq G47 G48)
 ├── G39: (ne G48 G49)
 ├── G40: (select G50 G51)
 │    ├── [ordering: +16]
 │    │    ├── best: (sort G40)
 │    │    └── cost: 1122.37
 │    ├── [ordering: +17]
 │    │    ├── best: (select G50="[ordering: +17]" G51)
 │    │    └── cost: 1053.93
 │    └── []
 │         ├── best: (select G50 G51)
 │         └── cost: 1053.93
 ├── G41: (scalar-list G18)
 ├── G42: (variable t1.c)
 ├── G43: (variable t1.b)
 ├── G44: (variable t1.a)
 ├── G45: (scan t61795@secondary [as=t1],cols=(11,12),constrained)
 │    └── []
 │         ├── best: (scan t61795@secondary [as=t1],cols=(11,12),constrained)
 │         └── cost: 1044.01
 ├── G46: (filters G36)
 ├── G47: (variable t1.c)
 ├── G48: (variable t1.b)
 ├── G49: (function G52 abs)
 ├── G50: (scan t61795@secondary [as=t1],cols=(16,17),constrained)
 │    ├── [ordering: +16]
 │    │    ├── best: (sort G50)
 │    │    └── cost: 1280.80
 │    ├── [ordering: +17]
 │    │    ├── best: (scan t61795@secondary [as=t1],cols=(16,17),constrained)
 │    │    └── cost: 1044.01
 │    └── []
 │         ├── best: (scan t61795@secondary [as=t1],cols=(16,17),constrained)
 │         └── cost: 1044.01
 ├── G51: (filters G39)
 └── G52: (scalar-list G48)

# --------------------------------------------------
# SplitDisjunctionAddKey
# --------------------------------------------------

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── ordering: +1
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9)
      │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/1 - /1]
      │    │         ├── key: (7)
      │    │         ├── fd: ()-->(8)
      │    │         └── ordering: +7 opt(8) [actual: +7]
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14)
      │         ├── ordering: +13 opt(15) [actual: +13]
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13: [/1 - /1]
      │              ├── key: (13)
      │              ├── fd: ()-->(15)
      │              └── ordering: +13 opt(15) [actual: +13]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT u, v, w FROM d WHERE w = 1 AND (u = 1 OR v = 1)
----
project
 ├── columns: u:2 v:3 w:4!null
 ├── fd: ()-->(4)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3 w:4!null
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-4)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3 w:4!null
      │    ├── left columns: k:7 u:8 v:9 w:10
      │    ├── right columns: k:13 u:14 v:15 w:16
      │    ├── ordering: +1
      │    ├── select
      │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,10), (7)-->(9)
      │    │    ├── ordering: +7 opt(8,10) [actual: +7]
      │    │    ├── index-join d
      │    │    │    ├── columns: k:7!null u:8 v:9 w:10
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
      │    │    │    ├── ordering: +7 opt(8) [actual: +7]
      │    │    │    └── scan d@u
      │    │    │         ├── columns: k:7!null u:8!null
      │    │    │         ├── constraint: /8/7: [/1 - /1]
      │    │    │         ├── key: (7)
      │    │    │         ├── fd: ()-->(8)
      │    │    │         └── ordering: +7 opt(8) [actual: +7]
      │    │    └── filters
      │    │         └── w:10 = 1 [outer=(10), constraints=(/10: [/1 - /1]; tight), fd=()-->(10)]
      │    └── select
      │         ├── columns: k:13!null u:14 v:15!null w:16!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15,16), (13)-->(14)
      │         ├── ordering: +13 opt(15,16) [actual: +13]
      │         ├── index-join d
      │         │    ├── columns: k:13!null u:14 v:15 w:16
      │         │    ├── key: (13)
      │         │    ├── fd: ()-->(15), (13)-->(14,16)
      │         │    ├── ordering: +13 opt(15) [actual: +13]
      │         │    └── scan d@v
      │         │         ├── columns: k:13!null v:15!null
      │         │         ├── constraint: /15/13: [/1 - /1]
      │         │         ├── key: (13)
      │         │         ├── fd: ()-->(15)
      │         │         └── ordering: +13 opt(15) [actual: +13]
      │         └── filters
      │              └── w:16 = 1 [outer=(16), constraints=(/16: [/1 - /1]; tight), fd=()-->(16)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           ├── const-agg [as=v:3, outer=(3)]
           │    └── v:3
           └── const-agg [as=w:4, outer=(4)]
                └── w:4

opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) AND (u = 10 OR v = 20)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2!null v:3!null
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2!null v:3!null
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── inner-join (zigzag d@u d@v)
      │    │    ├── columns: k:7!null u:8!null v:9!null
      │    │    ├── eq columns: [7] = [7]
      │    │    ├── left fixed columns: [8] = [1]
      │    │    ├── right fixed columns: [9] = [20]
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8,9)
      │    │    └── filters
      │    │         ├── u:8 = 1 [outer=(8), constraints=(/8: [/1 - /1]; tight), fd=()-->(8)]
      │    │         └── v:9 = 20 [outer=(9), constraints=(/9: [/20 - /20]; tight), fd=()-->(9)]
      │    └── inner-join (zigzag d@u d@v)
      │         ├── columns: k:13!null u:14!null v:15!null
      │         ├── eq columns: [13] = [13]
      │         ├── left fixed columns: [14] = [10]
      │         ├── right fixed columns: [15] = [2]
      │         ├── key: (13)
      │         ├── fd: ()-->(14,15)
      │         └── filters
      │              ├── v:15 = 2 [outer=(15), constraints=(/15: [/2 - /2]; tight), fd=()-->(15)]
      │              └── u:14 = 10 [outer=(14), constraints=(/14: [/10 - /10]; tight), fd=()-->(14)]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

opt expect=SplitDisjunctionAddKey
SELECT count(*) FROM d WHERE u = 1 OR v = 1
----
scalar-group-by
 ├── columns: count:7!null
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── project
 │    ├── columns: u:2 v:3
 │    └── distinct-on
 │         ├── columns: k:1!null u:2 v:3
 │         ├── grouping columns: k:1!null
 │         ├── internal-ordering: +1
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,3)
 │         ├── union-all
 │         │    ├── columns: k:1!null u:2 v:3
 │         │    ├── left columns: k:8 u:9 v:10
 │         │    ├── right columns: k:14 u:15 v:16
 │         │    ├── ordering: +1
 │         │    ├── index-join d
 │         │    │    ├── columns: k:8!null u:9!null v:10
 │         │    │    ├── key: (8)
 │         │    │    ├── fd: ()-->(9), (8)-->(10)
 │         │    │    ├── ordering: +8 opt(9) [actual: +8]
 │         │    │    └── scan d@u
 │         │    │         ├── columns: k:8!null u:9!null
 │         │    │         ├── constraint: /9/8: [/1 - /1]
 │         │    │         ├── key: (8)
 │         │    │         ├── fd: ()-->(9)
 │         │    │         └── ordering: +8 opt(9) [actual: +8]
 │         │    └── index-join d
 │         │         ├── columns: k:14!null u:15 v:16!null
 │         │         ├── key: (14)
 │         │         ├── fd: ()-->(16), (14)-->(15)
 │         │         ├── ordering: +14 opt(16) [actual: +14]
 │         │         └── scan d@v
 │         │              ├── columns: k:14!null v:16!null
 │         │              ├── constraint: /16/14: [/1 - /1]
 │         │              ├── key: (14)
 │         │              ├── fd: ()-->(16)
 │         │              └── ordering: +14 opt(16) [actual: +14]
 │         └── aggregations
 │              ├── const-agg [as=u:2, outer=(2)]
 │              │    └── u:2
 │              └── const-agg [as=v:3, outer=(3)]
 │                   └── v:3
 └── aggregations
      └── count-rows [as=count_rows:7]

# Multi-column primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM f WHERE u = 1 OR v = 2
----
project
 ├── columns: u:3 v:4
 └── distinct-on
      ├── columns: k:1!null j:2!null u:3 v:4
      ├── grouping columns: k:1!null j:2!null
      ├── internal-ordering: +1,+2
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── union-all
      │    ├── columns: k:1!null j:2!null u:3 v:4
      │    ├── left columns: k:7 j:8 u:9 v:10
      │    ├── right columns: k:13 j:14 u:15 v:16
      │    ├── ordering: +1,+2
      │    ├── index-join f
      │    │    ├── columns: k:7!null j:8!null u:9!null v:10
      │    │    ├── key: (7,8)
      │    │    ├── fd: ()-->(9), (7,8)-->(10)
      │    │    ├── ordering: +7,+8 opt(9) [actual: +7,+8]
      │    │    └── scan f@u
      │    │         ├── columns: k:7!null j:8!null u:9!null
      │    │         ├── constraint: /9/7/8: [/1 - /1]
      │    │         ├── key: (7,8)
      │    │         ├── fd: ()-->(9)
      │    │         └── ordering: +7,+8 opt(9) [actual: +7,+8]
      │    └── index-join f
      │         ├── columns: k:13!null j:14!null u:15 v:16!null
      │         ├── key: (13,14)
      │         ├── fd: ()-->(16), (13,14)-->(15)
      │         ├── ordering: +13,+14 opt(16) [actual: +13,+14]
      │         └── scan f@v
      │              ├── columns: k:13!null j:14!null v:16!null
      │              ├── constraint: /16/13/14: [/2 - /2]
      │              ├── key: (13,14)
      │              ├── fd: ()-->(16)
      │              └── ordering: +13,+14 opt(16) [actual: +13,+14]
      └── aggregations
           ├── const-agg [as=u:3, outer=(3)]
           │    └── u:3
           └── const-agg [as=v:4, outer=(4)]
                └── v:4

# Don't expand INs to many ORs.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u IN (1, 2, 3, 4) OR v IN (5, 6, 7, 8)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7: [/1 - /4]
      │    │         ├── key: (7)
      │    │         └── fd: (7)-->(8)
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: (13)-->(14,15)
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13: [/5 - /8]
      │              ├── key: (13)
      │              └── fd: (13)-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Split and constrain with an inverted index on JSONB on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, j FROM b WHERE u = 1 OR j @> '{"foo": "bar"}'
----
project
 ├── columns: u:2 j:4
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null u:2 j:4
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── union-all
      │    ├── columns: k:1!null u:2 j:4
      │    ├── left columns: k:10 u:11 j:13
      │    ├── right columns: k:19 u:20 j:22
      │    ├── immutable
      │    ├── index-join b
      │    │    ├── columns: k:10!null u:11!null j:13
      │    │    ├── key: (10)
      │    │    ├── fd: ()-->(11), (10)-->(13)
      │    │    └── scan b@u
      │    │         ├── columns: k:10!null u:11!null
      │    │         ├── constraint: /11/10: [/1 - /1]
      │    │         ├── key: (10)
      │    │         └── fd: ()-->(11)
      │    └── index-join b
      │         ├── columns: k:19!null u:20 j:22!null
      │         ├── immutable
      │         ├── key: (19)
      │         ├── fd: (19)-->(20,22)
      │         └── scan b@j_inv_idx
      │              ├── columns: k:19!null
      │              ├── inverted constraint: /27/19
      │              │    └── spans: ["7foo\x00\x01\x12bar\x00\x01", "7foo\x00\x01\x12bar\x00\x01"]
      │              └── key: (19)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=j:4, outer=(4)]
                └── j:4

# Split and constrain with an inverted index on an array on one side.
opt expect=SplitDisjunctionAddKey
SELECT u, a FROM c WHERE u = 1 OR a @> ARRAY[2]
----
project
 ├── columns: u:3 a:2
 ├── immutable
 └── distinct-on
      ├── columns: k:1!null a:2 u:3
      ├── grouping columns: k:1!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null a:2 u:3
      │    ├── left columns: k:9 a:10 u:11
      │    ├── right columns: k:17 a:18 u:19
      │    ├── immutable
      │    ├── index-join c
      │    │    ├── columns: k:9!null a:10 u:11!null
      │    │    ├── key: (9)
      │    │    ├── fd: ()-->(11), (9)-->(10)
      │    │    └── scan c@u
      │    │         ├── columns: k:9!null u:11!null
      │    │         ├── constraint: /11/9: [/1 - /1]
      │    │         ├── key: (9)
      │    │         └── fd: ()-->(11)
      │    └── index-join c
      │         ├── columns: k:17!null a:18!null u:19
      │         ├── immutable
      │         ├── key: (17)
      │         ├── fd: (17)-->(18,19)
      │         └── scan c@a_inv_idx
      │              ├── columns: k:17!null
      │              ├── inverted constraint: /24/17
      │              │    └── spans: ["\x8a", "\x8a"]
      │              └── key: (17)
      └── aggregations
           ├── const-agg [as=a:2, outer=(2)]
           │    └── a:2
           └── const-agg [as=u:3, outer=(3)]
                └── u:3

# Uncorrelated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT u, v FROM a)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: d.k:1!null d.u:2 d.v:3
      ├── grouping columns: d.k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: d.k:1!null d.u:2 d.v:3
      │    ├── left columns: d.k:12 d.u:13 d.v:14
      │    ├── right columns: d.k:18 d.u:19 d.v:20
      │    ├── ordering: +1
      │    ├── index-join d
      │    │    ├── columns: d.k:12!null d.u:13!null d.v:14
      │    │    ├── key: (12)
      │    │    ├── fd: ()-->(13), (12)-->(14)
      │    │    ├── ordering: +12 opt(13) [actual: +12]
      │    │    └── select
      │    │         ├── columns: d.k:12!null d.u:13!null
      │    │         ├── key: (12)
      │    │         ├── fd: ()-->(13)
      │    │         ├── ordering: +12 opt(13) [actual: +12]
      │    │         ├── scan d@u
      │    │         │    ├── columns: d.k:12!null d.u:13!null
      │    │         │    ├── constraint: /13/12: [/1 - /1]
      │    │         │    ├── key: (12)
      │    │         │    ├── fd: ()-->(13)
      │    │         │    └── ordering: +12 opt(13) [actual: +12]
      │    │         └── filters
      │    │              └── exists [subquery]
      │    │                   └── scan a
      │    │                        ├── columns: a.u:8 a.v:9
      │    │                        ├── limit: 1
      │    │                        ├── key: ()
      │    │                        └── fd: ()-->(8,9)
      │    └── index-join d
      │         ├── columns: d.k:18!null d.u:19 d.v:20!null
      │         ├── key: (18)
      │         ├── fd: ()-->(20), (18)-->(19)
      │         ├── ordering: +18 opt(20) [actual: +18]
      │         └── select
      │              ├── columns: d.k:18!null d.v:20!null
      │              ├── key: (18)
      │              ├── fd: ()-->(20)
      │              ├── ordering: +18 opt(20) [actual: +18]
      │              ├── scan d@v
      │              │    ├── columns: d.k:18!null d.v:20!null
      │              │    ├── constraint: /20/18: [/1 - /1]
      │              │    ├── key: (18)
      │              │    ├── fd: ()-->(20)
      │              │    └── ordering: +18 opt(20) [actual: +18]
      │              └── filters
      │                   └── exists [subquery]
      │                        └── scan a
      │                             ├── columns: a.u:8 a.v:9
      │                             ├── limit: 1
      │                             ├── key: ()
      │                             └── fd: ()-->(8,9)
      └── aggregations
           ├── const-agg [as=d.u:2, outer=(2)]
           │    └── d.u:2
           └── const-agg [as=d.v:3, outer=(3)]
                └── d.v:3

# Correlated subquery.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.u)
----
semi-join (lookup a@u)
 ├── columns: u:2 v:3
 ├── key columns: [2] = [8]
 ├── project
 │    ├── columns: d.u:2 d.v:3
 │    └── distinct-on
 │         ├── columns: d.k:1!null d.u:2 d.v:3
 │         ├── grouping columns: d.k:1!null
 │         ├── internal-ordering: +1
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,3)
 │         ├── union-all
 │         │    ├── columns: d.k:1!null d.u:2 d.v:3
 │         │    ├── left columns: d.k:12 d.u:13 d.v:14
 │         │    ├── right columns: d.k:18 d.u:19 d.v:20
 │         │    ├── ordering: +1
 │         │    ├── index-join d
 │         │    │    ├── columns: d.k:12!null d.u:13!null d.v:14
 │         │    │    ├── key: (12)
 │         │    │    ├── fd: ()-->(13), (12)-->(14)
 │         │    │    ├── ordering: +12 opt(13) [actual: +12]
 │         │    │    └── scan d@u
 │         │    │         ├── columns: d.k:12!null d.u:13!null
 │         │    │         ├── constraint: /13/12: [/1 - /1]
 │         │    │         ├── key: (12)
 │         │    │         ├── fd: ()-->(13)
 │         │    │         └── ordering: +12 opt(13) [actual: +12]
 │         │    └── index-join d
 │         │         ├── columns: d.k:18!null d.u:19 d.v:20!null
 │         │         ├── key: (18)
 │         │         ├── fd: ()-->(20), (18)-->(19)
 │         │         ├── ordering: +18 opt(20) [actual: +18]
 │         │         └── scan d@v
 │         │              ├── columns: d.k:18!null d.v:20!null
 │         │              ├── constraint: /20/18: [/1 - /1]
 │         │              ├── key: (18)
 │         │              ├── fd: ()-->(20)
 │         │              └── ordering: +18 opt(20) [actual: +18]
 │         └── aggregations
 │              ├── const-agg [as=d.u:2, outer=(2)]
 │              │    └── d.u:2
 │              └── const-agg [as=d.v:3, outer=(3)]
 │                   └── d.v:3
 └── filters (true)

# Correlated subquery with references to outer columns not in the scan columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 1) AND EXISTS (SELECT * FROM a WHERE a.u = d.w)
----
project
 ├── columns: u:2 v:3
 └── semi-join (lookup a@u)
      ├── columns: d.u:2 d.v:3 w:4
      ├── key columns: [4] = [8]
      ├── project
      │    ├── columns: d.u:2 d.v:3 w:4
      │    └── distinct-on
      │         ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      │         ├── grouping columns: d.k:1!null
      │         ├── internal-ordering: +1
      │         ├── key: (1)
      │         ├── fd: (1)-->(2-4)
      │         ├── union-all
      │         │    ├── columns: d.k:1!null d.u:2 d.v:3 w:4
      │         │    ├── left columns: d.k:12 d.u:13 d.v:14 w:15
      │         │    ├── right columns: d.k:18 d.u:19 d.v:20 w:21
      │         │    ├── ordering: +1
      │         │    ├── index-join d
      │         │    │    ├── columns: d.k:12!null d.u:13!null d.v:14 w:15
      │         │    │    ├── key: (12)
      │         │    │    ├── fd: ()-->(13), (12)-->(14,15)
      │         │    │    ├── ordering: +12 opt(13) [actual: +12]
      │         │    │    └── scan d@u
      │         │    │         ├── columns: d.k:12!null d.u:13!null
      │         │    │         ├── constraint: /13/12: [/1 - /1]
      │         │    │         ├── key: (12)
      │         │    │         ├── fd: ()-->(13)
      │         │    │         └── ordering: +12 opt(13) [actual: +12]
      │         │    └── index-join d
      │         │         ├── columns: d.k:18!null d.u:19 d.v:20!null w:21
      │         │         ├── key: (18)
      │         │         ├── fd: ()-->(20), (18)-->(19,21)
      │         │         ├── ordering: +18 opt(20) [actual: +18]
      │         │         └── scan d@v
      │         │              ├── columns: d.k:18!null d.v:20!null
      │         │              ├── constraint: /20/18: [/1 - /1]
      │         │              ├── key: (18)
      │         │              ├── fd: ()-->(20)
      │         │              └── ordering: +18 opt(20) [actual: +18]
      │         └── aggregations
      │              ├── const-agg [as=d.u:2, outer=(2)]
      │              │    └── d.u:2
      │              ├── const-agg [as=d.v:3, outer=(3)]
      │              │    └── d.v:3
      │              └── const-agg [as=w:4, outer=(4)]
      │                   └── w:4
      └── filters (true)

# Use rowid when there is no explicit primary key.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM no_explicit_primary_key WHERE u = 1 OR v = 5
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: u:2 v:3 rowid:4!null
      ├── grouping columns: rowid:4!null
      ├── internal-ordering: +4
      ├── key: (4)
      ├── fd: (4)-->(2,3)
      ├── union-all
      │    ├── columns: u:2 v:3 rowid:4!null
      │    ├── left columns: u:8 v:9 rowid:10
      │    ├── right columns: u:14 v:15 rowid:16
      │    ├── ordering: +4
      │    ├── index-join no_explicit_primary_key
      │    │    ├── columns: u:8!null v:9 rowid:10!null
      │    │    ├── key: (10)
      │    │    ├── fd: ()-->(8), (10)-->(9)
      │    │    ├── ordering: +10 opt(8) [actual: +10]
      │    │    └── scan no_explicit_primary_key@u
      │    │         ├── columns: u:8!null rowid:10!null
      │    │         ├── constraint: /8/10: [/1 - /1]
      │    │         ├── key: (10)
      │    │         ├── fd: ()-->(8)
      │    │         └── ordering: +10 opt(8) [actual: +10]
      │    └── index-join no_explicit_primary_key
      │         ├── columns: u:14 v:15!null rowid:16!null
      │         ├── key: (16)
      │         ├── fd: ()-->(15), (16)-->(14)
      │         ├── ordering: +16 opt(15) [actual: +16]
      │         └── scan no_explicit_primary_key@v
      │              ├── columns: v:15!null rowid:16!null
      │              ├── constraint: /15/16: [/5 - /5]
      │              ├── key: (16)
      │              ├── fd: ()-->(15)
      │              └── ordering: +16 opt(15) [actual: +16]
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a subset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM e WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join e
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: ()-->(8), (7)-->(9)
      │    │    └── scan e@uw
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/10/7: [/1 - /1]
      │    │         ├── key: (7)
      │    │         └── fd: ()-->(8)
      │    └── index-join e
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: ()-->(15), (13)-->(14)
      │         └── scan e@vw
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/16/13: [/1 - /1]
      │              ├── key: (13)
      │              └── fd: ()-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Apply when outer columns of both sides of OR are a superset of index columns.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 AND w = 2) OR (v = 1 AND w = 3)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── internal-ordering: +1
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:7 u:8 v:9 w:10
           │    ├── right columns: k:13 u:14 v:15 w:16
           │    ├── ordering: +1
           │    ├── select
           │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
           │    │    ├── key: (7)
           │    │    ├── fd: ()-->(8,10), (7)-->(9)
           │    │    ├── ordering: +7 opt(8,10) [actual: +7]
           │    │    ├── index-join d
           │    │    │    ├── columns: k:7!null u:8 v:9 w:10
           │    │    │    ├── key: (7)
           │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
           │    │    │    ├── ordering: +7 opt(8) [actual: +7]
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:7!null u:8!null
           │    │    │         ├── constraint: /8/7: [/1 - /1]
           │    │    │         ├── key: (7)
           │    │    │         ├── fd: ()-->(8)
           │    │    │         └── ordering: +7 opt(8) [actual: +7]
           │    │    └── filters
           │    │         └── w:10 = 2 [outer=(10), constraints=(/10: [/2 - /2]; tight), fd=()-->(10)]
           │    └── select
           │         ├── columns: k:13!null u:14 v:15!null w:16!null
           │         ├── key: (13)
           │         ├── fd: ()-->(15,16), (13)-->(14)
           │         ├── ordering: +13 opt(15,16) [actual: +13]
           │         ├── index-join d
           │         │    ├── columns: k:13!null u:14 v:15 w:16
           │         │    ├── key: (13)
           │         │    ├── fd: ()-->(15), (13)-->(14,16)
           │         │    ├── ordering: +13 opt(15) [actual: +13]
           │         │    └── scan d@v
           │         │         ├── columns: k:13!null v:15!null
           │         │         ├── constraint: /15/13: [/1 - /1]
           │         │         ├── key: (13)
           │         │         ├── fd: ()-->(15)
           │         │         └── ordering: +13 opt(15) [actual: +13]
           │         └── filters
           │              └── w:16 = 3 [outer=(16), constraints=(/16: [/3 - /3]; tight), fd=()-->(16)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Group sub-expr with the same columns together.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR v = 2) OR (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7
      │    │         │    ├── [/1 - /1]
      │    │         │    └── [/3 - /3]
      │    │         ├── key: (7)
      │    │         └── fd: (7)-->(8)
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: (13)-->(14,15)
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13
      │              │    ├── [/2 - /2]
      │              │    └── [/4 - /4]
      │              ├── key: (13)
      │              └── fd: (13)-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 1 OR u = 3 OR v = 2 OR v = 4 OR u = 5 OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7
      │    │         │    ├── [/1 - /1]
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (7)
      │    │         └── fd: (7)-->(8)
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: (13)-->(14,15)
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (13)
      │              └── fd: (13)-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Group sub-expr with the same columns together. Output should have a single union expr.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 3 OR v = 2) OR (u = 5 OR v = 4) OR v = 6
----
project
 ├── columns: u:2 v:3
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:7 u:8 v:9
      │    ├── right columns: k:13 u:14 v:15
      │    ├── index-join d
      │    │    ├── columns: k:7!null u:8!null v:9
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    └── scan d@u
      │    │         ├── columns: k:7!null u:8!null
      │    │         ├── constraint: /8/7
      │    │         │    ├── [/3 - /3]
      │    │         │    └── [/5 - /5]
      │    │         ├── key: (7)
      │    │         └── fd: (7)-->(8)
      │    └── index-join d
      │         ├── columns: k:13!null u:14 v:15!null
      │         ├── key: (13)
      │         ├── fd: (13)-->(14,15)
      │         └── scan d@v
      │              ├── columns: k:13!null v:15!null
      │              ├── constraint: /15/13
      │              │    ├── [/2 - /2]
      │              │    ├── [/4 - /4]
      │              │    └── [/6 - /6]
      │              ├── key: (13)
      │              └── fd: (13)-->(15)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Find the first disjunction in the filters that have different column sets on
# the left and right.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (w = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4!null
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4!null
           ├── grouping columns: k:1!null
           ├── internal-ordering: +1
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4!null
           │    ├── left columns: k:7 u:8 v:9 w:10
           │    ├── right columns: k:13 u:14 v:15 w:16
           │    ├── ordering: +1
           │    ├── select
           │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
           │    │    ├── key: (7)
           │    │    ├── fd: ()-->(8), (7)-->(9,10)
           │    │    ├── ordering: +7 opt(8) [actual: +7]
           │    │    ├── index-join d
           │    │    │    ├── columns: k:7!null u:8 v:9 w:10
           │    │    │    ├── key: (7)
           │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
           │    │    │    ├── ordering: +7 opt(8) [actual: +7]
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:7!null u:8!null
           │    │    │         ├── constraint: /8/7: [/3 - /3]
           │    │    │         ├── key: (7)
           │    │    │         ├── fd: ()-->(8)
           │    │    │         └── ordering: +7 opt(8) [actual: +7]
           │    │    └── filters
           │    │         └── (w:10 = 1) OR (w:10 = 2) [outer=(10), constraints=(/10: [/1 - /1] [/2 - /2]; tight)]
           │    └── select
           │         ├── columns: k:13!null u:14 v:15!null w:16!null
           │         ├── key: (13)
           │         ├── fd: ()-->(15), (13)-->(14,16)
           │         ├── ordering: +13 opt(15) [actual: +13]
           │         ├── index-join d
           │         │    ├── columns: k:13!null u:14 v:15 w:16
           │         │    ├── key: (13)
           │         │    ├── fd: ()-->(15), (13)-->(14,16)
           │         │    ├── ordering: +13 opt(15) [actual: +13]
           │         │    └── scan d@v
           │         │         ├── columns: k:13!null v:15!null
           │         │         ├── constraint: /15/13: [/4 - /4]
           │         │         ├── key: (13)
           │         │         ├── fd: ()-->(15)
           │         │         └── ordering: +13 opt(15) [actual: +13]
           │         └── filters
           │              └── (w:16 = 1) OR (w:16 = 2) [outer=(16), constraints=(/16: [/1 - /1] [/2 - /2]; tight)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Find the first disjunction in the filters that have columns on the left and
# right that constrain a scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE (u = 1 OR w = 2) AND (u = 3 OR v = 4)
----
project
 ├── columns: u:2 v:3
 └── project
      ├── columns: u:2 v:3 w:4
      └── distinct-on
           ├── columns: k:1!null u:2 v:3 w:4
           ├── grouping columns: k:1!null
           ├── internal-ordering: +1
           ├── key: (1)
           ├── fd: (1)-->(2-4)
           ├── union-all
           │    ├── columns: k:1!null u:2 v:3 w:4
           │    ├── left columns: k:7 u:8 v:9 w:10
           │    ├── right columns: k:13 u:14 v:15 w:16
           │    ├── ordering: +1
           │    ├── select
           │    │    ├── columns: k:7!null u:8!null v:9 w:10!null
           │    │    ├── key: (7)
           │    │    ├── fd: ()-->(8,10), (7)-->(9)
           │    │    ├── ordering: +7 opt(8,10) [actual: +7]
           │    │    ├── index-join d
           │    │    │    ├── columns: k:7!null u:8 v:9 w:10
           │    │    │    ├── key: (7)
           │    │    │    ├── fd: ()-->(8), (7)-->(9,10)
           │    │    │    ├── ordering: +7 opt(8) [actual: +7]
           │    │    │    └── scan d@u
           │    │    │         ├── columns: k:7!null u:8!null
           │    │    │         ├── constraint: /8/7: [/3 - /3]
           │    │    │         ├── key: (7)
           │    │    │         ├── fd: ()-->(8)
           │    │    │         └── ordering: +7 opt(8) [actual: +7]
           │    │    └── filters
           │    │         └── w:10 = 2 [outer=(10), constraints=(/10: [/2 - /2]; tight), fd=()-->(10)]
           │    └── select
           │         ├── columns: k:13!null u:14 v:15!null w:16
           │         ├── key: (13)
           │         ├── fd: ()-->(15), (13)-->(14,16)
           │         ├── ordering: +13 opt(15) [actual: +13]
           │         ├── index-join d
           │         │    ├── columns: k:13!null u:14 v:15 w:16
           │         │    ├── key: (13)
           │         │    ├── fd: ()-->(15), (13)-->(14,16)
           │         │    ├── ordering: +13 opt(15) [actual: +13]
           │         │    └── scan d@v
           │         │         ├── columns: k:13!null v:15!null
           │         │         ├── constraint: /15/13: [/4 - /4]
           │         │         ├── key: (13)
           │         │         ├── fd: ()-->(15)
           │         │         └── ordering: +13 opt(15) [actual: +13]
           │         └── filters
           │              └── (u:14 = 1) OR (w:16 = 2) [outer=(14,16)]
           └── aggregations
                ├── const-agg [as=u:2, outer=(2)]
                │    └── u:2
                ├── const-agg [as=v:3, outer=(3)]
                │    └── v:3
                └── const-agg [as=w:4, outer=(4)]
                     └── w:4

# Don't apply when outer columns of both sides of OR do not intersect with index columns.
opt expect-not=SplitDisjunctionAddKey
SELECT u, w FROM d WHERE u = 1 OR w = 1
----
select
 ├── columns: u:2 w:4
 ├── scan d
 │    └── columns: u:2 w:4
 └── filters
      └── (u:2 = 1) OR (w:4 = 1) [outer=(2,4)]

# Don't apply to queries with strict keys.
opt expect-not=SplitDisjunctionAddKey
SELECT k, u, v FROM d WHERE u = 1 OR v = 1
----
distinct-on
 ├── columns: k:1!null u:2 v:3
 ├── grouping columns: k:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── union-all
 │    ├── columns: k:1!null u:2 v:3
 │    ├── left columns: k:7 u:8 v:9
 │    ├── right columns: k:13 u:14 v:15
 │    ├── ordering: +1
 │    ├── index-join d
 │    │    ├── columns: k:7!null u:8!null v:9
 │    │    ├── key: (7)
 │    │    ├── fd: ()-->(8), (7)-->(9)
 │    │    ├── ordering: +7 opt(8) [actual: +7]
 │    │    └── scan d@u
 │    │         ├── columns: k:7!null u:8!null
 │    │         ├── constraint: /8/7: [/1 - /1]
 │    │         ├── key: (7)
 │    │         ├── fd: ()-->(8)
 │    │         └── ordering: +7 opt(8) [actual: +7]
 │    └── index-join d
 │         ├── columns: k:13!null u:14 v:15!null
 │         ├── key: (13)
 │         ├── fd: ()-->(15), (13)-->(14)
 │         ├── ordering: +13 opt(15) [actual: +13]
 │         └── scan d@v
 │              ├── columns: k:13!null v:15!null
 │              ├── constraint: /15/13: [/1 - /1]
 │              ├── key: (13)
 │              ├── fd: ()-->(15)
 │              └── ordering: +13 opt(15) [actual: +13]
 └── aggregations
      ├── const-agg [as=u:2, outer=(2)]
      │    └── u:2
      └── const-agg [as=v:3, outer=(3)]
           └── v:3

# Don't apply to disjunctions with identical colsets on the left and right.
opt expect-not=SplitDisjunctionAddKey
SELECT u FROM d WHERE u = 1 OR u = 5
----
scan d@u
 ├── columns: u:2!null
 └── constraint: /2/1
      ├── [/1 - /1]
      └── [/5 - /5]

# Verifies that flags are copied to the duplicated scan.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM a@{NO_INDEX_JOIN} WHERE u = 1 OR v = 1
----
project
 ├── columns: u:2 v:3
 ├── lax-key: (2,3)
 ├── fd: (3)~~>(2)
 └── distinct-on
      ├── columns: k:1!null u:2 v:3
      ├── grouping columns: k:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── union-all
      │    ├── columns: k:1!null u:2 v:3
      │    ├── left columns: k:6 u:7 v:8
      │    ├── right columns: k:11 u:12 v:13
      │    ├── ordering: +1
      │    ├── scan a@u
      │    │    ├── columns: k:6!null u:7!null v:8
      │    │    ├── constraint: /7/6: [/1 - /1]
      │    │    ├── flags: no-index-join
      │    │    ├── key: (6)
      │    │    ├── fd: ()-->(7), (6)-->(8), (8)~~>(6)
      │    │    └── ordering: +6 opt(7) [actual: +6]
      │    └── scan a@v
      │         ├── columns: k:11!null u:12 v:13!null
      │         ├── constraint: /13: [/1 - /1]
      │         ├── flags: no-index-join
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         └── fd: ()-->(11-13)
      └── aggregations
           ├── const-agg [as=u:2, outer=(2)]
           │    └── u:2
           └── const-agg [as=v:3, outer=(3)]
                └── v:3

# Columns are passed-through correctly when EliminateUnionAllLeft is applied.
opt expect=SplitDisjunctionAddKey
SELECT u, v FROM d WHERE u = 2 OR (v = 1 AND v = 3)
----
project
 ├── columns: u:2!null v:3
 ├── fd: ()-->(2)
 └── project
      ├── columns: k:1!null u:2!null v:3
      ├── key: (1)
      ├── fd: ()-->(2), (1)-->(3)
      ├── index-join d
      │    ├── columns: k:7!null u:8!null v:9
      │    ├── key: (7)
      │    ├── fd: ()-->(8), (7)-->(9)
      │    └── scan d@u
      │         ├── columns: k:7!null u:8!null
      │         ├── constraint: /8/7: [/2 - /2]
      │         ├── key: (7)
      │         └── fd: ()-->(8)
      └── projections
           ├── k:7 [as=k:1, outer=(7)]
           ├── u:8 [as=u:2, outer=(8)]
           └── v:9 [as=v:3, outer=(9)]

exec-ddl
CREATE INDEX idx_i ON p (i)
----

exec-ddl
CREATE INDEX idx_f ON p (f) WHERE s IN ('foo', 'bar', 'baz')
----

# Apply when one side of the disjunction can be "constrained" by an
# unconstrained partial index scan with no remaining filters.
opt expect=SplitDisjunctionAddKey
SELECT i, f, s, b FROM p WHERE i = 10 OR s IN ('foo', 'bar', 'baz')
----
project
 ├── columns: i:2 f:3 s:4 b:5
 └── distinct-on
      ├── columns: k:1!null i:2 f:3 s:4 b:5
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-5)
      ├── union-all
      │    ├── columns: k:1!null i:2 f:3 s:4 b:5
      │    ├── left columns: k:8 i:9 f:10 s:11 b:12
      │    ├── right columns: k:15 i:16 f:17 s:18 b:19
      │    ├── index-join p
      │    │    ├── columns: k:8!null i:9!null f:10 s:11 b:12
      │    │    ├── key: (8)
      │    │    ├── fd: ()-->(9), (8)-->(10-12)
      │    │    └── scan p@idx_i
      │    │         ├── columns: k:8!null i:9!null
      │    │         ├── constraint: /9/8: [/10 - /10]
      │    │         ├── key: (8)
      │    │         └── fd: ()-->(9)
      │    └── index-join p
      │         ├── columns: k:15!null i:16 f:17 s:18!null b:19
      │         ├── key: (15)
      │         ├── fd: (15)-->(16-19)
      │         └── scan p@idx_f,partial
      │              ├── columns: k:15!null f:17
      │              ├── key: (15)
      │              └── fd: (15)-->(17)
      └── aggregations
           ├── const-agg [as=i:2, outer=(2)]
           │    └── i:2
           ├── const-agg [as=f:3, outer=(3)]
           │    └── f:3
           ├── const-agg [as=s:4, outer=(4)]
           │    └── s:4
           └── const-agg [as=b:5, outer=(5)]
                └── b:5

# Apply when one side of the disjunction can be "constrained" by an
# unconstrained partial index scan with remaining filters.
opt expect=SplitDisjunctionAddKey
SELECT i, s, f, b FROM p WHERE i = 10 OR s = 'foo'
----
project
 ├── columns: i:2 s:4 f:3 b:5
 └── distinct-on
      ├── columns: k:1!null i:2 f:3 s:4 b:5
      ├── grouping columns: k:1!null
      ├── key: (1)
      ├── fd: (1)-->(2-5)
      ├── union-all
      │    ├── columns: k:1!null i:2 f:3 s:4 b:5
      │    ├── left columns: k:8 i:9 f:10 s:11 b:12
      │    ├── right columns: k:15 i:16 f:17 s:18 b:19
      │    ├── index-join p
      │    │    ├── columns: k:8!null i:9!null f:10 s:11 b:12
      │    │    ├── key: (8)
      │    │    ├── fd: ()-->(9), (8)-->(10-12)
      │    │    └── scan p@idx_i
      │    │         ├── columns: k:8!null i:9!null
      │    │         ├── constraint: /9/8: [/10 - /10]
      │    │         ├── key: (8)
      │    │         └── fd: ()-->(9)
      │    └── select
      │         ├── columns: k:15!null i:16 f:17 s:18!null b:19
      │         ├── key: (15)
      │         ├── fd: ()-->(18), (15)-->(16,17,19)
      │         ├── index-join p
      │         │    ├── columns: k:15!null i:16 f:17 s:18 b:19
      │         │    ├── key: (15)
      │         │    ├── fd: (15)-->(16-19)
      │         │    └── scan p@idx_f,partial
      │         │         ├── columns: k:15!null f:17
      │         │         ├── key: (15)
      │         │         └── fd: (15)-->(17)
      │         └── filters
      │              └── s:18 = 'foo' [outer=(18), constraints=(/18: [/'foo' - /'foo']; tight), fd=()-->(18)]
      └── aggregations
           ├── const-agg [as=i:2, outer=(2)]
           │    └── i:2
           ├── const-agg [as=f:3, outer=(3)]
           │    └── f:3
           ├── const-agg [as=s:4, outer=(4)]
           │    └── s:4
           └── const-agg [as=b:5, outer=(5)]
                └── b:5
