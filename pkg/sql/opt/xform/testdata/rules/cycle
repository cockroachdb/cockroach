exec-ddl
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT,
  INDEX (b)
)
----

exec-ddl
CREATE TABLE uv (
  u INT PRIMARY KEY,
  v INT,
  INDEX (v)
)
----

exec-ddl
CREATE TABLE xy (
  x INT PRIMARY KEY,
  y INT,
  INDEX (y)
)
----

# This test ensures that a memo cycle does not cause a stack overflow. Instead,
# the cycle is detected and the optimizer throws an internal error. The cycle is
# created by the test-only exploration rule MemoCycleTestRelRule.
expropt
(MemoCycleTestRel
    (Scan [ (Table "ab") (Cols "a,b") ])
    [ (Eq (Var "b") (Const 1 "int")) ]
)
----
error: memo group optimization passes surpassed limit of 100000; there may be a cycle in the memo
details:
memo (not optimized, ~3KB, required=[], cycle=[G1->G1])
 ├── G1: (memo-cycle-test-rel G2 G3) (memo-cycle-test-rel G1 G3)
 ├── G2: (scan ab,cols=(1,2)) (scan ab@ab_b_idx,cols=(1,2))
 │    └── []
 │         ├── best: (scan ab,cols=(1,2))
 │         └── cost: 1064.42
 ├── G3: (filters G4)
 ├── G4: (eq G5 G6)
 ├── G5: (variable b)
 └── G6: (const 1)

expropt
(LeftJoin
    (Scan [ (Table "ab") (Cols "a,b") ])
    (LeftJoin
        (MemoCycleTestRel
            (Scan [ (Table "uv") (Cols "u,v") ])
            [ (Eq (Var "v") (Const 1 "int")) ]
        )
        (Scan [ (Table "xy") (Cols "x,y") ])
        [ ]
        [ ]
    )
    [ ]
    [ ]
)
----
error: memo group optimization passes surpassed limit of 100000; there may be a cycle in the memo
details:
memo (not optimized, ~15KB, required=[], cycle=[G1->G3->G5->G5])
 ├── G1: (left-join G2 G3 G4)
 ├── G2: (scan ab,cols=()) (scan ab@ab_b_idx,cols=())
 │    └── []
 │         ├── best: (scan ab,cols=())
 │         └── cost: 1044.22
 ├── G3: (left-join G5 G6 G4)
 ├── G4: (filters)
 ├── G5: (memo-cycle-test-rel G7 G8) (memo-cycle-test-rel G5 G8)
 ├── G6: (scan xy,cols=())
 ├── G7: (scan uv,cols=(5,6)) (scan uv@uv_v_idx,cols=(5,6))
 │    └── []
 │         ├── best: (scan uv,cols=(5,6))
 │         └── cost: 1064.42
 ├── G8: (filters G9)
 ├── G9: (eq G10 G11)
 ├── G10: (variable v)
 └── G11: (const 1)
