exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    i INT,
    f FLOAT,
    s STRING,
    j JSON,
    INDEX s_idx (s) STORING (i, f),
    INDEX si_idx (s DESC, i) STORING (j)
)
----

exec-ddl
CREATE TABLE pqrs
(
    p INT NOT NULL,
    q INT NOT NULL,
    r INT NOT NULL,
    s INT NOT NULL,
    PRIMARY KEY (p, q),
    CHECK (p = 1 OR p = 5 OR p = 10),
    INDEX (r, s),
    CHECK (r > 0),
    CHECK (r < 3)
)
----

exec-ddl
ALTER TABLE pqrs INJECT STATISTICS '[
  {
    "columns": ["p"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000,
    "distinct_count": 10
  }
]'
----

exec-ddl
CREATE TABLE index_tab
(
    id INT PRIMARY KEY,
    val INT,
    region STRING,
    latitude INT,
    longitude INT,
    data1 INT NOT NULL,
    data2 INT NOT NULL,
    geom GEOMETRY,
    INDEX a (id, data1, data2),
    INDEX b (val, data1, data2),
    INDEX c (region, data1, data2),
    INDEX d (latitude, longitude, data1, data2),
    INVERTED INDEX geomIdx(geom)
)
----

exec-ddl
CREATE TABLE partial_index_tab
(
    a INT,
    b INT,
    INDEX (a) WHERE b > 0
)
----

# Insert statistics for index_tab. Histogram buckets are included for the
# latitude column in order to make the optimizer choose specific plans for
# SplitLimitedScanIntoUnionScans tests.
exec-ddl
ALTER TABLE index_tab INJECT STATISTICS '[
  {
    "columns": ["val"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 100
  },
  {
    "columns": ["region"],
    "created_at": "2018-01-01 1:30:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 1000
  },
  {
    "columns": ["latitude"],
    "created_at": "2018-01-01 2:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 100,
    "null_count": 0,
    "histo_col_type": "int",
    "histo_buckets": [
      {"num_eq": 1000, "num_range": 0, "distinct_range": 0, "upper_bound": "-5"},
      {"num_eq": 1000, "num_range": 0, "distinct_range": 0, "upper_bound": "0"},
      {"num_eq": 0, "num_range": 998000, "distinct_range": 98, "upper_bound": "2000"}
    ]
  },
  {
    "columns": ["longitude"],
    "created_at": "2018-01-01 2:30:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 100
  },
  {
    "columns": ["data1"],
    "created_at": "2018-01-01 3:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 100
  },
  {
    "columns": ["data2"],
    "created_at": "2018-01-01 3:30:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 100
  }
]'
----

# ---------------------------------------------------
# GenerateLimitedScans / PushLimitIntoFilteredScan
# ---------------------------------------------------

opt
SELECT * FROM a LIMIT 1
----
scan a
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── limit: 1
 ├── key: ()
 └── fd: ()-->(1-5)

# Combine limit with needed columns.
opt
SELECT s FROM a LIMIT 1
----
scan a@s_idx
 ├── columns: s:4
 ├── limit: 1
 ├── key: ()
 └── fd: ()-->(4)

# Combine limit with constraint.
opt
SELECT s FROM a WHERE s='foo' LIMIT 1
----
scan a@s_idx
 ├── columns: s:4!null
 ├── constraint: /4/1: [/'foo' - /'foo']
 ├── limit: 1
 ├── key: ()
 └── fd: ()-->(4)

# Limit of a limit.
opt
SELECT s FROM (SELECT s, i FROM a ORDER BY s LIMIT 10) a ORDER BY s, i LIMIT 1
----
top-k
 ├── columns: s:4  [hidden: i:2]
 ├── internal-ordering: +4,+2
 ├── k: 1
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2,4)
 └── scan a@s_idx
      ├── columns: i:2 s:4
      └── limit: 10

# Limit an unconstrained partial index scan.
opt
SELECT a FROM partial_index_tab where b > 0 LIMIT 1
----
project
 ├── columns: a:1
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan partial_index_tab@partial_index_tab_a_idx,partial
      ├── columns: a:1 rowid:3!null
      ├── limit: 1
      ├── key: ()
      └── fd: ()-->(1,3)

# Limit a constrained partial index scan.
opt
SELECT a FROM partial_index_tab where b > 0 and a > 10 LIMIT 1
----
project
 ├── columns: a:1!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 └── scan partial_index_tab@partial_index_tab_a_idx,partial
      ├── columns: a:1!null rowid:3!null
      ├── constraint: /1/3: [/11 - ]
      ├── limit: 1
      ├── key: ()
      └── fd: ()-->(1,3)

# Don't push when scan doesn't satisfy limit's ordering.
opt
SELECT s FROM a ORDER BY f LIMIT 1
----
top-k
 ├── columns: s:4  [hidden: f:3]
 ├── internal-ordering: +3
 ├── k: 1
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(3,4)
 └── scan a@s_idx
      └── columns: f:3 s:4

# Don't push when limit is not a constant.
opt
SELECT s FROM a LIMIT (SELECT k FROM a LIMIT 1)
----
limit
 ├── columns: s:4
 ├── immutable
 ├── scan a@s_idx
 │    └── columns: s:4
 └── subquery
      └── scan a@s_idx
           ├── columns: k:8!null
           ├── limit: 1
           ├── key: ()
           └── fd: ()-->(8)

memo
SELECT s FROM a WHERE s='foo' LIMIT 1
----
memo (optimized, ~8KB, required=[presentation: s:4])
 ├── G1: (limit G2 G3) (scan a@s_idx,cols=(4),constrained,lim=1) (scan a@si_idx,cols=(4),constrained,lim=1)
 │    └── [presentation: s:4]
 │         ├── best: (scan a@s_idx,cols=(4),constrained,lim=1)
 │         └── cost: 5.06
 ├── G2: (select G4 G5) (scan a@s_idx,cols=(4),constrained) (scan a@si_idx,cols=(4),constrained)
 │    └── [limit hint: 1.00]
 │         ├── best: (scan a@s_idx,cols=(4),constrained)
 │         └── cost: 15.07
 ├── G3: (const 1)
 ├── G4: (scan a,cols=(4)) (scan a@s_idx,cols=(4)) (scan a@si_idx,cols=(4))
 │    └── [limit hint: 100.00]
 │         ├── best: (scan a@s_idx,cols=(4))
 │         └── cost: 119.02
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable s)
 └── G8: (const 'foo')

# GenerateLimitedScans propagates row-level locking information.
opt
SELECT * FROM a LIMIT 1 FOR UPDATE
----
scan a
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── limit: 1
 ├── locking: for-update
 ├── volatile
 ├── key: ()
 └── fd: ()-->(1-5)

# PushLimitIntoFilteredScan propagates row-level locking information.
opt
SELECT s FROM a WHERE s='foo' LIMIT 1 FOR UPDATE
----
scan a@s_idx
 ├── columns: s:4!null
 ├── constraint: /4/1: [/'foo' - /'foo']
 ├── limit: 1
 ├── locking: for-update
 ├── volatile
 ├── key: ()
 └── fd: ()-->(4)

# --------------------------------------------------
# PushLimitIntoIndexJoin
# --------------------------------------------------

exec-ddl
CREATE TABLE kuv (k INT, u INT, v INT, INDEX (k, u))
----

opt expect=PushLimitIntoIndexJoin
SELECT * FROM kuv WHERE k = 1 OR k = 2 ORDER BY u LIMIT 5
----
index-join kuv
 ├── columns: k:1!null u:2 v:3
 ├── cardinality: [0 - 5]
 ├── ordering: +2
 └── limit
      ├── columns: k:1!null u:2 rowid:4!null
      ├── internal-ordering: +2
      ├── cardinality: [0 - 5]
      ├── key: (4)
      ├── fd: (4)-->(1,2)
      ├── ordering: +2
      ├── union-all
      │    ├── columns: k:1!null u:2 rowid:4!null
      │    ├── left columns: k:7 u:8 rowid:10
      │    ├── right columns: k:13 u:14 rowid:16
      │    ├── cardinality: [0 - 10]
      │    ├── ordering: +2
      │    ├── limit hint: 5.00
      │    ├── scan kuv@kuv_k_u_idx
      │    │    ├── columns: k:7!null u:8 rowid:10!null
      │    │    ├── constraint: /7/8/10: [/1 - /1]
      │    │    ├── limit: 5
      │    │    ├── key: (10)
      │    │    ├── fd: ()-->(7), (10)-->(8)
      │    │    ├── ordering: +8 opt(7) [actual: +8]
      │    │    └── limit hint: 5.00
      │    └── scan kuv@kuv_k_u_idx
      │         ├── columns: k:13!null u:14 rowid:16!null
      │         ├── constraint: /13/14/16: [/2 - /2]
      │         ├── limit: 5
      │         ├── key: (16)
      │         ├── fd: ()-->(13), (16)-->(14)
      │         ├── ordering: +14 opt(13) [actual: +14]
      │         └── limit hint: 5.00
      └── 5

# Ensure that the limit is not pushed down when the ordering requires columns
# produced by the IndexJoin.
opt expect-not=PushLimitIntoIndexJoin
SELECT * FROM kuv WHERE u > 1 AND u < 10 ORDER BY u, v LIMIT 5
----
top-k
 ├── columns: k:1 u:2!null v:3
 ├── internal-ordering: +2,+3
 ├── k: 5
 ├── cardinality: [0 - 5]
 ├── ordering: +2,+3
 └── select
      ├── columns: k:1 u:2!null v:3
      ├── scan kuv
      │    └── columns: k:1 u:2 v:3
      └── filters
           └── (u:2 > 1) AND (u:2 < 10) [outer=(2), constraints=(/2: [/2 - /9]; tight)]

exec-ddl
CREATE TABLE abcd (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT,
  INDEX b (b),
  INDEX cd (c,d),
  UNIQUE INDEX bcd (b,c,d)
)
----

opt
EXPLAIN SELECT * FROM abcd@b WHERE a >= 20 AND a <= 30 ORDER BY b DESC LIMIT 5
----
explain
 ├── columns: info:7
 └── limit
      ├── columns: a:1!null b:2 c:3 d:4
      ├── internal-ordering: -2
      ├── cardinality: [0 - 5]
      ├── key: (1)
      ├── fd: (1)-->(2-4), (2-4)~~>(1)
      ├── ordering: -2
      ├── select
      │    ├── columns: a:1!null b:2 c:3 d:4
      │    ├── cardinality: [0 - 11]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
      │    ├── ordering: -2
      │    ├── limit hint: 5.00
      │    ├── index-join abcd
      │    │    ├── columns: a:1!null b:2 c:3 d:4
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
      │    │    ├── ordering: -2
      │    │    ├── limit hint: 454.55
      │    │    └── scan abcd@b,rev
      │    │         ├── columns: a:1!null b:2
      │    │         ├── flags: force-index=b
      │    │         ├── key: (1)
      │    │         ├── fd: (1)-->(2)
      │    │         ├── ordering: -2
      │    │         └── limit hint: 454.55
      │    └── filters
      │         └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
      └── 5

optsteps
EXPLAIN SELECT * FROM abcd@b WHERE a >= 20 AND a <= 30 ORDER BY b DESC LIMIT 5
----
================================================================================
Initial expression
  Cost: 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00
================================================================================
  explain
   ├── columns: info:7
   └── sort
        ├── columns: a:1!null b:2 c:3 d:4
        ├── cardinality: [0 - 5]
        ├── key: (1)
        ├── fd: (1)-->(2-4), (2-4)~~>(1)
        ├── ordering: -2
        └── limit
             ├── columns: a:1!null b:2 c:3 d:4
             ├── internal-ordering: -2
             ├── cardinality: [0 - 5]
             ├── key: (1)
             ├── fd: (1)-->(2-4), (2-4)~~>(1)
             ├── sort
             │    ├── columns: a:1!null b:2 c:3 d:4
             │    ├── cardinality: [0 - 11]
             │    ├── key: (1)
             │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
             │    ├── ordering: -2
             │    ├── limit hint: 5.00
             │    └── project
             │         ├── columns: a:1!null b:2 c:3 d:4
             │         ├── cardinality: [0 - 11]
             │         ├── key: (1)
             │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
             │         └── select
             │              ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
             │              ├── cardinality: [0 - 11]
             │              ├── key: (1)
             │              ├── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
             │              ├── scan abcd
             │              │    ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
             │              │    ├── flags: force-index=b
             │              │    ├── key: (1)
             │              │    └── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
             │              └── filters
             │                   └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
             └── 5
================================================================================
SimplifySelectFilters
  Cost: 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00
================================================================================
   explain
    ├── columns: info:7
    └── sort
         ├── columns: a:1!null b:2 c:3 d:4
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
         └── limit
              ├── columns: a:1!null b:2 c:3 d:4
              ├── internal-ordering: -2
              ├── cardinality: [0 - 5]
              ├── key: (1)
              ├── fd: (1)-->(2-4), (2-4)~~>(1)
              ├── sort
              │    ├── columns: a:1!null b:2 c:3 d:4
  -           │    ├── cardinality: [0 - 11]
              │    ├── key: (1)
              │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │    ├── ordering: -2
              │    ├── limit hint: 5.00
              │    └── project
              │         ├── columns: a:1!null b:2 c:3 d:4
  -           │         ├── cardinality: [0 - 11]
              │         ├── key: (1)
              │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │         └── select
              │              ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
  -           │              ├── cardinality: [0 - 11]
              │              ├── key: (1)
              │              ├── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
              │              ├── scan abcd
              │              │    ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
              │              │    ├── flags: force-index=b
              │              │    ├── key: (1)
              │              │    └── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
              │              └── filters
  -           │                   └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
  +           │                   ├── a:1 >= 20 [outer=(1), constraints=(/1: [/20 - ]; tight)]
  +           │                   └── a:1 <= 30 [outer=(1), constraints=(/1: (/NULL - /30]; tight)]
              └── 5
================================================================================
ConsolidateSelectFilters
  Cost: 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00
================================================================================
   explain
    ├── columns: info:7
    └── sort
         ├── columns: a:1!null b:2 c:3 d:4
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
         └── limit
              ├── columns: a:1!null b:2 c:3 d:4
              ├── internal-ordering: -2
              ├── cardinality: [0 - 5]
              ├── key: (1)
              ├── fd: (1)-->(2-4), (2-4)~~>(1)
              ├── sort
              │    ├── columns: a:1!null b:2 c:3 d:4
  +           │    ├── cardinality: [0 - 11]
              │    ├── key: (1)
              │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │    ├── ordering: -2
              │    ├── limit hint: 5.00
              │    └── project
              │         ├── columns: a:1!null b:2 c:3 d:4
  +           │         ├── cardinality: [0 - 11]
              │         ├── key: (1)
              │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │         └── select
              │              ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
  +           │              ├── cardinality: [0 - 11]
              │              ├── key: (1)
              │              ├── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
              │              ├── scan abcd
              │              │    ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
              │              │    ├── flags: force-index=b
              │              │    ├── key: (1)
              │              │    └── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
              │              └── filters
  -           │                   ├── a:1 >= 20 [outer=(1), constraints=(/1: [/20 - ]; tight)]
  -           │                   └── a:1 <= 30 [outer=(1), constraints=(/1: (/NULL - /30]; tight)]
  +           │                   └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
              └── 5
================================================================================
PruneSelectCols
  Cost: 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00
================================================================================
   explain
    ├── columns: info:7
    └── sort
         ├── columns: a:1!null b:2 c:3 d:4
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
         └── limit
              ├── columns: a:1!null b:2 c:3 d:4
              ├── internal-ordering: -2
              ├── cardinality: [0 - 5]
              ├── key: (1)
              ├── fd: (1)-->(2-4), (2-4)~~>(1)
              ├── sort
              │    ├── columns: a:1!null b:2 c:3 d:4
              │    ├── cardinality: [0 - 11]
              │    ├── key: (1)
              │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │    ├── ordering: -2
              │    ├── limit hint: 5.00
              │    └── project
              │         ├── columns: a:1!null b:2 c:3 d:4
              │         ├── cardinality: [0 - 11]
              │         ├── key: (1)
              │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │         └── select
  -           │              ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
  +           │              ├── columns: a:1!null b:2 c:3 d:4
              │              ├── cardinality: [0 - 11]
              │              ├── key: (1)
  -           │              ├── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
  +           │              ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │              ├── scan abcd
  -           │              │    ├── columns: a:1!null b:2 c:3 d:4 crdb_internal_mvcc_timestamp:5 tableoid:6
  +           │              │    ├── columns: a:1!null b:2 c:3 d:4
              │              │    ├── flags: force-index=b
              │              │    ├── key: (1)
  -           │              │    └── fd: (1)-->(2-6), (2-4)~~>(1,5,6)
  +           │              │    └── fd: (1)-->(2-4), (2-4)~~>(1)
              │              └── filters
              │                   └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
              └── 5
================================================================================
EliminateProject
  Cost: 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.00
================================================================================
   explain
    ├── columns: info:7
    └── sort
         ├── columns: a:1!null b:2 c:3 d:4
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
         └── limit
              ├── columns: a:1!null b:2 c:3 d:4
              ├── internal-ordering: -2
              ├── cardinality: [0 - 5]
              ├── key: (1)
              ├── fd: (1)-->(2-4), (2-4)~~>(1)
              ├── sort
              │    ├── columns: a:1!null b:2 c:3 d:4
              │    ├── cardinality: [0 - 11]
              │    ├── key: (1)
              │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
              │    ├── ordering: -2
              │    ├── limit hint: 5.00
  -           │    └── project
  +           │    └── select
              │         ├── columns: a:1!null b:2 c:3 d:4
              │         ├── cardinality: [0 - 11]
              │         ├── key: (1)
              │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │         └── select
  -           │              ├── columns: a:1!null b:2 c:3 d:4
  -           │              ├── cardinality: [0 - 11]
  -           │              ├── key: (1)
  -           │              ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │              ├── scan abcd
  -           │              │    ├── columns: a:1!null b:2 c:3 d:4
  -           │              │    ├── flags: force-index=b
  -           │              │    ├── key: (1)
  -           │              │    └── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │              └── filters
  -           │                   └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
  +           │         ├── scan abcd
  +           │         │    ├── columns: a:1!null b:2 c:3 d:4
  +           │         │    ├── flags: force-index=b
  +           │         │    ├── key: (1)
  +           │         │    └── fd: (1)-->(2-4), (2-4)~~>(1)
  +           │         └── filters
  +           │              └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
              └── 5
================================================================================
GenerateIndexScans
  Cost: 3571.71
================================================================================
   explain
    ├── columns: info:7
  - └── sort
  + └── limit
         ├── columns: a:1!null b:2 c:3 d:4
  +      ├── internal-ordering: -2
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
  -      └── limit
  -           ├── columns: a:1!null b:2 c:3 d:4
  -           ├── internal-ordering: -2
  -           ├── cardinality: [0 - 5]
  -           ├── key: (1)
  -           ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -           ├── sort
  -           │    ├── columns: a:1!null b:2 c:3 d:4
  -           │    ├── cardinality: [0 - 11]
  -           │    ├── key: (1)
  -           │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │    ├── ordering: -2
  -           │    ├── limit hint: 5.00
  -           │    └── select
  -           │         ├── columns: a:1!null b:2 c:3 d:4
  -           │         ├── cardinality: [0 - 11]
  -           │         ├── key: (1)
  -           │         ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │         ├── scan abcd
  -           │         │    ├── columns: a:1!null b:2 c:3 d:4
  -           │         │    ├── flags: force-index=b
  -           │         │    ├── key: (1)
  -           │         │    └── fd: (1)-->(2-4), (2-4)~~>(1)
  -           │         └── filters
  -           │              └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
  -           └── 5
  +      ├── select
  +      │    ├── columns: a:1!null b:2 c:3 d:4
  +      │    ├── cardinality: [0 - 11]
  +      │    ├── key: (1)
  +      │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  +      │    ├── ordering: -2
  +      │    ├── limit hint: 5.00
  +      │    ├── index-join abcd
  +      │    │    ├── columns: a:1!null b:2 c:3 d:4
  +      │    │    ├── key: (1)
  +      │    │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  +      │    │    ├── ordering: -2
  +      │    │    ├── limit hint: 454.55
  +      │    │    └── scan abcd@b,rev
  +      │    │         ├── columns: a:1!null b:2
  +      │    │         ├── flags: force-index=b
  +      │    │         ├── key: (1)
  +      │    │         ├── fd: (1)-->(2)
  +      │    │         ├── ordering: -2
  +      │    │         └── limit hint: 454.55
  +      │    └── filters
  +      │         └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
  +      └── 5
--------------------------------------------------------------------------------
GeneratePartialIndexScans (no changes)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
GenerateConstrainedScans (no changes)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
GenerateZigzagJoins (no changes)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
GenerateTopK (higher cost)
--------------------------------------------------------------------------------
   explain
    ├── columns: info:7
  - └── limit
  + └── top-k
         ├── columns: a:1!null b:2 c:3 d:4
         ├── internal-ordering: -2
  +      ├── k: 5
         ├── cardinality: [0 - 5]
         ├── key: (1)
         ├── fd: (1)-->(2-4), (2-4)~~>(1)
         ├── ordering: -2
  -      ├── select
  -      │    ├── columns: a:1!null b:2 c:3 d:4
  -      │    ├── cardinality: [0 - 11]
  -      │    ├── key: (1)
  -      │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -      │    ├── ordering: -2
  -      │    ├── limit hint: 5.00
  -      │    ├── index-join abcd
  -      │    │    ├── columns: a:1!null b:2 c:3 d:4
  -      │    │    ├── key: (1)
  -      │    │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  -      │    │    ├── ordering: -2
  -      │    │    ├── limit hint: 454.55
  -      │    │    └── scan abcd@b,rev
  -      │    │         ├── columns: a:1!null b:2
  -      │    │         ├── flags: force-index=b
  -      │    │         ├── key: (1)
  -      │    │         ├── fd: (1)-->(2)
  -      │    │         ├── ordering: -2
  -      │    │         └── limit hint: 454.55
  -      │    └── filters
  -      │         └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
  -      └── 5
  +      └── select
  +           ├── columns: a:1!null b:2 c:3 d:4
  +           ├── cardinality: [0 - 11]
  +           ├── key: (1)
  +           ├── fd: (1)-->(2-4), (2-4)~~>(1)
  +           ├── index-join abcd
  +           │    ├── columns: a:1!null b:2 c:3 d:4
  +           │    ├── key: (1)
  +           │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
  +           │    └── scan abcd@b
  +           │         ├── columns: a:1!null b:2
  +           │         ├── flags: force-index=b
  +           │         ├── key: (1)
  +           │         └── fd: (1)-->(2)
  +           └── filters
  +                └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
--------------------------------------------------------------------------------
GeneratePartialOrderTopK (no changes)
--------------------------------------------------------------------------------
================================================================================
Final best expression
  Cost: 3571.71
================================================================================
  explain
   ├── columns: info:7
   └── limit
        ├── columns: a:1!null b:2 c:3 d:4
        ├── internal-ordering: -2
        ├── cardinality: [0 - 5]
        ├── key: (1)
        ├── fd: (1)-->(2-4), (2-4)~~>(1)
        ├── ordering: -2
        ├── select
        │    ├── columns: a:1!null b:2 c:3 d:4
        │    ├── cardinality: [0 - 11]
        │    ├── key: (1)
        │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
        │    ├── ordering: -2
        │    ├── limit hint: 5.00
        │    ├── index-join abcd
        │    │    ├── columns: a:1!null b:2 c:3 d:4
        │    │    ├── key: (1)
        │    │    ├── fd: (1)-->(2-4), (2-4)~~>(1)
        │    │    ├── ordering: -2
        │    │    ├── limit hint: 454.55
        │    │    └── scan abcd@b,rev
        │    │         ├── columns: a:1!null b:2
        │    │         ├── flags: force-index=b
        │    │         ├── key: (1)
        │    │         ├── fd: (1)-->(2)
        │    │         ├── ordering: -2
        │    │         └── limit hint: 454.55
        │    └── filters
        │         └── (a:1 >= 20) AND (a:1 <= 30) [outer=(1), constraints=(/1: [/20 - /30]; tight)]
        └── 5

# --------------------------------------------------
# PushLimitIntoOffset + GenerateLimitedScans
# --------------------------------------------------

# Regression testing for #30416.
# The limit is pushed down the offset and so an appropriate index scan is used
# over a primary key scan.
opt
SELECT * from a ORDER BY s LIMIT 10 OFFSET 10
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +4
 ├── index-join a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 20]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +4
 │    └── scan a@s_idx
 │         ├── columns: k:1!null i:2 f:3 s:4
 │         ├── limit: 20
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-4)
 │         └── ordering: +4
 └── 10

# The right index is used for the limited scan based on the order.
opt
SELECT * from a ORDER BY s DESC LIMIT 10 OFFSET 10
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: -4
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: -4
 ├── index-join a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 20]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: -4
 │    └── scan a@si_idx
 │         ├── columns: k:1!null i:2 s:4 j:5
 │         ├── limit: 20
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,4,5)
 │         └── ordering: -4
 └── 10

# PushLimitIntoIndexJoin propagates row-level locking information.
opt
SELECT * FROM kuv ORDER BY u LIMIT 5 FOR UPDATE
----
top-k
 ├── columns: k:1 u:2 v:3
 ├── internal-ordering: +2
 ├── k: 5
 ├── cardinality: [0 - 5]
 ├── volatile
 ├── ordering: +2
 └── scan kuv
      ├── columns: k:1 u:2 v:3
      ├── locking: for-update
      └── volatile

# -------------------------
# SplitLimitedScanIntoUnionScans
# -------------------------

# Case with limit 10.
opt
SELECT val, data1 FROM index_tab WHERE val > 0 AND val < 4 ORDER BY data1 LIMIT 10
----
limit
 ├── columns: val:2!null data1:6!null
 ├── internal-ordering: +6
 ├── cardinality: [0 - 10]
 ├── ordering: +6
 ├── union-all
 │    ├── columns: val:2!null data1:6!null
 │    ├── left columns: val:35 data1:39
 │    ├── right columns: val:46 data1:50
 │    ├── cardinality: [0 - 30]
 │    ├── ordering: +6
 │    ├── limit hint: 10.00
 │    ├── union-all
 │    │    ├── columns: val:35!null data1:39!null
 │    │    ├── left columns: val:13 data1:17
 │    │    ├── right columns: val:24 data1:28
 │    │    ├── cardinality: [0 - 20]
 │    │    ├── ordering: +39
 │    │    ├── limit hint: 10.00
 │    │    ├── scan index_tab@b
 │    │    │    ├── columns: val:13!null data1:17!null
 │    │    │    ├── constraint: /13/17/18/12: [/1 - /1]
 │    │    │    ├── limit: 10
 │    │    │    ├── fd: ()-->(13)
 │    │    │    ├── ordering: +17 opt(13) [actual: +17]
 │    │    │    └── limit hint: 10.00
 │    │    └── scan index_tab@b
 │    │         ├── columns: val:24!null data1:28!null
 │    │         ├── constraint: /24/28/29/23: [/2 - /2]
 │    │         ├── limit: 10
 │    │         ├── fd: ()-->(24)
 │    │         ├── ordering: +28 opt(24) [actual: +28]
 │    │         └── limit hint: 10.00
 │    └── scan index_tab@b
 │         ├── columns: val:46!null data1:50!null
 │         ├── constraint: /46/50/51/45: [/3 - /3]
 │         ├── limit: 10
 │         ├── fd: ()-->(46)
 │         ├── ordering: +50 opt(46) [actual: +50]
 │         └── limit hint: 10.00
 └── 10

# Case with single-key spans.
opt expect=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab WHERE region = 'US_EAST' OR region = 'US_WEST'
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── limit
 │    ├── columns: region:3!null data1:6!null
 │    ├── internal-ordering: -6
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,6)
 │    ├── union-all
 │    │    ├── columns: region:3!null data1:6!null
 │    │    ├── left columns: region:15 data1:18
 │    │    ├── right columns: region:26 data1:29
 │    │    ├── cardinality: [0 - 2]
 │    │    ├── ordering: -6
 │    │    ├── limit hint: 1.00
 │    │    ├── scan index_tab@c,rev
 │    │    │    ├── columns: region:15!null data1:18!null
 │    │    │    ├── constraint: /15/18/19/13: [/'US_EAST' - /'US_EAST']
 │    │    │    ├── limit: 1(rev)
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(15,18)
 │    │    │    └── limit hint: 1.00
 │    │    └── scan index_tab@c,rev
 │    │         ├── columns: region:26!null data1:29!null
 │    │         ├── constraint: /26/29/30/24: [/'US_WEST' - /'US_WEST']
 │    │         ├── limit: 1(rev)
 │    │         ├── key: ()
 │    │         ├── fd: ()-->(26,29)
 │    │         └── limit hint: 1.00
 │    └── 1
 └── aggregations
      └── const-agg [as=max:12, outer=(6)]
           └── data1:6

# Case with multi-column keys in single-key spans.
opt expect=SplitLimitedScanIntoUnionScans
SELECT max(data1)
FROM index_tab
WHERE (latitude, longitude) = (1, 2) OR (latitude, longitude) = (4, 5)
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── limit
 │    ├── columns: latitude:4!null longitude:5!null data1:6!null
 │    ├── internal-ordering: -6
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(4-6)
 │    ├── union-all
 │    │    ├── columns: latitude:4!null longitude:5!null data1:6!null
 │    │    ├── left columns: latitude:16 longitude:17 data1:18
 │    │    ├── right columns: latitude:27 longitude:28 data1:29
 │    │    ├── cardinality: [0 - 2]
 │    │    ├── ordering: -6
 │    │    ├── limit hint: 1.00
 │    │    ├── scan index_tab@d,rev
 │    │    │    ├── columns: latitude:16!null longitude:17!null data1:18!null
 │    │    │    ├── constraint: /16/17/18/19/13: [/1/2 - /1/2]
 │    │    │    ├── limit: 1(rev)
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(16-18)
 │    │    │    └── limit hint: 1.00
 │    │    └── scan index_tab@d,rev
 │    │         ├── columns: latitude:27!null longitude:28!null data1:29!null
 │    │         ├── constraint: /27/28/29/30/24: [/4/5 - /4/5]
 │    │         ├── limit: 1(rev)
 │    │         ├── key: ()
 │    │         ├── fd: ()-->(27-29)
 │    │         └── limit hint: 1.00
 │    └── 1
 └── aggregations
      └── const-agg [as=max:12, outer=(6)]
           └── data1:6

# Case with countable multi-key spans.
opt expect=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab WHERE val > 0 AND val < 4
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── limit
 │    ├── columns: val:2!null data1:6!null
 │    ├── internal-ordering: -6
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(2,6)
 │    ├── union-all
 │    │    ├── columns: val:2!null data1:6!null
 │    │    ├── left columns: val:36 data1:40
 │    │    ├── right columns: val:47 data1:51
 │    │    ├── cardinality: [0 - 3]
 │    │    ├── ordering: -6
 │    │    ├── limit hint: 1.00
 │    │    ├── union-all
 │    │    │    ├── columns: val:36!null data1:40!null
 │    │    │    ├── left columns: val:14 data1:18
 │    │    │    ├── right columns: val:25 data1:29
 │    │    │    ├── cardinality: [0 - 2]
 │    │    │    ├── ordering: -40
 │    │    │    ├── limit hint: 1.00
 │    │    │    ├── scan index_tab@b,rev
 │    │    │    │    ├── columns: val:14!null data1:18!null
 │    │    │    │    ├── constraint: /14/18/19/13: [/1 - /1]
 │    │    │    │    ├── limit: 1(rev)
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(14,18)
 │    │    │    │    └── limit hint: 1.00
 │    │    │    └── scan index_tab@b,rev
 │    │    │         ├── columns: val:25!null data1:29!null
 │    │    │         ├── constraint: /25/29/30/24: [/2 - /2]
 │    │    │         ├── limit: 1(rev)
 │    │    │         ├── key: ()
 │    │    │         ├── fd: ()-->(25,29)
 │    │    │         └── limit hint: 1.00
 │    │    └── scan index_tab@b,rev
 │    │         ├── columns: val:47!null data1:51!null
 │    │         ├── constraint: /47/51/52/46: [/3 - /3]
 │    │         ├── limit: 1(rev)
 │    │         ├── key: ()
 │    │         ├── fd: ()-->(47,51)
 │    │         └── limit hint: 1.00
 │    └── 1
 └── aggregations
      └── const-agg [as=max:12, outer=(6)]
           └── data1:6

# Case with limit ordering on more than one column.
opt expect=SplitLimitedScanIntoUnionScans
SELECT region, data1, data2
FROM index_tab
WHERE region='US_WEST' OR region='US_EAST'
ORDER BY data1, data2
LIMIT 10
----
limit
 ├── columns: region:3!null data1:6!null data2:7!null
 ├── internal-ordering: +6,+7
 ├── cardinality: [0 - 10]
 ├── ordering: +6,+7
 ├── union-all
 │    ├── columns: region:3!null data1:6!null data2:7!null
 │    ├── left columns: region:14 data1:17 data2:18
 │    ├── right columns: region:25 data1:28 data2:29
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +6,+7
 │    ├── limit hint: 10.00
 │    ├── scan index_tab@c
 │    │    ├── columns: region:14!null data1:17!null data2:18!null
 │    │    ├── constraint: /14/17/18/12: [/'US_EAST' - /'US_EAST']
 │    │    ├── limit: 10
 │    │    ├── fd: ()-->(14)
 │    │    ├── ordering: +17,+18 opt(14) [actual: +17,+18]
 │    │    └── limit hint: 10.00
 │    └── scan index_tab@c
 │         ├── columns: region:25!null data1:28!null data2:29!null
 │         ├── constraint: /25/28/29/23: [/'US_WEST' - /'US_WEST']
 │         ├── limit: 10
 │         ├── fd: ()-->(25)
 │         ├── ordering: +28,+29 opt(25) [actual: +28,+29]
 │         └── limit hint: 10.00
 └── 10

# Case with start key longer than the ordering prefix length.
opt expect=SplitLimitedScanIntoUnionScans
SELECT region, data1, data2
FROM index_tab
WHERE (region='US_WEST' OR region='US_EAST')
AND data1 > 3
ORDER BY data1, data2
LIMIT 10
----
limit
 ├── columns: region:3!null data1:6!null data2:7!null
 ├── internal-ordering: +6,+7
 ├── cardinality: [0 - 10]
 ├── ordering: +6,+7
 ├── union-all
 │    ├── columns: region:3!null data1:6!null data2:7!null
 │    ├── left columns: region:14 data1:17 data2:18
 │    ├── right columns: region:25 data1:28 data2:29
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +6,+7
 │    ├── limit hint: 10.00
 │    ├── scan index_tab@c
 │    │    ├── columns: region:14!null data1:17!null data2:18!null
 │    │    ├── constraint: /14/17/18/12: [/'US_EAST'/4 - /'US_EAST']
 │    │    ├── limit: 10
 │    │    ├── fd: ()-->(14)
 │    │    ├── ordering: +17,+18 opt(14) [actual: +17,+18]
 │    │    └── limit hint: 10.00
 │    └── scan index_tab@c
 │         ├── columns: region:25!null data1:28!null data2:29!null
 │         ├── constraint: /25/28/29/23: [/'US_WEST'/4 - /'US_WEST']
 │         ├── limit: 10
 │         ├── fd: ()-->(25)
 │         ├── ordering: +28,+29 opt(25) [actual: +28,+29]
 │         └── limit hint: 10.00
 └── 10

# Case with end key longer than the ordering prefix length.
opt expect=SplitLimitedScanIntoUnionScans
SELECT region, data1, data2
FROM index_tab
WHERE (region='US_WEST' OR region='US_EAST')
AND data1 < 3
ORDER BY data1, data2
LIMIT 10
----
limit
 ├── columns: region:3!null data1:6!null data2:7!null
 ├── internal-ordering: +6,+7
 ├── cardinality: [0 - 10]
 ├── ordering: +6,+7
 ├── union-all
 │    ├── columns: region:3!null data1:6!null data2:7!null
 │    ├── left columns: region:14 data1:17 data2:18
 │    ├── right columns: region:25 data1:28 data2:29
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +6,+7
 │    ├── limit hint: 10.00
 │    ├── scan index_tab@c
 │    │    ├── columns: region:14!null data1:17!null data2:18!null
 │    │    ├── constraint: /14/17/18/12: [/'US_EAST' - /'US_EAST'/2]
 │    │    ├── limit: 10
 │    │    ├── fd: ()-->(14)
 │    │    ├── ordering: +17,+18 opt(14) [actual: +17,+18]
 │    │    └── limit hint: 10.00
 │    └── scan index_tab@c
 │         ├── columns: region:25!null data1:28!null data2:29!null
 │         ├── constraint: /25/28/29/23: [/'US_WEST' - /'US_WEST'/2]
 │         ├── limit: 10
 │         ├── fd: ()-->(25)
 │         ├── ordering: +28,+29 opt(25) [actual: +28,+29]
 │         └── limit hint: 10.00
 └── 10

# Case with both keys longer than the ordering prefix length.
opt expect=SplitLimitedScanIntoUnionScans
SELECT region, data1, data2
FROM index_tab
WHERE (region='US_WEST' OR region='US_EAST')
AND data1 > 3
AND data1 < 1000
ORDER BY data1, data2
LIMIT 10
----
limit
 ├── columns: region:3!null data1:6!null data2:7!null
 ├── internal-ordering: +6,+7
 ├── cardinality: [0 - 10]
 ├── ordering: +6,+7
 ├── union-all
 │    ├── columns: region:3!null data1:6!null data2:7!null
 │    ├── left columns: region:14 data1:17 data2:18
 │    ├── right columns: region:25 data1:28 data2:29
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +6,+7
 │    ├── limit hint: 10.00
 │    ├── scan index_tab@c
 │    │    ├── columns: region:14!null data1:17!null data2:18!null
 │    │    ├── constraint: /14/17/18/12: [/'US_EAST'/4 - /'US_EAST'/999]
 │    │    ├── limit: 10
 │    │    ├── fd: ()-->(14)
 │    │    ├── ordering: +17,+18 opt(14) [actual: +17,+18]
 │    │    └── limit hint: 10.00
 │    └── scan index_tab@c
 │         ├── columns: region:25!null data1:28!null data2:29!null
 │         ├── constraint: /25/28/29/23: [/'US_WEST'/4 - /'US_WEST'/999]
 │         ├── limit: 10
 │         ├── fd: ()-->(25)
 │         ├── ordering: +28,+29 opt(25) [actual: +28,+29]
 │         └── limit hint: 10.00
 └── 10

# Case where one span can be used for a limited scan, but not the others. Note
# that the last Scan with constraints [/-5 - /-5] and [/0 - /0] is not limited.
opt expect=SplitLimitedScanIntoUnionScans
SELECT latitude, longitude, data1, data2
FROM index_tab
WHERE latitude = 0
OR latitude = -5
OR (latitude = 10 AND longitude > 10 AND longitude < 14)
ORDER BY data1, data2
LIMIT 10
----
top-k
 ├── columns: latitude:4!null longitude:5 data1:6!null data2:7!null
 ├── internal-ordering: +6,+7
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── ordering: +6,+7
 └── union-all
      ├── columns: latitude:4!null longitude:5 data1:6!null data2:7!null
      ├── left columns: latitude:81 longitude:82 data1:83 data2:84
      ├── right columns: latitude:92 longitude:93 data1:94 data2:95
      ├── union-all
      │    ├── columns: latitude:81!null longitude:82!null data1:83!null data2:84!null
      │    ├── left columns: latitude:59 longitude:60 data1:61 data2:62
      │    ├── right columns: latitude:70 longitude:71 data1:72 data2:73
      │    ├── cardinality: [0 - 30]
      │    ├── union-all
      │    │    ├── columns: latitude:59!null longitude:60!null data1:61!null data2:62!null
      │    │    ├── left columns: latitude:37 longitude:38 data1:39 data2:40
      │    │    ├── right columns: latitude:48 longitude:49 data1:50 data2:51
      │    │    ├── cardinality: [0 - 20]
      │    │    ├── scan index_tab@d
      │    │    │    ├── columns: latitude:37!null longitude:38!null data1:39!null data2:40!null
      │    │    │    ├── constraint: /37/38/39/40/34: [/10/11 - /10/11]
      │    │    │    ├── limit: 10
      │    │    │    └── fd: ()-->(37,38)
      │    │    └── scan index_tab@d
      │    │         ├── columns: latitude:48!null longitude:49!null data1:50!null data2:51!null
      │    │         ├── constraint: /48/49/50/51/45: [/10/12 - /10/12]
      │    │         ├── limit: 10
      │    │         └── fd: ()-->(48,49)
      │    └── scan index_tab@d
      │         ├── columns: latitude:70!null longitude:71!null data1:72!null data2:73!null
      │         ├── constraint: /70/71/72/73/67: [/10/13 - /10/13]
      │         ├── limit: 10
      │         └── fd: ()-->(70,71)
      └── scan index_tab@d
           ├── columns: latitude:92!null longitude:93 data1:94!null data2:95!null
           └── constraint: /92/93/94/95/89
                ├── [/-5 - /-5]
                └── [/0 - /0]

# Case with index join.
opt expect=SplitLimitedScanIntoUnionScans
SELECT *
FROM index_tab WHERE region = 'US_WEST' OR region = 'US_EAST'
ORDER BY data1 LIMIT 10
----
index-join index_tab
 ├── columns: id:1!null val:2 region:3!null latitude:4 longitude:5 data1:6!null data2:7!null geom:8
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-8)
 ├── ordering: +6
 └── limit
      ├── columns: id:1!null region:3!null data1:6!null data2:7!null
      ├── internal-ordering: +6
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(3,6,7)
      ├── ordering: +6
      ├── union-all
      │    ├── columns: id:1!null region:3!null data1:6!null data2:7!null
      │    ├── left columns: id:12 region:14 data1:17 data2:18
      │    ├── right columns: id:23 region:25 data1:28 data2:29
      │    ├── cardinality: [0 - 20]
      │    ├── ordering: +6
      │    ├── limit hint: 10.00
      │    ├── scan index_tab@c
      │    │    ├── columns: id:12!null region:14!null data1:17!null data2:18!null
      │    │    ├── constraint: /14/17/18/12: [/'US_EAST' - /'US_EAST']
      │    │    ├── limit: 10
      │    │    ├── key: (12)
      │    │    ├── fd: ()-->(14), (12)-->(17,18)
      │    │    ├── ordering: +17 opt(14) [actual: +17]
      │    │    └── limit hint: 10.00
      │    └── scan index_tab@c
      │         ├── columns: id:23!null region:25!null data1:28!null data2:29!null
      │         ├── constraint: /25/28/29/23: [/'US_WEST' - /'US_WEST']
      │         ├── limit: 10
      │         ├── key: (23)
      │         ├── fd: ()-->(25), (23)-->(28,29)
      │         ├── ordering: +28 opt(25) [actual: +28]
      │         └── limit hint: 10.00
      └── 10

# Case where check constraints are used.
opt expect=SplitLimitedScanIntoUnionScans
SELECT * FROM pqrs ORDER BY q LIMIT 5
----
limit
 ├── columns: p:1!null q:2!null r:3!null s:4!null
 ├── internal-ordering: +2
 ├── cardinality: [0 - 5]
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: +2
 ├── union-all
 │    ├── columns: p:1!null q:2!null r:3!null s:4!null
 │    ├── left columns: p:19 q:20 r:21 s:22
 │    ├── right columns: p:25 q:26 r:27 s:28
 │    ├── cardinality: [0 - 15]
 │    ├── ordering: +2
 │    ├── limit hint: 5.00
 │    ├── union-all
 │    │    ├── columns: p:19!null q:20!null r:21!null s:22!null
 │    │    ├── left columns: p:7 q:8 r:9 s:10
 │    │    ├── right columns: p:13 q:14 r:15 s:16
 │    │    ├── cardinality: [0 - 10]
 │    │    ├── ordering: +20
 │    │    ├── limit hint: 5.00
 │    │    ├── scan pqrs
 │    │    │    ├── columns: p:7!null q:8!null r:9!null s:10!null
 │    │    │    ├── constraint: /7/8: [/1 - /1]
 │    │    │    ├── limit: 5
 │    │    │    ├── key: (8)
 │    │    │    ├── fd: ()-->(7), (8)-->(9,10)
 │    │    │    ├── ordering: +8 opt(7) [actual: +8]
 │    │    │    └── limit hint: 5.00
 │    │    └── scan pqrs
 │    │         ├── columns: p:13!null q:14!null r:15!null s:16!null
 │    │         ├── constraint: /13/14: [/5 - /5]
 │    │         ├── limit: 5
 │    │         ├── key: (14)
 │    │         ├── fd: ()-->(13), (14)-->(15,16)
 │    │         ├── ordering: +14 opt(13) [actual: +14]
 │    │         └── limit hint: 5.00
 │    └── scan pqrs
 │         ├── columns: p:25!null q:26!null r:27!null s:28!null
 │         ├── constraint: /25/26: [/10 - /10]
 │         ├── limit: 5
 │         ├── key: (26)
 │         ├── fd: ()-->(25), (26)-->(27,28)
 │         ├── ordering: +26 opt(25) [actual: +26]
 │         └── limit hint: 5.00
 └── 5

# Case where multiple check constraints are combined into one constraint
# (CHECK (r > 0) and CHECK (r < 3)).
opt expect=SplitLimitedScanIntoUnionScans
SELECT * FROM pqrs ORDER BY s LIMIT 10
----
limit
 ├── columns: p:1!null q:2!null r:3!null s:4!null
 ├── internal-ordering: +4
 ├── cardinality: [0 - 10]
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: +4
 ├── union-all
 │    ├── columns: p:1!null q:2!null r:3!null s:4!null
 │    ├── left columns: p:7 q:8 r:9 s:10
 │    ├── right columns: p:13 q:14 r:15 s:16
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +4
 │    ├── limit hint: 10.00
 │    ├── scan pqrs@pqrs_r_s_idx
 │    │    ├── columns: p:7!null q:8!null r:9!null s:10!null
 │    │    ├── constraint: /9/10/7/8: [/1 - /1]
 │    │    ├── limit: 10
 │    │    ├── key: (7,8)
 │    │    ├── fd: ()-->(9), (7,8)-->(10)
 │    │    ├── ordering: +10 opt(9) [actual: +10]
 │    │    └── limit hint: 10.00
 │    └── scan pqrs@pqrs_r_s_idx
 │         ├── columns: p:13!null q:14!null r:15!null s:16!null
 │         ├── constraint: /15/16/13/14: [/2 - /2]
 │         ├── limit: 10
 │         ├── key: (13,14)
 │         ├── fd: ()-->(15), (13,14)-->(16)
 │         ├── ordering: +16 opt(15) [actual: +16]
 │         └── limit hint: 10.00
 └── 10

# Check constraints are not used because the scan is already constrained (the
# Scan's constraint is used instead).
opt expect=SplitLimitedScanIntoUnionScans
SELECT * FROM (SELECT * FROM pqrs WHERE p = 1 OR p = 5) ORDER BY q LIMIT 5
----
limit
 ├── columns: p:1!null q:2!null r:3!null s:4!null
 ├── internal-ordering: +2
 ├── cardinality: [0 - 5]
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: +2
 ├── union-all
 │    ├── columns: p:1!null q:2!null r:3!null s:4!null
 │    ├── left columns: p:7 q:8 r:9 s:10
 │    ├── right columns: p:13 q:14 r:15 s:16
 │    ├── cardinality: [0 - 10]
 │    ├── ordering: +2
 │    ├── limit hint: 5.00
 │    ├── scan pqrs
 │    │    ├── columns: p:7!null q:8!null r:9!null s:10!null
 │    │    ├── constraint: /7/8: [/1 - /1]
 │    │    ├── limit: 5
 │    │    ├── key: (8)
 │    │    ├── fd: ()-->(7), (8)-->(9,10)
 │    │    ├── ordering: +8 opt(7) [actual: +8]
 │    │    └── limit hint: 5.00
 │    └── scan pqrs
 │         ├── columns: p:13!null q:14!null r:15!null s:16!null
 │         ├── constraint: /13/14: [/5 - /5]
 │         ├── limit: 5
 │         ├── key: (14)
 │         ├── fd: ()-->(13), (14)-->(15,16)
 │         ├── ordering: +14 opt(13) [actual: +14]
 │         └── limit hint: 5.00
 └── 5

# Span boundary is exclusive, but the rule applies since the key is longer than
# the prefix.
opt expect=SplitLimitedScanIntoUnionScans
SELECT id, latitude, longitude FROM index_tab
WHERE (latitude = 0 OR latitude = 10) AND longitude IS NOT NULL
ORDER BY longitude LIMIT 10
----
limit
 ├── columns: id:1!null latitude:4!null longitude:5!null
 ├── internal-ordering: +5
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(4,5)
 ├── ordering: +5
 ├── union-all
 │    ├── columns: id:1!null latitude:4!null longitude:5!null
 │    ├── left columns: id:12 latitude:15 longitude:16
 │    ├── right columns: id:23 latitude:26 longitude:27
 │    ├── cardinality: [0 - 20]
 │    ├── ordering: +5
 │    ├── limit hint: 10.00
 │    ├── scan index_tab@d
 │    │    ├── columns: id:12!null latitude:15!null longitude:16!null
 │    │    ├── constraint: /15/16/17/18/12: (/0/NULL - /0]
 │    │    ├── limit: 10
 │    │    ├── key: (12)
 │    │    ├── fd: ()-->(15), (12)-->(16)
 │    │    ├── ordering: +16 opt(15) [actual: +16]
 │    │    └── limit hint: 10.00
 │    └── scan index_tab@d
 │         ├── columns: id:23!null latitude:26!null longitude:27!null
 │         ├── constraint: /26/27/28/29/23: (/10/NULL - /10]
 │         ├── limit: 10
 │         ├── key: (23)
 │         ├── fd: ()-->(26), (23)-->(27)
 │         ├── ordering: +27 opt(26) [actual: +27]
 │         └── limit hint: 10.00
 └── 10

# No-op case since span boundary is exclusive and the key length equals the
# prefix length.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT id, latitude, longitude FROM index_tab
WHERE latitude IS NOT NULL AND latitude < 4
ORDER BY longitude LIMIT 10
----
top-k
 ├── columns: id:1!null latitude:4!null longitude:5
 ├── internal-ordering: +5
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(4,5)
 ├── ordering: +5
 └── scan index_tab@d
      ├── columns: id:1!null latitude:4!null longitude:5
      ├── constraint: /4/5/6/7/1: (/NULL - /3]
      ├── key: (1)
      └── fd: (1)-->(4,5)

# No-op case because the scan has an inverted index.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT geom FROM index_tab WHERE ST_Intersects('POINT(3.0 3.0)'::geometry, geom)
----
select
 ├── columns: geom:8!null
 ├── immutable
 ├── index-join index_tab
 │    ├── columns: geom:8
 │    └── inverted-filter
 │         ├── columns: id:1!null
 │         ├── inverted expression: /11
 │         │    ├── tight: false, unique: false
 │         │    └── union spans
 │         │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │         │         ├── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │         │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x16\x00\x00\x00\x00\x00\x00\x00")
 │         ├── pre-filterer expression
 │         │    └── st_intersects('010100000000000000000008400000000000000840', geom:8)
 │         ├── key: (1)
 │         └── scan index_tab@geomidx
 │              ├── columns: id:1!null geom_inverted_key:11!null
 │              ├── inverted constraint: /11/1
 │              │    └── spans
 │              │         ├── ["B\xfd\x10\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x10\x00\x00\x00\x00\x00\x00\x00"]
 │              │         ├── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x00", "B\xfd\x14\x00\x00\x00\x00\x00\x00\x00"]
 │              │         └── ["B\xfd\x14\x00\x00\x00\x00\x00\x00\x01", "B\xfd\x16\x00\x00\x00\x00\x00\x00\x00")
 │              ├── key: (1)
 │              └── fd: (1)-->(11)
 └── filters
      └── st_intersects('010100000000000000000008400000000000000840', geom:8) [outer=(8), immutable, constraints=(/8: (/NULL - ])]

# No-op case because the multi-key span isn't countable.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab WHERE region > 'US_EAST' AND region < 'US_WEST'
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── scan index_tab@c
 │    ├── columns: region:3!null data1:6!null
 │    └── constraint: /3/6/7/1: [/e'US_EAST\x00' - /'US_WEST')
 └── aggregations
      └── max [as=max:12, outer=(6)]
           └── data1:6

# No-op case because the number of keys exceeds maxScanCount.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab WHERE val > 0 AND val < 20
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── scan index_tab@b
 │    ├── columns: val:2!null data1:6!null
 │    └── constraint: /2/6/7/1: [/1 - /19]
 └── aggregations
      └── max [as=max:12, outer=(6)]
           └── data1:6

# No-op case because the same number of rows would be scanned by the split-up
# scans as by the original.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab WHERE id > 0 AND id < 4
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── scan index_tab@a
 │    ├── columns: id:1!null data1:6!null
 │    ├── constraint: /1/6/7: [/1 - /3]
 │    ├── cardinality: [0 - 3]
 │    ├── key: (1)
 │    └── fd: (1)-->(6)
 └── aggregations
      └── max [as=max:12, outer=(6)]
           └── data1:6

# No-op case because the scan is already limited.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT max(data1)
FROM (SELECT region, data1 FROM index_tab LIMIT 10)
WHERE region='ASIA' OR region='AUSTRALIA'
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── select
 │    ├── columns: region:3!null data1:6!null
 │    ├── cardinality: [0 - 10]
 │    ├── scan index_tab@c
 │    │    ├── columns: region:3 data1:6!null
 │    │    └── limit: 10
 │    └── filters
 │         └── (region:3 = 'ASIA') OR (region:3 = 'AUSTRALIA') [outer=(3), constraints=(/3: [/'ASIA' - /'ASIA'] [/'AUSTRALIA' - /'AUSTRALIA']; tight)]
 └── aggregations
      └── max [as=max:12, outer=(6)]
           └── data1:6

# No-op case because the limit is negative.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT region, data1
FROM index_tab
WHERE region = 'ASIA' OR region = 'EUROPE' ORDER BY data1 LIMIT -1
----
limit
 ├── columns: region:3!null data1:6!null
 ├── internal-ordering: +6
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(3,6)
 ├── sort
 │    ├── columns: region:3!null data1:6!null
 │    ├── ordering: +6
 │    ├── limit hint: 1.00
 │    └── scan index_tab@c
 │         ├── columns: region:3!null data1:6!null
 │         └── constraint: /3/6/7/1
 │              ├── [/'ASIA' - /'ASIA']
 │              └── [/'EUROPE' - /'EUROPE']
 └── -1

# No-op case because scan is unconstrained.
opt expect-not=SplitLimitedScanIntoUnionScans
SELECT max(data1) FROM index_tab@b
----
scalar-group-by
 ├── columns: max:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── scan index_tab@b
 │    ├── columns: data1:6!null
 │    └── flags: force-index=b
 └── aggregations
      └── max [as=max:12, outer=(6)]
           └── data1:6

# ---------------------------------------------------
# GenerateTopK
# ---------------------------------------------------

opt expect=GenerateTopK
SELECT * FROM a ORDER BY i LIMIT 1
----
top-k
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2
 ├── k: 1
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── scan a
      ├── columns: k:1!null i:2 f:3 s:4 j:5
      ├── key: (1)
      └── fd: (1)-->(2-5)

opt expect=GenerateTopK
SELECT * FROM a ORDER BY i LIMIT 10
----
top-k
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +2
 └── scan a
      ├── columns: k:1!null i:2 f:3 s:4 j:5
      ├── key: (1)
      └── fd: (1)-->(2-5)

memo expect=GenerateTopK
SELECT * FROM a ORDER BY k LIMIT 1
----
memo (optimized, ~4KB, required=[presentation: k:1,i:2,f:3,s:4,j:5])
 ├── G1: (limit G2 G3 ordering=+1) (scan a,cols=(1-5),lim=1) (top-k G2 &{1 +1 })
 │    └── [presentation: k:1,i:2,f:3,s:4,j:5]
 │         ├── best: (scan a,cols=(1-5),lim=1)
 │         └── cost: 5.11
 ├── G2: (scan a,cols=(1-5))
 │    ├── [ordering: +1] [limit hint: 1.00]
 │    │    ├── best: (scan a,cols=(1-5))
 │    │    └── cost: 15.12
 │    └── []
 │         ├── best: (scan a,cols=(1-5))
 │         └── cost: 1125.02
 └── G3: (const 1)

# GenerateTopK is not triggered when the limit is not constant
opt expect-not=GenerateTopK
SELECT * FROM a ORDER BY i LIMIT (SELECT count(*) FROM a WHERE i < 10)
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +2
 ├── sort
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +2
 │    └── scan a
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── key: (1)
 │         └── fd: (1)-->(2-5)
 └── subquery
      └── scalar-group-by
           ├── columns: count_rows:15!null
           ├── cardinality: [1 - 1]
           ├── key: ()
           ├── fd: ()-->(15)
           ├── select
           │    ├── columns: i:9!null
           │    ├── scan a@s_idx
           │    │    └── columns: i:9
           │    └── filters
           │         └── i:9 < 10 [outer=(9), constraints=(/9: (/NULL - /9]; tight)]
           └── aggregations
                └── count-rows [as=count_rows:15]

# Nested GenerateTopK expressions
opt expect=GenerateTopK
SELECT * FROM (SELECT s,i FROM a ORDER BY f LIMIT 5) ORDER BY i LIMIT 2
----
project
 ├── columns: s:4 i:2
 ├── cardinality: [0 - 2]
 ├── ordering: +2
 └── top-k
      ├── columns: i:2 f:3 s:4
      ├── internal-ordering: +2
      ├── k: 2
      ├── cardinality: [0 - 2]
      ├── ordering: +2
      └── top-k
           ├── columns: i:2 f:3 s:4
           ├── internal-ordering: +3
           ├── k: 5
           ├── cardinality: [0 - 5]
           └── scan a@s_idx
                └── columns: i:2 f:3 s:4

# GenerateTopK is not triggered when the limit is a negative integer
opt expect-not=GenerateTopK
SELECT * FROM a ORDER BY i LIMIT -1
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── sort
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +2
 │    ├── limit hint: 1.00
 │    └── scan a
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── key: (1)
 │         └── fd: (1)-->(2-5)
 └── -1

# GenerateTopK is not triggered when there is no ordering
opt expect-not=GenerateTopK
SELECT * FROM a LIMIT 10
----
scan a
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── limit: 10
 ├── key: (1)
 └── fd: (1)-->(2-5)

# GenerateTopK triggered with offset.
opt
SELECT * FROM a ORDER BY i LIMIT 5 OFFSET 3
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +2
 ├── top-k
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── internal-ordering: +2
 │    ├── k: 8
 │    ├── cardinality: [0 - 8]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +2
 │    └── scan a
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── key: (1)
 │         └── fd: (1)-->(2-5)
 └── 3

# ---------------------------------------------------
# GenerateLimitedTopKScans
# ---------------------------------------------------

exec-ddl
CREATE TABLE defg (
d INT,
e INT,
f INT,
g INT,
INDEX dd (d),
INDEX dfg (d, f, g),
INDEX df (d, f)
)
----

# Generates an index scan on dd, dfg, and df and an index join to get all
# columns, though these are not the best cost plans.
memo expect=GenerateLimitedTopKScans
SELECT d, e FROM defg ORDER BY d, e LIMIT 10
----
memo (optimized, ~14KB, required=[presentation: d:1,e:2] [ordering: +1,+2])
 ├── G1: (limit G2 G3 ordering=+1,+2) (top-k G2 &{10 +1,+2 }) (top-k G4 &{10 +1,+2 }) (top-k G5 &{10 +1,+2 }) (top-k G6 &{10 +1,+2 }) (top-k G2 &{10 +1,+2 +1}) (top-k G4 &{10 +1,+2 +1}) (top-k G5 &{10 +1,+2 +1}) (top-k G6 &{10 +1,+2 +1})
 │    ├── [presentation: d:1,e:2] [ordering: +1,+2]
 │    │    ├── best: (top-k G2 &{10 +1,+2 })
 │    │    └── cost: 1185.69
 │    └── []
 │         ├── best: (top-k G2 &{10 +1,+2 })
 │         └── cost: 1185.69
 ├── G2: (scan defg,cols=(1,2))
 │    ├── [ordering: +1,+2] [limit hint: 10.00]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1345.17
 │    ├── [ordering: +1]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1334.20
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1334.20
 │    └── []
 │         ├── best: (scan defg,cols=(1,2))
 │         └── cost: 1094.72
 ├── G3: (const 10)
 ├── G4: (index-join G7 defg,cols=(1,2))
 │    ├── [ordering: +1]
 │    │    ├── best: (index-join G7="[ordering: +1]" defg,cols=(1,2))
 │    │    └── cost: 7134.44
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (index-join G7="[ordering: +1] [limit hint: 104.58]" defg,cols=(1,2))
 │    │    └── cost: 1336.81
 │    └── []
 │         ├── best: (index-join G7 defg,cols=(1,2))
 │         └── cost: 7134.44
 ├── G5: (index-join G8 defg,cols=(1,2))
 │    ├── [ordering: +1]
 │    │    ├── best: (index-join G8="[ordering: +1]" defg,cols=(1,2))
 │    │    └── cost: 7154.64
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (index-join G8="[ordering: +1] [limit hint: 104.58]" defg,cols=(1,2))
 │    │    └── cost: 1338.90
 │    └── []
 │         ├── best: (index-join G8 defg,cols=(1,2))
 │         └── cost: 7154.64
 ├── G6: (index-join G9 defg,cols=(1,2))
 │    ├── [ordering: +1]
 │    │    ├── best: (index-join G9="[ordering: +1]" defg,cols=(1,2))
 │    │    └── cost: 7144.54
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (index-join G9="[ordering: +1] [limit hint: 104.58]" defg,cols=(1,2))
 │    │    └── cost: 1337.85
 │    └── []
 │         ├── best: (index-join G9 defg,cols=(1,2))
 │         └── cost: 7144.54
 ├── G7: (scan defg@dd,cols=(1,5))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan defg@dd,cols=(1,5))
 │    │    └── cost: 1064.42
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (scan defg@dd,cols=(1,5))
 │    │    └── cost: 122.79
 │    └── []
 │         ├── best: (scan defg@dd,cols=(1,5))
 │         └── cost: 1064.42
 ├── G8: (scan defg@dfg,cols=(1,5))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan defg@dfg,cols=(1,5))
 │    │    └── cost: 1084.62
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (scan defg@dfg,cols=(1,5))
 │    │    └── cost: 124.88
 │    └── []
 │         ├── best: (scan defg@dfg,cols=(1,5))
 │         └── cost: 1084.62
 └── G9: (scan defg@df,cols=(1,5))
      ├── [ordering: +1]
      │    ├── best: (scan defg@df,cols=(1,5))
      │    └── cost: 1074.52
      ├── [ordering: +1] [limit hint: 104.58]
      │    ├── best: (scan defg@df,cols=(1,5))
      │    └── cost: 123.83
      └── []
           ├── best: (scan defg@df,cols=(1,5))
           └── cost: 1074.52

# Generates an index scan on df and an index join to get all columns.
opt expect=GenerateLimitedTopKScans
SELECT d, f, e FROM defg ORDER BY d, f, e LIMIT 10
----
top-k
 ├── columns: d:1 f:3 e:2
 ├── internal-ordering: +1,+3,+2
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── ordering: +1,+3,+2
 └── index-join defg
      ├── columns: d:1 e:2 f:3
      ├── ordering: +1,+3
      ├── limit hint: 100.00
      └── scan defg@df
           ├── columns: d:1 f:3 rowid:5!null
           ├── key: (5)
           ├── fd: (5)-->(1,3)
           ├── ordering: +1,+3
           └── limit hint: 100.00

# Does not generate a limited top K scan because the order by columns are covered.
opt expect-not=GenerateLimitedTopKScans
SELECT d FROM defg ORDER BY d LIMIT 10
----
scan defg@dd
 ├── columns: d:1
 ├── limit: 10
 └── ordering: +1

# First order column is not the first column in an index.
opt expect-not=GenerateLimitedTopKScans
SELECT * FROM defg ORDER BY f LIMIT 10
----
top-k
 ├── columns: d:1 e:2 f:3 g:4
 ├── internal-ordering: +3
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── ordering: +3
 └── scan defg
      └── columns: d:1 e:2 f:3 g:4

# ---------------------------------------------------
# GeneratePartialOrderTopK
# ---------------------------------------------------

# Index orderings dd, dfg, and df can be used.
memo expect=GeneratePartialOrderTopK
SELECT * FROM defg ORDER BY d, f, e LIMIT 10
----
memo (optimized, ~14KB, required=[presentation: d:1,e:2,f:3,g:4] [ordering: +1,+3,+2])
 ├── G1: (limit G2 G3 ordering=+1,+3,+2) (top-k G2 &{10 +1,+3,+2 }) (top-k G4 &{10 +1,+3,+2 }) (top-k G5 &{10 +1,+3,+2 }) (top-k G6 &{10 +1,+3,+2 }) (top-k G2 &{10 +1,+3,+2 +1,+3}) (top-k G4 &{10 +1,+3,+2 +1}) (top-k G5 &{10 +1,+3,+2 +1,+3}) (top-k G6 &{10 +1,+3,+2 +1,+3}) (top-k G4 &{10 +1,+3,+2 +1,+3})
 │    ├── [presentation: d:1,e:2,f:3,g:4] [ordering: +1,+3,+2]
 │    │    ├── best: (top-k G6="[ordering: +1,+3] [limit hint: 100.00]" &{10 +1,+3,+2 +1,+3})
 │    │    └── cost: 737.57
 │    └── []
 │         ├── best: (top-k G2 &{10 +1,+3,+2 })
 │         └── cost: 1206.52
 ├── G2: (scan defg,cols=(1-4))
 │    ├── [ordering: +1,+3,+2] [limit hint: 10.00]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1386.46
 │    ├── [ordering: +1,+3]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1385.37
 │    ├── [ordering: +1,+3] [limit hint: 100.00]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1385.37
 │    └── []
 │         ├── best: (scan defg,cols=(1-4))
 │         └── cost: 1114.92
 ├── G3: (const 10)
 ├── G4: (index-join G7 defg,cols=(1-4))
 │    ├── [ordering: +1,+3]
 │    │    ├── best: (sort G4="[ordering: +1]")
 │    │    └── cost: 7290.90
 │    ├── [ordering: +1,+3] [limit hint: 100.00]
 │    │    ├── best: (sort G4="[ordering: +1]")
 │    │    └── cost: 7290.90
 │    ├── [ordering: +1]
 │    │    ├── best: (index-join G7="[ordering: +1]" defg,cols=(1-4))
 │    │    └── cost: 7154.44
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (index-join G7="[ordering: +1] [limit hint: 104.58]" defg,cols=(1-4))
 │    │    └── cost: 1340.81
 │    └── []
 │         ├── best: (index-join G7 defg,cols=(1-4))
 │         └── cost: 7154.44
 ├── G5: (index-join G8 defg,cols=(1-4))
 │    ├── [ordering: +1,+3]
 │    │    ├── best: (index-join G8="[ordering: +1,+3]" defg,cols=(1-4))
 │    │    └── cost: 7174.84
 │    ├── [ordering: +1,+3] [limit hint: 100.00]
 │    │    ├── best: (index-join G8="[ordering: +1,+3] [limit hint: 100.00]" defg,cols=(1-4))
 │    │    └── cost: 729.04
 │    └── []
 │         ├── best: (index-join G8 defg,cols=(1-4))
 │         └── cost: 7174.84
 ├── G6: (index-join G9 defg,cols=(1-4))
 │    ├── [ordering: +1,+3]
 │    │    ├── best: (index-join G9="[ordering: +1,+3]" defg,cols=(1-4))
 │    │    └── cost: 7164.64
 │    ├── [ordering: +1,+3] [limit hint: 100.00]
 │    │    ├── best: (index-join G9="[ordering: +1,+3] [limit hint: 100.00]" defg,cols=(1-4))
 │    │    └── cost: 728.04
 │    └── []
 │         ├── best: (index-join G9 defg,cols=(1-4))
 │         └── cost: 7164.64
 ├── G7: (scan defg@dd,cols=(1,5))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan defg@dd,cols=(1,5))
 │    │    └── cost: 1064.42
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (scan defg@dd,cols=(1,5))
 │    │    └── cost: 122.79
 │    └── []
 │         ├── best: (scan defg@dd,cols=(1,5))
 │         └── cost: 1064.42
 ├── G8: (scan defg@dfg,cols=(1,3-5))
 │    ├── [ordering: +1,+3]
 │    │    ├── best: (scan defg@dfg,cols=(1,3-5))
 │    │    └── cost: 1104.82
 │    ├── [ordering: +1,+3] [limit hint: 100.00]
 │    │    ├── best: (scan defg@dfg,cols=(1,3-5))
 │    │    └── cost: 122.02
 │    └── []
 │         ├── best: (scan defg@dfg,cols=(1,3-5))
 │         └── cost: 1104.82
 └── G9: (scan defg@df,cols=(1,3,5))
      ├── [ordering: +1,+3]
      │    ├── best: (scan defg@df,cols=(1,3,5))
      │    └── cost: 1084.62
      ├── [ordering: +1,+3] [limit hint: 100.00]
      │    ├── best: (scan defg@df,cols=(1,3,5))
      │    └── cost: 120.02
      └── []
           ├── best: (scan defg@df,cols=(1,3,5))
           └── cost: 1084.62

# Only index ordering dfg can be used for the topk.
memo expect=GeneratePartialOrderTopK disable=GenerateLimitedTopKScans
SELECT d, f, g FROM defg ORDER BY d, g LIMIT 10
----
memo (optimized, ~5KB, required=[presentation: d:1,f:3,g:4] [ordering: +1,+4])
 ├── G1: (limit G2 G3 ordering=+1,+4) (top-k G2 &{10 +1,+4 }) (top-k G2 &{10 +1,+4 +1})
 │    ├── [presentation: d:1,f:3,g:4] [ordering: +1,+4]
 │    │    ├── best: (top-k G2="[ordering: +1] [limit hint: 104.58]" &{10 +1,+4 +1})
 │    │    └── cost: 135.73
 │    └── []
 │         ├── best: (top-k G2 &{10 +1,+4 })
 │         └── cost: 1185.79
 ├── G2: (scan defg,cols=(1,3,4)) (scan defg@dfg,cols=(1,3,4))
 │    ├── [ordering: +1,+4] [limit hint: 10.00]
 │    │    ├── best: (sort G2="[ordering: +1]")
 │    │    └── cost: 1221.18
 │    ├── [ordering: +1]
 │    │    ├── best: (scan defg@dfg,cols=(1,3,4))
 │    │    └── cost: 1094.72
 │    ├── [ordering: +1] [limit hint: 104.58]
 │    │    ├── best: (scan defg@dfg,cols=(1,3,4))
 │    │    └── cost: 125.92
 │    └── []
 │         ├── best: (scan defg@dfg,cols=(1,3,4))
 │         └── cost: 1094.72
 └── G3: (const 10)

# Ensure that we don't incorrectly use orderings that don't match the direction.
memo expect-not=GeneratePartialOrderTopK
SELECT * FROM defg ORDER BY g DESC LIMIT 10
----
memo (optimized, ~4KB, required=[presentation: d:1,e:2,f:3,g:4] [ordering: -4])
 ├── G1: (limit G2 G3 ordering=-4) (top-k G2 &{10 -4 })
 │    ├── [presentation: d:1,e:2,f:3,g:4] [ordering: -4]
 │    │    ├── best: (top-k G2 &{10 -4 })
 │    │    └── cost: 1201.77
 │    └── []
 │         ├── best: (top-k G2 &{10 -4 })
 │         └── cost: 1201.77
 ├── G2: (scan defg,cols=(1-4))
 │    ├── [ordering: -4] [limit hint: 10.00]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1374.40
 │    └── []
 │         ├── best: (scan defg,cols=(1-4))
 │         └── cost: 1114.92
 └── G3: (const 10)

# No index matches.
opt expect-not=GeneratePartialOrderTopK
SELECT * FROM defg ORDER BY e LIMIT 10
----
top-k
 ├── columns: d:1 e:2 f:3 g:4
 ├── internal-ordering: +2
 ├── k: 10
 ├── cardinality: [0 - 10]
 ├── ordering: +2
 └── scan defg
      └── columns: d:1 e:2 f:3 g:4

# Regression testing for #76102.
exec-ddl
CREATE TABLE tab_76102 (
 a INT2 NULL,
 b INT2 NULL AS (a + NULL) STORED,
 UNIQUE (a DESC)
)
----

# The GROUP BY column can only have one value (NULL), so  we do not benefit from
# limited TopK, and trying to apply the rule may lead to errors since the
# required ordering is optimized away in this case.
opt expect-not=GenerateLimitedTopKScans
SELECT b FROM tab_76102@tab_76102_a_key GROUP BY b LIMIT 5
----
index-join tab_76102
 ├── columns: b:2
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2)
 └── scan tab_76102@tab_76102_a_key
      ├── columns: rowid:3!null
      ├── limit: 1
      ├── flags: force-index=tab_76102_a_key
      ├── key: ()
      └── fd: ()-->(3)
