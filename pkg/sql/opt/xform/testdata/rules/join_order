exec-ddl
CREATE TABLE bx (
  b INT PRIMARY KEY,
  x INT
)
----

exec-ddl
CREATE TABLE cy (
  c INT PRIMARY KEY,
  y INT
)
----

exec-ddl
CREATE TABLE dz (
  d INT PRIMARY KEY,
  z INT
)
----

exec-ddl
CREATE TABLE abc (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT
)
----

opt join-limit=2 expect=ReorderJoins
SELECT * FROM abc, bx, cy WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c
----
inner-join (lookup cy)
 ├── columns: a:1!null b:2!null c:3!null d:4 b:6!null x:7 c:9!null y:10
 ├── key columns: [3] = [9]
 ├── lookup columns are key
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-4,6,7,9,10), (2)==(6), (3)==(9), (9)==(3), (6)==(2)
 ├── inner-join (lookup bx)
 │    ├── columns: a:1!null abc.b:2!null abc.c:3 d:4 bx.b:6!null x:7
 │    ├── key columns: [2] = [6]
 │    ├── lookup columns are key
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-4,6,7), (6)==(2), (2)==(6)
 │    ├── scan abc
 │    │    ├── columns: a:1!null abc.b:2 abc.c:3 d:4
 │    │    ├── constraint: /1: [/1 - /1]
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    └── fd: ()-->(1-4)
 │    └── filters (true)
 └── filters (true)

opt join-limit=2 expect=ReorderJoins
SELECT * FROM bx, abc, cy WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c
----
inner-join (lookup bx)
 ├── columns: b:1!null x:2 a:4!null b:5!null c:6!null d:7 c:9!null y:10
 ├── key columns: [5] = [1]
 ├── lookup columns are key
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2,4-7,9,10), (6)==(9), (1)==(5), (5)==(1), (9)==(6)
 ├── inner-join (lookup cy)
 │    ├── columns: a:4!null abc.b:5 abc.c:6!null d:7 cy.c:9!null y:10
 │    ├── key columns: [6] = [9]
 │    ├── lookup columns are key
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(4-7,9,10), (9)==(6), (6)==(9)
 │    ├── scan abc
 │    │    ├── columns: a:4!null abc.b:5 abc.c:6 d:7
 │    │    ├── constraint: /4: [/1 - /1]
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    └── fd: ()-->(4-7)
 │    └── filters (true)
 └── filters (true)

opt join-limit=2 expect=ReorderJoins
SELECT * FROM bx, cy, abc WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c
----
inner-join (lookup bx)
 ├── columns: b:1!null x:2 c:4!null y:5 a:7!null b:8!null c:9!null d:10
 ├── key columns: [8] = [1]
 ├── lookup columns are key
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2,4,5,7-10), (4)==(9), (1)==(8), (8)==(1), (9)==(4)
 ├── inner-join (lookup cy)
 │    ├── columns: cy.c:4!null y:5 a:7!null abc.b:8 abc.c:9!null d:10
 │    ├── key columns: [9] = [4]
 │    ├── lookup columns are key
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(4,5,7-10), (9)==(4), (4)==(9)
 │    ├── scan abc
 │    │    ├── columns: a:7!null abc.b:8 abc.c:9 d:10
 │    │    ├── constraint: /7: [/1 - /1]
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    └── fd: ()-->(7-10)
 │    └── filters (true)
 └── filters (true)

# Reorder subtrees of size 2.
exploretrace join-limit=2 rule=ReorderJoins format=hide-all
SELECT *
FROM bx, cy, dz, abc
WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c AND cy.c = dz.d
----
----
================================================================================
ReorderJoins
================================================================================
Source expression:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan cy
   │    ├── inner-join (hash)
   │    │    ├── scan dz
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters
   │    │         └── dz.d = abc.c
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

New expression 1 of 2:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan cy
   │    ├── inner-join (hash)
   │    │    ├── scan dz
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters
   │    │         └── dz.d = abc.c
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

New expression 2 of 2:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan cy
   │    ├── inner-join (hash)
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    ├── scan dz
   │    │    └── filters
   │    │         └── dz.d = abc.c
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

================================================================================
ReorderJoins
================================================================================
Source expression:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan cy
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

New expression 1 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan cy
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

New expression 2 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    ├── scan cy
   │    └── filters
   │         └── cy.c = dz.d
   └── filters
        └── abc.b = bx.b

New expression 3 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan dz
   │    ├── inner-join (hash)
   │    │    ├── scan cy
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters
   │    │         └── cy.c = abc.c
   │    └── filters
   │         └── dz.d = abc.c
   └── filters
        └── abc.b = bx.b

New expression 4 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── inner-join (hash)
   │    │    ├── scan cy
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters
   │    │         └── cy.c = abc.c
   │    ├── scan dz
   │    └── filters
   │         └── dz.d = abc.c
   └── filters
        └── abc.b = bx.b

New expression 5 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── inner-join (hash)
   │    │    ├── scan cy
   │    │    ├── scan dz
   │    │    └── filters
   │    │         └── cy.c = dz.d
   │    ├── scan abc
   │    │    └── constraint: /10: [/1 - /1]
   │    └── filters
   │         └── dz.d = abc.c
   └── filters
        └── abc.b = bx.b

New expression 6 of 6:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (hash)
   │    ├── scan abc
   │    │    └── constraint: /10: [/1 - /1]
   │    ├── inner-join (hash)
   │    │    ├── scan cy
   │    │    ├── scan dz
   │    │    └── filters
   │    │         └── cy.c = dz.d
   │    └── filters
   │         └── dz.d = abc.c
   └── filters
        └── abc.b = bx.b

================================================================================
ReorderJoins
================================================================================
Source expression:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (lookup cy)
   │    ├── lookup columns are key
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters (true)
   └── filters
        └── abc.b = bx.b

New expression 1 of 4:
  inner-join (hash)
   ├── scan bx
   ├── inner-join (lookup cy)
   │    ├── lookup columns are key
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters (true)
   └── filters
        └── abc.b = bx.b

New expression 2 of 4:
  inner-join (hash)
   ├── inner-join (lookup cy)
   │    ├── lookup columns are key
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters (true)
   ├── scan bx
   └── filters
        └── abc.b = bx.b

New expression 3 of 4:
  inner-join (hash)
   ├── scan cy
   ├── inner-join (hash)
   │    ├── scan bx
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters
   │         └── abc.b = bx.b
   └── filters
        └── cy.c = dz.d

New expression 4 of 4:
  inner-join (hash)
   ├── inner-join (hash)
   │    ├── scan bx
   │    ├── inner-join (lookup dz)
   │    │    ├── lookup columns are key
   │    │    ├── scan abc
   │    │    │    └── constraint: /10: [/1 - /1]
   │    │    └── filters (true)
   │    └── filters
   │         └── abc.b = bx.b
   ├── scan cy
   └── filters
        └── cy.c = dz.d
----
----

# No joins should be reordered besides commutation.
memo join-limit=0 expect-not=ReorderJoins
SELECT * FROM bx, cy, abc WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c
----
memo (optimized, ~24KB, required=[presentation: b:1,x:2,c:4,y:5,a:7,b:8,c:9,d:10])
 ├── G1: (inner-join G2 G3 G4) (merge-join G2 G3 G5 inner-join,+1,+8)
 │    └── [presentation: b:1,x:2,c:4,y:5,a:7,b:8,c:9,d:10]
 │         ├── best: (merge-join G2="[ordering: +1]" G3 G5 inner-join,+1,+8)
 │         └── cost: 2133.97
 ├── G2: (scan bx,cols=(1,2))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan bx,cols=(1,2))
 │    │    └── cost: 1054.41
 │    └── []
 │         ├── best: (scan bx,cols=(1,2))
 │         └── cost: 1054.41
 ├── G3: (inner-join G6 G7 G8) (merge-join G6 G7 G5 inner-join,+4,+9) (lookup-join G9 G8 abc,keyCols=[12],outCols=(4,5,7-10))
 │    └── []
 │         ├── best: (merge-join G6="[ordering: +4]" G7 G5 inner-join,+4,+9)
 │         └── cost: 1069.53
 ├── G4: (filters G10)
 ├── G5: (filters)
 ├── G6: (scan cy,cols=(4,5))
 │    ├── [ordering: +4]
 │    │    ├── best: (scan cy,cols=(4,5))
 │    │    └── cost: 1054.41
 │    └── []
 │         ├── best: (scan cy,cols=(4,5))
 │         └── cost: 1054.41
 ├── G7: (select G11 G12) (scan abc,cols=(7-10),constrained)
 │    └── []
 │         ├── best: (scan abc,cols=(7-10),constrained)
 │         └── cost: 5.09
 ├── G8: (filters G13)
 ├── G9: (project G6 G14 c y)
 │    └── []
 │         ├── best: (project G6 G14 c y)
 │         └── cost: 1074.42
 ├── G10: (eq G15 G16)
 ├── G11: (scan abc,cols=(7-10))
 │    └── []
 │         ├── best: (scan abc,cols=(7-10))
 │         └── cost: 1094.81
 ├── G12: (filters G17)
 ├── G13: (eq G18 G19)
 ├── G14: (projections G20)
 ├── G15: (variable abc.b)
 ├── G16: (variable bx.b)
 ├── G17: (eq G21 G20)
 ├── G18: (variable abc.c)
 ├── G19: (variable cy.c)
 ├── G20: (const 1)
 └── G21: (variable a)

memo join-limit=2
SELECT * FROM bx, cy, abc WHERE a = 1 AND abc.b = bx.b AND abc.c = cy.c
----
memo (optimized, ~43KB, required=[presentation: b:1,x:2,c:4,y:5,a:7,b:8,c:9,d:10])
 ├── G1: (inner-join G2 G3 G4) (inner-join G2 G3 G4) (inner-join G3 G2 G4) (inner-join G5 G6 G7) (inner-join G6 G5 G7) (merge-join G2 G3 G8 inner-join,+1,+8) (merge-join G2 G3 G8 inner-join,+1,+8) (lookup-join G3 G8 bx,keyCols=[8],outCols=(1,2,4,5,7-10)) (merge-join G5 G6 G8 inner-join,+4,+9) (lookup-join G6 G8 cy,keyCols=[9],outCols=(1,2,4,5,7-10))
 │    └── [presentation: b:1,x:2,c:4,y:5,a:7,b:8,c:9,d:10]
 │         ├── best: (lookup-join G3 G8 bx,keyCols=[8],outCols=(1,2,4,5,7-10))
 │         └── cost: 17.13
 ├── G2: (scan bx,cols=(1,2))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan bx,cols=(1,2))
 │    │    └── cost: 1054.41
 │    └── []
 │         ├── best: (scan bx,cols=(1,2))
 │         └── cost: 1054.41
 ├── G3: (inner-join G5 G9 G7) (inner-join G5 G9 G7) (inner-join G9 G5 G7) (merge-join G5 G9 G8 inner-join,+4,+9) (lookup-join G10 G7 abc,keyCols=[12],outCols=(4,5,7-10)) (merge-join G5 G9 G8 inner-join,+4,+9) (lookup-join G11 G7 abc,keyCols=[13],outCols=(4,5,7-10)) (lookup-join G9 G8 cy,keyCols=[9],outCols=(4,5,7-10))
 │    └── []
 │         ├── best: (lookup-join G9 G8 cy,keyCols=[9],outCols=(4,5,7-10))
 │         └── cost: 11.13
 ├── G4: (filters G12)
 ├── G5: (scan cy,cols=(4,5))
 │    ├── [ordering: +4]
 │    │    ├── best: (scan cy,cols=(4,5))
 │    │    └── cost: 1054.41
 │    └── []
 │         ├── best: (scan cy,cols=(4,5))
 │         └── cost: 1054.41
 ├── G6: (inner-join G2 G9 G4) (inner-join G9 G2 G4) (merge-join G2 G9 G8 inner-join,+1,+8) (lookup-join G13 G4 abc,keyCols=[14],outCols=(1,2,7-10)) (lookup-join G9 G8 bx,keyCols=[8],outCols=(1,2,7-10))
 │    └── []
 │         ├── best: (lookup-join G9 G8 bx,keyCols=[8],outCols=(1,2,7-10))
 │         └── cost: 11.13
 ├── G7: (filters G14)
 ├── G8: (filters)
 ├── G9: (select G15 G16) (scan abc,cols=(7-10),constrained)
 │    └── []
 │         ├── best: (scan abc,cols=(7-10),constrained)
 │         └── cost: 5.09
 ├── G10: (project G5 G17 c y)
 │    └── []
 │         ├── best: (project G5 G17 c y)
 │         └── cost: 1074.42
 ├── G11: (project G5 G17 c y)
 │    └── []
 │         ├── best: (project G5 G17 c y)
 │         └── cost: 1074.42
 ├── G12: (eq G18 G19)
 ├── G13: (project G2 G17 b x)
 │    └── []
 │         ├── best: (project G2 G17 b x)
 │         └── cost: 1074.42
 ├── G14: (eq G20 G21)
 ├── G15: (scan abc,cols=(7-10))
 │    └── []
 │         ├── best: (scan abc,cols=(7-10))
 │         └── cost: 1094.81
 ├── G16: (filters G22)
 ├── G17: (projections G23)
 ├── G18: (variable abc.b)
 ├── G19: (variable bx.b)
 ├── G20: (variable abc.c)
 ├── G21: (variable cy.c)
 ├── G22: (eq G24 G23)
 ├── G23: (const 1)
 └── G24: (variable a)

opt join-limit=3 expect=ReorderJoins
SELECT * FROM bx, cy, dz, abc WHERE a = 1
----
inner-join (cross)
 ├── columns: b:1!null x:2 c:4!null y:5 d:7!null z:8 a:10!null b:11 c:12 d:13
 ├── key: (1,4,7)
 ├── fd: ()-->(10-13), (1)-->(2), (4)-->(5), (7)-->(8)
 ├── inner-join (cross)
 │    ├── columns: cy.c:4!null y:5 dz.d:7!null z:8 a:10!null abc.b:11 abc.c:12 abc.d:13
 │    ├── key: (4,7)
 │    ├── fd: ()-->(10-13), (4)-->(5), (7)-->(8)
 │    ├── scan cy
 │    │    ├── columns: cy.c:4!null y:5
 │    │    ├── key: (4)
 │    │    └── fd: (4)-->(5)
 │    ├── inner-join (cross)
 │    │    ├── columns: dz.d:7!null z:8 a:10!null abc.b:11 abc.c:12 abc.d:13
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    ├── key: (7)
 │    │    ├── fd: ()-->(10-13), (7)-->(8)
 │    │    ├── scan dz
 │    │    │    ├── columns: dz.d:7!null z:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    ├── scan abc
 │    │    │    ├── columns: a:10!null abc.b:11 abc.c:12 abc.d:13
 │    │    │    ├── constraint: /10: [/1 - /1]
 │    │    │    ├── cardinality: [0 - 1]
 │    │    │    ├── key: ()
 │    │    │    └── fd: ()-->(10-13)
 │    │    └── filters (true)
 │    └── filters (true)
 ├── scan bx
 │    ├── columns: bx.b:1!null x:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters (true)

opt join-limit=2 format=show-all
SELECT * FROM abc, bx, cy, dz WHERE a = 1
----
inner-join (cross)
 ├── columns: a:1(int!null) b:2(int) c:3(int) d:4(int) b:6(int!null) x:7(int) c:9(int!null) y:10(int) d:12(int!null) z:13(int)
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── stats: [rows=1e+09]
 ├── cost: 32525715.9
 ├── key: (6,9,12)
 ├── fd: ()-->(1-4), (6)-->(7), (9)-->(10), (12)-->(13)
 ├── prune: (2-4,6,7,9,10,12,13)
 ├── interesting orderings: (+1) (+6) (+9) (+12)
 ├── inner-join (cross)
 │    ├── columns: t.public.bx.b:6(int!null) t.public.bx.x:7(int) t.public.cy.c:9(int!null) t.public.cy.y:10(int) t.public.dz.d:12(int!null) t.public.dz.z:13(int)
 │    ├── stats: [rows=1e+09]
 │    ├── cost: 10025710.8
 │    ├── key: (6,9,12)
 │    ├── fd: (6)-->(7), (9)-->(10), (12)-->(13)
 │    ├── prune: (6,7,9,10,12,13)
 │    ├── interesting orderings: (+6) (+9) (+12)
 │    ├── inner-join (cross)
 │    │    ├── columns: t.public.cy.c:9(int!null) t.public.cy.y:10(int) t.public.dz.d:12(int!null) t.public.dz.z:13(int)
 │    │    ├── stats: [rows=1000000]
 │    │    ├── cost: 12138.83
 │    │    ├── key: (9,12)
 │    │    ├── fd: (9)-->(10), (12)-->(13)
 │    │    ├── prune: (9,10,12,13)
 │    │    ├── interesting orderings: (+9) (+12)
 │    │    ├── scan t.public.cy
 │    │    │    ├── columns: t.public.cy.c:9(int!null) t.public.cy.y:10(int)
 │    │    │    ├── stats: [rows=1000]
 │    │    │    ├── cost: 1054.41
 │    │    │    ├── key: (9)
 │    │    │    ├── fd: (9)-->(10)
 │    │    │    ├── prune: (9,10)
 │    │    │    ├── interesting orderings: (+9)
 │    │    │    └── unfiltered-cols: (9-11)
 │    │    ├── scan t.public.dz
 │    │    │    ├── columns: t.public.dz.d:12(int!null) t.public.dz.z:13(int)
 │    │    │    ├── stats: [rows=1000]
 │    │    │    ├── cost: 1054.41
 │    │    │    ├── key: (12)
 │    │    │    ├── fd: (12)-->(13)
 │    │    │    ├── prune: (12,13)
 │    │    │    ├── interesting orderings: (+12)
 │    │    │    └── unfiltered-cols: (12-14)
 │    │    └── filters (true)
 │    ├── scan t.public.bx
 │    │    ├── columns: t.public.bx.b:6(int!null) t.public.bx.x:7(int)
 │    │    ├── stats: [rows=1000]
 │    │    ├── cost: 1054.41
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── prune: (6,7)
 │    │    ├── interesting orderings: (+6)
 │    │    └── unfiltered-cols: (6-8)
 │    └── filters (true)
 ├── scan t.public.abc
 │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int) t.public.abc.d:4(int)
 │    ├── constraint: /1: [/1 - /1]
 │    ├── cardinality: [0 - 1]
 │    ├── stats: [rows=1, distinct(1)=1, null(1)=0]
 │    ├── cost: 5.09
 │    ├── key: ()
 │    ├── fd: ()-->(1-4)
 │    ├── prune: (2-4)
 │    └── interesting orderings: (+1)
 └── filters (true)

# Note the difference in memo size for with and without reorder-joins, for only four tables.
# TODO(justin): Find a way to reduce this.

memo join-limit=0
SELECT * FROM bx, cy, dz, abc WHERE x = y AND y = z AND z = a
----
memo (optimized, ~24KB, required=[presentation: b:1,x:2,c:4,y:5,d:7,z:8,a:10,b:11,c:12,d:13])
 ├── G1: (inner-join G2 G3 G4) (merge-join G2 G3 G5 inner-join,+2,+5)
 │    └── [presentation: b:1,x:2,c:4,y:5,d:7,z:8,a:10,b:11,c:12,d:13]
 │         ├── best: (inner-join G2 G3 G4)
 │         └── cost: 5580.15
 ├── G2: (scan bx,cols=(1,2))
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan bx,cols=(1,2))
 │         └── cost: 1054.41
 ├── G3: (inner-join G6 G7 G8) (merge-join G6 G7 G5 inner-join,+5,+8)
 │    ├── [ordering: +(5|8|10)]
 │    │    ├── best: (merge-join G6="[ordering: +5]" G7="[ordering: +(8|10)]" G5 inner-join,+5,+8)
 │    │    └── cost: 3830.11
 │    └── []
 │         ├── best: (inner-join G6 G7 G8)
 │         └── cost: 3371.41
 ├── G4: (filters G9)
 ├── G5: (filters)
 ├── G6: (scan cy,cols=(4,5))
 │    ├── [ordering: +5]
 │    │    ├── best: (sort G6)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan cy,cols=(4,5))
 │         └── cost: 1054.41
 ├── G7: (inner-join G10 G11 G12) (merge-join G10 G11 G5 inner-join,+8,+10) (lookup-join G10 G5 abc,keyCols=[8],outCols=(7,8,10-13))
 │    ├── [ordering: +(8|10)]
 │    │    ├── best: (merge-join G10="[ordering: +8]" G11="[ordering: +10]" G5 inner-join,+8,+10)
 │    │    └── cost: 2418.46
 │    └── []
 │         ├── best: (inner-join G10 G11 G12)
 │         └── cost: 2189.14
 ├── G8: (filters G13)
 ├── G9: (eq G14 G15)
 ├── G10: (scan dz,cols=(7,8))
 │    ├── [ordering: +8]
 │    │    ├── best: (sort G10)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan dz,cols=(7,8))
 │         └── cost: 1054.41
 ├── G11: (scan abc,cols=(10-13))
 │    ├── [ordering: +10]
 │    │    ├── best: (scan abc,cols=(10-13))
 │    │    └── cost: 1094.81
 │    └── []
 │         ├── best: (scan abc,cols=(10-13))
 │         └── cost: 1094.81
 ├── G12: (filters G16)
 ├── G13: (eq G15 G17)
 ├── G14: (variable x)
 ├── G15: (variable y)
 ├── G16: (eq G17 G18)
 ├── G17: (variable z)
 └── G18: (variable a)

# This query is the worst-case scenario for join ordering because all relations
# are connected, which allows every join order to be added to the memo.
# TODO(drewk): implement branch pruning and/or a max operator limit for the
# memo.
memo join-limit=3
SELECT * FROM bx, cy, dz, abc WHERE x = y AND y = z AND z = a
----
memo (optimized, ~53KB, required=[presentation: b:1,x:2,c:4,y:5,d:7,z:8,a:10,b:11,c:12,d:13])
 ├── G1: (inner-join G2 G3 G4) (inner-join G2 G3 G4) (inner-join G3 G2 G4) (inner-join G5 G6 G7) (inner-join G6 G5 G7) (inner-join G8 G9 G7) (inner-join G9 G8 G7) (inner-join G10 G11 G12) (inner-join G11 G10 G12) (inner-join G13 G14 G12) (inner-join G14 G13 G12) (inner-join G15 G16 G12) (inner-join G16 G15 G12) (inner-join G17 G18 G12) (inner-join G18 G17 G12) (merge-join G11 G10 G19 inner-join,+10,+8) (merge-join G14 G13 G19 inner-join,+10,+8) (merge-join G16 G15 G19 inner-join,+10,+8) (lookup-join G17 G19 abc,keyCols=[8],outCols=(1,2,4,5,7,8,10-13)) (merge-join G18 G17 G19 inner-join,+10,+8)
 │    └── [presentation: b:1,x:2,c:4,y:5,d:7,z:8,a:10,b:11,c:12,d:13]
 │         ├── best: (inner-join G3 G2 G4)
 │         └── cost: 5536.15
 ├── G2: (scan bx,cols=(1,2))
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan bx,cols=(1,2))
 │         └── cost: 1054.41
 ├── G3: (inner-join G5 G9 G7) (inner-join G5 G9 G7) (inner-join G9 G5 G7) (inner-join G10 G14 G12) (inner-join G14 G10 G12) (inner-join G15 G18 G12) (inner-join G18 G15 G12) (merge-join G14 G10 G19 inner-join,+10,+8) (lookup-join G15 G19 abc,keyCols=[8],outCols=(4,5,7,8,10-13)) (merge-join G18 G15 G19 inner-join,+10,+8)
 │    └── []
 │         ├── best: (inner-join G5 G9 G7)
 │         └── cost: 3371.41
 ├── G4: (filters G20)
 ├── G5: (scan cy,cols=(4,5))
 │    ├── [ordering: +5]
 │    │    ├── best: (sort G5)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan cy,cols=(4,5))
 │         └── cost: 1054.41
 ├── G6: (inner-join G2 G9 G21) (inner-join G9 G2 G21) (inner-join G10 G16 G12) (inner-join G16 G10 G12) (inner-join G13 G18 G12) (inner-join G18 G13 G12) (merge-join G16 G10 G19 inner-join,+10,+8) (lookup-join G13 G19 abc,keyCols=[8],outCols=(1,2,7,8,10-13)) (merge-join G18 G13 G19 inner-join,+10,+8)
 │    └── []
 │         ├── best: (inner-join G2 G9 G21)
 │         └── cost: 3371.41
 ├── G7: (filters G22)
 ├── G8: (inner-join G2 G5 G4) (inner-join G5 G2 G4)
 │    ├── [ordering: +(2|5)]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 5423.89
 │    └── []
 │         ├── best: (inner-join G2 G5 G4)
 │         └── cost: 2236.85
 ├── G9: (inner-join G10 G18 G12) (inner-join G10 G18 G12) (inner-join G18 G10 G12) (lookup-join G10 G19 abc,keyCols=[8],outCols=(7,8,10-13)) (lookup-join G10 G19 abc,keyCols=[8],outCols=(7,8,10-13)) (merge-join G18 G10 G19 inner-join,+10,+8)
 │    └── []
 │         ├── best: (inner-join G10 G18 G12)
 │         └── cost: 2189.14
 ├── G10: (scan dz,cols=(7,8))
 │    ├── [ordering: +8]
 │    │    ├── best: (sort G10)
 │    │    └── cost: 1293.74
 │    └── []
 │         ├── best: (scan dz,cols=(7,8))
 │         └── cost: 1054.41
 ├── G11: (inner-join G2 G14 G4) (inner-join G14 G2 G4) (inner-join G5 G16 G4) (inner-join G16 G5 G4) (inner-join G8 G18 G23) (inner-join G18 G8 G23) (lookup-join G8 G19 abc,keyCols=[5],outCols=(1,2,4,5,10-13)) (merge-join G18 G8 G19 inner-join,+10,+5)
 │    ├── [ordering: +(2|5|10)]
 │    │    ├── best: (merge-join G18="[ordering: +10]" G8="[ordering: +(2|5)]" G19 inner-join,+10,+5)
 │    │    └── cost: 6724.73
 │    └── []
 │         ├── best: (inner-join G2 G14 G4)
 │         └── cost: 3371.41
 ├── G12: (filters G24)
 ├── G13: (inner-join G2 G10 G21) (inner-join G10 G2 G21)
 │    ├── [ordering: +(2|8)]
 │    │    ├── best: (sort G13)
 │    │    └── cost: 5423.89
 │    └── []
 │         ├── best: (inner-join G2 G10 G21)
 │         └── cost: 2236.85
 ├── G14: (inner-join G5 G18 G23) (inner-join G18 G5 G23) (lookup-join G5 G19 abc,keyCols=[5],outCols=(4,5,10-13)) (merge-join G18 G5 G19 inner-join,+10,+5)
 │    ├── [ordering: +(5|10)]
 │    │    ├── best: (merge-join G18="[ordering: +10]" G5="[ordering: +5]" G19 inner-join,+10,+5)
 │    │    └── cost: 2418.46
 │    └── []
 │         ├── best: (inner-join G5 G18 G23)
 │         └── cost: 2189.14
 ├── G15: (inner-join G5 G10 G7) (inner-join G10 G5 G7)
 │    ├── [ordering: +(5|8)]
 │    │    ├── best: (sort G15)
 │    │    └── cost: 5423.89
 │    └── []
 │         ├── best: (inner-join G5 G10 G7)
 │         └── cost: 2236.85
 ├── G16: (inner-join G2 G18 G25) (inner-join G18 G2 G25) (lookup-join G2 G19 abc,keyCols=[2],outCols=(1,2,10-13)) (merge-join G18 G2 G19 inner-join,+10,+2)
 │    ├── [ordering: +(2|10)]
 │    │    ├── best: (merge-join G18="[ordering: +10]" G2="[ordering: +2]" G19 inner-join,+10,+2)
 │    │    └── cost: 2418.46
 │    └── []
 │         ├── best: (inner-join G2 G18 G25)
 │         └── cost: 2189.14
 ├── G17: (inner-join G2 G15 G4) (inner-join G15 G2 G4) (inner-join G5 G13 G7) (inner-join G13 G5 G7) (inner-join G8 G10 G7) (inner-join G10 G8 G7)
 │    ├── [ordering: +(2|5|8)]
 │    │    ├── best: (sort G17)
 │    │    └── cost: 44312.22
 │    └── []
 │         ├── best: (inner-join G15 G2 G4)
 │         └── cost: 4401.59
 ├── G18: (scan abc,cols=(10-13))
 │    ├── [ordering: +10]
 │    │    ├── best: (scan abc,cols=(10-13))
 │    │    └── cost: 1094.81
 │    └── []
 │         ├── best: (scan abc,cols=(10-13))
 │         └── cost: 1094.81
 ├── G19: (filters)
 ├── G20: (eq G26 G27)
 ├── G21: (filters G28)
 ├── G22: (eq G27 G29)
 ├── G23: (filters G30)
 ├── G24: (eq G29 G31)
 ├── G25: (filters G32)
 ├── G26: (variable x)
 ├── G27: (variable y)
 ├── G28: (eq G26 G29)
 ├── G29: (variable z)
 ├── G30: (eq G27 G31)
 ├── G31: (variable a)
 └── G32: (eq G26 G31)

opt
SELECT * FROM bx, cy, dz, abc WHERE x = y AND y = z AND z = a
----
inner-join (hash)
 ├── columns: b:1!null x:2!null c:4!null y:5!null d:7!null z:8!null a:10!null b:11 c:12 d:13
 ├── key: (1,4,7)
 ├── fd: (1)-->(2), (4)-->(5), (7)-->(8), (10)-->(11-13), (8)==(2,5,10), (10)==(2,5,8), (5)==(2,8,10), (2)==(5,8,10)
 ├── inner-join (hash)
 │    ├── columns: cy.c:4!null y:5!null dz.d:7!null z:8!null a:10!null abc.b:11 abc.c:12 abc.d:13
 │    ├── key: (4,7)
 │    ├── fd: (4)-->(5), (7)-->(8), (10)-->(11-13), (8)==(5,10), (10)==(5,8), (5)==(8,10)
 │    ├── scan cy
 │    │    ├── columns: cy.c:4!null y:5
 │    │    ├── key: (4)
 │    │    └── fd: (4)-->(5)
 │    ├── inner-join (hash)
 │    │    ├── columns: dz.d:7!null z:8!null a:10!null abc.b:11 abc.c:12 abc.d:13
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    ├── key: (7)
 │    │    ├── fd: (7)-->(8), (10)-->(11-13), (8)==(10), (10)==(8)
 │    │    ├── scan dz
 │    │    │    ├── columns: dz.d:7!null z:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    ├── scan abc
 │    │    │    ├── columns: a:10!null abc.b:11 abc.c:12 abc.d:13
 │    │    │    ├── key: (10)
 │    │    │    └── fd: (10)-->(11-13)
 │    │    └── filters
 │    │         └── z:8 = a:10 [outer=(8,10), constraints=(/8: (/NULL - ]; /10: (/NULL - ]), fd=(8)==(10), (10)==(8)]
 │    └── filters
 │         └── y:5 = z:8 [outer=(5,8), constraints=(/5: (/NULL - ]; /8: (/NULL - ]), fd=(5)==(8), (8)==(5)]
 ├── scan bx
 │    ├── columns: bx.b:1!null x:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      └── x:2 = y:5 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]

# Regression test for #34795.
exec-ddl
CREATE TABLE a (id INT8 PRIMARY KEY)
----

opt join-limit=3
SELECT
    1
FROM
    a as a1
    INNER JOIN a as a2 ON 1 = a2.id
    INNER JOIN a AS a3 ON a1.id = a3.id
    CROSS JOIN a as a4
WHERE
    a4.id = 1 AND (SELECT true FROM a WHERE a1.id = 1)
----
project
 ├── columns: "?column?":12!null
 ├── fd: ()-->(12)
 ├── inner-join (cross)
 │    ├── columns: a1.id:1!null a2.id:3!null a3.id:5!null a4.id:7!null bool:11!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── key: (5)
 │    ├── fd: ()-->(3,7,11), (1)==(5), (5)==(1)
 │    ├── inner-join (cross)
 │    │    ├── columns: a1.id:1!null a2.id:3!null a3.id:5!null bool:11!null
 │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 │    │    ├── key: (5)
 │    │    ├── fd: ()-->(3,11), (1)==(5), (5)==(1)
 │    │    ├── scan a [as=a2]
 │    │    │    ├── columns: a2.id:3!null
 │    │    │    ├── constraint: /3: [/1 - /1]
 │    │    │    ├── cardinality: [0 - 1]
 │    │    │    ├── key: ()
 │    │    │    └── fd: ()-->(3)
 │    │    ├── inner-join (lookup a [as=a3])
 │    │    │    ├── columns: a1.id:1!null a3.id:5!null bool:11!null
 │    │    │    ├── key columns: [1] = [5]
 │    │    │    ├── lookup columns are key
 │    │    │    ├── key: (5)
 │    │    │    ├── fd: ()-->(11), (1)==(5), (5)==(1)
 │    │    │    ├── select
 │    │    │    │    ├── columns: a1.id:1!null bool:11!null
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(11)
 │    │    │    │    ├── ensure-distinct-on
 │    │    │    │    │    ├── columns: a1.id:1!null bool:11
 │    │    │    │    │    ├── grouping columns: a1.id:1!null
 │    │    │    │    │    ├── error: "more than one row returned by a subquery used as an expression"
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(11)
 │    │    │    │    │    ├── left-join (cross)
 │    │    │    │    │    │    ├── columns: a1.id:1!null bool:11
 │    │    │    │    │    │    ├── scan a [as=a1]
 │    │    │    │    │    │    │    ├── columns: a1.id:1!null
 │    │    │    │    │    │    │    └── key: (1)
 │    │    │    │    │    │    ├── project
 │    │    │    │    │    │    │    ├── columns: bool:11!null
 │    │    │    │    │    │    │    ├── fd: ()-->(11)
 │    │    │    │    │    │    │    ├── scan a
 │    │    │    │    │    │    │    └── projections
 │    │    │    │    │    │    │         └── true [as=bool:11]
 │    │    │    │    │    │    └── filters
 │    │    │    │    │    │         └── a1.id:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
 │    │    │    │    │    └── aggregations
 │    │    │    │    │         └── const-agg [as=bool:11, outer=(11)]
 │    │    │    │    │              └── bool:11
 │    │    │    │    └── filters
 │    │    │    │         └── bool:11 [outer=(11), constraints=(/11: [/true - /true]; tight), fd=()-->(11)]
 │    │    │    └── filters (true)
 │    │    └── filters (true)
 │    ├── scan a [as=a4]
 │    │    ├── columns: a4.id:7!null
 │    │    ├── constraint: /7: [/1 - /1]
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    └── fd: ()-->(7)
 │    └── filters (true)
 └── projections
      └── 1 [as="?column?":12]

# An edge for b = d should be added to the graph.
reorderjoins format=hide-all
SELECT * FROM bx
INNER JOIN cy ON b = c
INNER JOIN (SELECT * FROM dz WHERE z > 0) ON c = d
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── b = c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
b = c [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── b = c
 ├── select
 │    ├── scan dz
 │    └── filters
 │         └── z > 0
 └── filters
      └── c = d

----Vertexes----
A:
scan bx

B:
scan cy

C:
select
 ├── scan dz
 └── filters
      └── z > 0

----Edges----
b = c [inner]
c = d [inner]
b = d [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
B AC    refs [AB] [inner]
AC B    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]

Joins Considered: 12
--------------------------------------------------------------------------------
----Final Plan----
inner-join (merge)
 ├── scan bx
 ├── inner-join (merge)
 │    ├── scan cy
 │    ├── select
 │    │    ├── scan dz
 │    │    └── filters
 │    │         └── z > 0
 │    └── filters (true)
 └── filters (true)
--------------------------------------------------------------------------------
----
----

reorderjoins format=hide-all
SELECT * FROM bx
INNER JOIN cy ON b = c
INNER JOIN (SELECT max(z) AS m FROM dz) ON y = m
INNER JOIN abc ON m = a
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── bx.b = cy.c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
bx.b = cy.c [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── bx.b = cy.c
 ├── scalar-group-by
 │    ├── scan dz
 │    └── aggregations
 │         └── max
 │              └── z
 └── filters
      └── y = max

----Vertexes----
A:
scan bx

B:
scan cy

C:
scalar-group-by
 ├── scan dz
 └── aggregations
      └── max
           └── z

----Edges----
bx.b = cy.c [inner]
y = max [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]

Joins Considered: 8
--------------------------------------------------------------------------------
----Join Tree #3----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── inner-join (hash)
 │    │    ├── scan bx
 │    │    ├── scan cy
 │    │    └── filters
 │    │         └── bx.b = cy.c
 │    ├── scalar-group-by
 │    │    ├── scan dz
 │    │    └── aggregations
 │    │         └── max
 │    │              └── z
 │    └── filters
 │         └── y = max
 ├── scan abc
 └── filters
      └── max = a

----Vertexes----
A:
scan bx

B:
scan cy

C:
scalar-group-by
 ├── scan dz
 └── aggregations
      └── max
           └── z

D:
scan abc

----Edges----
bx.b = cy.c [inner]
y = max [inner]
max = a [inner]
y = a [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]
----Joining BD----
B D    refs [BD] [inner]
D B    refs [BD] [inner]
----Joining ABD----
A BD    refs [AB] [inner]
BD A    refs [AB] [inner]
AB D    refs [BD] [inner]
D AB    refs [BD] [inner]
----Joining CD----
C D    refs [CD] [inner]
D C    refs [CD] [inner]
----Joining BCD----
B CD    refs [BC] [inner]
CD B    refs [BC] [inner]
C BD    refs [BC] [inner]
BD C    refs [BC] [inner]
BC D    refs [CD] [inner]
D BC    refs [CD] [inner]
----Joining ABCD----
A BCD    refs [AB] [inner]
BCD A    refs [AB] [inner]
AB CD    refs [BC] [inner]
CD AB    refs [BC] [inner]
C ABD    refs [BC] [inner]
ABD C    refs [BC] [inner]
ABC D    refs [CD] [inner]
D ABC    refs [CD] [inner]

Joins Considered: 30
--------------------------------------------------------------------------------
----Final Plan----
inner-join (lookup bx)
 ├── lookup columns are key
 ├── inner-join (hash)
 │    ├── scan cy
 │    ├── inner-join (lookup abc)
 │    │    ├── lookup columns are key
 │    │    ├── scalar-group-by
 │    │    │    ├── scan dz
 │    │    │    └── aggregations
 │    │    │         └── max
 │    │    │              └── z
 │    │    └── filters (true)
 │    └── filters
 │         └── y = max
 └── filters (true)
--------------------------------------------------------------------------------
----
----

# Treat the join with hints as a base relation. Note that the implicit edges
# x = a and y = a are added to the join graph. The x = y filter is not an edge
# because it comes from the join with hints. However, it can still be used in
# calculating transitive closure.
reorderjoins format=hide-all
SELECT * FROM bx
INNER HASH JOIN cy ON x = y
INNER JOIN dz ON y = z
INNER JOIN abc ON z = a
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── flags: force hash join (store right side)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── x = y
 ├── scan dz
 └── filters
      └── y = z

----Vertexes----
A:
inner-join (hash)
 ├── flags: force hash join (store right side)
 ├── scan bx
 ├── scan cy
 └── filters
      └── x = y

B:
scan dz

----Edges----
y = z [inner]
x = z [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── inner-join (hash)
 │    │    ├── flags: force hash join (store right side)
 │    │    ├── scan bx
 │    │    ├── scan cy
 │    │    └── filters
 │    │         └── x = y
 │    ├── scan dz
 │    └── filters
 │         └── y = z
 ├── scan abc
 └── filters
      └── z = a

----Vertexes----
A:
inner-join (hash)
 ├── flags: force hash join (store right side)
 ├── scan bx
 ├── scan cy
 └── filters
      └── x = y

B:
scan dz

C:
scan abc

----Edges----
y = z [inner]
z = a [inner]
x = z [inner]
x = a [inner]
y = a [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
B AC    refs [AB] [inner]
AC B    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]

Joins Considered: 12
--------------------------------------------------------------------------------
----Final Plan----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── flags: force hash join (store right side)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── x = y
 ├── inner-join (hash)
 │    ├── scan dz
 │    ├── scan abc
 │    └── filters
 │         └── z = a
 └── filters
      └── y = z
--------------------------------------------------------------------------------
----
----

# Ignore the apply join. However, all other joins can be reordered despite the
# presence of outer columns.
reorderjoins format=hide-all
SELECT * FROM bx
INNER JOIN LATERAL
(
  SELECT * FROM (VALUES (x))
  INNER JOIN cy ON True
  INNER JOIN dz ON y = z
  INNER JOIN abc ON z = a
)
ON x = y
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── scan cy
 ├── scan dz
 └── filters
      └── y = z

----Vertexes----
A:
scan cy

B:
scan dz

----Edges----
y = z [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── scan cy
 │    ├── scan dz
 │    └── filters
 │         └── y = z
 ├── scan abc
 └── filters
      └── z = a

----Vertexes----
A:
scan cy

B:
scan dz

C:
scan abc

----Edges----
y = z [inner]
z = a [inner]
y = a [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
B AC    refs [AB] [inner]
AC B    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]

Joins Considered: 12
--------------------------------------------------------------------------------
----Join Tree #3----
inner-join (cross)
 ├── values
 │    └── (x,)
 ├── inner-join (hash)
 │    ├── inner-join (hash)
 │    │    ├── scan cy
 │    │    ├── scan dz
 │    │    └── filters
 │    │         └── y = z
 │    ├── scan abc
 │    └── filters
 │         └── z = a
 └── filters (true)

----Vertexes----
D:
values
 └── (x,)

A:
scan cy

B:
scan dz

C:
scan abc

----Edges----
y = z [inner]
z = a [inner]
cross [inner]
y = a [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [AB] [inner]
BC A    refs [AB] [inner]
B AC    refs [AB] [inner]
AC B    refs [AB] [inner]
AB C    refs [BC] [inner]
C AB    refs [BC] [inner]
----Joining DABC----
D ABC    refs [] [inner]
ABC D    refs [] [inner]

Joins Considered: 14
--------------------------------------------------------------------------------
----Final Plan----
inner-join-apply
 ├── scan bx
 ├── inner-join (cross)
 │    ├── inner-join (hash)
 │    │    ├── scan cy
 │    │    ├── inner-join (hash)
 │    │    │    ├── scan dz
 │    │    │    ├── scan abc
 │    │    │    └── filters
 │    │    │         └── z = a
 │    │    └── filters
 │    │         └── y = z
 │    ├── values
 │    │    └── (x,)
 │    └── filters (true)
 └── filters
      └── x = y
--------------------------------------------------------------------------------
----
----

reorderjoins format=hide-all
SELECT * FROM
(
  SELECT b AS bx_b, c AS cy_c
  FROM bx
  INNER JOIN cy ON x = y
)
INNER JOIN
(
  SELECT b AS abc_b, c AS abc_c
  FROM abc
  INNER JOIN dz ON a = z
)
ON abc_b = bx_b AND abc_c = cy_c
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── x = y

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
x = y [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── scan abc
 ├── scan dz
 └── filters
      └── a = z

----Vertexes----
C:
scan abc

D:
scan dz

----Edges----
a = z [inner]

----Joining CD----
C D    refs [CD] [inner]
D C    refs [CD] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #3----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── x = y
 ├── inner-join (hash)
 │    ├── scan abc
 │    ├── scan dz
 │    └── filters
 │         └── a = z
 └── filters
      ├── abc.b = bx.b
      └── abc.c = cy.c

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan abc

D:
scan dz

----Edges----
x = y [inner]
a = z [inner]
abc.b = bx.b [inner]
abc.c = cy.c [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining BC----
B C    refs [BC] [inner]
C B    refs [BC] [inner]
----Joining ABC----
A BC    refs [ABC] [inner]
BC A    refs [ABC] [inner]
B AC    refs [ABC] [inner]
AC B    refs [ABC] [inner]
AB C    refs [ABC] [inner]
C AB    refs [ABC] [inner]
----Joining CD----
C D    refs [CD] [inner]
D C    refs [CD] [inner]
----Joining ACD----
A CD    refs [AC] [inner]
CD A    refs [AC] [inner]
AC D    refs [CD] [inner]
D AC    refs [CD] [inner]
----Joining BCD----
B CD    refs [BC] [inner]
CD B    refs [BC] [inner]
BC D    refs [CD] [inner]
D BC    refs [CD] [inner]
----Joining ABCD----
A BCD    refs [ABC] [inner]
BCD A    refs [ABC] [inner]
B ACD    refs [ABC] [inner]
ACD B    refs [ABC] [inner]
AB CD    refs [ABC] [inner]
CD AB    refs [ABC] [inner]
ABC D    refs [CD] [inner]
D ABC    refs [CD] [inner]

Joins Considered: 30
--------------------------------------------------------------------------------
----Final Plan----
project
 └── inner-join (hash)
      ├── scan dz
      ├── inner-join (hash)
      │    ├── scan bx
      │    ├── inner-join (hash)
      │    │    ├── scan cy
      │    │    ├── scan abc
      │    │    └── filters
      │    │         └── abc.c = cy.c
      │    └── filters
      │         ├── x = y
      │         └── abc.b = bx.b
      └── filters
           └── a = z
--------------------------------------------------------------------------------
----
----

reorderjoins format=hide-all
SELECT *
FROM bx
INNER JOIN cy ON b = c
LEFT JOIN dz ON x = z
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── b = c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
b = c [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
left-join (hash)
 ├── inner-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── b = c
 ├── scan dz
 └── filters
      └── x = z

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan dz

----Edges----
b = c [inner]
x = z [left]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining AC----
A C    refs [AC] [left]
----Joining ABC----
B AC    refs [AB] [inner]
AC B    refs [AB] [inner]
AB C    refs [AC] [left]

Joins Considered: 6
--------------------------------------------------------------------------------
----Final Plan----
left-join (hash)
 ├── inner-join (merge)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters
      └── x = z
--------------------------------------------------------------------------------
----
----

# Left-asscom property for left joins.
reorderjoins format=hide-all
SELECT *
FROM bx
LEFT JOIN cy ON b = c
LEFT JOIN dz ON x = z
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
left-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── b = c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
b = c [left]

----Joining AB----
A B    refs [AB] [left]

Joins Considered: 1
--------------------------------------------------------------------------------
----Join Tree #2----
left-join (hash)
 ├── left-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── b = c
 ├── scan dz
 └── filters
      └── x = z

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan dz

----Edges----
b = c [left]
x = z [left]

----Joining AB----
A B    refs [AB] [left]
----Joining AC----
A C    refs [AC] [left]
----Joining ABC----
AC B    refs [AB] [left]
AB C    refs [AC] [left]

Joins Considered: 4
--------------------------------------------------------------------------------
----Final Plan----
left-join (hash)
 ├── left-join (merge)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters
      └── x = z
--------------------------------------------------------------------------------
----
----

# Left-asscom property does not apply when the upper left join references the
# right side of the lower. However, associative property does apply when the
# predicate of the upper join rejects nulls on the right input of the lower
# join.
reorderjoins format=hide-all
SELECT *
FROM bx
LEFT JOIN cy ON b = c
LEFT JOIN dz ON y = z
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
left-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── b = c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
b = c [left]

----Joining AB----
A B    refs [AB] [left]

Joins Considered: 1
--------------------------------------------------------------------------------
----Join Tree #2----
left-join (hash)
 ├── left-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── b = c
 ├── scan dz
 └── filters
      └── y = z

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan dz

----Edges----
b = c [left]
y = z [left]

----Joining AB----
A B    refs [AB] [left]
----Joining BC----
B C    refs [BC] [left]
----Joining ABC----
A BC    refs [AB] [left]
AB C    refs [BC] [left]

Joins Considered: 4
--------------------------------------------------------------------------------
----Final Plan----
left-join (hash)
 ├── left-join (merge)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters
      └── y = z
--------------------------------------------------------------------------------
----
----

# Left, semi and anti join tree. Multiple applications of left-asscom are
# possible. Note that the inner join results from commuting the semi join.
reorderjoins format=hide-all
SELECT *
FROM bx
LEFT JOIN cy ON bx.b = cy.c
WHERE
EXISTS (SELECT * FROM dz WHERE bx.b = dz.d) AND
NOT EXISTS (SELECT * FROM abc WHERE bx.b = abc.a)
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
anti-join (hash)
 ├── scan bx
 ├── scan abc
 └── filters
      └── bx.b = a

----Vertexes----
A:
scan bx

B:
scan abc

----Edges----
bx.b = a [anti]

----Joining AB----
A B    refs [AB] [anti]

Joins Considered: 1
--------------------------------------------------------------------------------
----Join Tree #2----
semi-join (hash)
 ├── anti-join (hash)
 │    ├── scan bx
 │    ├── scan abc
 │    └── filters
 │         └── bx.b = a
 ├── scan dz
 └── filters
      └── bx.b = dz.d

----Vertexes----
A:
scan bx

B:
scan abc

C:
scan dz

----Edges----
bx.b = a [anti]
bx.b = dz.d [semi]

----Joining AB----
A B    refs [AB] [anti]
----Joining AC----
A C    refs [AC] [semi]
----Joining ABC----
AC B    refs [AB] [anti]
AB C    refs [AC] [semi]

Joins Considered: 4
--------------------------------------------------------------------------------
----Join Tree #3----
inner-join (hash)
 ├── anti-join (hash)
 │    ├── scan bx
 │    ├── scan abc
 │    └── filters
 │         └── bx.b = a
 ├── scan dz
 └── filters
      └── bx.b = dz.d

----Vertexes----
A:
scan bx

B:
scan abc

C:
scan dz

----Edges----
bx.b = a [anti]
bx.b = dz.d [inner]

----Joining AB----
A B    refs [AB] [anti]
----Joining AC----
A C    refs [AC] [inner]
C A    refs [AC] [inner]
----Joining ABC----
AC B    refs [AB] [anti]
AB C    refs [AC] [inner]
C AB    refs [AC] [inner]

Joins Considered: 6
--------------------------------------------------------------------------------
----Join Tree #4----
left-join (hash)
 ├── semi-join (hash)
 │    ├── anti-join (hash)
 │    │    ├── scan bx
 │    │    ├── scan abc
 │    │    └── filters
 │    │         └── bx.b = a
 │    ├── scan dz
 │    └── filters
 │         └── bx.b = dz.d
 ├── scan cy
 └── filters
      └── bx.b = cy.c

----Vertexes----
A:
scan bx

B:
scan abc

C:
scan dz

D:
scan cy

----Edges----
bx.b = a [anti]
bx.b = dz.d [semi]
bx.b = cy.c [left]

----Joining AB----
A B    refs [AB] [anti]
----Joining AC----
A C    refs [AC] [semi]
----Joining ABC----
AC B    refs [AB] [anti]
AB C    refs [AC] [semi]
----Joining AD----
A D    refs [AD] [left]
----Joining ABD----
AD B    refs [AB] [anti]
AB D    refs [AD] [left]
----Joining ACD----
AD C    refs [AC] [semi]
AC D    refs [AD] [left]
----Joining ABCD----
ACD B    refs [AB] [anti]
ABD C    refs [AC] [semi]
ABC D    refs [AD] [left]

Joins Considered: 12
--------------------------------------------------------------------------------
----Final Plan----
semi-join (lookup dz)
 ├── lookup columns are key
 ├── left-join (lookup cy)
 │    ├── lookup columns are key
 │    ├── anti-join (merge)
 │    │    ├── scan bx
 │    │    ├── scan abc
 │    │    └── filters (true)
 │    └── filters (true)
 └── filters (true)
--------------------------------------------------------------------------------
----
----

# Join tree with only cross joins.
reorderjoins format=hide-all
SELECT * FROM bx
INNER JOIN cy ON True
INNER JOIN dz ON True
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
inner-join (cross)
 ├── scan bx
 ├── scan cy
 └── filters (true)

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
cross [inner]

----Joining AB----
A B    refs [] [inner]
B A    refs [] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (cross)
 ├── inner-join (cross)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters (true)

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan dz

----Edges----
cross [inner]
cross [inner]

----Joining AB----
A B    refs [] [inner]
B A    refs [] [inner]
----Joining ABC----
AB C    refs [] [inner]
C AB    refs [] [inner]

Joins Considered: 4
--------------------------------------------------------------------------------
----Final Plan----
inner-join (cross)
 ├── inner-join (cross)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters (true)
--------------------------------------------------------------------------------
----
----

reorderjoins format=hide-all
SELECT *
FROM bx
FULL JOIN cy ON b = c
FULL JOIN dz ON y = z
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
full-join (hash)
 ├── scan bx
 ├── scan cy
 └── filters
      └── b = c

----Vertexes----
A:
scan bx

B:
scan cy

----Edges----
b = c [full]

----Joining AB----
A B    refs [AB] [full]
B A    refs [AB] [full]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #2----
full-join (hash)
 ├── full-join (hash)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters
 │         └── b = c
 ├── scan dz
 └── filters
      └── y = z

----Vertexes----
A:
scan bx

B:
scan cy

C:
scan dz

----Edges----
b = c [full]
y = z [full]

----Joining AB----
A B    refs [AB] [full]
B A    refs [AB] [full]
----Joining BC----
B C    refs [BC] [full]
C B    refs [BC] [full]
----Joining ABC----
A BC    refs [AB] [full]
BC A    refs [AB] [full]
AB C    refs [BC] [full]
C AB    refs [BC] [full]

Joins Considered: 8
--------------------------------------------------------------------------------
----Final Plan----
full-join (hash)
 ├── full-join (merge)
 │    ├── scan bx
 │    ├── scan cy
 │    └── filters (true)
 ├── scan dz
 └── filters
      └── y = z
--------------------------------------------------------------------------------
----
----

# Iteratively reorder subtrees of up to size 2.
reorderjoins join-limit=2 format=hide-all
SELECT * FROM abc AS a1
INNER JOIN abc AS a2 ON a1.a = a2.a
LEFT JOIN abc AS a3 ON a2.b = a3.b
INNER JOIN abc AS a4 ON a3.a = a4.a
WHERE EXISTS (SELECT * FROM abc AS a5 WHERE a2.c = a5.c)
----
----
--------------------------------------------------------------------------------
----Join Tree #1----
semi-join (hash)
 ├── scan abc [as=a2]
 ├── scan abc [as=a5]
 └── filters
      └── a2.c = a5.c

----Vertexes----
A:
scan abc [as=a2]

B:
scan abc [as=a5]

----Edges----
a2.c = a5.c [semi]

----Joining AB----
A B    refs [AB] [semi]

Joins Considered: 1
--------------------------------------------------------------------------------
----Join Tree #2----
inner-join (hash)
 ├── scan abc [as=a2]
 ├── distinct-on
 │    └── scan abc [as=a5]
 └── filters
      └── a2.c = a5.c

----Vertexes----
A:
scan abc [as=a2]

B:
distinct-on
 └── scan abc [as=a5]

----Edges----
a2.c = a5.c [inner]

----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]

Joins Considered: 2
--------------------------------------------------------------------------------
----Join Tree #3----
inner-join (hash)
 ├── scan abc [as=a1]
 ├── semi-join (hash)
 │    ├── scan abc [as=a2]
 │    ├── scan abc [as=a5]
 │    └── filters
 │         └── a2.c = a5.c
 └── filters
      └── a1.a = a2.a

----Vertexes----
C:
scan abc [as=a1]

A:
scan abc [as=a2]

B:
scan abc [as=a5]

----Edges----
a2.c = a5.c [semi]
a1.a = a2.a [inner]

----Joining CA----
C A    refs [CA] [inner]
A C    refs [CA] [inner]
----Joining AB----
A B    refs [AB] [semi]
----Joining CAB----
C AB    refs [CA] [inner]
AB C    refs [CA] [inner]
CA B    refs [AB] [semi]

Joins Considered: 6
--------------------------------------------------------------------------------
----Join Tree #4----
inner-join (hash)
 ├── scan abc [as=a1]
 ├── inner-join (hash)
 │    ├── scan abc [as=a2]
 │    ├── distinct-on
 │    │    └── scan abc [as=a5]
 │    └── filters
 │         └── a2.c = a5.c
 └── filters
      └── a1.a = a2.a

----Vertexes----
C:
scan abc [as=a1]

A:
scan abc [as=a2]

B:
distinct-on
 └── scan abc [as=a5]

----Edges----
a2.c = a5.c [inner]
a1.a = a2.a [inner]

----Joining CA----
C A    refs [CA] [inner]
A C    refs [CA] [inner]
----Joining AB----
A B    refs [AB] [inner]
B A    refs [AB] [inner]
----Joining CAB----
C AB    refs [CA] [inner]
AB C    refs [CA] [inner]
CA B    refs [AB] [inner]
B CA    refs [AB] [inner]

Joins Considered: 8
--------------------------------------------------------------------------------
----Join Tree #5----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── scan abc [as=a1]
 │    ├── semi-join (hash)
 │    │    ├── scan abc [as=a2]
 │    │    ├── scan abc [as=a5]
 │    │    └── filters
 │    │         └── a2.c = a5.c
 │    └── filters
 │         └── a1.a = a2.a
 ├── scan abc [as=a3]
 └── filters
      └── a2.b = a3.b

----Vertexes----
C:
scan abc [as=a1]

A:
semi-join (hash)
 ├── scan abc [as=a2]
 ├── scan abc [as=a5]
 └── filters
      └── a2.c = a5.c

D:
scan abc [as=a3]

----Edges----
a1.a = a2.a [inner]
a2.b = a3.b [inner]

----Joining CA----
C A    refs [CA] [inner]
A C    refs [CA] [inner]
----Joining AD----
A D    refs [AD] [inner]
D A    refs [AD] [inner]
----Joining CAD----
C AD    refs [CA] [inner]
AD C    refs [CA] [inner]
CA D    refs [AD] [inner]
D CA    refs [AD] [inner]

Joins Considered: 8
--------------------------------------------------------------------------------
----Join Tree #6----
inner-join (hash)
 ├── inner-join (hash)
 │    ├── inner-join (hash)
 │    │    ├── scan abc [as=a1]
 │    │    ├── semi-join (hash)
 │    │    │    ├── scan abc [as=a2]
 │    │    │    ├── scan abc [as=a5]
 │    │    │    └── filters
 │    │    │         └── a2.c = a5.c
 │    │    └── filters
 │    │         └── a1.a = a2.a
 │    ├── scan abc [as=a3]
 │    └── filters
 │         └── a2.b = a3.b
 ├── scan abc [as=a4]
 └── filters
      └── a3.a = a4.a

----Vertexes----
C:
inner-join (hash)
 ├── scan abc [as=a1]
 ├── semi-join (hash)
 │    ├── scan abc [as=a2]
 │    ├── scan abc [as=a5]
 │    └── filters
 │         └── a2.c = a5.c
 └── filters
      └── a1.a = a2.a

D:
scan abc [as=a3]

E:
scan abc [as=a4]

----Edges----
a2.b = a3.b [inner]
a3.a = a4.a [inner]

----Joining CD----
C D    refs [CD] [inner]
D C    refs [CD] [inner]
----Joining DE----
D E    refs [DE] [inner]
E D    refs [DE] [inner]
----Joining CDE----
C DE    refs [CD] [inner]
DE C    refs [CD] [inner]
CD E    refs [DE] [inner]
E CD    refs [DE] [inner]

Joins Considered: 8
--------------------------------------------------------------------------------
----Final Plan----
inner-join (hash)
 ├── project
 │    └── inner-join (hash)
 │         ├── inner-join (merge)
 │         │    ├── scan abc [as=a1]
 │         │    ├── scan abc [as=a2]
 │         │    └── filters (true)
 │         ├── distinct-on
 │         │    └── scan abc [as=a5]
 │         └── filters
 │              └── a2.c = a5.c
 ├── inner-join (merge)
 │    ├── scan abc [as=a3]
 │    ├── scan abc [as=a4]
 │    └── filters (true)
 └── filters
      └── a2.b = a3.b
--------------------------------------------------------------------------------
----
----

# Regression test for #59076. Do not reorder on the inner join produced by
# CommuteSemiJoin when it matches on an already-reordered semi join because
# doing so can lead to an exponential blowup in the size of the memo.
check-size rule-limit=200 group-limit=100
SELECT * FROM cy
WHERE EXISTS (SELECT 1 FROM dz WHERE z = y)
AND EXISTS (SELECT 1 FROM bx WHERE x = y)
AND EXISTS (SELECT 1 FROM abc WHERE a = y)
----
Rules Applied: 169
Groups Added: 86
