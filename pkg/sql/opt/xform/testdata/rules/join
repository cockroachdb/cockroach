exec-ddl
CREATE TABLE abc
(
    a INT,
    b INT,
    c INT,
    INDEX ab (a,b) STORING (c),
    INDEX bc (b,c) STORING (a)
)
----
TABLE abc
 ├── a int
 ├── b int
 ├── c int
 ├── rowid int not null (hidden)
 ├── INDEX primary
 │    └── rowid int not null (hidden)
 ├── INDEX ab
 │    ├── a int
 │    ├── b int
 │    ├── rowid int not null (hidden)
 │    └── c int (storing)
 └── INDEX bc
      ├── b int
      ├── c int
      ├── rowid int not null (hidden)
      └── a int (storing)

exec-ddl
CREATE TABLE xyz
(
    x INT,
    y INT,
    z INT,
    INDEX xy (x,y) STORING (z),
    INDEX yz (y,z) STORING (x)
)
----
TABLE xyz
 ├── x int
 ├── y int
 ├── z int
 ├── rowid int not null (hidden)
 ├── INDEX primary
 │    └── rowid int not null (hidden)
 ├── INDEX xy
 │    ├── x int
 │    ├── y int
 │    ├── rowid int not null (hidden)
 │    └── z int (storing)
 └── INDEX yz
      ├── y int
      ├── z int
      ├── rowid int not null (hidden)
      └── x int (storing)


# --------------------------------------------------
# CreateMergeJoins
# --------------------------------------------------

opt format=show-all
SELECT * FROM abc JOIN xyz ON a=x
----
merge-join
 ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
 ├── stats: [rows=100000]
 ├── cost: 3160
 ├── prune: (2,3,6,7)
 ├── scan abc@ab
 │    ├── columns: abc.a:1(int) abc.b:2(int) abc.c:3(int)
 │    ├── stats: [rows=1000]
 │    ├── cost: 1070
 │    ├── ordering: +1
 │    ├── prune: (1-3)
 │    └── interesting orderings: (+1,+2) (+2,+3)
 ├── scan xyz@xy
 │    ├── columns: xyz.x:5(int) xyz.y:6(int) xyz.z:7(int)
 │    ├── stats: [rows=1000]
 │    ├── cost: 1070
 │    ├── ordering: +5
 │    ├── prune: (5-7)
 │    └── interesting orderings: (+5,+6) (+6,+7)
 └── merge-on
      ├── type: inner-join
      ├── left ordering: +1
      ├── right ordering: +5
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── eq [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
                ├── variable: abc.a [type=int, outer=(1)]
                └── variable: xyz.x [type=int, outer=(5)]

memo
SELECT * FROM abc JOIN xyz ON a=x
----
memo (optimized)
 ├── G1: (inner-join G2 G3 G5) (merge-join G2 G3 G4)
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (merge-join G2="[ordering: +1]" G3="[ordering: +5]" G4)
 │         └── cost: 3160.00
 ├── G2: (scan abc,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@bc,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G3: (scan xyz,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@yz,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +5]"
 │         ├── best: (scan xyz@xy,cols=(5-7))
 │         └── cost: 1070.00
 ├── G4: (merge-on G5 inner-join,+1,+5)
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable abc.a)
 └── G8: (variable xyz.x)

# Use constraints to force the choice of an index which doesn't help, and
# verify that we don't prefer a merge-join that has to sort both of its inputs.
opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y WHERE b=1 AND y=1
----
inner-join
 ├── columns: a:1(int) b:2(int!null) c:3(int) x:5(int) y:6(int!null) z:7(int)
 ├── scan abc@bc
 │    ├── columns: a:1(int) b:2(int!null) c:3(int)
 │    └── constraint: /2/3/4: [/1 - /1]
 ├── scan xyz@yz
 │    ├── columns: x:5(int) y:6(int!null) z:7(int)
 │    └── constraint: /6/7/8: [/1 - /1]
 └── filters [type=bool, outer=(1,2,5,6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ])]
      ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
      └── abc.b = xyz.y [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
