exec-ddl
CREATE TABLE abc
(
    a INT,
    b INT,
    c INT,
    INDEX ab (a,b) STORING (c),
    INDEX bc (b,c) STORING (a)
)
----
TABLE abc
 ├── a int
 ├── b int
 ├── c int
 ├── rowid int not null (hidden)
 ├── INDEX primary
 │    └── rowid int not null (hidden)
 ├── INDEX ab
 │    ├── a int
 │    ├── b int
 │    ├── rowid int not null (hidden)
 │    └── c int (storing)
 └── INDEX bc
      ├── b int
      ├── c int
      ├── rowid int not null (hidden)
      └── a int (storing)

exec-ddl
CREATE TABLE stu
(
    s INT,
    t INT,
    u INT,
    PRIMARY KEY (s,t,u),
    INDEX uts (u,t,s)
)
----
TABLE stu
 ├── s int not null
 ├── t int not null
 ├── u int not null
 ├── INDEX primary
 │    ├── s int not null
 │    ├── t int not null
 │    └── u int not null
 └── INDEX uts
      ├── u int not null
      ├── t int not null
      └── s int not null

exec-ddl
CREATE TABLE xyz
(
    x INT,
    y INT,
    z INT,
    INDEX xy (x,y) STORING (z),
    INDEX yz (y,z) STORING (x)
)
----
TABLE xyz
 ├── x int
 ├── y int
 ├── z int
 ├── rowid int not null (hidden)
 ├── INDEX primary
 │    └── rowid int not null (hidden)
 ├── INDEX xy
 │    ├── x int
 │    ├── y int
 │    ├── rowid int not null (hidden)
 │    └── z int (storing)
 └── INDEX yz
      ├── y int
      ├── z int
      ├── rowid int not null (hidden)
      └── x int (storing)

# --------------------------------------------------
# CommuteJoin
# --------------------------------------------------

# Verify that the reversed join expressions get added to the memo, and there
# are no duplicates.
memo
SELECT * FROM abc JOIN xyz ON a=z
----
memo (optimized)
 ├── G1: (inner-join G2 G4 G5) (inner-join G4 G2 G5) (merge-join G2 G4 G3) (lookup-join G4 G5 abc@ab,keyCols=[7],lookupCols=(1-3))
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (inner-join G2 G4 G5)
 │         └── cost: 3170.00
 ├── G2: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G3: (merge-on G5 inner-join,+1,+7)
 ├── G4: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +7]"
 │         ├── best: (sort G4)
 │         └── cost: 1279.32
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable abc.a)
 └── G8: (variable xyz.z)

memo
SELECT * FROM abc FULL OUTER JOIN xyz ON a=z
----
memo (optimized)
 ├── G1: (full-join G2 G3 G5) (full-join G3 G2 G5) (merge-join G2 G3 G4)
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (full-join G2 G3 G5)
 │         └── cost: 3170.00
 ├── G2: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G3: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +7]"
 │         ├── best: (sort G3)
 │         └── cost: 1279.32
 ├── G4: (merge-on G5 full-join,+1,+7)
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable abc.a)
 └── G8: (variable xyz.z)

# Verify that we swap to get the smaller side on the right.
opt
SELECT * FROM abc INNER JOIN xyz ON a=c WHERE b=1
----
inner-join
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:5(int) y:6(int) z:7(int)
 ├── fd: ()-->(2), (1)==(3), (3)==(1)
 ├── scan xyz
 │    └── columns: x:5(int) y:6(int) z:7(int)
 ├── select
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── fd: ()-->(2), (1)==(3), (3)==(1)
 │    ├── scan abc@bc
 │    │    ├── columns: a:1(int) b:2(int!null) c:3(int!null)
 │    │    ├── constraint: /2/3/4: (/1/NULL - /1]
 │    │    └── fd: ()-->(2)
 │    └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 │         └── abc.a = abc.c [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
 └── true [type=bool]

opt
SELECT * FROM (SELECT * FROM abc WHERE b=1) FULL OUTER JOIN xyz ON a=z
----
full-join
 ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
 ├── fd: ()~~>(2)
 ├── scan xyz
 │    └── columns: x:5(int) y:6(int) z:7(int)
 ├── scan abc@bc
 │    ├── columns: a:1(int) b:2(int!null) c:3(int)
 │    ├── constraint: /2/3/4: [/1 - /1]
 │    └── fd: ()-->(2)
 └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

# --------------------------------------------------
# CommuteLeftJoin
# --------------------------------------------------

memo
SELECT * FROM abc LEFT OUTER JOIN xyz ON a=z
----
memo (optimized)
 ├── G1: (left-join G2 G3 G5) (right-join G3 G2 G5) (merge-join G2 G3 G4)
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (left-join G2 G3 G5)
 │         └── cost: 3170.00
 ├── G2: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G3: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +7]"
 │         ├── best: (sort G3)
 │         └── cost: 1279.32
 ├── G4: (merge-on G5 left-join,+1,+7)
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable abc.a)
 └── G8: (variable xyz.z)

opt
SELECT * FROM abc LEFT OUTER JOIN xyz ON a=z WHERE b=1
----
right-join
 ├── columns: a:1(int) b:2(int!null) c:3(int) x:5(int) y:6(int) z:7(int)
 ├── fd: ()-->(2)
 ├── scan xyz
 │    └── columns: x:5(int) y:6(int) z:7(int)
 ├── scan abc@bc
 │    ├── columns: a:1(int) b:2(int!null) c:3(int)
 │    ├── constraint: /2/3/4: [/1 - /1]
 │    └── fd: ()-->(2)
 └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

# --------------------------------------------------
# CommuteRightJoin
# --------------------------------------------------

memo
SELECT * FROM abc RIGHT OUTER JOIN xyz ON a=z
----
memo (optimized)
 ├── G1: (right-join G2 G4 G5) (left-join G4 G2 G5) (merge-join G2 G4 G3) (lookup-join G4 G5 abc@ab,keyCols=[7],lookupCols=(1-3))
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (right-join G2 G4 G5)
 │         └── cost: 3170.00
 ├── G2: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G3: (merge-on G5 right-join,+1,+7)
 ├── G4: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +7]"
 │         ├── best: (sort G4)
 │         └── cost: 1279.32
 ├── G5: (filters G6)
 ├── G6: (eq G7 G8)
 ├── G7: (variable abc.a)
 └── G8: (variable xyz.z)

opt
SELECT * FROM (SELECT * FROM abc WHERE b=1) RIGHT OUTER JOIN xyz ON a=z
----
left-join
 ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
 ├── fd: ()~~>(2)
 ├── scan xyz
 │    └── columns: x:5(int) y:6(int) z:7(int)
 ├── scan abc@bc
 │    ├── columns: a:1(int) b:2(int!null) c:3(int)
 │    ├── constraint: /2/3/4: [/1 - /1]
 │    └── fd: ()-->(2)
 └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

# --------------------------------------------------
# GenerateMergeJoins
# --------------------------------------------------

opt
SELECT * FROM abc JOIN xyz ON a=x
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int) z:7(int)
 ├── fd: (1)==(5), (5)==(1)
 ├── scan abc@ab
 │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    └── ordering: +1
 ├── scan xyz@xy
 │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    └── ordering: +5
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +5
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           └── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

memo
SELECT * FROM abc JOIN xyz ON a=x
----
memo (optimized)
 ├── G1: (inner-join G3 G5 G6) (inner-join G5 G3 G6) (merge-join G3 G5 G2) (lookup-join G3 G6 xyz@xy,keyCols=[1],lookupCols=(5-7)) (merge-join G5 G3 G4) (lookup-join G5 G6 abc@ab,keyCols=[5],lookupCols=(1-3))
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (merge-join G3="[ordering: +1]" G5="[ordering: +5]" G2)
 │         └── cost: 3160.00
 ├── G2: (merge-on G6 inner-join,+1,+5)
 ├── G3: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc,cols=(1-3))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc@ab,cols=(1-3))
 │         └── cost: 1070.00
 ├── G4: (merge-on G6 inner-join,+5,+1)
 ├── G5: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    ├── ""
 │    │    ├── best: (scan xyz,cols=(5-7))
 │    │    └── cost: 1070.00
 │    └── "[ordering: +5]"
 │         ├── best: (scan xyz@xy,cols=(5-7))
 │         └── cost: 1070.00
 ├── G6: (filters G7)
 ├── G7: (eq G8 G9)
 ├── G8: (variable abc.a)
 └── G9: (variable xyz.x)

opt
SELECT * FROM abc JOIN xyz ON x=a
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int) z:7(int)
 ├── fd: (1)==(5), (5)==(1)
 ├── scan abc@ab
 │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    └── ordering: +1
 ├── scan xyz@xy
 │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    └── ordering: +5
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +5
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           └── xyz.x = abc.a [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

opt
SELECT * FROM abc JOIN xyz ON a=x AND a=x AND x=a
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int) z:7(int)
 ├── fd: (1)==(5), (5)==(1)
 ├── scan abc@ab
 │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    └── ordering: +1
 ├── scan xyz@xy
 │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    └── ordering: +5
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +5
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
           ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── xyz.x = abc.a [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

# Use constraints to force the choice of an index which doesn't help, and
# verify that we don't prefer a merge-join that has to sort both of its inputs.
opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y WHERE b=1 AND y=1
----
inner-join
 ├── columns: a:1(int!null) b:2(int!null) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
 ├── fd: ()-->(2,6), (1)==(5), (5)==(1), (2)==(6), (6)==(2)
 ├── scan abc@bc
 │    ├── columns: a:1(int) b:2(int!null) c:3(int)
 │    ├── constraint: /2/3/4: [/1 - /1]
 │    └── fd: ()-->(2)
 ├── scan xyz@yz
 │    ├── columns: x:5(int) y:6(int!null) z:7(int)
 │    ├── constraint: /6/7/8: [/1 - /1]
 │    └── fd: ()-->(6)
 └── filters [type=bool, outer=(1,2,5,6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5), (5)==(1), (2)==(6), (6)==(2)]
      ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
      └── abc.b = xyz.y [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]

# Verify case where we generate multiple merge-joins.
memo
SELECT * FROM stu AS l JOIN stu AS r ON (l.s, l.t, l.u) = (r.s, r.t, r.u)
----
memo (optimized)
 ├── G1: (inner-join G5 G7 G8) (inner-join G7 G5 G8) (merge-join G5 G7 G2) (merge-join G5 G7 G3) (lookup-join G5 G8 stu,keyCols=[1 2 3],lookupCols=(4-6)) (lookup-join G5 G8 stu@uts,keyCols=[3 2 1],lookupCols=(4-6)) (merge-join G7 G5 G4) (merge-join G7 G5 G6) (lookup-join G7 G8 stu,keyCols=[4 5 6],lookupCols=(1-3)) (lookup-join G7 G8 stu@uts,keyCols=[6 5 4],lookupCols=(1-3))
 │    └── "[presentation: s:1,t:2,u:3,s:4,t:5,u:6]"
 │         ├── best: (merge-join G5="[ordering: +1,+2,+3]" G7="[ordering: +4,+5,+6]" G2)
 │         └── cost: 3140.00
 ├── G2: (merge-on G8 inner-join,+1,+2,+3,+4,+5,+6)
 ├── G3: (merge-on G8 inner-join,+3,+2,+1,+6,+5,+4)
 ├── G4: (merge-on G8 inner-join,+4,+5,+6,+1,+2,+3)
 ├── G5: (scan stu) (scan stu,rev) (scan stu@uts) (scan stu@uts,rev)
 │    ├── ""
 │    │    ├── best: (scan stu)
 │    │    └── cost: 1060.00
 │    ├── "[ordering: +1,+2,+3]"
 │    │    ├── best: (scan stu)
 │    │    └── cost: 1060.00
 │    └── "[ordering: +3,+2,+1]"
 │         ├── best: (scan stu@uts)
 │         └── cost: 1060.00
 ├── G6: (merge-on G8 inner-join,+6,+5,+4,+3,+2,+1)
 ├── G7: (scan stu) (scan stu,rev) (scan stu@uts) (scan stu@uts,rev)
 │    ├── ""
 │    │    ├── best: (scan stu)
 │    │    └── cost: 1060.00
 │    ├── "[ordering: +4,+5,+6]"
 │    │    ├── best: (scan stu)
 │    │    └── cost: 1060.00
 │    └── "[ordering: +6,+5,+4]"
 │         ├── best: (scan stu@uts)
 │         └── cost: 1060.00
 ├── G8: (filters G9 G10 G11)
 ├── G9: (eq G12 G13)
 ├── G10: (eq G14 G15)
 ├── G11: (eq G16 G17)
 ├── G12: (variable stu.s)
 ├── G13: (variable stu.s)
 ├── G14: (variable stu.t)
 ├── G15: (variable stu.t)
 ├── G16: (variable stu.u)
 └── G17: (variable stu.u)

exploretrace rule=GenerateMergeJoins
SELECT * FROM stu AS l JOIN stu AS r ON (l.s, l.t, l.u) = (r.s, r.t, r.u)
----
----
================================================================================
GenerateMergeJoins
================================================================================
Source expression:
  inner-join
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    └── key: (1-3)
   ├── scan stu
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    └── key: (4-6)
   └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
        ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
        ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
        └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 2:
  inner-join (merge)
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    ├── key: (1-3)
   │    └── ordering: +1,+2,+3
   ├── scan stu
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    ├── key: (4-6)
   │    └── ordering: +4,+5,+6
   └── merge-on
        ├── left ordering: +1,+2,+3
        ├── right ordering: +4,+5,+6
        └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
             ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
             └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]

New expression 2 of 2:
  inner-join (merge)
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu@uts
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    ├── key: (1-3)
   │    └── ordering: +3,+2,+1
   ├── scan stu@uts
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    ├── key: (4-6)
   │    └── ordering: +6,+5,+4
   └── merge-on
        ├── left ordering: +3,+2,+1
        ├── right ordering: +6,+5,+4
        └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
             ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
             └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]

================================================================================
GenerateMergeJoins
================================================================================
Source expression:
  inner-join
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    └── key: (4-6)
   ├── scan stu
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    └── key: (1-3)
   └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
        ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
        ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
        └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 2:
  inner-join (merge)
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    ├── key: (4-6)
   │    └── ordering: +4,+5,+6
   ├── scan stu
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    ├── key: (1-3)
   │    └── ordering: +1,+2,+3
   └── merge-on
        ├── left ordering: +4,+5,+6
        ├── right ordering: +1,+2,+3
        └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
             ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
             └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]

New expression 2 of 2:
  inner-join (merge)
   ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) s:4(int!null) t:5(int!null) u:6(int!null)
   ├── key: (4-6)
   ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)
   ├── scan stu@uts
   │    ├── columns: stu.s:4(int!null) stu.t:5(int!null) stu.u:6(int!null)
   │    ├── key: (4-6)
   │    └── ordering: +6,+5,+4
   ├── scan stu@uts
   │    ├── columns: stu.s:1(int!null) stu.t:2(int!null) stu.u:3(int!null)
   │    ├── key: (1-3)
   │    └── ordering: +3,+2,+1
   └── merge-on
        ├── left ordering: +6,+5,+4
        ├── right ordering: +3,+2,+1
        └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(4), (4)==(1), (2)==(5), (5)==(2), (3)==(6), (6)==(3)]
             ├── stu.s = stu.s [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── stu.t = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
             └── stu.u = stu.u [type=bool, outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ])]
----
----

# Add statistics to make table stu large (so that sorting abc is relatively cheap).
exec-ddl
ALTER TABLE stu INJECT STATISTICS '[
  {
    "columns": ["s"],
    "created_at": "2018-05-01 1:00:00.00000+00:00",
    "row_count": 1000000,
    "distinct_count": 1000000
  }
]'
----

# The ordering is coming from the left side.
opt
SELECT * FROM stu, abc WHERE (c,b,a) = (s,t,u)
----
inner-join (merge)
 ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) a:4(int!null) b:5(int!null) c:6(int!null)
 ├── fd: (1)==(6), (6)==(1), (2)==(5), (5)==(2), (3)==(4), (4)==(3)
 ├── scan stu
 │    ├── columns: s:1(int!null) t:2(int!null) u:3(int!null)
 │    ├── key: (1-3)
 │    └── ordering: +1,+2,+3
 ├── sort
 │    ├── columns: a:4(int) b:5(int) c:6(int)
 │    ├── ordering: +6,+5,+4
 │    └── scan abc
 │         └── columns: a:4(int) b:5(int) c:6(int)
 └── merge-on
      ├── left ordering: +1,+2,+3
      ├── right ordering: +6,+5,+4
      └── filters [type=bool, outer=(1-6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1), (2)==(5), (5)==(2), (3)==(4), (4)==(3)]
           ├── abc.c = stu.s [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
           ├── abc.b = stu.t [type=bool, outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
           └── abc.a = stu.u [type=bool, outer=(3,4), constraints=(/3: (/NULL - ]; /4: (/NULL - ])]

# The ordering is coming from the right side.
opt
SELECT * FROM abc, stu WHERE (c,b,a) = (s,t,u)
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) s:5(int!null) t:6(int!null) u:7(int!null)
 ├── fd: (3)==(5), (5)==(3), (2)==(6), (6)==(2), (1)==(7), (7)==(1)
 ├── scan stu
 │    ├── columns: s:5(int!null) t:6(int!null) u:7(int!null)
 │    ├── key: (5-7)
 │    └── ordering: +5,+6,+7
 ├── sort
 │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    ├── ordering: +3,+2,+1
 │    └── scan abc
 │         └── columns: a:1(int) b:2(int) c:3(int)
 └── merge-on
      ├── left ordering: +5,+6,+7
      ├── right ordering: +3,+2,+1
      └── filters [type=bool, outer=(1-3,5-7), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(5), (5)==(3), (2)==(6), (6)==(2), (1)==(7), (7)==(1)]
           ├── abc.c = stu.s [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ])]
           ├── abc.b = stu.t [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
           └── abc.a = stu.u [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

# In these cases, we shouldn't pick up equivalencies.
memo
SELECT * FROM abc JOIN xyz ON a=b
----
memo (optimized)
 ├── G1: (inner-join G3 G2 G4) (inner-join G2 G3 G4)
 │    └── "[presentation: a:1,b:2,c:3,x:5,y:6,z:7]"
 │         ├── best: (inner-join G2 G3 G4)
 │         └── cost: 1456.81
 ├── G2: (scan xyz,cols=(5-7)) (scan xyz,rev,cols=(5-7)) (scan xyz@xy,cols=(5-7)) (scan xyz@xy,rev,cols=(5-7)) (scan xyz@yz,cols=(5-7)) (scan xyz@yz,rev,cols=(5-7))
 │    └── ""
 │         ├── best: (scan xyz,cols=(5-7))
 │         └── cost: 1070.00
 ├── G3: (select G5 G10) (select G6 G10) (select G7 G10) (select G8 G10) (select G9 G10)
 │    └── ""
 │         ├── best: (select G6 G10)
 │         └── cost: 360.00
 ├── G4: (true)
 ├── G5: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    └── ""
 │         ├── best: (scan abc,cols=(1-3))
 │         └── cost: 1070.00
 ├── G6: (scan abc@ab,cols=(1-3),constrained)
 │    └── ""
 │         ├── best: (scan abc@ab,cols=(1-3),constrained)
 │         └── cost: 356.67
 ├── G7: (scan abc@ab,rev,cols=(1-3),constrained)
 │    └── ""
 │         ├── best: (scan abc@ab,rev,cols=(1-3),constrained)
 │         └── cost: 384.60
 ├── G8: (scan abc@bc,cols=(1-3),constrained)
 │    └── ""
 │         ├── best: (scan abc@bc,cols=(1-3),constrained)
 │         └── cost: 356.67
 ├── G9: (scan abc@bc,rev,cols=(1-3),constrained)
 │    └── ""
 │         ├── best: (scan abc@bc,rev,cols=(1-3),constrained)
 │         └── cost: 384.60
 ├── G10: (filters G11)
 ├── G11: (eq G12 G13)
 ├── G12: (variable abc.a)
 └── G13: (variable abc.b)

exec-ddl
CREATE TABLE kfloat (k FLOAT PRIMARY KEY)
----
TABLE kfloat
 ├── k float not null
 └── INDEX primary
      └── k float not null

memo
SELECT * FROM abc JOIN kfloat ON a=k
----
memo (optimized)
 ├── G1: (inner-join G3 G2 G4) (inner-join G2 G3 G4)
 │    └── "[presentation: a:1,b:2,c:3,k:5]"
 │         ├── best: (inner-join G3 G2 G4)
 │         └── cost: 3120.00
 ├── G2: (scan kfloat) (scan kfloat,rev)
 │    └── ""
 │         ├── best: (scan kfloat)
 │         └── cost: 1020.00
 ├── G3: (scan abc,cols=(1-3)) (scan abc,rev,cols=(1-3)) (scan abc@ab,cols=(1-3)) (scan abc@ab,rev,cols=(1-3)) (scan abc@bc,cols=(1-3)) (scan abc@bc,rev,cols=(1-3))
 │    └── ""
 │         ├── best: (scan abc,cols=(1-3))
 │         └── cost: 1070.00
 ├── G4: (filters G5)
 ├── G5: (eq G6 G7)
 ├── G6: (variable abc.a)
 └── G7: (variable kfloat.k)

# We should only pick up one equivalency.
opt
SELECT * FROM abc JOIN xyz ON a=x AND a=y
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
 ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
 ├── scan abc@ab
 │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    └── ordering: +1
 ├── scan xyz@xy
 │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    └── ordering: +5
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +5
      └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
           ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Verify that the required orderings are simplified: the equality columns are
# (u,t)=(x,z) but we are able to utilize indexes on s,t,u and y,z.
opt
SELECT * FROM (SELECT * FROM stu WHERE s = u) JOIN (SELECT * FROM xyz WHERE x = y) ON u=x AND t=z
----
inner-join (lookup stu@uts)
 ├── columns: s:1(int!null) t:2(int!null) u:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── key columns: [4 6] = [3 2]
 ├── fd: (1)==(3-5), (3)==(1,4,5), (4)==(1,3,5), (5)==(1,3,4), (2)==(6), (6)==(2)
 ├── select
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int)
 │    ├── fd: (4)==(5), (5)==(4)
 │    ├── scan xyz@xy
 │    │    ├── columns: x:4(int!null) y:5(int) z:6(int)
 │    │    └── constraint: /4/5/7: (/NULL - ]
 │    └── filters [type=bool, outer=(4,5), constraints=(/4: (/NULL - ]; /5: (/NULL - ]), fd=(4)==(5), (5)==(4)]
 │         └── xyz.x = xyz.y [type=bool, outer=(4,5), constraints=(/4: (/NULL - ]; /5: (/NULL - ])]
 └── filters [type=bool, outer=(1-4,6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(1,4), (4)==(1,3), (2)==(6), (6)==(2), (1)==(3,4)]
      ├── stu.u = xyz.x [type=bool, outer=(3,4), constraints=(/3: (/NULL - ]; /4: (/NULL - ])]
      ├── stu.t = xyz.z [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
      └── stu.s = stu.u [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]

# Verify multiple merge-joins can be chained.
opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y JOIN stu ON a=s
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int) x:5(int!null) y:6(int!null) z:7(int) s:9(int!null) t:10(int!null) u:11(int!null)
 ├── fd: (1)==(5,9), (5)==(1,9), (2)==(6), (6)==(2), (9)==(1,5)
 ├── inner-join (merge)
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
 │    ├── fd: (1)==(5), (5)==(1), (2)==(6), (6)==(2)
 │    ├── ordering: +(1|5)
 │    ├── scan abc@ab
 │    │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    │    └── ordering: +1,+2
 │    ├── scan xyz@xy
 │    │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    │    └── ordering: +5,+6
 │    └── merge-on
 │         ├── left ordering: +1,+2
 │         ├── right ordering: +5,+6
 │         └── filters [type=bool, outer=(1,2,5,6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5), (5)==(1), (2)==(6), (6)==(2)]
 │              ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
 │              └── abc.b = xyz.y [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
 ├── scan stu
 │    ├── columns: s:9(int!null) t:10(int!null) u:11(int!null)
 │    ├── key: (9-11)
 │    └── ordering: +9
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +9
      └── filters [type=bool, outer=(1,9), constraints=(/1: (/NULL - ]; /9: (/NULL - ]), fd=(1)==(9), (9)==(1)]
           └── abc.a = stu.s [type=bool, outer=(1,9), constraints=(/1: (/NULL - ]; /9: (/NULL - ])]

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y JOIN stu ON a=u AND y=t
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int) x:5(int!null) y:6(int!null) z:7(int) s:9(int!null) t:10(int!null) u:11(int!null)
 ├── fd: (1)==(5,11), (5)==(1,11), (2)==(6,10), (6)==(2,10), (11)==(1,5), (10)==(2,6)
 ├── scan stu@uts
 │    ├── columns: s:9(int!null) t:10(int!null) u:11(int!null)
 │    ├── key: (9-11)
 │    └── ordering: +11,+10
 ├── inner-join (merge)
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
 │    ├── fd: (1)==(5), (5)==(1), (2)==(6), (6)==(2)
 │    ├── ordering: +(1|5),+(2|6)
 │    ├── scan abc@ab
 │    │    ├── columns: a:1(int) b:2(int) c:3(int)
 │    │    └── ordering: +1,+2
 │    ├── scan xyz@xy
 │    │    ├── columns: x:5(int) y:6(int) z:7(int)
 │    │    └── ordering: +5,+6
 │    └── merge-on
 │         ├── left ordering: +1,+2
 │         ├── right ordering: +5,+6
 │         └── filters [type=bool, outer=(1,2,5,6), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5), (5)==(1), (2)==(6), (6)==(2)]
 │              ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
 │              └── abc.b = xyz.y [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
 └── merge-on
      ├── left ordering: +11,+10
      ├── right ordering: +1,+6
      └── filters [type=bool, outer=(1,6,10,11), constraints=(/1: (/NULL - ]; /6: (/NULL - ]; /10: (/NULL - ]; /11: (/NULL - ]), fd=(1)==(11), (11)==(1), (6)==(10), (10)==(6)]
           ├── abc.a = stu.u [type=bool, outer=(1,11), constraints=(/1: (/NULL - ]; /11: (/NULL - ])]
           └── xyz.y = stu.t [type=bool, outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ])]

# --------------------------------------------------
# GenerateLookupJoin
# --------------------------------------------------

# Verify rule application when we can do a lookup join on both sides.
exploretrace rule=GenerateLookupJoin
SELECT * FROM abc JOIN xyz ON a=x AND a=y
----
----
================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup xyz@xy)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [1] = [5]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup abc@ab)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [5] = [1]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
----
----

# Verify rule application when we can do a lookup join on the left side.
exploretrace rule=GenerateLookupJoin
SELECT * FROM abc JOIN xyz ON a=z
----
----
================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int!null)
   ├── fd: (1)==(7), (7)==(1)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
        └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup abc@ab)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int!null)
   ├── key columns: [7] = [1]
   ├── fd: (1)==(7), (7)==(1)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
        └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]
----
----

exploretrace rule=GenerateLookupJoin
SELECT * FROM abc RIGHT JOIN xyz ON a=z
----
----
================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  left-join
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
        └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]

New expression 1 of 1:
  left-join (lookup abc@ab)
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── key columns: [7] = [1]
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
        └── abc.a = xyz.z [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ])]
----
----

# Verify we don't generate a lookup join.
exploretrace rule=GenerateLookupJoin
SELECT * FROM abc LEFT JOIN xyz ON a=z
----


# Verify rule application when we can do a lookup join on the right side.
exploretrace rule=GenerateLookupJoin
SELECT * FROM abc JOIN xyz ON c=x
----
----
================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int) b:2(int) c:3(int!null) x:5(int!null) y:6(int) z:7(int)
   ├── fd: (3)==(5), (5)==(3)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
        └── abc.c = xyz.x [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup xyz@xy)
   ├── columns: a:1(int) b:2(int) c:3(int!null) x:5(int!null) y:6(int) z:7(int)
   ├── key columns: [3] = [5]
   ├── fd: (3)==(5), (5)==(3)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
        └── abc.c = xyz.x [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ])]
----
----

exploretrace rule=GenerateLookupJoin
SELECT * FROM abc LEFT JOIN xyz ON c=x
----
----
================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  left-join
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
        └── abc.c = xyz.x [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ])]

New expression 1 of 1:
  left-join (lookup xyz@xy)
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── key columns: [3] = [5]
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
        └── abc.c = xyz.x [type=bool, outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ])]
----
----

# Verify we don't generate a lookup join.
exploretrace rule=GenerateLookupJoin
SELECT * FROM abc RIGHT JOIN xyz ON c=x
----

# --------------------------------------------------
# GenerateLookupJoinWithFilter
# --------------------------------------------------

# Verify rule application when we can do a lookup join on both sides.
exploretrace rule=GenerateLookupJoinWithFilter
SELECT * FROM abc JOIN xyz ON a=x AND a=y AND a > 1
----
----
================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup xyz@xy)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [1] = [5]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: [/2 - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── xyz.x > 1 [type=bool, outer=(5), constraints=(/5: [/2 - ]; tight)]

================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup abc@ab)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [5] = [1]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: [/2 - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── abc.a > 1 [type=bool, outer=(1), constraints=(/1: [/2 - ]; tight)]
----
----

# Verify rule application when we can do a lookup join on both sides.
exploretrace rule=GenerateLookupJoinWithFilter
SELECT * FROM abc JOIN xyz ON a=x AND a=y AND a > 1
----
----
================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup xyz@xy)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [1] = [5]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: [/2 - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── xyz.x > 1 [type=bool, outer=(5), constraints=(/5: [/2 - ]; tight)]

================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup abc@ab)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:5(int!null) y:6(int!null) z:7(int)
   ├── key columns: [5] = [1]
   ├── fd: (1)==(5,6), (5)==(1,6), (6)==(1,5)
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: [/2 - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── abc.a > 1 [type=bool, outer=(1), constraints=(/1: [/2 - ]; tight)]
----
----

# Verify rule application when we can do a lookup join on one side.
exploretrace rule=GenerateLookupJoinWithFilter
SELECT * FROM abc LEFT JOIN xyz ON a=x AND a=y AND a > 1
----
----
================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  left-join
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan xyz@xy
   │    ├── columns: x:5(int!null) y:6(int) z:7(int)
   │    └── constraint: /5/6/8: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  left-join (lookup xyz@xy)
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── key columns: [1] = [5]
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: [/2 - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── xyz.x > 1 [type=bool, outer=(5), constraints=(/5: [/2 - ]; tight)]
----
----

exploretrace rule=GenerateLookupJoinWithFilter
SELECT * FROM abc RIGHT JOIN xyz ON a=x AND a=y AND a > 1
----
----
================================================================================
GenerateLookupJoinWithFilter
================================================================================
Source expression:
  left-join
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   ├── scan abc@ab
   │    ├── columns: a:1(int!null) b:2(int) c:3(int)
   │    └── constraint: /1/2/4: [/2 - ]
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: (/NULL - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        └── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

New expression 1 of 1:
  left-join (lookup abc@ab)
   ├── columns: a:1(int) b:2(int) c:3(int) x:5(int) y:6(int) z:7(int)
   ├── key columns: [5] = [1]
   ├── scan xyz
   │    └── columns: x:5(int) y:6(int) z:7(int)
   └── filters [type=bool, outer=(1,5,6), constraints=(/1: [/2 - ]; /5: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(5,6), (5)==(1,6), (6)==(1,5)]
        ├── abc.a = xyz.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
        ├── abc.a = xyz.y [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
        └── abc.a > 1 [type=bool, outer=(1), constraints=(/1: [/2 - ]; tight)]
----
----

# --------------------------------------------------
# PushJoinThroughIndexJoin
# --------------------------------------------------

exec-ddl
CREATE TABLE uvw
(
    u INT PRIMARY KEY,
    v INT,
    w INT,
    INDEX v (v)
)
----
TABLE uvw
 ├── u int not null
 ├── v int
 ├── w int
 ├── INDEX primary
 │    └── u int not null
 └── INDEX v
      ├── v int
      └── u int not null

exploretrace rule=PushJoinThroughIndexJoin
SELECT * FROM abc JOIN uvw ON a=u
----
----
================================================================================
PushJoinThroughIndexJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int) w:7(int)
   ├── fd: (5)-->(6,7), (1)==(5), (5)==(1)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan uvw
   │    ├── columns: u:5(int!null) v:6(int) w:7(int)
   │    ├── key: (5)
   │    └── fd: (5)-->(6,7)
   └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
        └── abc.a = uvw.u [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup uvw)
   ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int) w:7(int)
   ├── key columns: [5] = [5]
   ├── fd: (5)-->(6,7), (1)==(5), (5)==(1)
   ├── inner-join
   │    ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int)
   │    ├── fd: (5)-->(6), (1)==(5), (5)==(1)
   │    ├── scan abc
   │    │    └── columns: a:1(int) b:2(int) c:3(int)
   │    ├── scan uvw@v
   │    │    ├── columns: u:5(int!null) v:6(int)
   │    │    ├── key: (5)
   │    │    └── fd: (5)-->(6)
   │    └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
   │         └── abc.a = uvw.u [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
   └── true [type=bool]

================================================================================
PushJoinThroughIndexJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int) w:7(int)
   ├── fd: (5)-->(6,7), (1)==(5), (5)==(1)
   ├── scan abc
   │    └── columns: a:1(int) b:2(int) c:3(int)
   ├── scan uvw
   │    ├── columns: u:5(int!null) v:6(int) w:7(int)
   │    ├── key: (5)
   │    └── fd: (5)-->(6,7)
   └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
        └── abc.a = uvw.u [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

New expression 1 of 1:
  inner-join (lookup uvw)
   ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int) w:7(int)
   ├── key columns: [5] = [5]
   ├── fd: (5)-->(6,7), (1)==(5), (5)==(1)
   ├── inner-join
   │    ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int)
   │    ├── fd: (5)-->(6), (1)==(5), (5)==(1)
   │    ├── scan abc
   │    │    └── columns: a:1(int) b:2(int) c:3(int)
   │    ├── scan uvw@v,rev
   │    │    ├── columns: u:5(int!null) v:6(int)
   │    │    ├── key: (5)
   │    │    └── fd: (5)-->(6)
   │    └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
   │         └── abc.a = uvw.u [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
   └── true [type=bool]
----
----

exec-ddl
ALTER TABLE abc INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-05-01 1:00:00.00000+00:00",
    "row_count": 1,
    "distinct_count": 1
  }
]'
----

exec-ddl
ALTER TABLE uvw INJECT STATISTICS '[
  {
    "columns": ["u"],
    "created_at": "2018-05-01 1:00:00.00000+00:00",
    "row_count": 10,
    "distinct_count": 10
  }
]'
----

opt
SELECT * FROM abc JOIN uvw ON a=v
----
inner-join (lookup uvw)
 ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null) w:7(int)
 ├── key columns: [5] = [5]
 ├── fd: (5)-->(6,7), (1)==(6), (6)==(1)
 ├── inner-join (lookup uvw@v)
 │    ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null)
 │    ├── key columns: [1] = [6]
 │    ├── fd: (5)-->(6), (1)==(6), (6)==(1)
 │    ├── scan abc
 │    │    └── columns: a:1(int) b:2(int) c:3(int)
 │    └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │         └── abc.a = uvw.v [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 └── true [type=bool]

opt
SELECT * FROM abc JOIN uvw ON a=v AND b+u>1
----
inner-join (lookup uvw)
 ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null) w:7(int)
 ├── key columns: [5] = [5]
 ├── fd: (5)-->(6,7), (1)==(6), (6)==(1)
 ├── inner-join (lookup uvw@v)
 │    ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null)
 │    ├── key columns: [1] = [6]
 │    ├── fd: (5)-->(6), (1)==(6), (6)==(1)
 │    ├── scan abc
 │    │    └── columns: a:1(int) b:2(int) c:3(int)
 │    └── filters [type=bool, outer=(1,2,5,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │         ├── abc.a = uvw.v [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 │         └── (abc.b + uvw.u) > 1 [type=bool, outer=(2,5)]
 └── true [type=bool]

opt
SELECT * FROM abc JOIN uvw ON a=v WHERE b+w>1
----
inner-join (lookup uvw)
 ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null) w:7(int)
 ├── key columns: [5] = [5]
 ├── fd: (5)-->(6,7), (1)==(6), (6)==(1)
 ├── inner-join (lookup uvw@v)
 │    ├── columns: a:1(int!null) b:2(int) c:3(int) u:5(int!null) v:6(int!null)
 │    ├── key columns: [1] = [6]
 │    ├── fd: (5)-->(6), (1)==(6), (6)==(1)
 │    ├── scan abc
 │    │    └── columns: a:1(int) b:2(int) c:3(int)
 │    └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │         └── abc.a = uvw.v [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 └── filters [type=bool, outer=(2,7)]
      └── (abc.b + uvw.w) > 1 [type=bool, outer=(2,7)]
