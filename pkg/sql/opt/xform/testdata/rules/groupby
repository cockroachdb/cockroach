exec-ddl
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  INDEX yy (y)
)
----

exec-ddl
CREATE TABLE kuvw (
  k INT PRIMARY KEY,
  u INT,
  v INT,
  w INT,

  INDEX uvw(u,v,w),
  INDEX wvu(w,v,u),
  INDEX vw(v,w) STORING (u),
  INDEX w(w) STORING (u,v)
)
----

# --------------------------------------------------
# ReplaceScalarMinMaxWithLimit (Min variations)
# --------------------------------------------------

opt
SELECT min(a) FROM abc
----
scalar-group-by
 ├── columns: min:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:7, outer=(1)]
           └── a:1

# Verify the rule still fires even if DISTINCT is used.
opt
SELECT min(DISTINCT a) FROM abc
----
scalar-group-by
 ├── columns: min:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:7, outer=(1)]
           └── a:1

# Verify the rule does not fire when FILTER is used.
opt
SELECT min(a) FILTER (WHERE a > 'a') FROM abc
----
scalar-group-by
 ├── columns: min:8
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(8)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── constraint: /1: [/e'a\x00' - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:8, outer=(1)]
           └── a:1

opt
SELECT min(b) FROM abc
----
scalar-group-by
 ├── columns: min:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc
 │    └── columns: b:2
 └── aggregations
      └── min [as=min:7, outer=(2)]
           └── b:2

opt
SELECT min(y) FROM xyz where z=7
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@zyx
 │    ├── columns: y:2!null z:3!null
 │    ├── constraint: /3/2/1: (/7.0/NULL - /7.0]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2,3)
 └── aggregations
      └── const-agg [as=min:6, outer=(2)]
           └── y:2

# ReplaceScalarMaxWithLimit has the same behavior with max() as
# the previous min() query because z is the prefix of a unique key
opt
SELECT max(y) FROM xyz where z=7
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@zyx,rev
 │    ├── columns: y:2!null z:3!null
 │    ├── constraint: /3/2/1: (/7.0/NULL - /7.0]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(2,3)
 └── aggregations
      └── const-agg [as=max:6, outer=(2)]
           └── y:2

# We expect ReplaceScalarMinWithLimit not to be preferred here.
# This is because we know nothing about the ordering of y
# on the index xy after a scan on xy with x>7.
opt
SELECT min(y) FROM xyz@xy WHERE x>7
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── constraint: /1/2: [/8 - ]
 │    ├── flags: force-index=xy
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      └── min [as=min:6, outer=(2)]
           └── y:2

# We expect ReplaceMaxWithLimit not to be preferred here.
# This is because we know nothing about the ordering of y
# on the index xy after a scan on xy with x>7
opt
SELECT max(y) FROM xyz@xy WHERE x>7
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── constraint: /1/2: [/8 - ]
 │    ├── flags: force-index=xy
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      └── max [as=max:6, outer=(2)]
           └── y:2

opt
SELECT max(x) FROM xyz
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy,rev
 │    ├── columns: x:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:6, outer=(1)]
           └── x:1

opt
SELECT min(x) FROM xyz
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:6, outer=(1)]
           └── x:1

opt
SELECT min(x) FROM xyz WHERE x in (0, 4, 7)
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null
 │    ├── constraint: /1/2
 │    │    ├── [/0 - /0]
 │    │    ├── [/4 - /4]
 │    │    └── [/7 - /7]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:6, outer=(1)]
           └── x:1

opt
SELECT max(x) FROM xyz WHERE x in (0, 4, 7)
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@xy,rev
 │    ├── columns: x:1!null
 │    ├── constraint: /1/2
 │    │    ├── [/0 - /0]
 │    │    ├── [/4 - /4]
 │    │    └── [/7 - /7]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:6, outer=(1)]
           └── x:1

opt
SELECT min(y) FROM xyz
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@yy
 │    ├── columns: y:2!null
 │    ├── constraint: /2/1: (/NULL - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2)
 └── aggregations
      └── const-agg [as=min:6, outer=(2)]
           └── y:2

opt
SELECT min(y), min(y) FROM xyz
----
scalar-group-by
 ├── columns: min:6 min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan xyz@yy
 │    ├── columns: y:2!null
 │    ├── constraint: /2/1: (/NULL - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2)
 └── aggregations
      └── const-agg [as=min:6, outer=(2)]
           └── y:2

# ReplaceScalarMinWithLimit does not apply when there is
# a grouping column
opt
SELECT min(y) FROM xyz GROUP BY y
----
project
 ├── columns: min:6
 └── group-by
      ├── columns: y:2 min:6
      ├── grouping columns: y:2
      ├── internal-ordering: +2
      ├── key: (2)
      ├── fd: (2)-->(6)
      ├── scan xyz@yy
      │    ├── columns: y:2
      │    └── ordering: +2
      └── aggregations
           └── min [as=min:6, outer=(2)]
                └── y:2

# ReplaceScalarMaxWithLimit does not apply when there is
# a grouping column
opt
SELECT max(y) FROM xyz GROUP BY y
----
project
 ├── columns: max:6
 └── group-by
      ├── columns: y:2 max:6
      ├── grouping columns: y:2
      ├── internal-ordering: +2
      ├── key: (2)
      ├── fd: (2)-->(6)
      ├── scan xyz@yy
      │    ├── columns: y:2
      │    └── ordering: +2
      └── aggregations
           └── max [as=max:6, outer=(2)]
                └── y:2

# ReplaceScalarMinWithLimit does not apply when there is
# a grouping column
opt
SELECT min(y) FROM xyz GROUP BY x
----
project
 ├── columns: min:6
 └── group-by
      ├── columns: x:1!null min:6
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(6)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           └── min [as=min:6, outer=(2)]
                └── y:2

# ReplaceScalarMinWithLimit does not apply on multiple aggregations
# on different columns
opt
SELECT min(y), min(x) FROM xyz
----
scalar-group-by
 ├── columns: min:6 min:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      ├── min [as=min:6, outer=(2)]
      │    └── y:2
      └── min [as=min:7, outer=(1)]
           └── x:1


# ReplaceScalarMaxWithLimit does not apply on multiple aggregations
# on different columns
opt
SELECT max(y), max(x) FROM xyz
----
scalar-group-by
 ├── columns: max:6 max:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      ├── max [as=max:6, outer=(2)]
      │    └── y:2
      └── max [as=max:7, outer=(1)]
           └── x:1

# ReplaceScalarMinWithLimit does not apply with
# multiple grouping columns
opt
SELECT x,min(y) FROM xyz GROUP BY x,y
----
group-by
 ├── columns: x:1!null min:6
 ├── grouping columns: x:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 └── aggregations
      └── min [as=min:6, outer=(2)]
           └── y:2

# ReplaceScalarMaxWithLimit does not apply with
# multiple grouping columns
opt
SELECT x,max(y) FROM xyz GROUP BY x,y
----
group-by
 ├── columns: x:1!null max:6
 ├── grouping columns: x:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 └── aggregations
      └── max [as=max:6, outer=(2)]
           └── y:2

# ReplaceScalarMinWithLimit does not apply to non-scalar
# aggregates
opt
SELECT min(x), count(y) FROM xyz GROUP BY x,y
----
project
 ├── columns: min:6!null count:7!null
 └── group-by
      ├── columns: x:1!null min:6!null count:7!null
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(6,7)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           ├── min [as=min:6, outer=(1)]
           │    └── x:1
           └── count [as=count:7, outer=(2)]
                └── y:2

# ReplaceScalarMaxWithLimit does not apply to non-scalar
# aggregates
opt
SELECT max(x), count(y) FROM xyz GROUP BY x,y
----
project
 ├── columns: max:6!null count:7!null
 └── group-by
      ├── columns: x:1!null max:6!null count:7!null
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(6,7)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           ├── max [as=max:6, outer=(1)]
           │    └── x:1
           └── count [as=count:7, outer=(2)]
                └── y:2

memo
SELECT min(a) FROM abc
----
memo (optimized, ~5KB, required=[presentation: min:7])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: min:7]
 │         ├── best: (scalar-group-by G4 G5 cols=())
 │         └── cost: 5.10
 ├── G2: (scan abc,cols=(1))
 │    ├── [ordering: +1] [limit hint: 1.00]
 │    │    ├── best: (scan abc,cols=(1))
 │    │    └── cost: 5.06
 │    └── []
 │         ├── best: (scan abc,cols=(1))
 │         └── cost: 1075.01
 ├── G3: (aggregations G6)
 ├── G4: (limit G2 G7 ordering=+1) (scan abc,cols=(1),lim=1)
 │    └── []
 │         ├── best: (scan abc,cols=(1),lim=1)
 │         └── cost: 5.06
 ├── G5: (aggregations G8)
 ├── G6: (min G9)
 ├── G7: (const 1)
 ├── G8: (const-agg G9)
 └── G9: (variable a)

memo
SELECT min(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: min:7])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: min:7]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1085.04
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: +2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1304.48
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1075.01
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=+2)
 │    └── []
 │         ├── best: (limit G7="[ordering: +2] [limit hint: 1.00]" G8 ordering=+2)
 │         └── cost: 1304.53
 ├── G5: (aggregations G9)
 ├── G6: (min G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: +2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: +2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1304.51
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1085.03
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

memo
SELECT max(a) FROM abc
----
memo (optimized, ~5KB, required=[presentation: max:7])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:7]
 │         ├── best: (scalar-group-by G4 G5 cols=())
 │         └── cost: 5.10
 ├── G2: (scan abc,cols=(1))
 │    ├── [ordering: -1] [limit hint: 1.00]
 │    │    ├── best: (scan abc,rev,cols=(1))
 │    │    └── cost: 5.16
 │    └── []
 │         ├── best: (scan abc,cols=(1))
 │         └── cost: 1075.01
 ├── G3: (aggregations G6)
 ├── G4: (limit G2 G7 ordering=-1) (scan abc,rev,cols=(1),lim=1(rev))
 │    └── []
 │         ├── best: (scan abc,rev,cols=(1),lim=1(rev))
 │         └── cost: 5.06
 ├── G5: (aggregations G8)
 ├── G6: (max G9)
 ├── G7: (const 1)
 ├── G8: (const-agg G9)
 └── G9: (variable a)

memo
SELECT max(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: max:7])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:7]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1085.04
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: -2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1304.48
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1075.01
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=-2)
 │    └── []
 │         ├── best: (limit G7="[ordering: -2] [limit hint: 1.00]" G8 ordering=-2)
 │         └── cost: 1304.53
 ├── G5: (aggregations G9)
 ├── G6: (max G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: -2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: -2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1304.51
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1085.03
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

# --------------------------------------------------
# ReplaceScalarMinMaxWithLimit (Max variations)
# --------------------------------------------------

opt
SELECT max(a) FROM abc
----
scalar-group-by
 ├── columns: max:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:7, outer=(1)]
           └── a:1

# Verify the rule still fires even if DISTINCT is used.
opt
SELECT max(DISTINCT a) FROM abc
----
scalar-group-by
 ├── columns: max:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:7, outer=(1)]
           └── a:1

# Verify the rule does not fire when FILTER is used.
opt
SELECT max(a) FILTER (WHERE a > 'a') FROM abc
----
scalar-group-by
 ├── columns: max:8
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(8)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── constraint: /1: [/e'a\x00' - ]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:8, outer=(1)]
           └── a:1

opt
SELECT max(b) FROM abc
----
scalar-group-by
 ├── columns: max:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc
 │    └── columns: b:2
 └── aggregations
      └── max [as=max:7, outer=(2)]
           └── b:2

memo
SELECT max(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: max:7])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:7]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1085.04
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: -2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1304.48
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1075.01
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=-2)
 │    └── []
 │         ├── best: (limit G7="[ordering: -2] [limit hint: 1.00]" G8 ordering=-2)
 │         └── cost: 1304.53
 ├── G5: (aggregations G9)
 ├── G6: (max G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: -2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: -2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1304.51
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1085.03
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

# --------------------------------------------------
# ReplaceMinWithLimit & ReplaceMaxWithLimit
# --------------------------------------------------

# Basic min case (min function must take non-null column).
opt expect=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE w = 5 GROUP BY w
----
project
 ├── columns: min:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@w
 │    ├── columns: k:1!null w:4!null
 │    ├── constraint: /4/1: [/5 - /5]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,4)
 └── projections
      └── k:1 [as=min:7, outer=(1)]

# Basic max case.
opt expect=ReplaceMaxWithLimit
SELECT max(w) FROM kuvw WHERE v = 5 GROUP BY v
----
project
 ├── columns: max:7
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@vw,rev
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(3,4)
 └── projections
      └── w:4 [as=max:7, outer=(4)]

# Add const_agg function, as well as min function.
opt expect=ReplaceMinWithLimit
SELECT v + 1, min(w), v FROM kuvw WHERE v = 5 AND w IS NOT NULL GROUP BY v
----
project
 ├── columns: "?column?":8!null min:7!null v:3!null
 ├── cardinality: [0 - 1]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(3,7,8)
 ├── project
 │    ├── columns: min:7!null v:3!null
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,7)
 │    ├── scan kuvw@vw
 │    │    ├── columns: v:3!null w:4!null
 │    │    ├── constraint: /3/4/1: (/5/NULL - /5]
 │    │    ├── limit: 1
 │    │    ├── key: ()
 │    │    └── fd: ()-->(3,4)
 │    └── projections
 │         └── w:4 [as=min:7, outer=(4)]
 └── projections
      └── v:3 + 1 [as="?column?":8, outer=(3), immutable]

# Add const_agg function, as well as max function.
opt expect=ReplaceMaxWithLimit
SELECT v + 1, max(w), v FROM kuvw WHERE v = 5 GROUP BY v
----
project
 ├── columns: "?column?":8!null max:7 v:3!null
 ├── cardinality: [0 - 1]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(3,7,8)
 ├── project
 │    ├── columns: max:7 v:3!null
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,7)
 │    ├── scan kuvw@vw,rev
 │    │    ├── columns: v:3!null w:4
 │    │    ├── constraint: /3/4/1: [/5 - /5]
 │    │    ├── limit: 1(rev)
 │    │    ├── key: ()
 │    │    └── fd: ()-->(3,4)
 │    └── projections
 │         └── w:4 [as=max:7, outer=(4)]
 └── projections
      └── v:3 + 1 [as="?column?":8, outer=(3), immutable]

# Use multiple grouping columns with min function.
opt expect=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: min:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=min:7, outer=(1)]

# Use multiple grouping columns with max function.
opt expect=ReplaceMaxWithLimit
SELECT max(k) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: max:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@vw,rev
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=max:7, outer=(1)]

# Use multiple grouping columns with min function, and project them.
opt expect=ReplaceMinWithLimit
SELECT v, min(k), w FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: v:3!null min:7!null w:4!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(3,4,7)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=min:7, outer=(1)]

# Use multiple grouping columns with max function, and project them.
opt expect=ReplaceMaxWithLimit
SELECT v, max(k), w FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: v:3!null max:7!null w:4!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(3,4,7)
 ├── scan kuvw@vw,rev
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=max:7, outer=(1)]

# Multiple grouping columns, but different min column; use different index.
opt expect=ReplaceMinWithLimit
SELECT min(u) FROM kuvw WHERE v = 5 AND w = 10 AND u > 0 GROUP BY v, w
----
project
 ├── columns: min:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@wvu
 │    ├── columns: u:2!null v:3!null w:4!null
 │    ├── constraint: /4/3/2/1: [/10/5/1 - /10/5]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2-4)
 └── projections
      └── u:2 [as=min:7, outer=(2)]

# Multiple grouping columns, but different max column; use different index.
opt expect=ReplaceMaxWithLimit
SELECT max(u) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: max:7
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@wvu,rev
 │    ├── columns: u:2 v:3!null w:4!null
 │    ├── constraint: /4/3/2/1: [/10/5 - /10/5]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(2-4)
 └── projections
      └── u:2 [as=max:7, outer=(2)]

# One of grouping columns is not constant, with min function.
opt expect-not=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE v = 5 GROUP BY v, w
----
project
 ├── columns: min:7!null
 └── group-by
      ├── columns: w:4 min:7!null
      ├── grouping columns: w:4
      ├── internal-ordering: +4 opt(3)
      ├── key: (4)
      ├── fd: (4)-->(7)
      ├── scan kuvw@vw
      │    ├── columns: k:1!null v:3!null w:4
      │    ├── constraint: /3/4/1: [/5 - /5]
      │    ├── key: (1)
      │    ├── fd: ()-->(3), (1)-->(4)
      │    └── ordering: +4 opt(3) [actual: +4]
      └── aggregations
           └── min [as=min:7, outer=(1)]
                └── k:1

# One of grouping columns is not constant, with max function.
opt expect-not=ReplaceMaxWithLimit
SELECT max(k) FROM kuvw WHERE v = 5 GROUP BY v, w
----
project
 ├── columns: max:7!null
 └── group-by
      ├── columns: w:4 max:7!null
      ├── grouping columns: w:4
      ├── internal-ordering: +4 opt(3)
      ├── key: (4)
      ├── fd: (4)-->(7)
      ├── scan kuvw@vw
      │    ├── columns: k:1!null v:3!null w:4
      │    ├── constraint: /3/4/1: [/5 - /5]
      │    ├── key: (1)
      │    ├── fd: ()-->(3), (1)-->(4)
      │    └── ordering: +4 opt(3) [actual: +4]
      └── aggregations
           └── max [as=max:7, outer=(1)]
                └── k:1

# We expect ReplaceMinWithLimit not to be preferred here.
# This is because we know nothing about the ordering of w
# on the index vw after a scan on vw with v>5.
opt expect-not=ReplaceMinWithLimit
SELECT min(w) FROM kuvw WHERE v > 5 AND w IS NOT NULL GROUP BY v
----
project
 ├── columns: min:7!null
 └── group-by
      ├── columns: v:3!null min:7!null
      ├── grouping columns: v:3!null
      ├── internal-ordering: +3
      ├── key: (3)
      ├── fd: (3)-->(7)
      ├── select
      │    ├── columns: v:3!null w:4!null
      │    ├── ordering: +3
      │    ├── scan kuvw@vw
      │    │    ├── columns: v:3!null w:4
      │    │    ├── constraint: /3/4/1: (/6/NULL - ]
      │    │    └── ordering: +3
      │    └── filters
      │         └── w:4 IS NOT NULL [outer=(4), constraints=(/4: (/NULL - ]; tight)]
      └── aggregations
           └── min [as=min:7, outer=(4)]
                └── w:4

# We expect ReplaceMaxWithLimit not to be preferred here.
# This is because we know nothing about the ordering of w
# on the index vw after a scan on vw with v>5.
opt expect-not=ReplaceMaxWithLimit
SELECT max(w) FROM kuvw WHERE v > 5 GROUP BY v
----
project
 ├── columns: max:7
 └── group-by
      ├── columns: v:3!null max:7
      ├── grouping columns: v:3!null
      ├── internal-ordering: +3
      ├── key: (3)
      ├── fd: (3)-->(7)
      ├── scan kuvw@vw
      │    ├── columns: v:3!null w:4
      │    ├── constraint: /3/4/1: [/6 - ]
      │    └── ordering: +3
      └── aggregations
           └── max [as=max:7, outer=(4)]
                └── w:4

# ReplaceMinWithLimit does not apply on multiple aggregations
# on different columns
opt expect-not=ReplaceMinWithLimit
SELECT min(w), min(k) FROM kuvw WHERE v = 5 AND w IS NOT NULL GROUP BY v
----
group-by
 ├── columns: min:7!null min:8!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7,8)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: (/5/NULL - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(3), (1)-->(4)
 └── aggregations
      ├── min [as=min:7, outer=(4)]
      │    └── w:4
      └── min [as=min:8, outer=(1)]
           └── k:1

# ReplaceMaxWithLimit does not apply on multiple aggregations
# on different columns
opt expect-not=ReplaceMaxWithLimit
SELECT max(w), max(k) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: max:7 max:8!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7,8)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(3), (1)-->(4)
 └── aggregations
      ├── max [as=max:7, outer=(4)]
      │    └── w:4
      └── max [as=max:8, outer=(1)]
           └── k:1

# ReplaceMinWithLimit does not apply when other aggregates are present.
opt expect-not=ReplaceMinWithLimit
SELECT min(k), max(k) FROM kuvw WHERE w = 5 GROUP BY w
----
group-by
 ├── columns: min:7!null max:8!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7,8)
 ├── scan kuvw@wvu
 │    ├── columns: k:1!null w:4!null
 │    ├── constraint: /4/3/2/1: [/5 - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(4)
 └── aggregations
      ├── min [as=min:7, outer=(1)]
      │    └── k:1
      └── max [as=max:8, outer=(1)]
           └── k:1

# ReplaceMaxWithLimit does not apply when other aggregates are present.
opt expect-not=ReplaceMaxWithLimit
SELECT max(w), count(w) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: max:7 count:8!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7,8)
 ├── scan kuvw@vw
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    └── fd: ()-->(3)
 └── aggregations
      ├── max [as=max:7, outer=(4)]
      │    └── w:4
      └── count [as=count:8, outer=(4)]
           └── w:4

# min/max functions are not symmetric because of NULL ordering (NULL values
# always sort first, which interferes with MIN calculation). Ensure that min
# function on nullable column does not trigger ReplaceMinWithLimit.
opt expect-not=ReplaceMinWithLimit
SELECT min(w) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: min:7
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan kuvw@vw
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    └── fd: ()-->(3)
 └── aggregations
      └── min [as=min:7, outer=(4)]
           └── w:4

# --------------------------------------------------
# GenerateStreamingGroupBy
# --------------------------------------------------

# All index orderings can be used.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY w) GROUP BY u,v
----
memo (optimized, ~7KB, required=[presentation: array_agg:7])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:7]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1145.44
 ├── G2: (group-by G4 G5 cols=(2,3),ordering=+4 opt(2,3)) (group-by G4 G5 cols=(2,3),ordering=+2,+3,+4) (group-by G4 G5 cols=(2,3),ordering=+4,+3,+2) (group-by G4 G5 cols=(2,3),ordering=+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+3,+4]" G5 cols=(2,3),ordering=+2,+3,+4)
 │         └── cost: 1135.43
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4 opt(2,3)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)

# All index orderings can be used (note that +w is redundant with +w,+v+,u).
memo
SELECT sum(w) FROM kuvw GROUP BY u,v,w
----
memo (optimized, ~6KB, required=[presentation: sum:7])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:7]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1155.44
 ├── G2: (group-by G4 G5 cols=(2-4)) (group-by G4 G5 cols=(2-4),ordering=+2,+3,+4) (group-by G4 G5 cols=(2-4),ordering=+4,+3,+2) (group-by G4 G5 cols=(2-4),ordering=+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+3,+4]" G5 cols=(2-4),ordering=+2,+3,+4)
 │         └── cost: 1145.43
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G5: (aggregations G6)
 ├── G6: (sum G7)
 └── G7: (variable w)

# Only index ordering +v,+w can be used (as +v).
memo
SELECT sum(w) FROM kuvw GROUP BY v
----
memo (optimized, ~6KB, required=[presentation: sum:7])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:7]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1107.24
 ├── G2: (group-by G4 G5 cols=(3)) (group-by G4 G5 cols=(3),ordering=+3)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +3]" G5 cols=(3),ordering=+3)
 │         └── cost: 1106.23
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(3,4)) (scan kuvw@uvw,cols=(3,4)) (scan kuvw@wvu,cols=(3,4)) (scan kuvw@vw,cols=(3,4)) (scan kuvw@w,cols=(3,4))
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(3,4))
 │    │    └── cost: 1085.21
 │    └── []
 │         ├── best: (scan kuvw,cols=(3,4))
 │         └── cost: 1085.21
 ├── G5: (aggregations G6)
 ├── G6: (sum G7)
 └── G7: (variable w)

# Only ordering +u,+v,+w can be used.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY u,w) GROUP BY v
----
memo (optimized, ~7KB, required=[presentation: array_agg:7])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:7]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1127.44
 ├── G2: (group-by G4 G5 cols=(3),ordering=+2,+4 opt(3)) (group-by G4 G5 cols=(3),ordering=+2,+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+4 opt(3)]" G5 cols=(3),ordering=+2,+4 opt(3))
 │         └── cost: 1126.43
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +2,+4 opt(3)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)

# Verify the orderings are simplified.
memo
SELECT array_agg(k) FROM (SELECT * FROM kuvw WHERE u=v ORDER BY u) GROUP BY w
----
memo (optimized, ~12KB, required=[presentation: array_agg:7])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:7]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1094.44
 ├── G2: (group-by G4 G5 cols=(4),ordering=+(2|3) opt(4)) (group-by G4 G5 cols=(4),ordering=+(2|3),+4) (group-by G4 G5 cols=(4),ordering=+4,+(2|3))
 │    └── []
 │         ├── best: (group-by G4="[ordering: +(2|3) opt(4)]" G5 cols=(4),ordering=+(2|3) opt(4))
 │         └── cost: 1094.34
 ├── G3: (projections)
 ├── G4: (select G6 G7) (select G8 G7) (select G9 G7)
 │    ├── [ordering: +(2|3) opt(4)]
 │    │    ├── best: (select G8="[ordering: +2]" G7)
 │    │    └── cost: 1093.93
 │    ├── [ordering: +(2|3),+4]
 │    │    ├── best: (select G8="[ordering: +2,+3,+4]" G7)
 │    │    └── cost: 1093.93
 │    ├── [ordering: +4,+(2|3)]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1095.22
 │    └── []
 │         ├── best: (select G8 G7)
 │         └── cost: 1093.93
 ├── G5: (aggregations G10)
 ├── G6: (scan kuvw,cols=(1-4)) (scan kuvw@uvw,cols=(1-4)) (scan kuvw@wvu,cols=(1-4)) (scan kuvw@vw,cols=(1-4)) (scan kuvw@w,cols=(1-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1105.61
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1105.61
 │    ├── [ordering: +4,+3]
 │    │    ├── best: (scan kuvw@wvu,cols=(1-4))
 │    │    └── cost: 1105.61
 │    └── []
 │         ├── best: (scan kuvw,cols=(1-4))
 │         └── cost: 1105.61
 ├── G7: (filters G11)
 ├── G8: (scan kuvw@uvw,cols=(1-4),constrained)
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1351.44
 │    └── []
 │         ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │         └── cost: 1084.01
 ├── G9: (scan kuvw@vw,cols=(1-4),constrained)
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1351.44
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │         └── cost: 1084.01
 ├── G10: (array-agg G12)
 ├── G11: (eq G13 G14)
 ├── G12: (variable k)
 ├── G13: (variable u)
 └── G14: (variable v)

memo
SELECT sum(k) FROM (SELECT * FROM kuvw WHERE u=v) GROUP BY u,w
----
memo (optimized, ~12KB, required=[presentation: sum:7])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:7]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1094.45
 ├── G2: (group-by G4 G5 cols=(2,4)) (group-by G4 G5 cols=(2,4),ordering=+(2|3),+4) (group-by G4 G5 cols=(2,4),ordering=+4,+(2|3)) (group-by G4 G5 cols=(2,4),ordering=+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +(2|3),+4]" G5 cols=(2,4),ordering=+(2|3),+4)
 │         └── cost: 1094.34
 ├── G3: (projections)
 ├── G4: (select G6 G7) (select G8 G7) (select G9 G7)
 │    ├── [ordering: +(2|3),+4]
 │    │    ├── best: (select G8="[ordering: +2,+3,+4]" G7)
 │    │    └── cost: 1093.93
 │    ├── [ordering: +4,+(2|3)]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1095.22
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1095.17
 │    └── []
 │         ├── best: (select G8 G7)
 │         └── cost: 1093.93
 ├── G5: (aggregations G10)
 ├── G6: (scan kuvw,cols=(1-4)) (scan kuvw@uvw,cols=(1-4)) (scan kuvw@wvu,cols=(1-4)) (scan kuvw@vw,cols=(1-4)) (scan kuvw@w,cols=(1-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1105.61
 │    ├── [ordering: +4,+3]
 │    │    ├── best: (scan kuvw@wvu,cols=(1-4))
 │    │    └── cost: 1105.61
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(1-4))
 │    │    └── cost: 1105.61
 │    └── []
 │         ├── best: (scan kuvw,cols=(1-4))
 │         └── cost: 1105.61
 ├── G7: (filters G11)
 ├── G8: (scan kuvw@uvw,cols=(1-4),constrained)
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1351.44
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1340.60
 │    └── []
 │         ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │         └── cost: 1084.01
 ├── G9: (scan kuvw@vw,cols=(1-4),constrained)
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │    │    └── cost: 1084.01
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1351.44
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1340.60
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │         └── cost: 1084.01
 ├── G10: (sum G12)
 ├── G11: (eq G13 G14)
 ├── G12: (variable k)
 ├── G13: (variable u)
 └── G14: (variable v)

# Ensure that we don't incorrectly use orderings that don't match the direction.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY w DESC) GROUP BY u,v
----
memo (optimized, ~6KB, required=[presentation: array_agg:7])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:7]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1215.60
 ├── G2: (group-by G4 G5 cols=(2,3),ordering=-4 opt(2,3))
 │    └── []
 │         ├── best: (group-by G4="[ordering: -4 opt(2,3)]" G5 cols=(2,3),ordering=-4 opt(2,3))
 │         └── cost: 1205.59
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: -4 opt(2,3)]
 │    │    ├── best: (sort G4="[ordering: +2,+3]")
 │    │    └── cost: 1155.42
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)


# All orderings can be used (note that +w is redundant with +w,+v,+u).
memo
SELECT DISTINCT u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2-4)) (distinct-on G2 G3 cols=(2-4),ordering=+2,+3,+4) (distinct-on G2 G3 cols=(2-4),ordering=+4,+3,+2) (distinct-on G2 G3 cols=(2-4),ordering=+3,+4)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2-4),ordering=+2,+3,+4)
 │         └── cost: 1135.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 └── G3: (aggregations)

# Orderings +u,+v and +v can be used.
memo
SELECT DISTINCT ON (u, v) u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2,3)) (distinct-on G2 G3 cols=(2,3),ordering=+2,+3) (distinct-on G2 G3 cols=(2,3),ordering=+3)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2,+3]" G3 cols=(2,3),ordering=+2,+3)
 │         └── cost: 1135.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4)
 ├── G4: (first-agg G5)
 └── G5: (variable w)

# Only ordering +u can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2)) (distinct-on G2 G3 cols=(2),ordering=+2)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2]" G3 cols=(2),ordering=+2)
 │         └── cost: 1126.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Only ordering +v can be used.
memo
SELECT DISTINCT ON (v) u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(3)) (distinct-on G2 G3 cols=(3),ordering=+3)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +3]" G3 cols=(3),ordering=+3)
 │         └── cost: 1126.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable w)

# Only ordering +w can be used.
memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(4)) (distinct-on G2 G3 cols=(4),ordering=+4)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +4]" G3 cols=(4),ordering=+4)
 │         └── cost: 1126.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

# Only ordering +u can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw ORDER BY u, w
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4] [ordering: +2])
 ├── G1: (distinct-on G2 G3 cols=(2),ordering=+4 opt(2)) (distinct-on G2 G3 cols=(2),ordering=+4)
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +2]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1154.73
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +4 opt(2)]" G3 cols=(2),ordering=+4 opt(2))
 │         └── cost: 1136.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+4]
 │    │    ├── best: (sort G2="[ordering: +2]")
 │    │    └── cost: 1221.86
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4 opt(2)]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Only ordering +u,+v,+w can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw ORDER BY u, v, w
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4] [ordering: +2])
 ├── G1: (distinct-on G2 G3 cols=(2),ordering=+3,+4 opt(2)) (distinct-on G2 G3 cols=(2),ordering=+2,+3,+4) (distinct-on G2 G3 cols=(2),ordering=+3,+4)
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +2]
 │    │    ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2),ordering=+3,+4 opt(2))
 │    │    └── cost: 1126.43
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2),ordering=+2,+3,+4)
 │         └── cost: 1126.43
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3,+4 opt(2)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Ensure that we don't incorrectly use orderings that don't match the direction.
memo
SELECT DISTINCT ON (w, u) u, v, w FROM kuvw ORDER BY w, u, v DESC
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4,+2])
 ├── G1: (distinct-on G2 G3 cols=(2,4),ordering=-3 opt(2,4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4,+2]
 │    │    ├── best: (distinct-on G2="[ordering: +4,+2,-3]" G3 cols=(2,4),ordering=-3 opt(2,4))
 │    │    └── cost: 1266.20
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -3 opt(2,4)]" G3 cols=(2,4),ordering=-3 opt(2,4))
 │         └── cost: 1228.81
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4,+2,-3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1226.18
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: -3 opt(2,4)]
 │    │    ├── best: (sort G2="[ordering: +2]")
 │    │    └── cost: 1178.64
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4)
 ├── G4: (first-agg G5)
 └── G5: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w, u DESC, v
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=-2,+3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4]
 │    │    ├── best: (distinct-on G2="[ordering: +4,-2,+3]" G3 cols=(4),ordering=-2,+3 opt(4))
 │    │    └── cost: 1257.20
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -2,+3 opt(4)]" G3 cols=(4),ordering=-2,+3 opt(4))
 │         └── cost: 1262.88
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4,-2,+3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1226.18
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: -2,+3 opt(4)]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1221.86
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w DESC, u DESC, v
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: -4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=-2,+3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: -4]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1281.18
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -2,+3 opt(4)]" G3 cols=(4),ordering=-2,+3 opt(4))
 │         └── cost: 1262.88
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: -2,+3 opt(4)]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1221.86
 │    ├── [ordering: -4,-2,+3]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1356.94
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w, u, v DESC
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=+2,-3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4]
 │    │    ├── best: (distinct-on G2="[ordering: +4,+2,-3]" G3 cols=(4),ordering=+2,-3 opt(4))
 │    │    └── cost: 1257.20
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +2,-3 opt(4)]" G3 cols=(4),ordering=+2,-3 opt(4))
 │         └── cost: 1262.88
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,-3 opt(4)]
 │    │    ├── best: (sort G2="[ordering: +2]")
 │    │    └── cost: 1221.86
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1095.41
 │    ├── [ordering: +4,+2,-3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1226.18
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1095.41
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

# Ensure that streaming ensure-distinct-on will be used.
memo
SELECT (SELECT w FROM kuvw WHERE v=1 AND x=u) FROM xyz ORDER BY x+1, x
----
memo (optimized, ~27KB, required=[presentation: w:12] [ordering: +13,+1])
 ├── G1: (project G2 G3 x)
 │    ├── [presentation: w:12] [ordering: +13,+1]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1421.77
 │    └── []
 │         ├── best: (project G2 G3 x)
 │         └── cost: 1161.33
 ├── G2: (ensure-distinct-on G4 G5 cols=(1)) (ensure-distinct-on G4 G5 cols=(1),ordering=+1)
 │    └── []
 │         ├── best: (ensure-distinct-on G4="[ordering: +1]" G5 cols=(1),ordering=+1)
 │         └── cost: 1131.32
 ├── G3: (projections G6 G7)
 ├── G4: (left-join G8 G9 G10) (right-join G9 G8 G10) (merge-join G8 G9 G11 left-join,+1,+7) (lookup-join G12 G11 kuvw@uvw,keyCols=[1 14],outCols=(1,7-9)) (lookup-join G13 G10 kuvw@vw,keyCols=[15],outCols=(1,7-9)) (merge-join G9 G8 G11 right-join,+7,+1)
 │    ├── [ordering: +1]
 │    │    ├── best: (merge-join G8="[ordering: +1]" G9="[ordering: +7 opt(8)]" G11 left-join,+1,+7)
 │    │    └── cost: 1101.30
 │    └── []
 │         ├── best: (merge-join G8="[ordering: +1]" G9="[ordering: +7 opt(8)]" G11 left-join,+1,+7)
 │         └── cost: 1101.30
 ├── G5: (aggregations G14)
 ├── G6: (variable kuvw.w)
 ├── G7: (plus G15 G16)
 ├── G8: (scan xyz,cols=(1)) (scan xyz@xy,cols=(1)) (scan xyz@zyx,cols=(1)) (scan xyz@yy,cols=(1))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan xyz@xy,cols=(1))
 │    │    └── cost: 1054.61
 │    └── []
 │         ├── best: (scan xyz@xy,cols=(1))
 │         └── cost: 1054.61
 ├── G9: (select G17 G18) (scan kuvw@vw,cols=(7-9),constrained)
 │    ├── [ordering: +7 opt(8)]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 26.58
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(7-9),constrained)
 │         └── cost: 25.41
 ├── G10: (filters G19)
 ├── G11: (filters)
 ├── G12: (project G8 G20 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G20 x)
 │    │    └── cost: 1074.62
 │    └── []
 │         ├── best: (project G8 G20 x)
 │         └── cost: 1074.62
 ├── G13: (project G8 G20 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G20 x)
 │    │    └── cost: 1074.62
 │    └── []
 │         ├── best: (project G8 G20 x)
 │         └── cost: 1074.62
 ├── G14: (const-agg G6)
 ├── G15: (variable x)
 ├── G16: (const 1)
 ├── G17: (scan kuvw,cols=(7-9)) (scan kuvw@uvw,cols=(7-9)) (scan kuvw@wvu,cols=(7-9)) (scan kuvw@vw,cols=(7-9)) (scan kuvw@w,cols=(7-9))
 │    ├── [ordering: +7]
 │    │    ├── best: (scan kuvw@uvw,cols=(7-9))
 │    │    └── cost: 1095.41
 │    └── []
 │         ├── best: (scan kuvw,cols=(7-9))
 │         └── cost: 1095.41
 ├── G18: (filters G21)
 ├── G19: (eq G15 G22)
 ├── G20: (projections G16)
 ├── G21: (eq G23 G16)
 ├── G22: (variable u)
 └── G23: (variable v)

# Ensure that streaming upsert-distinct-on will be used.
memo
INSERT INTO xyz SELECT v, w, 1.0 FROM kuvw ON CONFLICT (x) DO NOTHING
----
memo (optimized, ~21KB, required=[])
 ├── G1: (insert G2 G3 G4 xyz)
 │    └── []
 │         ├── best: (insert G2 G3 G4 xyz)
 │         └── cost: 2189.77
 ├── G2: (upsert-distinct-on G5 G6 cols=(8)) (upsert-distinct-on G5 G6 cols=(8),ordering=+8 opt(12))
 │    └── []
 │         ├── best: (upsert-distinct-on G5 G6 cols=(8))
 │         └── cost: 2189.76
 ├── G3: (unique-checks)
 ├── G4: (f-k-checks)
 ├── G5: (anti-join G7 G8 G9) (merge-join G7 G8 G10 anti-join,+8,+13) (lookup-join G7 G10 xyz,keyCols=[8],outCols=(8,9,12,13)) (lookup-join G7 G10 xyz@xy,keyCols=[8],outCols=(8,9,12,13))
 │    ├── [ordering: +8 opt(12)]
 │    │    ├── best: (merge-join G7="[ordering: +8 opt(12)]" G8="[ordering: +13]" G10 anti-join,+8,+13)
 │    │    └── cost: 2189.74
 │    └── []
 │         ├── best: (merge-join G7="[ordering: +8 opt(12)]" G8="[ordering: +13]" G10 anti-join,+8,+13)
 │         └── cost: 2189.74
 ├── G6: (aggregations G11 G12)
 ├── G7: (project G13 G14 v w)
 │    ├── [ordering: +8 opt(12)]
 │    │    ├── best: (project G13="[ordering: +8]" G14 v w)
 │    │    └── cost: 1105.22
 │    └── []
 │         ├── best: (project G13 G14 v w)
 │         └── cost: 1105.22
 ├── G8: (scan xyz,cols=(13)) (scan xyz@xy,cols=(13)) (scan xyz@zyx,cols=(13)) (scan xyz@yy,cols=(13))
 │    ├── [ordering: +13]
 │    │    ├── best: (scan xyz@xy,cols=(13))
 │    │    └── cost: 1054.61
 │    └── []
 │         ├── best: (scan xyz@xy,cols=(13))
 │         └── cost: 1054.61
 ├── G9: (filters G15)
 ├── G10: (filters)
 ├── G11: (first-agg G16)
 ├── G12: (first-agg G17)
 ├── G13: (scan kuvw,cols=(8,9)) (scan kuvw@uvw,cols=(8,9)) (scan kuvw@wvu,cols=(8,9)) (scan kuvw@vw,cols=(8,9)) (scan kuvw@w,cols=(8,9))
 │    ├── [ordering: +8]
 │    │    ├── best: (scan kuvw@vw,cols=(8,9))
 │    │    └── cost: 1085.21
 │    └── []
 │         ├── best: (scan kuvw,cols=(8,9))
 │         └── cost: 1085.21
 ├── G14: (projections G18)
 ├── G15: (eq G19 G20)
 ├── G16: (variable w)
 ├── G17: (variable "?column?")
 ├── G18: (const 1.0)
 ├── G19: (variable v)
 └── G20: (variable x)

# Ensure that streaming ensure-upsert-distinct-on will be used.
memo
INSERT INTO xyz SELECT v, w, 1.0 FROM kuvw ON CONFLICT (x) DO UPDATE SET z=2.0
----
memo (optimized, ~22KB, required=[])
 ├── G1: (upsert G2 G3 G4 xyz)
 │    └── []
 │         ├── best: (upsert G2 G3 G4 xyz)
 │         └── cost: 2280.48
 ├── G2: (project G5 G6 v w ?column? x y z)
 │    └── []
 │         ├── best: (project G5 G6 v w ?column? x y z)
 │         └── cost: 2280.47
 ├── G3: (unique-checks)
 ├── G4: (f-k-checks)
 ├── G5: (left-join G7 G8 G9) (right-join G8 G7 G9) (lookup-join G7 G10 xyz,keyCols=[8],outCols=(8,9,12-15)) (lookup-join G11 G10 xyz,keyCols=[13],outCols=(8,9,12-15)) (merge-join G8 G7 G10 right-join,+13,+8)
 │    └── []
 │         ├── best: (merge-join G8="[ordering: +13]" G7="[ordering: +8 opt(12)]" G10 right-join,+13,+8)
 │         └── cost: 2260.46
 ├── G6: (projections G12)
 ├── G7: (ensure-upsert-distinct-on G13 G14 cols=(8)) (ensure-upsert-distinct-on G13 G14 cols=(8),ordering=+8 opt(12))
 │    ├── [ordering: +8 opt(12)]
 │    │    ├── best: (ensure-upsert-distinct-on G13="[ordering: +8 opt(12)]" G14 cols=(8))
 │    │    └── cost: 1145.24
 │    └── []
 │         ├── best: (ensure-upsert-distinct-on G13="[ordering: +8 opt(12)]" G14 cols=(8),ordering=+8 opt(12))
 │         └── cost: 1145.24
 ├── G8: (scan xyz,cols=(13-15)) (scan xyz@zyx,cols=(13-15))
 │    ├── [ordering: +13]
 │    │    ├── best: (scan xyz,cols=(13-15))
 │    │    └── cost: 1085.21
 │    └── []
 │         ├── best: (scan xyz,cols=(13-15))
 │         └── cost: 1085.21
 ├── G9: (filters G15)
 ├── G10: (filters)
 ├── G11: (lookup-join G7 G10 xyz@xy,keyCols=[8],outCols=(8,9,12-14))
 │    └── []
 │         ├── best: (lookup-join G7 G10 xyz@xy,keyCols=[8],outCols=(8,9,12-14))
 │         └── cost: 7195.25
 ├── G12: (case G16 G17 G18)
 ├── G13: (project G19 G20 v w)
 │    ├── [ordering: +8 opt(12)]
 │    │    ├── best: (project G19="[ordering: +8]" G20 v w)
 │    │    └── cost: 1105.22
 │    └── []
 │         ├── best: (project G19 G20 v w)
 │         └── cost: 1105.22
 ├── G14: (aggregations G21 G22)
 ├── G15: (eq G23 G24)
 ├── G16: (true)
 ├── G17: (scalar-list G25)
 ├── G18: (const 2.0)
 ├── G19: (scan kuvw,cols=(8,9)) (scan kuvw@uvw,cols=(8,9)) (scan kuvw@wvu,cols=(8,9)) (scan kuvw@vw,cols=(8,9)) (scan kuvw@w,cols=(8,9))
 │    ├── [ordering: +8]
 │    │    ├── best: (scan kuvw@vw,cols=(8,9))
 │    │    └── cost: 1085.21
 │    └── []
 │         ├── best: (scan kuvw,cols=(8,9))
 │         └── cost: 1085.21
 ├── G20: (projections G26)
 ├── G21: (first-agg G27)
 ├── G22: (first-agg G28)
 ├── G23: (variable v)
 ├── G24: (variable x)
 ├── G25: (when G29 G28)
 ├── G26: (const 1.0)
 ├── G27: (variable w)
 ├── G28: (variable "?column?")
 ├── G29: (is G24 G30)
 └── G30: (null)

# ------------------------------------------------------------------------
# SplitGroupByScanIntoUnionScans + SplitGroupByFilteredScanIntoUnionScans
# ------------------------------------------------------------------------

exec-ddl
CREATE TABLE regional (
  r STRING NOT NULL CHECK (r IN ('east', 'west')),
  a INT NOT NULL,
  b INT NOT NULL,
  c FLOAT,
  d INT,
  e INT,
  UNIQUE (r, a, b) STORING (c),
  UNIQUE (r, d, e),
  UNIQUE INDEX partial_a (r, a) WHERE b > 0,
  UNIQUE INDEX partial_d (r, d) WHERE e = 1
)
----

exec-ddl
ALTER TABLE regional INJECT STATISTICS '[
  {
    "columns": ["r"],
    "distinct_count": 2,
    "row_count": 100000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["a"],
    "distinct_count": 100000,
    "row_count": 100000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["b"],
    "distinct_count": 100000,
    "row_count": 100000,
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "histo_col_type": "int",
    "histo_buckets": [
      {"num_eq": 0, "num_range": 0, "distinct_range": 0, "upper_bound": "0"},
      {"num_eq": 1, "num_range": 99999, "distinct_range": 99999, "upper_bound": "100000"}
    ]
  },
  {
    "columns": ["d"],
    "distinct_count": 100000,
    "row_count": 100000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  },
  {
    "columns": ["e"],
    "distinct_count": 2,
    "row_count": 100000,
    "created_at": "2018-01-01 1:00:00.00000+00:00"
  }
]'
----

# This query mimics the validation query for new unique constraints in REGIONAL
# BY ROW tables.
opt expect=SplitGroupByScanIntoUnionScans
SELECT a, b
FROM regional
GROUP BY a, b
HAVING count(*) > 1
LIMIT 1
----
project
 ├── columns: a:2!null b:3!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2,3)
 └── limit
      ├── columns: a:2!null b:3!null count_rows:10!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(2,3,10)
      ├── select
      │    ├── columns: a:2!null b:3!null count_rows:10!null
      │    ├── key: (2,3)
      │    ├── fd: (2,3)-->(10)
      │    ├── limit hint: 1.00
      │    ├── group-by
      │    │    ├── columns: a:2!null b:3!null count_rows:10!null
      │    │    ├── grouping columns: a:2!null b:3!null
      │    │    ├── internal-ordering: +2,+3
      │    │    ├── key: (2,3)
      │    │    ├── fd: (2,3)-->(10)
      │    │    ├── limit hint: 3.00
      │    │    ├── union-all
      │    │    │    ├── columns: a:2!null b:3!null
      │    │    │    ├── left columns: a:12 b:13
      │    │    │    ├── right columns: a:21 b:22
      │    │    │    ├── ordering: +2,+3
      │    │    │    ├── scan regional@secondary
      │    │    │    │    ├── columns: a:12!null b:13!null
      │    │    │    │    ├── constraint: /11/12/13: [/'east' - /'east']
      │    │    │    │    ├── key: (12,13)
      │    │    │    │    └── ordering: +12,+13
      │    │    │    └── scan regional@secondary
      │    │    │         ├── columns: a:21!null b:22!null
      │    │    │         ├── constraint: /20/21/22: [/'west' - /'west']
      │    │    │         ├── key: (21,22)
      │    │    │         └── ordering: +21,+22
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:10]
      │    └── filters
      │         └── count_rows:10 > 1 [outer=(10), constraints=(/10: [/2 - ]; tight)]
      └── 1

# This query mimics the validation query for new unique constraints in REGIONAL
# BY ROW tables for nullable columns.
opt expect=SplitGroupByFilteredScanIntoUnionScans
SELECT d, e
FROM regional
WHERE d IS NOT NULL AND e IS NOT NULL
GROUP BY d, e
HAVING count(*) > 1
LIMIT 1;
----
project
 ├── columns: d:5!null e:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(5,6)
 └── limit
      ├── columns: d:5!null e:6!null count_rows:10!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(5,6,10)
      ├── select
      │    ├── columns: d:5!null e:6!null count_rows:10!null
      │    ├── key: (5,6)
      │    ├── fd: (5,6)-->(10)
      │    ├── limit hint: 1.00
      │    ├── group-by
      │    │    ├── columns: d:5!null e:6!null count_rows:10!null
      │    │    ├── grouping columns: d:5!null e:6!null
      │    │    ├── internal-ordering: +5,+6
      │    │    ├── key: (5,6)
      │    │    ├── fd: (5,6)-->(10)
      │    │    ├── limit hint: 3.00
      │    │    ├── union-all
      │    │    │    ├── columns: d:5!null e:6!null
      │    │    │    ├── left columns: d:33 e:34
      │    │    │    ├── right columns: d:42 e:43
      │    │    │    ├── ordering: +5,+6
      │    │    │    ├── select
      │    │    │    │    ├── columns: d:33!null e:34!null
      │    │    │    │    ├── ordering: +33,+34
      │    │    │    │    ├── scan regional@secondary
      │    │    │    │    │    ├── columns: d:33!null e:34
      │    │    │    │    │    ├── constraint: /29/33/34: (/'east'/NULL - /'east']
      │    │    │    │    │    └── ordering: +33,+34
      │    │    │    │    └── filters
      │    │    │    │         └── e:34 IS NOT NULL [outer=(34), constraints=(/34: (/NULL - ]; tight)]
      │    │    │    └── select
      │    │    │         ├── columns: d:42!null e:43!null
      │    │    │         ├── ordering: +42,+43
      │    │    │         ├── scan regional@secondary
      │    │    │         │    ├── columns: d:42!null e:43
      │    │    │         │    ├── constraint: /38/42/43: (/'west'/NULL - /'west']
      │    │    │         │    └── ordering: +42,+43
      │    │    │         └── filters
      │    │    │              └── e:43 IS NOT NULL [outer=(43), constraints=(/43: (/NULL - ]; tight)]
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:10]
      │    └── filters
      │         └── count_rows:10 > 1 [outer=(10), constraints=(/10: [/2 - ]; tight)]
      └── 1

# This query mimics the validation query for new partial unique constraints in
# REGIONAL BY ROW tables.
opt expect=(SplitGroupByScanIntoUnionScans,EliminateIndexJoinOrProjectInsideGroupBy)
SELECT a
FROM regional
WHERE a IS NOT NULL AND b > 0
GROUP BY a
HAVING count(*) > 1
LIMIT 1
----
project
 ├── columns: a:2!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2)
 └── limit
      ├── columns: a:2!null count_rows:10!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(2,10)
      ├── select
      │    ├── columns: a:2!null count_rows:10!null
      │    ├── key: (2)
      │    ├── fd: (2)-->(10)
      │    ├── limit hint: 1.00
      │    ├── group-by
      │    │    ├── columns: a:2!null count_rows:10!null
      │    │    ├── grouping columns: a:2!null
      │    │    ├── internal-ordering: +2
      │    │    ├── key: (2)
      │    │    ├── fd: (2)-->(10)
      │    │    ├── limit hint: 3.00
      │    │    ├── union-all
      │    │    │    ├── columns: a:2!null rowid:7!null
      │    │    │    ├── left columns: a:48 rowid:53
      │    │    │    ├── right columns: a:57 rowid:62
      │    │    │    ├── ordering: +2
      │    │    │    ├── scan regional@partial_a,partial
      │    │    │    │    ├── columns: a:48!null rowid:53!null
      │    │    │    │    ├── constraint: /47/48: [/'east' - /'east']
      │    │    │    │    ├── key: (53)
      │    │    │    │    ├── fd: (53)-->(48), (48)-->(53)
      │    │    │    │    └── ordering: +48
      │    │    │    └── scan regional@partial_a,partial
      │    │    │         ├── columns: a:57!null rowid:62!null
      │    │    │         ├── constraint: /56/57: [/'west' - /'west']
      │    │    │         ├── key: (62)
      │    │    │         ├── fd: (62)-->(57), (57)-->(62)
      │    │    │         └── ordering: +57
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:10]
      │    └── filters
      │         └── count_rows:10 > 1 [outer=(10), constraints=(/10: [/2 - ]; tight)]
      └── 1

# This query mimics the validation query for new partial unique constraints in
# REGIONAL BY ROW tables.
opt expect=(SplitGroupByScanIntoUnionScans,EliminateIndexJoinOrProjectInsideGroupBy)
SELECT d
FROM regional
WHERE d IS NOT NULL AND e = 1
GROUP BY d
HAVING count(*) > 1
LIMIT 1
----
project
 ├── columns: d:5!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 └── limit
      ├── columns: d:5!null count_rows:10!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(5,10)
      ├── select
      │    ├── columns: d:5!null count_rows:10!null
      │    ├── key: (5)
      │    ├── fd: (5)-->(10)
      │    ├── limit hint: 1.00
      │    ├── group-by
      │    │    ├── columns: d:5!null count_rows:10!null
      │    │    ├── grouping columns: d:5!null
      │    │    ├── internal-ordering: +5
      │    │    ├── key: (5)
      │    │    ├── fd: (5)-->(10)
      │    │    ├── limit hint: 3.00
      │    │    ├── union-all
      │    │    │    ├── columns: d:5!null
      │    │    │    ├── left columns: d:51
      │    │    │    ├── right columns: d:60
      │    │    │    ├── ordering: +5
      │    │    │    ├── scan regional@partial_d,partial
      │    │    │    │    ├── columns: d:51!null
      │    │    │    │    ├── constraint: /47/51: (/'east'/NULL - /'east']
      │    │    │    │    └── ordering: +51
      │    │    │    └── scan regional@partial_d,partial
      │    │    │         ├── columns: d:60!null
      │    │    │         ├── constraint: /56/60: (/'west'/NULL - /'west']
      │    │    │         └── ordering: +60
      │    │    └── aggregations
      │    │         └── count-rows [as=count_rows:10]
      │    └── filters
      │         └── count_rows:10 > 1 [outer=(10), constraints=(/10: [/2 - ]; tight)]
      └── 1

# Rule applies for distinct-on.
opt expect=SplitGroupByScanIntoUnionScans
SELECT DISTINCT a, b
FROM regional
----
distinct-on
 ├── columns: a:2!null b:3!null
 ├── grouping columns: a:2!null b:3!null
 ├── internal-ordering: +2,+3
 ├── key: (2,3)
 └── union-all
      ├── columns: a:2!null b:3!null
      ├── left columns: a:11 b:12
      ├── right columns: a:20 b:21
      ├── ordering: +2,+3
      ├── scan regional@secondary
      │    ├── columns: a:11!null b:12!null
      │    ├── constraint: /10/11/12: [/'east' - /'east']
      │    ├── key: (11,12)
      │    └── ordering: +11,+12
      └── scan regional@secondary
           ├── columns: a:20!null b:21!null
           ├── constraint: /19/20/21: [/'west' - /'west']
           ├── key: (20,21)
           └── ordering: +20,+21

# Rule applies for distinct-on.
opt expect=SplitGroupByFilteredScanIntoUnionScans
SELECT DISTINCT a, b
FROM regional WHERE b > 5
----
distinct-on
 ├── columns: a:2!null b:3!null
 ├── grouping columns: a:2!null b:3!null
 ├── internal-ordering: +2,+3
 ├── key: (2,3)
 └── union-all
      ├── columns: a:2!null b:3!null
      ├── left columns: a:11 b:12
      ├── right columns: a:20 b:21
      ├── ordering: +2,+3
      ├── select
      │    ├── columns: a:11!null b:12!null
      │    ├── key: (11,12)
      │    ├── ordering: +11,+12
      │    ├── scan regional@secondary
      │    │    ├── columns: a:11!null b:12!null
      │    │    ├── constraint: /10/11/12: [/'east' - /'east']
      │    │    ├── key: (11,12)
      │    │    └── ordering: +11,+12
      │    └── filters
      │         └── b:12 > 5 [outer=(12), constraints=(/12: [/6 - ]; tight)]
      └── select
           ├── columns: a:20!null b:21!null
           ├── key: (20,21)
           ├── ordering: +20,+21
           ├── scan regional@secondary
           │    ├── columns: a:20!null b:21!null
           │    ├── constraint: /19/20/21: [/'west' - /'west']
           │    ├── key: (20,21)
           │    └── ordering: +20,+21
           └── filters
                └── b:21 > 5 [outer=(21), constraints=(/21: [/6 - ]; tight)]

# Rule applies for ensure-upsert-distinct-on.
opt expect=SplitGroupByScanIntoUnionScans
INSERT INTO xyz SELECT a, b, c FROM regional ON CONFLICT (x) DO UPDATE SET z=2.0
----
upsert xyz
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: x:15
 ├── fetch columns: x:15 y:16 z:17
 ├── insert-mapping:
 │    ├── a:7 => x:1
 │    ├── b:8 => y:2
 │    └── c:9 => z:3
 ├── update-mapping:
 │    └── upsert_z:23 => z:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_z:23 a:7!null b:8!null c:9 x:15 y:16 z:17
      ├── key: (7)
      ├── fd: (7)-->(8,9,15-17,23), (15)-->(16,17)
      ├── right-join (merge)
      │    ├── columns: a:7!null b:8!null c:9 x:15 y:16 z:17
      │    ├── left ordering: +15
      │    ├── right ordering: +7
      │    ├── key: (7)
      │    ├── fd: (7)-->(8,9,15-17), (15)-->(16,17)
      │    ├── scan xyz
      │    │    ├── columns: x:15!null y:16 z:17
      │    │    ├── key: (15)
      │    │    ├── fd: (15)-->(16,17)
      │    │    └── ordering: +15
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: a:7!null b:8!null c:9
      │    │    ├── grouping columns: a:7!null
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    ├── ordering: +7
      │    │    ├── union-all
      │    │    │    ├── columns: a:7!null b:8!null c:9
      │    │    │    ├── left columns: a:25 b:26 c:27
      │    │    │    ├── right columns: a:34 b:35 c:36
      │    │    │    ├── ordering: +7
      │    │    │    ├── scan regional@secondary
      │    │    │    │    ├── columns: a:25!null b:26!null c:27
      │    │    │    │    ├── constraint: /24/25/26: [/'east' - /'east']
      │    │    │    │    ├── key: (25,26)
      │    │    │    │    ├── fd: (25,26)-->(27)
      │    │    │    │    └── ordering: +25
      │    │    │    └── scan regional@secondary
      │    │    │         ├── columns: a:34!null b:35!null c:36
      │    │    │         ├── constraint: /33/34/35: [/'west' - /'west']
      │    │    │         ├── key: (34,35)
      │    │    │         ├── fd: (34,35)-->(36)
      │    │    │         └── ordering: +34
      │    │    └── aggregations
      │    │         ├── first-agg [as=b:8, outer=(8)]
      │    │         │    └── b:8
      │    │         └── first-agg [as=c:9, outer=(9)]
      │    │              └── c:9
      │    └── filters (true)
      └── projections
           └── CASE WHEN x:15 IS NULL THEN c:9 ELSE 2.0 END [as=upsert_z:23, outer=(9,15)]

# Rule applies for ensure-upsert-distinct-on.
opt expect=SplitGroupByFilteredScanIntoUnionScans
INSERT INTO xyz SELECT a, b, c FROM regional WHERE b > 5
ON CONFLICT (x) DO UPDATE SET z=2.0
----
upsert xyz
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: x:15
 ├── fetch columns: x:15 y:16 z:17
 ├── insert-mapping:
 │    ├── a:7 => x:1
 │    ├── b:8 => y:2
 │    └── c:9 => z:3
 ├── update-mapping:
 │    └── upsert_z:23 => z:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_z:23 a:7!null b:8!null c:9 x:15 y:16 z:17
      ├── key: (7)
      ├── fd: (7)-->(8,9,15-17,23), (15)-->(16,17)
      ├── right-join (merge)
      │    ├── columns: a:7!null b:8!null c:9 x:15 y:16 z:17
      │    ├── left ordering: +15
      │    ├── right ordering: +7
      │    ├── key: (7)
      │    ├── fd: (7)-->(8,9,15-17), (15)-->(16,17)
      │    ├── scan xyz
      │    │    ├── columns: x:15!null y:16 z:17
      │    │    ├── key: (15)
      │    │    ├── fd: (15)-->(16,17)
      │    │    └── ordering: +15
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: a:7!null b:8!null c:9
      │    │    ├── grouping columns: a:7!null
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8,9)
      │    │    ├── ordering: +7
      │    │    ├── union-all
      │    │    │    ├── columns: a:7!null b:8!null c:9
      │    │    │    ├── left columns: a:25 b:26 c:27
      │    │    │    ├── right columns: a:34 b:35 c:36
      │    │    │    ├── ordering: +7
      │    │    │    ├── select
      │    │    │    │    ├── columns: a:25!null b:26!null c:27
      │    │    │    │    ├── key: (25,26)
      │    │    │    │    ├── fd: (25,26)-->(27)
      │    │    │    │    ├── ordering: +25
      │    │    │    │    ├── scan regional@secondary
      │    │    │    │    │    ├── columns: a:25!null b:26!null c:27
      │    │    │    │    │    ├── constraint: /24/25/26: [/'east' - /'east']
      │    │    │    │    │    ├── key: (25,26)
      │    │    │    │    │    ├── fd: (25,26)-->(27)
      │    │    │    │    │    └── ordering: +25
      │    │    │    │    └── filters
      │    │    │    │         └── b:26 > 5 [outer=(26), constraints=(/26: [/6 - ]; tight)]
      │    │    │    └── select
      │    │    │         ├── columns: a:34!null b:35!null c:36
      │    │    │         ├── key: (34,35)
      │    │    │         ├── fd: (34,35)-->(36)
      │    │    │         ├── ordering: +34
      │    │    │         ├── scan regional@secondary
      │    │    │         │    ├── columns: a:34!null b:35!null c:36
      │    │    │         │    ├── constraint: /33/34/35: [/'west' - /'west']
      │    │    │         │    ├── key: (34,35)
      │    │    │         │    ├── fd: (34,35)-->(36)
      │    │    │         │    └── ordering: +34
      │    │    │         └── filters
      │    │    │              └── b:35 > 5 [outer=(35), constraints=(/35: [/6 - ]; tight)]
      │    │    └── aggregations
      │    │         ├── first-agg [as=b:8, outer=(8)]
      │    │         │    └── b:8
      │    │         └── first-agg [as=c:9, outer=(9)]
      │    │              └── c:9
      │    └── filters (true)
      └── projections
           └── CASE WHEN x:15 IS NULL THEN c:9 ELSE 2.0 END [as=upsert_z:23, outer=(9,15)]

# Order can be provided for the internal ordering of array_agg.
opt expect=SplitGroupByScanIntoUnionScans
SELECT a, array_agg(b)
FROM (SELECT * FROM regional ORDER BY b)
GROUP BY a
----
group-by
 ├── columns: a:2!null array_agg:10!null
 ├── grouping columns: a:2!null
 ├── internal-ordering: +2,+3
 ├── key: (2)
 ├── fd: (2)-->(10)
 ├── union-all
 │    ├── columns: a:2!null b:3!null
 │    ├── left columns: a:12 b:13
 │    ├── right columns: a:21 b:22
 │    ├── ordering: +2,+3
 │    ├── scan regional@secondary
 │    │    ├── columns: a:12!null b:13!null
 │    │    ├── constraint: /11/12/13: [/'east' - /'east']
 │    │    ├── key: (12,13)
 │    │    └── ordering: +12,+13
 │    └── scan regional@secondary
 │         ├── columns: a:21!null b:22!null
 │         ├── constraint: /20/21/22: [/'west' - /'west']
 │         ├── key: (21,22)
 │         └── ordering: +21,+22
 └── aggregations
      └── array-agg [as=array_agg:10, outer=(3)]
           └── b:3

# Order cannot be provided for the internal ordering of array_agg.
opt expect-not=SplitGroupByScanIntoUnionScans
SELECT a, array_agg(c)
FROM (SELECT * FROM regional ORDER BY c)
GROUP BY a
----
group-by
 ├── columns: a:2!null array_agg:10
 ├── grouping columns: a:2!null
 ├── internal-ordering: +4 opt(2)
 ├── key: (2)
 ├── fd: (2)-->(10)
 ├── sort
 │    ├── columns: a:2!null c:4
 │    ├── ordering: +4 opt(2) [actual: +4]
 │    └── scan regional@secondary
 │         └── columns: a:2!null c:4
 └── aggregations
      └── array-agg [as=array_agg:10, outer=(4)]
           └── c:4

# The first index column is a grouping column, so the rule doesn't apply.
opt expect-not=SplitGroupByScanIntoUnionScans
SELECT r, a
FROM regional
GROUP BY r, a
----
distinct-on
 ├── columns: r:1!null a:2!null
 ├── grouping columns: r:1!null a:2!null
 ├── internal-ordering: +1,+2
 ├── key: (1,2)
 └── scan regional@secondary
      ├── columns: r:1!null a:2!null
      └── ordering: +1,+2

# The first index column is an internal ordering column, so the rule doesn't apply.
opt expect-not=SplitGroupByScanIntoUnionScans
SELECT a, array_agg(r)
FROM (SELECT * FROM regional ORDER BY r)
GROUP BY a
----
group-by
 ├── columns: a:2!null array_agg:10!null
 ├── grouping columns: a:2!null
 ├── internal-ordering: +1 opt(2)
 ├── key: (2)
 ├── fd: (2)-->(10)
 ├── scan regional@secondary
 │    ├── columns: r:1!null a:2!null
 │    └── ordering: +1 opt(2) [actual: +1]
 └── aggregations
      └── array-agg [as=array_agg:10, outer=(1)]
           └── r:1

# ------------------------------------------------------------------------
# EliminateIndexJoinOrProjectInsideGroupBy
# ------------------------------------------------------------------------

exec-ddl
CREATE TABLE abcd (
  a INT,
  b FLOAT,
  c INT,
  d INT,
  INDEX partial_ab (a, b) WHERE c > 0,
  INDEX partial_cb (c, b) WHERE d = 1
)
----

# Rule applies for group-by.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
SELECT max(b), a FROM abcd WHERE c > 0 GROUP BY a
----
group-by
 ├── columns: max:8 a:1
 ├── grouping columns: a:1
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── scan abcd@partial_ab,partial
 │    ├── columns: a:1 b:2 rowid:5!null
 │    ├── key: (5)
 │    ├── fd: (5)-->(1,2)
 │    └── ordering: +1
 └── aggregations
      └── max [as=max:8, outer=(2)]
           └── b:2

# Rule applies for group-by.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
SELECT count(*), c FROM abcd WHERE d = 1 GROUP BY c
----
group-by
 ├── columns: count:8!null c:3
 ├── grouping columns: c:3
 ├── internal-ordering: +3
 ├── key: (3)
 ├── fd: (3)-->(8)
 ├── scan abcd@partial_cb,partial
 │    ├── columns: c:3
 │    └── ordering: +3
 └── aggregations
      └── count-rows [as=count_rows:8]

# Rule applies for distinct-on.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
SELECT DISTINCT a, b FROM abcd WHERE c > 0
----
distinct-on
 ├── columns: a:1 b:2
 ├── grouping columns: a:1 b:2
 ├── internal-ordering: +1,+2
 ├── key: (1,2)
 └── scan abcd@partial_ab,partial
      ├── columns: a:1 b:2 rowid:5!null
      ├── key: (5)
      ├── fd: (5)-->(1,2)
      └── ordering: +1,+2

# Rule applies for distinct-on.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
SELECT DISTINCT c FROM abcd WHERE d = 1
----
distinct-on
 ├── columns: c:3
 ├── grouping columns: c:3
 ├── internal-ordering: +3
 ├── key: (3)
 └── scan abcd@partial_cb,partial
      ├── columns: c:3
      └── ordering: +3

# Rule applies for ensure-upsert-distinct-on.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
INSERT INTO xyz SELECT a, a, b FROM abcd WHERE c > 0 ON CONFLICT (x) DO UPDATE SET z=2.0
----
upsert xyz
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: x:13
 ├── fetch columns: x:13 y:14 z:15
 ├── insert-mapping:
 │    ├── a:6 => x:1
 │    ├── a:6 => y:2
 │    └── b:7 => z:3
 ├── update-mapping:
 │    └── upsert_z:21 => z:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_z:21 a:6 b:7 x:13 y:14 z:15
      ├── lax-key: (6,13)
      ├── fd: (6)~~>(7), (13)-->(14,15), (6,13)~~>(7,21)
      ├── right-join (merge)
      │    ├── columns: a:6 b:7 x:13 y:14 z:15
      │    ├── left ordering: +13
      │    ├── right ordering: +6
      │    ├── lax-key: (6,13)
      │    ├── fd: (6)~~>(7), (13)-->(14,15)
      │    ├── scan xyz
      │    │    ├── columns: x:13!null y:14 z:15
      │    │    ├── key: (13)
      │    │    ├── fd: (13)-->(14,15)
      │    │    └── ordering: +13
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: a:6 b:7
      │    │    ├── grouping columns: a:6
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── lax-key: (6)
      │    │    ├── fd: (6)~~>(7)
      │    │    ├── ordering: +6
      │    │    ├── scan abcd@partial_ab,partial
      │    │    │    ├── columns: a:6 b:7 rowid:10!null
      │    │    │    ├── key: (10)
      │    │    │    ├── fd: (10)-->(6,7)
      │    │    │    └── ordering: +6
      │    │    └── aggregations
      │    │         └── first-agg [as=b:7, outer=(7)]
      │    │              └── b:7
      │    └── filters (true)
      └── projections
           └── CASE WHEN x:13 IS NULL THEN b:7 ELSE 2.0 END [as=upsert_z:21, outer=(7,13)]

# Rule applies for ensure-upsert-distinct-on.
opt expect=EliminateIndexJoinOrProjectInsideGroupBy
INSERT INTO xyz SELECT c, c, b FROM abcd WHERE d = 1 ON CONFLICT (x) DO UPDATE SET z=2.0
----
upsert xyz
 ├── columns: <none>
 ├── arbiter indexes: primary
 ├── canary column: x:13
 ├── fetch columns: x:13 y:14 z:15
 ├── insert-mapping:
 │    ├── c:8 => x:1
 │    ├── c:8 => y:2
 │    └── b:7 => z:3
 ├── update-mapping:
 │    └── upsert_z:21 => z:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_z:21 b:7 c:8 x:13 y:14 z:15
      ├── lax-key: (8,13)
      ├── fd: (8)~~>(7), (13)-->(14,15), (8,13)~~>(7,21)
      ├── left-join (lookup xyz)
      │    ├── columns: b:7 c:8 x:13 y:14 z:15
      │    ├── key columns: [8] = [13]
      │    ├── lookup columns are key
      │    ├── lax-key: (8,13)
      │    ├── fd: (8)~~>(7), (13)-->(14,15)
      │    ├── ensure-upsert-distinct-on
      │    │    ├── columns: b:7 c:8
      │    │    ├── grouping columns: c:8
      │    │    ├── internal-ordering: +8
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── lax-key: (8)
      │    │    ├── fd: (8)~~>(7)
      │    │    ├── scan abcd@partial_cb,partial
      │    │    │    ├── columns: b:7 c:8
      │    │    │    └── ordering: +8
      │    │    └── aggregations
      │    │         └── first-agg [as=b:7, outer=(7)]
      │    │              └── b:7
      │    └── filters (true)
      └── projections
           └── CASE WHEN x:13 IS NULL THEN b:7 ELSE 2.0 END [as=upsert_z:21, outer=(7,13)]

# Rule does not apply because c is used as a grouping column.
opt expect-not=EliminateIndexJoinOrProjectInsideGroupBy
SELECT max(b), c FROM abcd WHERE c > 0 GROUP BY c
----
group-by
 ├── columns: max:8 c:3!null
 ├── grouping columns: c:3!null
 ├── key: (3)
 ├── fd: (3)-->(8)
 ├── select
 │    ├── columns: b:2 c:3!null
 │    ├── scan abcd
 │    │    ├── columns: b:2 c:3
 │    │    └── partial index predicates
 │    │         ├── partial_ab: filters
 │    │         │    └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 │    │         └── partial_cb: filters
 │    │              └── d:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │    └── filters
 │         └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 └── aggregations
      └── max [as=max:8, outer=(2)]
           └── b:2

# Rule does not apply because d is used as a grouping column.
opt expect-not=EliminateIndexJoinOrProjectInsideGroupBy
SELECT count(*), d FROM abcd WHERE d = 1 GROUP BY d
----
group-by
 ├── columns: count:8!null d:4!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(4,8)
 ├── project
 │    ├── columns: d:4!null
 │    ├── fd: ()-->(4)
 │    ├── scan abcd@partial_cb,partial
 │    └── projections
 │         └── 1 [as=d:4]
 └── aggregations
      ├── count-rows [as=count_rows:8]
      └── const-agg [as=d:4, outer=(4)]
           └── d:4

# Rule does not apply because c is used in an aggregate.
opt expect-not=EliminateIndexJoinOrProjectInsideGroupBy
SELECT max(c), a FROM abcd WHERE c > 0 GROUP BY a
----
group-by
 ├── columns: max:8!null a:1
 ├── grouping columns: a:1
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── select
 │    ├── columns: a:1 c:3!null
 │    ├── scan abcd
 │    │    ├── columns: a:1 c:3
 │    │    └── partial index predicates
 │    │         ├── partial_ab: filters
 │    │         │    └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 │    │         └── partial_cb: filters
 │    │              └── d:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │    └── filters
 │         └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 └── aggregations
      └── max [as=max:8, outer=(3)]
           └── c:3

# Rule does not apply because d is used in an aggregate.
opt expect-not=EliminateIndexJoinOrProjectInsideGroupBy
SELECT max(d), c FROM abcd WHERE d = 1 GROUP BY c
----
group-by
 ├── columns: max:8!null c:3
 ├── grouping columns: c:3
 ├── internal-ordering: +3 opt(4)
 ├── key: (3)
 ├── fd: (3)-->(8)
 ├── project
 │    ├── columns: d:4!null c:3
 │    ├── fd: ()-->(4)
 │    ├── ordering: +3 opt(4) [actual: +3]
 │    ├── scan abcd@partial_cb,partial
 │    │    ├── columns: c:3
 │    │    └── ordering: +3
 │    └── projections
 │         └── 1 [as=d:4]
 └── aggregations
      └── max [as=max:8, outer=(4)]
           └── d:4

# Rule does not apply because c is needed for the ordering of array_agg.
opt expect-not=EliminateIndexJoinOrProjectInsideGroupBy
SELECT a, array_agg(b)
FROM (SELECT a, b FROM abcd WHERE c > 0 ORDER BY c)
GROUP BY a
----
group-by
 ├── columns: a:1 array_agg:8
 ├── grouping columns: a:1
 ├── internal-ordering: +3 opt(1)
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── sort
 │    ├── columns: a:1 b:2 c:3!null
 │    ├── ordering: +3 opt(1) [actual: +3]
 │    └── select
 │         ├── columns: a:1 b:2 c:3!null
 │         ├── scan abcd
 │         │    ├── columns: a:1 b:2 c:3
 │         │    └── partial index predicates
 │         │         ├── partial_ab: filters
 │         │         │    └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 │         │         └── partial_cb: filters
 │         │              └── d:4 = 1 [outer=(4), constraints=(/4: [/1 - /1]; tight), fd=()-->(4)]
 │         └── filters
 │              └── c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 └── aggregations
      └── array-agg [as=array_agg:8, outer=(2)]
           └── b:2
