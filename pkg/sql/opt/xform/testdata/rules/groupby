exec-ddl
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----

exec-ddl
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  INDEX yy (y)
)
----

exec-ddl
CREATE TABLE kuvw (
  k INT PRIMARY KEY,
  u INT,
  v INT,
  w INT,

  INDEX uvw(u,v,w),
  INDEX wvu(w,v,u),
  INDEX vw(v,w) STORING (u),
  INDEX w(w) STORING (u,v)
)
----

# --------------------------------------------------
# ReplaceScalarMinMaxWithLimit (Min variations)
# --------------------------------------------------

opt
SELECT min(a) FROM abc
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:6, outer=(1)]
           └── a:1

# Verify the rule still fires even if DISTINCT is used.
opt
SELECT min(DISTINCT a) FROM abc
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:6, outer=(1)]
           └── a:1

# Verify the rule does not fire when FILTER is used.
opt
SELECT min(a) FILTER (WHERE a > 'a') FROM abc
----
scalar-group-by
 ├── columns: min:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc
 │    ├── columns: a:1!null
 │    ├── constraint: /1: [/e'a\x00' - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:7, outer=(1)]
           └── a:1

opt
SELECT min(b) FROM abc
----
scalar-group-by
 ├── columns: min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc
 │    └── columns: b:2
 └── aggregations
      └── min [as=min:6, outer=(2)]
           └── b:2

opt
SELECT min(y) FROM xyz where z=7
----
scalar-group-by
 ├── columns: min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@zyx
 │    ├── columns: y:2!null z:3!null
 │    ├── constraint: /3/2/1: (/7.0/NULL - /7.0]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2,3)
 └── aggregations
      └── const-agg [as=min:5, outer=(2)]
           └── y:2

# ReplaceScalarMaxWithLimit has the same behavior with max() as
# the previous min() query because z is the prefix of a unique key
opt
SELECT max(y) FROM xyz where z=7
----
scalar-group-by
 ├── columns: max:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@zyx,rev
 │    ├── columns: y:2!null z:3!null
 │    ├── constraint: /3/2/1: (/7.0/NULL - /7.0]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(2,3)
 └── aggregations
      └── const-agg [as=max:5, outer=(2)]
           └── y:2

# We expect ReplaceScalarMinWithLimit not to be preferred here.
# This is because we know nothing about the ordering of y
# on the index xy after a scan on xy with x>7.
opt
SELECT min(y) FROM xyz@xy WHERE x>7
----
scalar-group-by
 ├── columns: min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── constraint: /1/2: [/8 - ]
 │    ├── flags: force-index=xy
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      └── min [as=min:5, outer=(2)]
           └── y:2

# We expect ReplaceMaxWithLimit not to be preferred here.
# This is because we know nothing about the ordering of y
# on the index xy after a scan on xy with x>7
opt
SELECT max(y) FROM xyz@xy WHERE x>7
----
scalar-group-by
 ├── columns: max:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── constraint: /1/2: [/8 - ]
 │    ├── flags: force-index=xy
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      └── max [as=max:5, outer=(2)]
           └── y:2

opt
SELECT max(x) FROM xyz
----
scalar-group-by
 ├── columns: max:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy,rev
 │    ├── columns: x:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:5, outer=(1)]
           └── x:1

opt
SELECT min(x) FROM xyz
----
scalar-group-by
 ├── columns: min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:5, outer=(1)]
           └── x:1

opt
SELECT min(x) FROM xyz WHERE x in (0, 4, 7)
----
scalar-group-by
 ├── columns: min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null
 │    ├── constraint: /1/2
 │    │    ├── [/0 - /0]
 │    │    ├── [/4 - /4]
 │    │    └── [/7 - /7]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=min:5, outer=(1)]
           └── x:1

opt
SELECT max(x) FROM xyz WHERE x in (0, 4, 7)
----
scalar-group-by
 ├── columns: max:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@xy,rev
 │    ├── columns: x:1!null
 │    ├── constraint: /1/2
 │    │    ├── [/0 - /0]
 │    │    ├── [/4 - /4]
 │    │    └── [/7 - /7]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:5, outer=(1)]
           └── x:1

opt
SELECT min(y) FROM xyz
----
scalar-group-by
 ├── columns: min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@yy
 │    ├── columns: y:2!null
 │    ├── constraint: /2/1: (/NULL - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2)
 └── aggregations
      └── const-agg [as=min:5, outer=(2)]
           └── y:2

opt
SELECT min(y), min(y) FROM xyz
----
scalar-group-by
 ├── columns: min:5 min:5
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan xyz@yy
 │    ├── columns: y:2!null
 │    ├── constraint: /2/1: (/NULL - ]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2)
 └── aggregations
      └── const-agg [as=min:5, outer=(2)]
           └── y:2

# ReplaceScalarMinWithLimit does not apply when there is
# a grouping column
opt
SELECT min(y) FROM xyz GROUP BY y
----
project
 ├── columns: min:5
 └── group-by
      ├── columns: y:2 min:5
      ├── grouping columns: y:2
      ├── internal-ordering: +2
      ├── key: (2)
      ├── fd: (2)-->(5)
      ├── scan xyz@yy
      │    ├── columns: y:2
      │    └── ordering: +2
      └── aggregations
           └── min [as=min:5, outer=(2)]
                └── y:2

# ReplaceScalarMaxWithLimit does not apply when there is
# a grouping column
opt
SELECT max(y) FROM xyz GROUP BY y
----
project
 ├── columns: max:5
 └── group-by
      ├── columns: y:2 max:5
      ├── grouping columns: y:2
      ├── internal-ordering: +2
      ├── key: (2)
      ├── fd: (2)-->(5)
      ├── scan xyz@yy
      │    ├── columns: y:2
      │    └── ordering: +2
      └── aggregations
           └── max [as=max:5, outer=(2)]
                └── y:2

# ReplaceScalarMinWithLimit does not apply when there is
# a grouping column
opt
SELECT min(y) FROM xyz GROUP BY x
----
project
 ├── columns: min:5
 └── group-by
      ├── columns: x:1!null min:5
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(5)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           └── min [as=min:5, outer=(2)]
                └── y:2

# ReplaceScalarMinWithLimit does not apply on multiple aggregations
# on different columns
opt
SELECT min(y), min(x) FROM xyz
----
scalar-group-by
 ├── columns: min:5 min:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5,6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      ├── min [as=min:5, outer=(2)]
      │    └── y:2
      └── min [as=min:6, outer=(1)]
           └── x:1


# ReplaceScalarMaxWithLimit does not apply on multiple aggregations
# on different columns
opt
SELECT max(y), max(x) FROM xyz
----
scalar-group-by
 ├── columns: max:5 max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5,6)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      ├── max [as=max:5, outer=(2)]
      │    └── y:2
      └── max [as=max:6, outer=(1)]
           └── x:1

# ReplaceScalarMinWithLimit does not apply with
# multiple grouping columns
opt
SELECT x,min(y) FROM xyz GROUP BY x,y
----
group-by
 ├── columns: x:1!null min:5
 ├── grouping columns: x:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 └── aggregations
      └── min [as=min:5, outer=(2)]
           └── y:2

# ReplaceScalarMaxWithLimit does not apply with
# multiple grouping columns
opt
SELECT x,max(y) FROM xyz GROUP BY x,y
----
group-by
 ├── columns: x:1!null max:5
 ├── grouping columns: x:1!null
 ├── internal-ordering: +1
 ├── key: (1)
 ├── fd: (1)-->(5)
 ├── scan xyz@xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 └── aggregations
      └── max [as=max:5, outer=(2)]
           └── y:2

# ReplaceScalarMinWithLimit does not apply to non-scalar
# aggregates
opt
SELECT min(x), count(y) FROM xyz GROUP BY x,y
----
project
 ├── columns: min:5!null count:6!null
 └── group-by
      ├── columns: x:1!null min:5!null count:6!null
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(5,6)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           ├── min [as=min:5, outer=(1)]
           │    └── x:1
           └── count [as=count:6, outer=(2)]
                └── y:2

# ReplaceScalarMaxWithLimit does not apply to non-scalar
# aggregates
opt
SELECT max(x), count(y) FROM xyz GROUP BY x,y
----
project
 ├── columns: max:5!null count:6!null
 └── group-by
      ├── columns: x:1!null max:5!null count:6!null
      ├── grouping columns: x:1!null
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(5,6)
      ├── scan xyz@xy
      │    ├── columns: x:1!null y:2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      └── aggregations
           ├── max [as=max:5, outer=(1)]
           │    └── x:1
           └── count [as=count:6, outer=(2)]
                └── y:2

memo
SELECT min(a) FROM abc
----
memo (optimized, ~5KB, required=[presentation: min:6])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: min:6]
 │         ├── best: (scalar-group-by G4 G5 cols=())
 │         └── cost: 5.10
 ├── G2: (scan abc,cols=(1))
 │    ├── [ordering: +1] [limit hint: 1.00]
 │    │    ├── best: (scan abc,cols=(1))
 │    │    └── cost: 5.06
 │    └── []
 │         ├── best: (scan abc,cols=(1))
 │         └── cost: 1064.51
 ├── G3: (aggregations G6)
 ├── G4: (limit G2 G7 ordering=+1) (scan abc,cols=(1),lim=1)
 │    └── []
 │         ├── best: (scan abc,cols=(1),lim=1)
 │         └── cost: 5.06
 ├── G5: (aggregations G8)
 ├── G6: (min G9)
 ├── G7: (const 1)
 ├── G8: (const-agg G9)
 └── G9: (variable a)

memo
SELECT min(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: min:6])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: min:6]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1074.54
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: +2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.84
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1064.51
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=+2)
 │    └── []
 │         ├── best: (limit G7="[ordering: +2] [limit hint: 1.00]" G8 ordering=+2)
 │         └── cost: 1293.89
 ├── G5: (aggregations G9)
 ├── G6: (min G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: +2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: +2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1293.87
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1074.53
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

memo
SELECT max(a) FROM abc
----
memo (optimized, ~5KB, required=[presentation: max:6])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:6]
 │         ├── best: (scalar-group-by G4 G5 cols=())
 │         └── cost: 5.10
 ├── G2: (scan abc,cols=(1))
 │    ├── [ordering: -1] [limit hint: 1.00]
 │    │    ├── best: (scan abc,rev,cols=(1))
 │    │    └── cost: 5.06
 │    └── []
 │         ├── best: (scan abc,cols=(1))
 │         └── cost: 1064.51
 ├── G3: (aggregations G6)
 ├── G4: (limit G2 G7 ordering=-1) (scan abc,rev,cols=(1),lim=1(rev))
 │    └── []
 │         ├── best: (scan abc,rev,cols=(1),lim=1(rev))
 │         └── cost: 5.06
 ├── G5: (aggregations G8)
 ├── G6: (max G9)
 ├── G7: (const 1)
 ├── G8: (const-agg G9)
 └── G9: (variable a)

memo
SELECT max(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: max:6])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:6]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1074.54
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: -2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.84
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1064.51
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=-2)
 │    └── []
 │         ├── best: (limit G7="[ordering: -2] [limit hint: 1.00]" G8 ordering=-2)
 │         └── cost: 1293.89
 ├── G5: (aggregations G9)
 ├── G6: (max G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: -2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: -2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1293.87
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1074.53
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

# --------------------------------------------------
# ReplaceScalarMinMaxWithLimit (Max variations)
# --------------------------------------------------

opt
SELECT max(a) FROM abc
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:6, outer=(1)]
           └── a:1

# Verify the rule still fires even if DISTINCT is used.
opt
SELECT max(DISTINCT a) FROM abc
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:6, outer=(1)]
           └── a:1

# Verify the rule does not fire when FILTER is used.
opt
SELECT max(a) FILTER (WHERE a > 'a') FROM abc
----
scalar-group-by
 ├── columns: max:7
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 ├── scan abc,rev
 │    ├── columns: a:1!null
 │    ├── constraint: /1: [/e'a\x00' - ]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1)
 └── aggregations
      └── const-agg [as=max:7, outer=(1)]
           └── a:1

opt
SELECT max(b) FROM abc
----
scalar-group-by
 ├── columns: max:6
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan abc
 │    └── columns: b:2
 └── aggregations
      └── max [as=max:6, outer=(2)]
           └── b:2

memo
SELECT max(b) FROM abc
----
memo (optimized, ~6KB, required=[presentation: max:6])
 ├── G1: (scalar-group-by G2 G3 cols=()) (scalar-group-by G4 G5 cols=())
 │    └── [presentation: max:6]
 │         ├── best: (scalar-group-by G2 G3 cols=())
 │         └── cost: 1074.54
 ├── G2: (scan abc,cols=(2))
 │    ├── [ordering: -2] [limit hint: 1.01]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1293.84
 │    └── []
 │         ├── best: (scan abc,cols=(2))
 │         └── cost: 1064.51
 ├── G3: (aggregations G6)
 ├── G4: (limit G7 G8 ordering=-2)
 │    └── []
 │         ├── best: (limit G7="[ordering: -2] [limit hint: 1.00]" G8 ordering=-2)
 │         └── cost: 1293.89
 ├── G5: (aggregations G9)
 ├── G6: (max G10)
 ├── G7: (select G2 G11)
 │    ├── [ordering: -2] [limit hint: 1.00]
 │    │    ├── best: (select G2="[ordering: -2] [limit hint: 1.01]" G11)
 │    │    └── cost: 1293.87
 │    └── []
 │         ├── best: (select G2 G11)
 │         └── cost: 1074.53
 ├── G8: (const 1)
 ├── G9: (const-agg G10)
 ├── G10: (variable b)
 ├── G11: (filters G12)
 ├── G12: (is-not G10 G13)
 └── G13: (null)

# --------------------------------------------------
# ReplaceMinWithLimit & ReplaceMaxWithLimit
# --------------------------------------------------

# Basic min case (min function must take non-null column).
opt expect=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE w = 5 GROUP BY w
----
project
 ├── columns: min:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@w
 │    ├── columns: k:1!null w:4!null
 │    ├── constraint: /4/1: [/5 - /5]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,4)
 └── projections
      └── k:1 [as=min:6, outer=(1)]

# Basic max case.
opt expect=ReplaceMaxWithLimit
SELECT max(w) FROM kuvw WHERE v = 5 GROUP BY v
----
project
 ├── columns: max:6
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@vw,rev
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(3,4)
 └── projections
      └── w:4 [as=max:6, outer=(4)]

# Add const_agg function, as well as min function.
opt expect=ReplaceMinWithLimit
SELECT v + 1, min(w), v FROM kuvw WHERE v = 5 AND w IS NOT NULL GROUP BY v
----
project
 ├── columns: "?column?":7!null min:6!null v:3!null
 ├── cardinality: [0 - 1]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(3,6,7)
 ├── project
 │    ├── columns: min:6!null v:3!null
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,6)
 │    ├── scan kuvw@vw
 │    │    ├── columns: v:3!null w:4!null
 │    │    ├── constraint: /3/4/1: (/5/NULL - /5]
 │    │    ├── limit: 1
 │    │    ├── key: ()
 │    │    └── fd: ()-->(3,4)
 │    └── projections
 │         └── w:4 [as=min:6, outer=(4)]
 └── projections
      └── v:3 + 1 [as="?column?":7, outer=(3), immutable]

# Add const_agg function, as well as max function.
opt expect=ReplaceMaxWithLimit
SELECT v + 1, max(w), v FROM kuvw WHERE v = 5 GROUP BY v
----
project
 ├── columns: "?column?":7!null max:6 v:3!null
 ├── cardinality: [0 - 1]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(3,6,7)
 ├── project
 │    ├── columns: max:6 v:3!null
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(3,6)
 │    ├── scan kuvw@vw,rev
 │    │    ├── columns: v:3!null w:4
 │    │    ├── constraint: /3/4/1: [/5 - /5]
 │    │    ├── limit: 1(rev)
 │    │    ├── key: ()
 │    │    └── fd: ()-->(3,4)
 │    └── projections
 │         └── w:4 [as=max:6, outer=(4)]
 └── projections
      └── v:3 + 1 [as="?column?":7, outer=(3), immutable]

# Use multiple grouping columns with min function.
opt expect=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: min:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=min:6, outer=(1)]

# Use multiple grouping columns with max function.
opt expect=ReplaceMaxWithLimit
SELECT max(k) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: max:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@vw,rev
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=max:6, outer=(1)]

# Use multiple grouping columns with min function, and project them.
opt expect=ReplaceMinWithLimit
SELECT v, min(k), w FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: v:3!null min:6!null w:4!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(3,4,6)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=min:6, outer=(1)]

# Use multiple grouping columns with max function, and project them.
opt expect=ReplaceMaxWithLimit
SELECT v, max(k), w FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: v:3!null max:6!null w:4!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(3,4,6)
 ├── scan kuvw@vw,rev
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: [/5/10 - /5/10]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(1,3,4)
 └── projections
      └── k:1 [as=max:6, outer=(1)]

# Multiple grouping columns, but different min column; use different index.
opt expect=ReplaceMinWithLimit
SELECT min(u) FROM kuvw WHERE v = 5 AND w = 10 AND u > 0 GROUP BY v, w
----
project
 ├── columns: min:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@wvu
 │    ├── columns: u:2!null v:3!null w:4!null
 │    ├── constraint: /4/3/2/1: [/10/5/1 - /10/5]
 │    ├── limit: 1
 │    ├── key: ()
 │    └── fd: ()-->(2-4)
 └── projections
      └── u:2 [as=min:6, outer=(2)]

# Multiple grouping columns, but different max column; use different index.
opt expect=ReplaceMaxWithLimit
SELECT max(u) FROM kuvw WHERE v = 5 AND w = 10 GROUP BY v, w
----
project
 ├── columns: max:6
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@wvu,rev
 │    ├── columns: u:2 v:3!null w:4!null
 │    ├── constraint: /4/3/2/1: [/10/5 - /10/5]
 │    ├── limit: 1(rev)
 │    ├── key: ()
 │    └── fd: ()-->(2-4)
 └── projections
      └── u:2 [as=max:6, outer=(2)]

# One of grouping columns is not constant, with min function.
opt expect-not=ReplaceMinWithLimit
SELECT min(k) FROM kuvw WHERE v = 5 GROUP BY v, w
----
project
 ├── columns: min:6!null
 └── group-by
      ├── columns: w:4 min:6!null
      ├── grouping columns: w:4
      ├── internal-ordering: +4 opt(3)
      ├── key: (4)
      ├── fd: (4)-->(6)
      ├── scan kuvw@vw
      │    ├── columns: k:1!null v:3!null w:4
      │    ├── constraint: /3/4/1: [/5 - /5]
      │    ├── key: (1)
      │    ├── fd: ()-->(3), (1)-->(4)
      │    └── ordering: +4 opt(3) [actual: +4]
      └── aggregations
           └── min [as=min:6, outer=(1)]
                └── k:1

# One of grouping columns is not constant, with max function.
opt expect-not=ReplaceMaxWithLimit
SELECT max(k) FROM kuvw WHERE v = 5 GROUP BY v, w
----
project
 ├── columns: max:6!null
 └── group-by
      ├── columns: w:4 max:6!null
      ├── grouping columns: w:4
      ├── internal-ordering: +4 opt(3)
      ├── key: (4)
      ├── fd: (4)-->(6)
      ├── scan kuvw@vw
      │    ├── columns: k:1!null v:3!null w:4
      │    ├── constraint: /3/4/1: [/5 - /5]
      │    ├── key: (1)
      │    ├── fd: ()-->(3), (1)-->(4)
      │    └── ordering: +4 opt(3) [actual: +4]
      └── aggregations
           └── max [as=max:6, outer=(1)]
                └── k:1

# We expect ReplaceMinWithLimit not to be preferred here.
# This is because we know nothing about the ordering of w
# on the index vw after a scan on vw with v>5.
opt expect-not=ReplaceMinWithLimit
SELECT min(w) FROM kuvw WHERE v > 5 AND w IS NOT NULL GROUP BY v
----
project
 ├── columns: min:6!null
 └── group-by
      ├── columns: v:3!null min:6!null
      ├── grouping columns: v:3!null
      ├── internal-ordering: +3
      ├── key: (3)
      ├── fd: (3)-->(6)
      ├── select
      │    ├── columns: v:3!null w:4!null
      │    ├── ordering: +3
      │    ├── scan kuvw@vw
      │    │    ├── columns: v:3!null w:4
      │    │    ├── constraint: /3/4/1: (/6/NULL - ]
      │    │    └── ordering: +3
      │    └── filters
      │         └── w:4 IS NOT NULL [outer=(4), constraints=(/4: (/NULL - ]; tight)]
      └── aggregations
           └── min [as=min:6, outer=(4)]
                └── w:4

# We expect ReplaceMaxWithLimit not to be preferred here.
# This is because we know nothing about the ordering of w
# on the index vw after a scan on vw with v>5.
opt expect-not=ReplaceMaxWithLimit
SELECT max(w) FROM kuvw WHERE v > 5 GROUP BY v
----
project
 ├── columns: max:6
 └── group-by
      ├── columns: v:3!null max:6
      ├── grouping columns: v:3!null
      ├── internal-ordering: +3
      ├── key: (3)
      ├── fd: (3)-->(6)
      ├── scan kuvw@vw
      │    ├── columns: v:3!null w:4
      │    ├── constraint: /3/4/1: [/6 - ]
      │    └── ordering: +3
      └── aggregations
           └── max [as=max:6, outer=(4)]
                └── w:4

# ReplaceMinWithLimit does not apply on multiple aggregations
# on different columns
opt expect-not=ReplaceMinWithLimit
SELECT min(w), min(k) FROM kuvw WHERE v = 5 AND w IS NOT NULL GROUP BY v
----
group-by
 ├── columns: min:6!null min:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4!null
 │    ├── constraint: /3/4/1: (/5/NULL - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(3), (1)-->(4)
 └── aggregations
      ├── min [as=min:6, outer=(4)]
      │    └── w:4
      └── min [as=min:7, outer=(1)]
           └── k:1

# ReplaceMaxWithLimit does not apply on multiple aggregations
# on different columns
opt expect-not=ReplaceMaxWithLimit
SELECT max(w), max(k) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: max:6 max:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan kuvw@vw
 │    ├── columns: k:1!null v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(3), (1)-->(4)
 └── aggregations
      ├── max [as=max:6, outer=(4)]
      │    └── w:4
      └── max [as=max:7, outer=(1)]
           └── k:1

# ReplaceMinWithLimit does not apply when other aggregates are present.
opt expect-not=ReplaceMinWithLimit
SELECT min(k), max(k) FROM kuvw WHERE w = 5 GROUP BY w
----
group-by
 ├── columns: min:6!null max:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan kuvw@wvu
 │    ├── columns: k:1!null w:4!null
 │    ├── constraint: /4/3/2/1: [/5 - /5]
 │    ├── key: (1)
 │    └── fd: ()-->(4)
 └── aggregations
      ├── min [as=min:6, outer=(1)]
      │    └── k:1
      └── max [as=max:7, outer=(1)]
           └── k:1

# ReplaceMaxWithLimit does not apply when other aggregates are present.
opt expect-not=ReplaceMaxWithLimit
SELECT max(w), count(w) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: max:6 count:7!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan kuvw@vw
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    └── fd: ()-->(3)
 └── aggregations
      ├── max [as=max:6, outer=(4)]
      │    └── w:4
      └── count [as=count:7, outer=(4)]
           └── w:4

# min/max functions are not symmetric because of NULL ordering (NULL values
# always sort first, which interferes with MIN calculation). Ensure that min
# function on nullable column does not trigger ReplaceMinWithLimit.
opt expect-not=ReplaceMinWithLimit
SELECT min(w) FROM kuvw WHERE v = 5 GROUP BY v
----
group-by
 ├── columns: min:6
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scan kuvw@vw
 │    ├── columns: v:3!null w:4
 │    ├── constraint: /3/4/1: [/5 - /5]
 │    └── fd: ()-->(3)
 └── aggregations
      └── min [as=min:6, outer=(4)]
           └── w:4

# --------------------------------------------------
# GenerateStreamingGroupBy
# --------------------------------------------------

# All index orderings can be used.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY w) GROUP BY u,v
----
memo (optimized, ~7KB, required=[presentation: array_agg:6])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:6]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1134.74
 ├── G2: (group-by G4 G5 cols=(2,3),ordering=+4 opt(2,3)) (group-by G4 G5 cols=(2,3),ordering=+2,+3,+4) (group-by G4 G5 cols=(2,3),ordering=+4,+3,+2) (group-by G4 G5 cols=(2,3),ordering=+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+3,+4]" G5 cols=(2,3),ordering=+2,+3,+4)
 │         └── cost: 1124.73
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4 opt(2,3)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)

# All index orderings can be used (note that +w is redundant with +w,+v+,u).
memo
SELECT sum(w) FROM kuvw GROUP BY u,v,w
----
memo (optimized, ~6KB, required=[presentation: sum:6])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:6]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1144.74
 ├── G2: (group-by G4 G5 cols=(2-4)) (group-by G4 G5 cols=(2-4),ordering=+2,+3,+4) (group-by G4 G5 cols=(2-4),ordering=+4,+3,+2) (group-by G4 G5 cols=(2-4),ordering=+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+3,+4]" G5 cols=(2-4),ordering=+2,+3,+4)
 │         └── cost: 1134.73
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G5: (aggregations G6)
 ├── G6: (sum G7)
 └── G7: (variable w)

# Only index ordering +v,+w can be used (as +v).
memo
SELECT sum(w) FROM kuvw GROUP BY v
----
memo (optimized, ~6KB, required=[presentation: sum:6])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:6]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1096.64
 ├── G2: (group-by G4 G5 cols=(3)) (group-by G4 G5 cols=(3),ordering=+3)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +3]" G5 cols=(3),ordering=+3)
 │         └── cost: 1095.63
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(3,4)) (scan kuvw@uvw,cols=(3,4)) (scan kuvw@wvu,cols=(3,4)) (scan kuvw@vw,cols=(3,4)) (scan kuvw@w,cols=(3,4))
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(3,4))
 │    │    └── cost: 1074.61
 │    └── []
 │         ├── best: (scan kuvw,cols=(3,4))
 │         └── cost: 1074.61
 ├── G5: (aggregations G6)
 ├── G6: (sum G7)
 └── G7: (variable w)

# Only ordering +u,+v,+w can be used.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY u,w) GROUP BY v
----
memo (optimized, ~7KB, required=[presentation: array_agg:6])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:6]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1116.74
 ├── G2: (group-by G4 G5 cols=(3),ordering=+2,+4 opt(3)) (group-by G4 G5 cols=(3),ordering=+2,+3,+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +2,+4 opt(3)]" G5 cols=(3),ordering=+2,+4 opt(3))
 │         └── cost: 1115.73
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +2,+4 opt(3)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)

# Verify the orderings are simplified.
memo
SELECT array_agg(k) FROM (SELECT * FROM kuvw WHERE u=v ORDER BY u) GROUP BY w
----
memo (optimized, ~12KB, required=[presentation: array_agg:6])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:6]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1083.64
 ├── G2: (group-by G4 G5 cols=(4),ordering=+(2|3) opt(4)) (group-by G4 G5 cols=(4),ordering=+(2|3)) (group-by G4 G5 cols=(4),ordering=+4,+(2|3)) (group-by G4 G5 cols=(4),ordering=+(2|3),+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +(2|3) opt(4)]" G5 cols=(4),ordering=+(2|3) opt(4))
 │         └── cost: 1083.54
 ├── G3: (projections)
 ├── G4: (select G6 G7) (select G8 G7) (select G9 G7)
 │    ├── [ordering: +(2|3) opt(4)]
 │    │    ├── best: (select G8="[ordering: +2 opt(4)]" G7)
 │    │    └── cost: 1083.13
 │    ├── [ordering: +(2|3),+4]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1084.42
 │    ├── [ordering: +(2|3)]
 │    │    ├── best: (select G8="[ordering: +2]" G7)
 │    │    └── cost: 1083.13
 │    ├── [ordering: +4,+(2|3)]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1084.42
 │    └── []
 │         ├── best: (select G8 G7)
 │         └── cost: 1083.13
 ├── G5: (aggregations G10)
 ├── G6: (scan kuvw,cols=(1-4)) (scan kuvw@uvw,cols=(1-4)) (scan kuvw@wvu,cols=(1-4)) (scan kuvw@vw,cols=(1-4)) (scan kuvw@w,cols=(1-4))
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1094.81
 │    ├── [ordering: +2,+4]
 │    │    ├── best: (sort G6="[ordering: +2]")
 │    │    └── cost: 1231.26
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1094.81
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G6="[ordering: +4]")
 │    │    └── cost: 1231.26
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(1-4))
 │    │    └── cost: 1094.81
 │    └── []
 │         ├── best: (scan kuvw,cols=(1-4))
 │         └── cost: 1094.81
 ├── G7: (filters G11)
 ├── G8: (scan kuvw@uvw,cols=(1-4),constrained)
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1073.21
 │    ├── [ordering: +2,+4]
 │    │    ├── best: (sort G8="[ordering: +2]")
 │    │    └── cost: 1208.01
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1073.21
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1340.50
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1329.66
 │    └── []
 │         ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │         └── cost: 1073.21
 ├── G9: (scan kuvw@vw,cols=(1-4),constrained)
 │    ├── [ordering: +2 opt(4)]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1329.66
 │    ├── [ordering: +2,+4]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1340.50
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1329.66
 │    ├── [ordering: +4,+2]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1340.50
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1329.66
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │         └── cost: 1073.21
 ├── G10: (array-agg G12)
 ├── G11: (eq G13 G14)
 ├── G12: (variable k)
 ├── G13: (variable u)
 └── G14: (variable v)

memo
SELECT sum(k) FROM (SELECT * FROM kuvw WHERE u=v) GROUP BY u,w
----
memo (optimized, ~12KB, required=[presentation: sum:6])
 ├── G1: (project G2 G3 sum)
 │    └── [presentation: sum:6]
 │         ├── best: (project G2 G3 sum)
 │         └── cost: 1083.70
 ├── G2: (group-by G4 G5 cols=(2,4)) (group-by G4 G5 cols=(2,4),ordering=+(2|3)) (group-by G4 G5 cols=(2,4),ordering=+4)
 │    └── []
 │         ├── best: (group-by G4="[ordering: +(2|3)]" G5 cols=(2,4),ordering=+(2|3))
 │         └── cost: 1083.59
 ├── G3: (projections)
 ├── G4: (select G6 G7) (select G8 G7) (select G9 G7)
 │    ├── [ordering: +(2|3)]
 │    │    ├── best: (select G8="[ordering: +2]" G7)
 │    │    └── cost: 1083.13
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1084.37
 │    └── []
 │         ├── best: (select G8 G7)
 │         └── cost: 1083.13
 ├── G5: (aggregations G10)
 ├── G6: (scan kuvw,cols=(1-4)) (scan kuvw@uvw,cols=(1-4)) (scan kuvw@wvu,cols=(1-4)) (scan kuvw@vw,cols=(1-4)) (scan kuvw@w,cols=(1-4))
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4))
 │    │    └── cost: 1094.81
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(1-4))
 │    │    └── cost: 1094.81
 │    └── []
 │         ├── best: (scan kuvw,cols=(1-4))
 │         └── cost: 1094.81
 ├── G7: (filters G11)
 ├── G8: (scan kuvw@uvw,cols=(1-4),constrained)
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │    │    └── cost: 1073.21
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G8)
 │    │    └── cost: 1329.66
 │    └── []
 │         ├── best: (scan kuvw@uvw,cols=(1-4),constrained)
 │         └── cost: 1073.21
 ├── G9: (scan kuvw@vw,cols=(1-4),constrained)
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1329.66
 │    ├── [ordering: +4]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 1329.66
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(1-4),constrained)
 │         └── cost: 1073.21
 ├── G10: (sum G12)
 ├── G11: (eq G13 G14)
 ├── G12: (variable k)
 ├── G13: (variable u)
 └── G14: (variable v)

# Ensure that we don't incorrectly use orderings that don't match the direction.
memo
SELECT array_agg(w) FROM (SELECT * FROM kuvw ORDER BY w DESC) GROUP BY u,v
----
memo (optimized, ~6KB, required=[presentation: array_agg:6])
 ├── G1: (project G2 G3 array_agg)
 │    └── [presentation: array_agg:6]
 │         ├── best: (project G2 G3 array_agg)
 │         └── cost: 1245.54
 ├── G2: (group-by G4 G5 cols=(2,3),ordering=-4 opt(2,3))
 │    └── []
 │         ├── best: (group-by G4="[ordering: -4 opt(2,3)]" G5 cols=(2,3),ordering=-4 opt(2,3))
 │         └── cost: 1235.53
 ├── G3: (projections)
 ├── G4: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: -4 opt(2,3)]
 │    │    ├── best: (scan kuvw@uvw,rev,cols=(2-4))
 │    │    └── cost: 1185.51
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G5: (aggregations G6)
 ├── G6: (array-agg G7)
 └── G7: (variable w)


# All orderings can be used (note that +w is redundant with +w,+v,+u).
memo
SELECT DISTINCT u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2-4)) (distinct-on G2 G3 cols=(2-4),ordering=+2,+3,+4) (distinct-on G2 G3 cols=(2-4),ordering=+4,+3,+2) (distinct-on G2 G3 cols=(2-4),ordering=+3,+4)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2-4),ordering=+2,+3,+4)
 │         └── cost: 1124.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4,+3,+2]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 └── G3: (aggregations)

# Orderings +u,+v and +v can be used.
memo
SELECT DISTINCT ON (u, v) u, v, w FROM kuvw
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2,3)) (distinct-on G2 G3 cols=(2,3),ordering=+2,+3) (distinct-on G2 G3 cols=(2,3),ordering=+3)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2,+3]" G3 cols=(2,3),ordering=+2,+3)
 │         └── cost: 1124.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4)
 ├── G4: (first-agg G5)
 └── G5: (variable w)

# Only ordering +u can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(2)) (distinct-on G2 G3 cols=(2),ordering=+2)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +2]" G3 cols=(2),ordering=+2)
 │         └── cost: 1115.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Only ordering +v can be used.
memo
SELECT DISTINCT ON (v) u, v, w FROM kuvw
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(3)) (distinct-on G2 G3 cols=(3),ordering=+3)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +3]" G3 cols=(3),ordering=+3)
 │         └── cost: 1115.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +3]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable w)

# Only ordering +w can be used.
memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4])
 ├── G1: (distinct-on G2 G3 cols=(4)) (distinct-on G2 G3 cols=(4),ordering=+4)
 │    └── [presentation: u:2,v:3,w:4]
 │         ├── best: (distinct-on G2="[ordering: +4]" G3 cols=(4),ordering=+4)
 │         └── cost: 1115.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

# Only ordering +u can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw ORDER BY u, w
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +2])
 ├── G1: (distinct-on G2 G3 cols=(2),ordering=+4 opt(2)) (distinct-on G2 G3 cols=(2),ordering=+4)
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +2]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1144.03
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +4 opt(2)]" G3 cols=(2),ordering=+4 opt(2))
 │         └── cost: 1125.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+4]
 │    │    ├── best: (sort G2="[ordering: +2]")
 │    │    └── cost: 1211.16
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4 opt(2)]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Only ordering +u,+v,+w can be used.
memo
SELECT DISTINCT ON (u) u, v, w FROM kuvw ORDER BY u, v, w
----
memo (optimized, ~5KB, required=[presentation: u:2,v:3,w:4] [ordering: +2])
 ├── G1: (distinct-on G2 G3 cols=(2),ordering=+3,+4 opt(2)) (distinct-on G2 G3 cols=(2),ordering=+2,+3,+4) (distinct-on G2 G3 cols=(2),ordering=+3,+4)
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +2]
 │    │    ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2),ordering=+3,+4 opt(2))
 │    │    └── cost: 1115.73
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +2,+3,+4]" G3 cols=(2),ordering=+2,+3,+4)
 │         └── cost: 1115.73
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,+3,+4]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3,+4 opt(2)]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +3,+4]
 │    │    ├── best: (scan kuvw@vw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable v)
 └── G7: (variable w)

# Ensure that we don't incorrectly use orderings that don't match the direction.
memo
SELECT DISTINCT ON (w, u) u, v, w FROM kuvw ORDER BY w, u, v DESC
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4,+2])
 ├── G1: (distinct-on G2 G3 cols=(2,4),ordering=-3 opt(2,4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4,+2]
 │    │    ├── best: (distinct-on G2="[ordering: +4,+2,-3]" G3 cols=(2,4),ordering=-3 opt(2,4))
 │    │    └── cost: 1255.50
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -3 opt(2,4)]" G3 cols=(2,4),ordering=-3 opt(2,4))
 │         └── cost: 1235.53
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4,+2,-3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1215.48
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: -3 opt(2,4)]
 │    │    ├── best: (scan kuvw@uvw,rev,cols=(2-4))
 │    │    └── cost: 1185.51
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4)
 ├── G4: (first-agg G5)
 └── G5: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w, u DESC, v
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=-2,+3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4]
 │    │    ├── best: (distinct-on G2="[ordering: +4,-2,+3]" G3 cols=(4),ordering=-2,+3 opt(4))
 │    │    └── cost: 1246.50
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -2,+3 opt(4)]" G3 cols=(4),ordering=-2,+3 opt(4))
 │         └── cost: 1386.02
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +4,-2,+3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1215.48
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: -2,+3 opt(4)]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1345.00
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w DESC, u DESC, v
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: -4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=-2,+3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: -4]
 │    │    ├── best: (distinct-on G2="[ordering: -4,-2,+3]" G3 cols=(4),ordering=-2,+3 opt(4))
 │    │    └── cost: 1377.12
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: -2,+3 opt(4)]" G3 cols=(4),ordering=-2,+3 opt(4))
 │         └── cost: 1386.02
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: -2,+3 opt(4)]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1345.00
 │    ├── [ordering: -4,-2,+3]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1346.10
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

memo
SELECT DISTINCT ON (w) u, v, w FROM kuvw ORDER BY w, u, v DESC
----
memo (optimized, ~4KB, required=[presentation: u:2,v:3,w:4] [ordering: +4])
 ├── G1: (distinct-on G2 G3 cols=(4),ordering=+2,-3 opt(4))
 │    ├── [presentation: u:2,v:3,w:4] [ordering: +4]
 │    │    ├── best: (distinct-on G2="[ordering: +4,+2,-3]" G3 cols=(4),ordering=+2,-3 opt(4))
 │    │    └── cost: 1246.50
 │    └── []
 │         ├── best: (distinct-on G2="[ordering: +2,-3 opt(4)]" G3 cols=(4),ordering=+2,-3 opt(4))
 │         └── cost: 1252.18
 ├── G2: (scan kuvw,cols=(2-4)) (scan kuvw@uvw,cols=(2-4)) (scan kuvw@wvu,cols=(2-4)) (scan kuvw@vw,cols=(2-4)) (scan kuvw@w,cols=(2-4))
 │    ├── [ordering: +2,-3 opt(4)]
 │    │    ├── best: (sort G2="[ordering: +2]")
 │    │    └── cost: 1211.16
 │    ├── [ordering: +2]
 │    │    ├── best: (scan kuvw@uvw,cols=(2-4))
 │    │    └── cost: 1084.71
 │    ├── [ordering: +4,+2,-3]
 │    │    ├── best: (sort G2="[ordering: +4]")
 │    │    └── cost: 1215.48
 │    ├── [ordering: +4]
 │    │    ├── best: (scan kuvw@wvu,cols=(2-4))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(2-4))
 │         └── cost: 1084.71
 ├── G3: (aggregations G4 G5)
 ├── G4: (first-agg G6)
 ├── G5: (first-agg G7)
 ├── G6: (variable u)
 └── G7: (variable v)

# Ensure that streaming ensure-distinct-on will be used.
memo
SELECT (SELECT w FROM kuvw WHERE v=1 AND x=u) FROM xyz ORDER BY x+1, x
----
memo (optimized, ~37KB, required=[presentation: w:10] [ordering: +11,+1])
 ├── G1: (project G2 G3 x)
 │    ├── [presentation: w:10] [ordering: +11,+1]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1400.63
 │    └── []
 │         ├── best: (project G2 G3 x)
 │         └── cost: 1140.33
 ├── G2: (ensure-distinct-on G4 G5 cols=(1)) (ensure-distinct-on G4 G5 cols=(1),ordering=+1)
 │    └── []
 │         ├── best: (ensure-distinct-on G4="[ordering: +1]" G5 cols=(1),ordering=+1)
 │         └── cost: 1110.32
 ├── G3: (projections G6 G7)
 ├── G4: (left-join G8 G9 G10) (left-join G8 G9 G10) (right-join G9 G8 G10) (merge-join G8 G9 G11 left-join,+1,+6) (lookup-join G12 G11 kuvw@uvw,keyCols=[1 12],outCols=(1,6-8)) (lookup-join G13 G10 kuvw@vw,keyCols=[13],outCols=(1,6-8)) (right-join G9 G8 G10) (merge-join G8 G9 G11 left-join,+1,+6) (lookup-join G14 G11 kuvw@uvw,keyCols=[1 14],outCols=(1,6-8)) (lookup-join G15 G10 kuvw@vw,keyCols=[15],outCols=(1,6-8)) (merge-join G9 G8 G11 right-join,+6,+1) (merge-join G9 G8 G11 right-join,+6,+1)
 │    ├── [ordering: +1]
 │    │    ├── best: (merge-join G8="[ordering: +1]" G9="[ordering: +6 opt(7)]" G11 left-join,+1,+6)
 │    │    └── cost: 1080.30
 │    └── []
 │         ├── best: (merge-join G8="[ordering: +1]" G9="[ordering: +6 opt(7)]" G11 left-join,+1,+6)
 │         └── cost: 1080.30
 ├── G5: (aggregations G16)
 ├── G6: (variable kuvw.w)
 ├── G7: (plus G17 G18)
 ├── G8: (scan xyz,cols=(1)) (scan xyz@xy,cols=(1)) (scan xyz@zyx,cols=(1)) (scan xyz@yy,cols=(1))
 │    ├── [ordering: +1]
 │    │    ├── best: (scan xyz@xy,cols=(1))
 │    │    └── cost: 1044.31
 │    └── []
 │         ├── best: (scan xyz@xy,cols=(1))
 │         └── cost: 1044.31
 ├── G9: (select G19 G20) (scan kuvw@vw,cols=(6-8),constrained)
 │    ├── [ordering: +6 opt(7)]
 │    │    ├── best: (sort G9)
 │    │    └── cost: 15.88
 │    └── []
 │         ├── best: (scan kuvw@vw,cols=(6-8),constrained)
 │         └── cost: 14.71
 ├── G10: (filters G21)
 ├── G11: (filters)
 ├── G12: (project G8 G22 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G22 x)
 │    │    └── cost: 1064.32
 │    └── []
 │         ├── best: (project G8 G22 x)
 │         └── cost: 1064.32
 ├── G13: (project G8 G22 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G22 x)
 │    │    └── cost: 1064.32
 │    └── []
 │         ├── best: (project G8 G22 x)
 │         └── cost: 1064.32
 ├── G14: (project G8 G22 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G22 x)
 │    │    └── cost: 1064.32
 │    └── []
 │         ├── best: (project G8 G22 x)
 │         └── cost: 1064.32
 ├── G15: (project G8 G22 x)
 │    ├── [ordering: +1]
 │    │    ├── best: (project G8="[ordering: +1]" G22 x)
 │    │    └── cost: 1064.32
 │    └── []
 │         ├── best: (project G8 G22 x)
 │         └── cost: 1064.32
 ├── G16: (const-agg G6)
 ├── G17: (variable x)
 ├── G18: (const 1)
 ├── G19: (scan kuvw,cols=(6-8)) (scan kuvw@uvw,cols=(6-8)) (scan kuvw@wvu,cols=(6-8)) (scan kuvw@vw,cols=(6-8)) (scan kuvw@w,cols=(6-8))
 │    ├── [ordering: +6 opt(7)]
 │    │    ├── best: (scan kuvw@uvw,cols=(6-8))
 │    │    └── cost: 1084.71
 │    └── []
 │         ├── best: (scan kuvw,cols=(6-8))
 │         └── cost: 1084.71
 ├── G20: (filters G23)
 ├── G21: (eq G17 G24)
 ├── G22: (projections G18)
 ├── G23: (eq G25 G18)
 ├── G24: (variable u)
 └── G25: (variable v)

# Ensure that streaming upsert-distinct-on will be used.
memo
INSERT INTO xyz SELECT v, w, 1.0 FROM kuvw ON CONFLICT (x) DO NOTHING
----
memo (optimized, ~30KB, required=[])
 ├── G1: (insert G2 G3 G4 xyz)
 │    └── []
 │         ├── best: (insert G2 G3 G4 xyz)
 │         └── cost: 2168.87
 ├── G2: (upsert-distinct-on G5 G6 cols=(7)) (upsert-distinct-on G5 G6 cols=(7),ordering=+7 opt(10))
 │    └── []
 │         ├── best: (upsert-distinct-on G5 G6 cols=(7))
 │         └── cost: 2168.86
 ├── G3: (unique-checks)
 ├── G4: (f-k-checks)
 ├── G5: (anti-join G7 G8 G9) (anti-join G7 G8 G9) (merge-join G7 G8 G10 anti-join,+7,+11) (lookup-join G7 G10 xyz,keyCols=[7],outCols=(7,8,10,11)) (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10,11)) (merge-join G7 G8 G10 anti-join,+7,+11) (lookup-join G7 G10 xyz,keyCols=[7],outCols=(7,8,10,11)) (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10,11))
 │    ├── [ordering: +7 opt(10)]
 │    │    ├── best: (merge-join G7="[ordering: +7 opt(10)]" G8="[ordering: +11]" G10 anti-join,+7,+11)
 │    │    └── cost: 2168.84
 │    └── []
 │         ├── best: (merge-join G7="[ordering: +7 opt(10)]" G8="[ordering: +11]" G10 anti-join,+7,+11)
 │         └── cost: 2168.84
 ├── G6: (aggregations G11 G12)
 ├── G7: (project G13 G14 v w)
 │    ├── [ordering: +7 opt(10)]
 │    │    ├── best: (project G13="[ordering: +7]" G14 v w)
 │    │    └── cost: 1094.62
 │    └── []
 │         ├── best: (project G13 G14 v w)
 │         └── cost: 1094.62
 ├── G8: (scan xyz,cols=(11)) (scan xyz@xy,cols=(11)) (scan xyz@zyx,cols=(11)) (scan xyz@yy,cols=(11))
 │    ├── [ordering: +11]
 │    │    ├── best: (scan xyz@xy,cols=(11))
 │    │    └── cost: 1044.31
 │    └── []
 │         ├── best: (scan xyz@xy,cols=(11))
 │         └── cost: 1044.31
 ├── G9: (filters G15)
 ├── G10: (filters)
 ├── G11: (first-agg G16)
 ├── G12: (first-agg G17)
 ├── G13: (scan kuvw,cols=(7,8)) (scan kuvw@uvw,cols=(7,8)) (scan kuvw@wvu,cols=(7,8)) (scan kuvw@vw,cols=(7,8)) (scan kuvw@w,cols=(7,8))
 │    ├── [ordering: +7]
 │    │    ├── best: (scan kuvw@vw,cols=(7,8))
 │    │    └── cost: 1074.61
 │    └── []
 │         ├── best: (scan kuvw,cols=(7,8))
 │         └── cost: 1074.61
 ├── G14: (projections G18)
 ├── G15: (eq G19 G20)
 ├── G16: (variable w)
 ├── G17: (variable "?column?")
 ├── G18: (const 1.0)
 ├── G19: (variable v)
 └── G20: (variable x)

# Ensure that streaming ensure-upsert-distinct-on will be used.
memo
INSERT INTO xyz SELECT v, w, 1.0 FROM kuvw ON CONFLICT (x) DO UPDATE SET z=2.0
----
memo (optimized, ~27KB, required=[])
 ├── G1: (upsert G2 G3 G4 xyz)
 │    └── []
 │         ├── best: (upsert G2 G3 G4 xyz)
 │         └── cost: 2259.28
 ├── G2: (project G5 G6 v w ?column? x y z)
 │    └── []
 │         ├── best: (project G5 G6 v w ?column? x y z)
 │         └── cost: 2259.27
 ├── G3: (unique-checks)
 ├── G4: (f-k-checks)
 ├── G5: (left-join G7 G8 G9) (left-join G7 G8 G9) (right-join G8 G7 G9) (lookup-join G7 G10 xyz,keyCols=[7],outCols=(7,8,10-13)) (lookup-join G11 G10 xyz,keyCols=[11],outCols=(7,8,10-13)) (right-join G8 G7 G9) (lookup-join G7 G10 xyz,keyCols=[7],outCols=(7,8,10-13)) (lookup-join G12 G10 xyz,keyCols=[11],outCols=(7,8,10-13)) (merge-join G8 G7 G10 right-join,+11,+7) (merge-join G8 G7 G10 right-join,+11,+7)
 │    └── []
 │         ├── best: (merge-join G8="[ordering: +11]" G7="[ordering: +7 opt(10)]" G10 right-join,+11,+7)
 │         └── cost: 2239.26
 ├── G6: (projections G13)
 ├── G7: (ensure-upsert-distinct-on G14 G15 cols=(7)) (ensure-upsert-distinct-on G14 G15 cols=(7),ordering=+7 opt(10))
 │    ├── [ordering: +7 opt(10)]
 │    │    ├── best: (ensure-upsert-distinct-on G14="[ordering: +7 opt(10)]" G15 cols=(7))
 │    │    └── cost: 1134.64
 │    └── []
 │         ├── best: (ensure-upsert-distinct-on G14="[ordering: +7 opt(10)]" G15 cols=(7),ordering=+7 opt(10))
 │         └── cost: 1134.64
 ├── G8: (scan xyz,cols=(11-13)) (scan xyz@zyx,cols=(11-13))
 │    ├── [ordering: +11]
 │    │    ├── best: (scan xyz,cols=(11-13))
 │    │    └── cost: 1074.61
 │    └── []
 │         ├── best: (scan xyz,cols=(11-13))
 │         └── cost: 1074.61
 ├── G9: (filters G16)
 ├── G10: (filters)
 ├── G11: (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10-12))
 │    └── []
 │         ├── best: (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10-12))
 │         └── cost: 7184.65
 ├── G12: (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10-12))
 │    └── []
 │         ├── best: (lookup-join G7 G10 xyz@xy,keyCols=[7],outCols=(7,8,10-12))
 │         └── cost: 7184.65
 ├── G13: (case G17 G18 G19)
 ├── G14: (project G20 G21 v w)
 │    ├── [ordering: +7 opt(10)]
 │    │    ├── best: (project G20="[ordering: +7]" G21 v w)
 │    │    └── cost: 1094.62
 │    └── []
 │         ├── best: (project G20 G21 v w)
 │         └── cost: 1094.62
 ├── G15: (aggregations G22 G23)
 ├── G16: (eq G24 G25)
 ├── G17: (true)
 ├── G18: (scalar-list G26)
 ├── G19: (const 2.0)
 ├── G20: (scan kuvw,cols=(7,8)) (scan kuvw@uvw,cols=(7,8)) (scan kuvw@wvu,cols=(7,8)) (scan kuvw@vw,cols=(7,8)) (scan kuvw@w,cols=(7,8))
 │    ├── [ordering: +7]
 │    │    ├── best: (scan kuvw@vw,cols=(7,8))
 │    │    └── cost: 1074.61
 │    └── []
 │         ├── best: (scan kuvw,cols=(7,8))
 │         └── cost: 1074.61
 ├── G21: (projections G27)
 ├── G22: (first-agg G28)
 ├── G23: (first-agg G29)
 ├── G24: (variable v)
 ├── G25: (variable x)
 ├── G26: (when G30 G29)
 ├── G27: (const 1.0)
 ├── G28: (variable w)
 ├── G29: (variable "?column?")
 ├── G30: (is G25 G31)
 └── G31: (null)
