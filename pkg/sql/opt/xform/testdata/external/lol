exec-ddl
CREATE TABLE abc (a INT PRIMARY KEY, b INT, c INT, INDEX b(b), UNIQUE INDEX c(c))
----
TABLE abc
 ├── a int not null
 ├── b int
 ├── c int
 ├── INDEX primary
 │    └── a int not null
 ├── INDEX b
 │    ├── b int
 │    └── a int not null
 └── INDEX c
      ├── c int
      └── a int not null (storing)

exec-ddl
CREATE TABLE xyz (x INT PRIMARY KEY, y INT, z INT, INDEX y(y), UNIQUE INDEX z(z))
----
TABLE xyz
 ├── x int not null
 ├── y int
 ├── z int
 ├── INDEX primary
 │    └── x int not null
 ├── INDEX y
 │    ├── y int
 │    └── x int not null
 └── INDEX z
      ├── z int
      └── x int not null (storing)

#exploretrace rule=PushJoinThroughIndexJoin format=show-all
exploretrace format=show-all
SELECT * FROM abc JOIN xyz ON a=x
----
----
================================================================================
GenerateIndexScans
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 2:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6210
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── index-join abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 5110
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── scan abc@b
   │         ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int)
   │         ├── stats: [rows=1000]
   │         ├── cost: 1040
   │         ├── key: (1)
   │         └── fd: (1)-->(2)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 2 of 2:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6210
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── index-join abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 5110
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── scan abc@c
   │         ├── columns: t.public.abc.a:1(int!null) t.public.abc.c:3(int)
   │         ├── stats: [rows=1000]
   │         ├── cost: 1040
   │         ├── key: (1)
   │         └── fd: (1)-->(3), (3)~~>(1)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
GenerateIndexScans
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 2:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6210
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   ├── index-join xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 5110
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── prune: (4-6)
   │    └── scan xyz@y
   │         ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int)
   │         ├── stats: [rows=1000]
   │         ├── cost: 1040
   │         ├── key: (4)
   │         └── fd: (4)-->(5)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 2 of 2:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6210
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   ├── index-join xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 5110
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── prune: (4-6)
   │    └── scan xyz@z
   │         ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.z:6(int)
   │         ├── stats: [rows=1000]
   │         ├── cost: 1040
   │         ├── key: (4)
   │         └── fd: (4)-->(6), (6)~~>(4)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
CommuteJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 1:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    └── prune: (1-3)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
GenerateMergeJoins
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 1:
  inner-join (merge)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2150
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── ordering: +1
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── ordering: +4
   │    └── prune: (4-6)
   └── merge-on
        ├── left ordering: +1
        ├── right ordering: +4
        └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
             └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
                  ├── variable: t.public.abc.a [type=int, outer=(1)]
                  └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 1:
  inner-join (lookup xyz)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── key columns: [1] = [4]
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6120
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
CommuteJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    └── prune: (4-6)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

No new expressions.

================================================================================
GenerateMergeJoins
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── prune: (4-6)
   │    └── interesting orderings: (+4) (+5,+4) (+6,+4)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 1:
  inner-join (merge)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2150
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── ordering: +4
   │    ├── prune: (4-6)
   │    └── interesting orderings: (+4) (+5,+4) (+6,+4)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── ordering: +1
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   └── merge-on
        ├── left ordering: +4
        ├── right ordering: +1
        └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
             └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
                  ├── variable: t.public.abc.a [type=int, outer=(1)]
                  └── variable: t.public.xyz.x [type=int, outer=(4)]

================================================================================
GenerateLookupJoin
================================================================================
Source expression:
  inner-join
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 2160
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── prune: (4-6)
   │    └── interesting orderings: (+4) (+5,+4) (+6,+4)
   ├── scan abc
   │    ├── columns: t.public.abc.a:1(int!null) t.public.abc.b:2(int) t.public.abc.c:3(int)
   │    ├── stats: [rows=1000, distinct(1)=1000]
   │    ├── cost: 1060
   │    ├── key: (1)
   │    ├── fd: (1)-->(2,3), (3)~~>(1,2)
   │    ├── prune: (1-3)
   │    └── interesting orderings: (+1) (+2,+1) (+3,+1)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]

New expression 1 of 1:
  inner-join (lookup abc)
   ├── columns: a:1(int!null) b:2(int) c:3(int) x:4(int!null) y:5(int) z:6(int)
   ├── key columns: [4] = [1]
   ├── stats: [rows=1000, distinct(1)=1000, distinct(4)=1000]
   ├── cost: 6120
   ├── key: (4)
   ├── fd: (1)-->(2,3), (3)~~>(1,2), (4)-->(5,6), (6)~~>(4,5), (1)==(4), (4)==(1)
   ├── prune: (2,3,5,6)
   ├── scan xyz
   │    ├── columns: t.public.xyz.x:4(int!null) t.public.xyz.y:5(int) t.public.xyz.z:6(int)
   │    ├── stats: [rows=1000, distinct(4)=1000]
   │    ├── cost: 1060
   │    ├── key: (4)
   │    ├── fd: (4)-->(5,6), (6)~~>(4,5)
   │    ├── prune: (4-6)
   │    └── interesting orderings: (+4) (+5,+4) (+6,+4)
   └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
        └── eq [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]
             ├── variable: t.public.abc.a [type=int, outer=(1)]
             └── variable: t.public.xyz.x [type=int, outer=(4)]
----
----

memo
SELECT * FROM abc JOIN xyz ON a=x
----
memo (optimized)
 ├── G1: (inner-join G3 G5 G8) (inner-join G5 G3 G8) (merge-join G3 G5 G2) (lookup-join G3 G8 xyz,keyCols=[1],lookupCols=(4-6)) (merge-join G5 G3 G4) (lookup-join G5 G8 abc,keyCols=[4],lookupCols=(1-3))
 │    └── "[presentation: a:1,b:2,c:3,x:4,y:5,z:6]"
 │         ├── best: (merge-join G3="[ordering: +1]" G5="[ordering: +4]" G2)
 │         └── cost: 2150.00
 ├── G2: (merge-on G8 inner-join,+1,+4)
 ├── G3: (scan abc) (index-join G6 abc,cols=(1-3)) (index-join G7 abc,cols=(1-3))
 │    ├── ""
 │    │    ├── best: (scan abc)
 │    │    └── cost: 1060.00
 │    └── "[ordering: +1]"
 │         ├── best: (scan abc)
 │         └── cost: 1060.00
 ├── G4: (merge-on G8 inner-join,+4,+1)
 ├── G5: (scan xyz) (index-join G9 xyz,cols=(4-6)) (index-join G10 xyz,cols=(4-6))
 │    ├── ""
 │    │    ├── best: (scan xyz)
 │    │    └── cost: 1060.00
 │    └── "[ordering: +4]"
 │         ├── best: (scan xyz)
 │         └── cost: 1060.00
 ├── G6: (scan abc@b,cols=(1,2))
 │    ├── ""
 │    │    ├── best: (scan abc@b,cols=(1,2))
 │    │    └── cost: 1040.00
 │    └── "[ordering: +1]"
 │         ├── best: (sort G6)
 │         └── cost: 1249.32
 ├── G7: (scan abc@c,cols=(1,3))
 │    ├── ""
 │    │    ├── best: (scan abc@c,cols=(1,3))
 │    │    └── cost: 1040.00
 │    └── "[ordering: +1]"
 │         ├── best: (sort G7)
 │         └── cost: 1249.32
 ├── G8: (filters G11)
 ├── G9: (scan xyz@y,cols=(4,5))
 │    ├── ""
 │    │    ├── best: (scan xyz@y,cols=(4,5))
 │    │    └── cost: 1040.00
 │    └── "[ordering: +4]"
 │         ├── best: (sort G9)
 │         └── cost: 1249.32
 ├── G10: (scan xyz@z,cols=(4,6))
 │    ├── ""
 │    │    ├── best: (scan xyz@z,cols=(4,6))
 │    │    └── cost: 1040.00
 │    └── "[ordering: +4]"
 │         ├── best: (sort G10)
 │         └── cost: 1249.32
 ├── G11: (eq G12 G13)
 ├── G12: (variable a)
 └── G13: (variable x)
