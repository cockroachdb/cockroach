exec-ddl
CREATE TABLE a
(
    x INT,
    y FLOAT,
    z DECIMAL,
    s STRING NOT NULL,
    PRIMARY KEY (x, y DESC)
)
----

exec-ddl
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, b, c))
----

exec-ddl
CREATE TABLE xyz (x INT, y INT, z INT, PRIMARY KEY (x, y, z))
----

exec-ddl
CREATE TABLE abcd (a INT, b INT, c INT, d INT, INDEX ab(a, b) STORING (c, d), INDEX cd(c, d) STORING (a, b))
----

# --------------------------------------------------
# Scan operator.
# --------------------------------------------------

# Order by entire key, in same order as key.
opt
SELECT * FROM a ORDER BY x, y DESC
----
scan a
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 └── ordering: +1,-2

# Order by prefix.
opt
SELECT * FROM a ORDER BY x
----
scan a
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 └── ordering: +1

# Order by additional column (should be dropped by optimizer).
opt
SELECT * FROM a ORDER BY x, y DESC, z
----
scan a
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 └── ordering: +1,-2

# Order by suffix (scan shouldn't be able to provide).
opt
SELECT * FROM a ORDER BY y DESC
----
sort
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 ├── ordering: -2
 └── scan a
      └── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)

# Order by suffix, don't project prefix (scan shouldn't be able to provide).
opt
SELECT y FROM a ORDER BY y DESC
----
sort
 ├── columns: y:2(float!null)
 ├── ordering: -2
 └── scan a
      └── columns: y:2(float!null)

# --------------------------------------------------
# Select operator (pass through).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT * FROM a WHERE x>y ORDER BY x, y DESC
----
select
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 ├── ordering: +1,-2
 ├── scan a
 │    ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 │    └── ordering: +1,-2
 └── filters
      └── x > y [type=bool]

# Pass through ordering to scan operator that can't support it.
opt
SELECT * FROM a WHERE x>y ORDER BY z DESC
----
sort
 ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
 ├── ordering: -3
 └── select
      ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
      ├── scan a
      │    └── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
      └── filters
           └── x > y [type=bool]

# --------------------------------------------------
# Project operator (pass through).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT x+1 AS r, y FROM a ORDER BY x, y DESC
----
project
 ├── columns: r:5(int) y:2(float!null)  [hidden: x:1(int!null)]
 ├── ordering: +1,-2
 ├── scan a
 │    ├── columns: x:1(int!null) y:2(float!null)
 │    └── ordering: +1,-2
 └── projections
      └── x + 1 [type=int]

# Pass through ordering to scan operator that can't support it.
opt
SELECT y, x, z+1 AS r FROM a ORDER BY x, y
----
sort (segmented)
 ├── columns: y:2(float!null) x:1(int!null) r:5(decimal)
 ├── ordering: +1,+2
 └── project
      ├── columns: r:5(decimal) x:1(int!null) y:2(float!null)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: x:1(int!null) y:2(float!null) z:3(decimal)
      │    └── ordering: +1
      └── projections
           └── z + 1 [type=decimal]

# Ordering cannot be passed through because it includes computed column.
opt
SELECT x, y+1 AS computed, y FROM a ORDER BY x, computed
----
sort (segmented)
 ├── columns: x:1(int!null) computed:5(float) y:2(float!null)
 ├── ordering: +1,+5
 └── project
      ├── columns: computed:5(float) x:1(int!null) y:2(float!null)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: x:1(int!null) y:2(float!null)
      │    └── ordering: +1
      └── projections
           └── y + 1.0 [type=float]

# --------------------------------------------------
# Select + Project operators (pass through both).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT y, x-1 AS z FROM a WHERE x>y ORDER BY x, y DESC
----
project
 ├── columns: y:2(float!null) z:5(int)  [hidden: x:1(int!null)]
 ├── ordering: +1,-2
 ├── select
 │    ├── columns: x:1(int!null) y:2(float!null)
 │    ├── ordering: +1,-2
 │    ├── scan a
 │    │    ├── columns: x:1(int!null) y:2(float!null)
 │    │    └── ordering: +1,-2
 │    └── filters
 │         └── x > y [type=bool]
 └── projections
      └── x - 1 [type=int]

memo
SELECT y, x-1 AS z FROM a WHERE x>y ORDER BY x, y DESC
----
memo (optimized, ~5KB, required=[presentation: y:2,z:5] [ordering: +1,-2])
 ├── G1: (project G2 G3 x y)
 │    ├── [presentation: y:2,z:5] [ordering: +1,-2]
 │    │    ├── best: (project G2="[ordering: +1,-2]" G3 x y)
 │    │    └── cost: 1076.71
 │    └── []
 │         ├── best: (project G2 G3 x y)
 │         └── cost: 1076.71
 ├── G2: (select G4 G5)
 │    ├── [ordering: +1,-2]
 │    │    ├── best: (select G4="[ordering: +1,-2]" G5)
 │    │    └── cost: 1070.03
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1070.03
 ├── G3: (projections G6)
 ├── G4: (scan a,cols=(1,2))
 │    ├── [ordering: +1,-2]
 │    │    ├── best: (scan a,cols=(1,2))
 │    │    └── cost: 1060.02
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1060.02
 ├── G5: (filters G7)
 ├── G6: (minus G8 G9)
 ├── G7: (gt G8 G10)
 ├── G8: (variable x)
 ├── G9: (const 1)
 └── G10: (variable y)

# Pass through ordering to scan operator that can't support it.
opt
SELECT y, z FROM a WHERE x>y ORDER BY y
----
sort
 ├── columns: y:2(float!null) z:3(decimal)
 ├── ordering: +2
 └── project
      ├── columns: y:2(float!null) z:3(decimal)
      └── select
           ├── columns: x:1(int!null) y:2(float!null) z:3(decimal)
           ├── scan a
           │    └── columns: x:1(int!null) y:2(float!null) z:3(decimal)
           └── filters
                └── x > y [type=bool]

memo
SELECT y, z FROM a WHERE x>y ORDER BY y
----
memo (optimized, ~5KB, required=[presentation: y:2,z:3] [ordering: +2])
 ├── G1: (project G2 G3 y z)
 │    ├── [presentation: y:2,z:3] [ordering: +2]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1145.92
 │    └── []
 │         ├── best: (project G2 G3 y z)
 │         └── cost: 1083.37
 ├── G2: (select G4 G5)
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1142.58
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1080.03
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1-3))
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1289.35
 │    └── []
 │         ├── best: (scan a,cols=(1-3))
 │         └── cost: 1070.02
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable x)
 └── G8: (variable y)

# --------------------------------------------------
# GroupBy operator.
# --------------------------------------------------

# Verify that the internal ordering is required of the input.
opt
SELECT array_agg(z) FROM (SELECT * FROM a ORDER BY y)
----
scalar-group-by
 ├── columns: array_agg:5(decimal[])
 ├── internal-ordering: +2
 ├── sort
 │    ├── columns: y:2(float!null) z:3(decimal)
 │    ├── ordering: +2
 │    └── scan a
 │         └── columns: y:2(float!null) z:3(decimal)
 └── aggregations
      └── array-agg [type=decimal[]]
           └── variable: z [type=decimal]

opt
SELECT array_agg(x) FROM (SELECT * FROM a ORDER BY x, y DESC)
----
scalar-group-by
 ├── columns: array_agg:5(int[])
 ├── internal-ordering: +1,-2
 ├── scan a
 │    ├── columns: x:1(int!null) y:2(float!null)
 │    └── ordering: +1,-2
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: x [type=int]

# Pass through ordering on grouping columns.
opt
SELECT a, min(b) FROM abc GROUP BY a ORDER BY a
----
group-by
 ├── columns: a:1(int!null) min:4(int)
 ├── grouping columns: a:1(int!null)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null)
 │    └── ordering: +1
 └── aggregations
      └── min [type=int]
           └── variable: b [type=int]

opt
SELECT a, b, min(c) FROM abc GROUP BY a, b ORDER BY a
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) min:4(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [type=int]
           └── variable: c [type=int]

opt
SELECT a, b, min(c) FROM abc GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) min:4(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [type=int]
           └── variable: c [type=int]

opt
SELECT a, b, min(c) FROM abc GROUP BY b, a ORDER BY a, b
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) min:4(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [type=int]
           └── variable: c [type=int]

# We can't pass through the ordering if it refers to aggregation results.
opt
SELECT a, b, min(c) AS m FROM abc GROUP BY a, b ORDER BY a, m
----
sort (segmented)
 ├── columns: a:1(int!null) b:2(int!null) m:4(int)
 ├── ordering: +1,+4
 └── group-by
      ├── columns: a:1(int!null) b:2(int!null) min:4(int)
      ├── grouping columns: a:1(int!null) b:2(int!null)
      ├── internal-ordering: +1,+2
      ├── ordering: +1
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1,+2
      └── aggregations
           └── min [type=int]
                └── variable: c [type=int]

# Satisfy both the required and the internal orderings by requiring a+,b+,c+.
opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY c) GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) array_agg:4(int[])
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +3 opt(1,2)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: c [type=int]

opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY a, b, c) GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) array_agg:4(int[])
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +3 opt(1,2)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: c [type=int]

opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY b, c, a) GROUP BY b, a ORDER BY a, b
----
group-by
 ├── columns: a:1(int!null) b:2(int!null) array_agg:4(int[])
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +3 opt(1,2)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [type=int[]]
           └── variable: c [type=int]

# Verify that the GroupBy child ordering is simplified according to the child's
# FD set.
opt
SELECT sum(c) FROM abc WHERE a = 1 GROUP BY b ORDER BY b
----
group-by
 ├── columns: sum:4(decimal)  [hidden: b:2(int!null)]
 ├── grouping columns: b:2(int!null)
 ├── ordering: +2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── constraint: /1/2/3: [/1 - /1]
 │    └── ordering: +2 opt(1)
 └── aggregations
      └── sum [type=decimal]
           └── variable: c [type=int]

# Verify we do a streaming group-by using the a, b ordering.
opt
SELECT sum(d) FROM abcd GROUP BY a, b, c
----
project
 ├── columns: sum:6(decimal)
 └── group-by
      ├── columns: a:1(int) b:2(int) c:3(int) sum:6(decimal)
      ├── grouping columns: a:1(int) b:2(int) c:3(int)
      ├── internal-ordering: +1,+2
      ├── scan abcd@ab
      │    ├── columns: a:1(int) b:2(int) c:3(int) d:4(int)
      │    └── ordering: +1,+2
      └── aggregations
           └── sum [type=decimal]
                └── variable: d [type=int]

# Verify we do a streaming group-by using the c, d ordering.
opt
SELECT sum(a) FROM abcd GROUP BY b, c, d
----
project
 ├── columns: sum:6(decimal)
 └── group-by
      ├── columns: b:2(int) c:3(int) d:4(int) sum:6(decimal)
      ├── grouping columns: b:2(int) c:3(int) d:4(int)
      ├── internal-ordering: +3,+4
      ├── scan abcd@cd
      │    ├── columns: a:1(int) b:2(int) c:3(int) d:4(int)
      │    └── ordering: +3,+4
      └── aggregations
           └── sum [type=decimal]
                └── variable: a [type=int]

opt
SELECT array_agg(d) FROM (SELECT * FROM abcd ORDER BY c) GROUP BY a, b
----
project
 ├── columns: array_agg:6(int[])
 └── group-by
      ├── columns: a:1(int) b:2(int) array_agg:6(int[])
      ├── grouping columns: a:1(int) b:2(int)
      ├── internal-ordering: +3 opt(1,2)
      ├── scan abcd@cd
      │    ├── columns: a:1(int) b:2(int) c:3(int) d:4(int)
      │    └── ordering: +3 opt(1,2)
      └── aggregations
           └── array-agg [type=int[]]
                └── variable: d [type=int]

# --------------------------------------------------
# Explain operator.
# --------------------------------------------------
opt
EXPLAIN (VERBOSE) SELECT * FROM a ORDER BY y
----
explain
 ├── columns: tree:5(string) field:8(string) description:9(string) columns:10(string) ordering:11(string)  [hidden: level:6(int) node_type:7(string)]
 ├── mode: verbose
 └── sort
      ├── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)
      ├── ordering: +2
      └── scan a
           └── columns: x:1(int!null) y:2(float!null) z:3(decimal) s:4(string!null)

memo
EXPLAIN (VERBOSE) SELECT * FROM a ORDER BY y
----
memo (optimized, ~2KB, required=[presentation: tree:5,field:8,description:9,columns:10,ordering:11])
 ├── G1: (explain G2 [presentation: x:1,y:2,z:3,s:4] [ordering: +2])
 │    └── [presentation: tree:5,field:8,description:9,columns:10,ordering:11]
 │         ├── best: (explain G2="[presentation: x:1,y:2,z:3,s:4] [ordering: +2]" [presentation: x:1,y:2,z:3,s:4] [ordering: +2])
 │         └── cost: 1299.36
 └── G2: (scan a)
      ├── [presentation: x:1,y:2,z:3,s:4] [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1299.35
      └── []
           ├── best: (scan a)
           └── cost: 1080.02

# --------------------------------------------------
# With Ordinality
# --------------------------------------------------

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2)
 │    │    └── cost: 1060.03
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM a WITH ORDINALITY ORDER BY -ordinality
----
memo (optimized, ~5KB, required=[presentation: y:2] [ordering: +6])
 ├── G1: (project G2 G3 y)
 │    ├── [presentation: y:2] [ordering: +6]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1299.37
 │    └── []
 │         ├── best: (project G2 G3 y)
 │         └── cost: 1080.04
 ├── G2: (ordinality G4)
 │    └── []
 │         ├── best: (ordinality G4)
 │         └── cost: 1060.03
 ├── G3: (projections G5)
 ├── G4: (scan a,cols=(2))
 │    └── []
 │         ├── best: (scan a,cols=(2))
 │         └── cost: 1050.02
 ├── G5: (unary-minus G6)
 └── G6: (variable ordinality)

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality, x
----
memo (optimized, ~6KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2)
 │    │    └── cost: 1060.03
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM (SELECT * FROM a ORDER BY y) WITH ORDINALITY ORDER BY y, ordinality
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +2,+5])
 ├── G1: (ordinality G2 ordering=+2)
 │    ├── [presentation: y:2] [ordering: +2,+5]
 │    │    ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │         └── cost: 1279.36
 └── G2: (scan a,cols=(2))
      ├── [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1269.35
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM (SELECT * FROM a ORDER BY y) WITH ORDINALITY ORDER BY ordinality, y
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2 ordering=+2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │         └── cost: 1279.36
 └── G2: (scan a,cols=(2))
      ├── [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1269.35
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality DESC
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: -5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: -5]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

# --------------------------------------------------
# Merge Join
# --------------------------------------------------

opt
SELECT * FROM abc JOIN xyz ON a=x ORDER BY a
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1
 ├── right ordering: +4
 ├── ordering: +(1|4)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x ORDER BY x
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1
 ├── right ordering: +4
 ├── ordering: +(1|4)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4
 └── filters (true)

# A left join guarantees an ordering on the left side.
opt
SELECT * FROM abc LEFT JOIN xyz ON a=x ORDER BY a
----
left-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int) y:5(int) z:6(int)
 ├── left ordering: +1
 ├── right ordering: +4
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4
 └── filters (true)

# A left join doesn't guarantee an ordering on x (some rows will have NULLs).
opt
SELECT * FROM abc LEFT JOIN xyz ON a=x ORDER BY x
----
sort
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int) y:5(int) z:6(int)
 ├── ordering: +4
 └── left-join (merge)
      ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int) y:5(int) z:6(int)
      ├── left ordering: +1
      ├── right ordering: +4
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1
      ├── scan xyz
      │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │    └── ordering: +4
      └── filters (true)

# A right join doesn't guarantee an ordering on a (some rows will have NULLs).
opt
SELECT * FROM abc RIGHT JOIN xyz ON a=x ORDER BY a
----
sort
 ├── columns: a:1(int) b:2(int) c:3(int) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── ordering: +1
 └── left-join (merge)
      ├── columns: a:1(int) b:2(int) c:3(int) x:4(int!null) y:5(int!null) z:6(int!null)
      ├── left ordering: +4
      ├── right ordering: +1
      ├── scan xyz
      │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │    └── ordering: +4
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1
      └── filters (true)

opt
SELECT * FROM abc RIGHT JOIN xyz ON a=x ORDER BY x
----
left-join (merge)
 ├── columns: a:1(int) b:2(int) c:3(int) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +4
 ├── right ordering: +1
 ├── ordering: +4
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 └── filters (true)

opt
SELECT * FROM abc FULL OUTER JOIN xyz ON a=x ORDER BY a
----
sort
 ├── columns: a:1(int) b:2(int) c:3(int) x:4(int) y:5(int) z:6(int)
 ├── ordering: +1
 └── full-join (merge)
      ├── columns: a:1(int) b:2(int) c:3(int) x:4(int) y:5(int) z:6(int)
      ├── left ordering: +1
      ├── right ordering: +4
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1
      ├── scan xyz
      │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │    └── ordering: +4
      └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── ordering: +(1|4)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4,+5
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a, b
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── ordering: +(1|4),+(2|5)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4,+5
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a, y
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── ordering: +(1|4),+(2|5)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4,+5
 └── filters (true)

# --------------------------------------------------
# Limit / Offset
# --------------------------------------------------

# Basic cases.

opt
SELECT * FROM abc ORDER BY a, b LIMIT 10
----
scan abc
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── limit: 10
 └── ordering: +1,+2

# The filter prevents pushing of the limit into the scan.
opt
SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10
----
limit
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1,+2
 ├── select
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +1,+2
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    │    ├── ordering: +1,+2
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c < (a + b) [type=bool]
 └── const: 10 [type=int]

opt
SELECT * FROM abc ORDER BY a, b OFFSET 10 
----
offset
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── const: 10 [type=int]


# Cases where the requirement on Limit/Offset is incompatible with the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY b
----
sort
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── ordering: +2
 └── scan abc
      ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      └── limit: 10

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY b
----
sort
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── ordering: +2
 └── limit
      ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      ├── internal-ordering: +1,+2
      ├── select
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    ├── ordering: +1,+2
      │    ├── limit hint: 10.00
      │    ├── scan abc
      │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    │    ├── ordering: +1,+2
      │    │    └── limit hint: 30.00
      │    └── filters
      │         └── c < (a + b) [type=bool]
      └── const: 10 [type=int]

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY b
----
sort
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── ordering: +2
 └── offset
      ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      ├── internal-ordering: +1,+2
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1,+2
      └── const: 10 [type=int]


# Cases where the requirement on Limit/Offset is weaker than the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY a
----
scan abc
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── limit: 10
 └── ordering: +1

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY a
----
limit
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1
 ├── select
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +1,+2
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    │    ├── ordering: +1,+2
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c < (a + b) [type=bool]
 └── const: 10 [type=int]

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY a
----
offset
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── const: 10 [type=int]

# Cases where the requirement on Limit/Offset is stronger than the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY a, b, c
----
scan abc
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── limit: 10
 └── ordering: +1,+2,+3

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY a, b, c
----
limit
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1,+2,+3
 ├── select
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +1,+2,+3
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    │    ├── ordering: +1,+2,+3
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c < (a + b) [type=bool]
 └── const: 10 [type=int]

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY a, b, c
----
offset
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1,+2,+3
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2,+3
 └── const: 10 [type=int]

# --------------------------------------------------
# DistinctOn
# --------------------------------------------------

# DISTINCT doesn't require any particular ordering of its input. It could pass
# through the requirement, but that doesn't improve the estimated cost in this
# case.
opt
SELECT DISTINCT b, c FROM abc ORDER BY b
----
distinct-on
 ├── columns: b:2(int!null) c:3(int!null)
 ├── grouping columns: b:2(int!null) c:3(int!null)
 ├── ordering: +2
 └── sort
      ├── columns: b:2(int!null) c:3(int!null)
      ├── ordering: +2
      └── scan abc
           └── columns: b:2(int!null) c:3(int!null)

# In this case the ordering is passed through.
opt
SELECT DISTINCT a, b, c FROM abc ORDER BY a, b
----
scan abc
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 └── ordering: +1,+2

# DISTINCT ON requires the ordering of its input, as it affects the results
# (values of a in this case).
opt
SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY b
----
distinct-on
 ├── columns: a:1(int) b:2(int!null) c:3(int!null)
 ├── grouping columns: b:2(int!null) c:3(int!null)
 ├── ordering: +2
 ├── sort
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +2
 │    └── scan abc
 │         └── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 └── aggregations
      └── first-agg [type=int]
           └── variable: a [type=int]

opt
SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY b, c, a
----
distinct-on
 ├── columns: a:1(int) b:2(int!null) c:3(int!null)
 ├── grouping columns: b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1 opt(2,3)
 ├── ordering: +2,+3
 ├── sort
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +2,+3,+1
 │    └── scan abc
 │         └── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 └── aggregations
      └── first-agg [type=int]
           └── variable: a [type=int]

opt
SELECT DISTINCT ON (a) a, c FROM abc ORDER BY a, c DESC, b
----
distinct-on
 ├── columns: a:1(int!null) c:3(int)
 ├── grouping columns: a:1(int!null)
 ├── internal-ordering: -3,+2 opt(1)
 ├── ordering: +1
 ├── sort (segmented)
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    ├── ordering: +1,-3,+2
 │    └── scan abc
 │         ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │         └── ordering: +1
 └── aggregations
      └── first-agg [type=int]
           └── variable: c [type=int]

# Pass through the ordering from above.
opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc) ORDER BY a
----
distinct-on
 ├── columns: a:1(int!null) b:2(int!null) c:3(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [type=int]
           └── variable: c [type=int]

# Internal orderings that refer just to ON columns can be ignored.
opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc ORDER BY a) ORDER BY a, b
----
distinct-on
 ├── columns: a:1(int!null) b:2(int!null) c:3(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [type=int]
           └── variable: c [type=int]

opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc ORDER BY a, b) ORDER BY a
----
distinct-on
 ├── columns: a:1(int!null) b:2(int!null) c:3(int)
 ├── grouping columns: a:1(int!null) b:2(int!null)
 ├── internal-ordering: +1,+2
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [type=int]
           └── variable: c [type=int]

# The c,b part of the inner ordering can be ignored.
opt
SELECT * FROM (SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY c, b, a) ORDER BY a
----
distinct-on
 ├── columns: a:1(int) b:2(int!null) c:3(int!null)
 ├── grouping columns: b:2(int!null) c:3(int!null)
 ├── internal-ordering: +1 opt(2,3)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 └── aggregations
      └── first-agg [type=int]
           └── variable: a [type=int]

# There is no ordering that satisfies both the intra-group ordering of c+ and the
# inter-group ordering of a+; we have to sort twice.
opt
SELECT * FROM (SELECT DISTINCT ON (b) a, b, c FROM abc ORDER BY b, c) ORDER BY a
----
sort
 ├── columns: a:1(int) b:2(int!null) c:3(int)
 ├── ordering: +1
 └── distinct-on
      ├── columns: a:1(int) b:2(int!null) c:3(int)
      ├── grouping columns: b:2(int!null)
      ├── internal-ordering: +3 opt(2)
      ├── sort
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    ├── ordering: +3 opt(2)
      │    └── scan abc
      │         └── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      └── aggregations
           ├── first-agg [type=int]
           │    └── variable: a [type=int]
           └── first-agg [type=int]
                └── variable: c [type=int]

# Same as above, except we can use the index ordering for the distinct input.
opt
SELECT * FROM (SELECT DISTINCT ON (a) a, b, c FROM abc ORDER BY a, b) ORDER BY c
----
sort
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── ordering: +3
 └── distinct-on
      ├── columns: a:1(int!null) b:2(int) c:3(int)
      ├── grouping columns: a:1(int!null)
      ├── internal-ordering: +1,+2
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── ordering: +1,+2
      └── aggregations
           ├── first-agg [type=int]
           │    └── variable: b [type=int]
           └── first-agg [type=int]
                └── variable: c [type=int]

# --------------------------------------------------
# Insert operator.
# --------------------------------------------------

# Verify that external ordering is passed through to input.
opt
SELECT * FROM [INSERT INTO abc SELECT * FROM xyz ORDER BY y, z LIMIT 2 RETURNING *] ORDER BY b
----
sort
 ├── columns: a:7(int!null) b:8(int!null) c:9(int!null)
 ├── ordering: +8
 └── with &1
      ├── columns: a:7(int!null) b:8(int!null) c:9(int!null)
      ├── insert abc
      │    ├── columns: abc.a:1(int!null) abc.b:2(int!null) abc.c:3(int!null)
      │    ├── insert-mapping:
      │    │    ├──  x:4 => abc.a:1
      │    │    ├──  y:5 => abc.b:2
      │    │    └──  z:6 => abc.c:3
      │    └── limit
      │         ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         ├── internal-ordering: +5,+6
      │         ├── sort
      │         │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         │    ├── ordering: +5,+6
      │         │    ├── limit hint: 2.00
      │         │    └── scan xyz
      │         │         └── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         └── const: 2 [type=int]
      └── with-scan &1
           ├── columns: a:7(int!null) b:8(int!null) c:9(int!null)
           └── mapping:
                ├──  abc.a:1(int) => a:7(int)
                ├──  abc.b:2(int) => b:8(int)
                └──  abc.c:3(int) => c:9(int)

# Verify that provided orderings are derived correctly.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [INSERT INTO xyz SELECT b, c, d FROM abcd ORDER BY c, d LIMIT 2 RETURNING *]
ORDER BY y
----
sort
 ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
 ├── cardinality: [0 - 2]
 ├── side-effects, mutations
 ├── ordering: +10
 ├── prune: (9-11)
 └── with &1
      ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
      ├── cardinality: [0 - 2]
      ├── side-effects, mutations
      ├── prune: (9-11)
      ├── insert xyz
      │    ├── columns: xyz.x:1(int!null) xyz.y:2(int!null) xyz.z:3(int!null)
      │    ├── insert-mapping:
      │    │    ├──  b:5 => xyz.x:1
      │    │    ├──  c:6 => xyz.y:2
      │    │    └──  d:7 => xyz.z:3
      │    ├── cardinality: [0 - 2]
      │    ├── side-effects, mutations
      │    └── scan abcd@cd
      │         ├── columns: b:5(int) c:6(int) d:7(int)
      │         ├── limit: 2
      │         ├── prune: (5)
      │         └── interesting orderings: (+6,+7)
      └── with-scan &1
           ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
           ├── mapping:
           │    ├──  xyz.x:1(int) => x:9(int)
           │    ├──  xyz.y:2(int) => y:10(int)
           │    └──  xyz.z:3(int) => z:11(int)
           ├── cardinality: [0 - 2]
           └── prune: (9-11)

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [INSERT INTO xyz SELECT b, c, d FROM abcd ORDER BY c, d LIMIT 2 RETURNING *]
WHERE x=y
ORDER BY y
----
sort
 ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
 ├── cardinality: [0 - 2]
 ├── side-effects, mutations
 ├── fd: (9)==(10), (10)==(9)
 ├── ordering: +(9|10) [actual: +9]
 ├── prune: (11)
 └── with &1
      ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
      ├── cardinality: [0 - 2]
      ├── side-effects, mutations
      ├── fd: (9)==(10), (10)==(9)
      ├── prune: (11)
      ├── insert xyz
      │    ├── columns: xyz.x:1(int!null) xyz.y:2(int!null) xyz.z:3(int!null)
      │    ├── insert-mapping:
      │    │    ├──  b:5 => xyz.x:1
      │    │    ├──  c:6 => xyz.y:2
      │    │    └──  d:7 => xyz.z:3
      │    ├── cardinality: [0 - 2]
      │    ├── side-effects, mutations
      │    └── scan abcd@cd
      │         ├── columns: b:5(int) c:6(int) d:7(int)
      │         ├── limit: 2
      │         ├── prune: (5)
      │         └── interesting orderings: (+6,+7)
      └── select
           ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
           ├── cardinality: [0 - 2]
           ├── fd: (9)==(10), (10)==(9)
           ├── prune: (11)
           ├── with-scan &1
           │    ├── columns: x:9(int!null) y:10(int!null) z:11(int!null)
           │    ├── mapping:
           │    │    ├──  xyz.x:1(int) => x:9(int)
           │    │    ├──  xyz.y:2(int) => y:10(int)
           │    │    └──  xyz.z:3(int) => z:11(int)
           │    ├── cardinality: [0 - 2]
           │    └── prune: (9-11)
           └── filters
                └── x = y [type=bool, outer=(9,10), fd=(9)==(10), (10)==(9)]

# Ignore internal ordering.
opt
SELECT * FROM [INSERT INTO abc SELECT * FROM xyz ORDER BY y, z RETURNING *]
----
with &1
 ├── columns: a:7(int!null) b:8(int!null) c:9(int!null)
 ├── insert abc
 │    ├── columns: abc.a:1(int!null) abc.b:2(int!null) abc.c:3(int!null)
 │    ├── insert-mapping:
 │    │    ├──  x:4 => abc.a:1
 │    │    ├──  y:5 => abc.b:2
 │    │    └──  z:6 => abc.c:3
 │    └── scan xyz
 │         └── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 └── with-scan &1
      ├── columns: a:7(int!null) b:8(int!null) c:9(int!null)
      └── mapping:
           ├──  abc.a:1(int) => a:7(int)
           ├──  abc.b:2(int) => b:8(int)
           └──  abc.c:3(int) => c:9(int)

# --------------------------------------------------
# Update operator.
# --------------------------------------------------

# Verify that the external ordering is passed through to input.
opt
SELECT * FROM [UPDATE abcd SET (a, b)=(1, 2) RETURNING *] ORDER BY c
----
sort
 ├── columns: a:13(int!null) b:14(int!null) c:15(int) d:16(int)
 ├── ordering: +15 opt(13,14)
 └── with &1
      ├── columns: a:13(int!null) b:14(int!null) c:15(int) d:16(int)
      ├── project
      │    ├── columns: abcd.a:1(int!null) abcd.b:2(int!null) abcd.c:3(int) abcd.d:4(int)
      │    └── update abcd
      │         ├── columns: abcd.a:1(int!null) abcd.b:2(int!null) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         ├── update-mapping:
      │         │    ├──  column11:11 => abcd.a:1
      │         │    └──  column12:12 => abcd.b:2
      │         └── project
      │              ├── columns: column11:11(int!null) column12:12(int!null) abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              ├── scan abcd
      │              │    └── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              └── projections
      │                   ├── const: 1 [type=int]
      │                   └── const: 2 [type=int]
      └── with-scan &1
           ├── columns: a:13(int!null) b:14(int!null) c:15(int) d:16(int)
           └── mapping:
                ├──  abcd.a:1(int) => a:13(int)
                ├──  abcd.b:2(int) => b:14(int)
                ├──  abcd.c:3(int) => c:15(int)
                └──  abcd.d:4(int) => d:16(int)

# Verify that provided orderings are derived correctly.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [UPDATE abcd SET b=b+1 ORDER BY c LIMIT 10 RETURNING *]
ORDER BY c, d
----
sort
 ├── columns: a:12(int) b:13(int) c:14(int) d:15(int)
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── ordering: +14,+15
 ├── prune: (12-15)
 └── with &1
      ├── columns: a:12(int) b:13(int) c:14(int) d:15(int)
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── prune: (12-15)
      ├── project
      │    ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int)
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    ├── prune: (1-4)
      │    └── update abcd
      │         ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         ├── update-mapping:
      │         │    └──  column11:11 => abcd.b:2
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── project
      │              ├── columns: column11:11(int) abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              ├── cardinality: [0 - 10]
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9), (7)-->(11)
      │              ├── prune: (6-11)
      │              ├── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      │              ├── scan abcd@cd
      │              │    ├── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              │    ├── limit: 10
      │              │    ├── key: (10)
      │              │    ├── fd: (10)-->(6-9)
      │              │    ├── prune: (6-10)
      │              │    └── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      │              └── projections
      │                   └── abcd.b + 1 [type=int, outer=(7)]
      └── with-scan &1
           ├── columns: a:12(int) b:13(int) c:14(int) d:15(int)
           ├── mapping:
           │    ├──  abcd.a:1(int) => a:12(int)
           │    ├──  abcd.b:2(int) => b:13(int)
           │    ├──  abcd.c:3(int) => c:14(int)
           │    └──  abcd.d:4(int) => d:15(int)
           ├── cardinality: [0 - 10]
           └── prune: (12-15)

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [UPDATE abcd SET b=b+1 ORDER BY c, d LIMIT 10 RETURNING *]
WHERE b=c
ORDER BY b, d
----
sort
 ├── columns: a:12(int) b:13(int!null) c:14(int!null) d:15(int)
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── fd: (13)==(14), (14)==(13)
 ├── ordering: +(13|14),+15 [actual: +13,+15]
 ├── prune: (12,15)
 └── with &1
      ├── columns: a:12(int) b:13(int!null) c:14(int!null) d:15(int)
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── fd: (13)==(14), (14)==(13)
      ├── prune: (12,15)
      ├── project
      │    ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int)
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    ├── prune: (1-4)
      │    └── update abcd
      │         ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         ├── update-mapping:
      │         │    └──  column11:11 => abcd.b:2
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── project
      │              ├── columns: column11:11(int) abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              ├── cardinality: [0 - 10]
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9), (7)-->(11)
      │              ├── prune: (6-11)
      │              ├── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      │              ├── scan abcd@cd
      │              │    ├── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              │    ├── limit: 10
      │              │    ├── key: (10)
      │              │    ├── fd: (10)-->(6-9)
      │              │    ├── prune: (6-10)
      │              │    └── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      │              └── projections
      │                   └── abcd.b + 1 [type=int, outer=(7)]
      └── select
           ├── columns: a:12(int) b:13(int!null) c:14(int!null) d:15(int)
           ├── cardinality: [0 - 10]
           ├── fd: (13)==(14), (14)==(13)
           ├── prune: (12,15)
           ├── with-scan &1
           │    ├── columns: a:12(int) b:13(int) c:14(int) d:15(int)
           │    ├── mapping:
           │    │    ├──  abcd.a:1(int) => a:12(int)
           │    │    ├──  abcd.b:2(int) => b:13(int)
           │    │    ├──  abcd.c:3(int) => c:14(int)
           │    │    └──  abcd.d:4(int) => d:15(int)
           │    ├── cardinality: [0 - 10]
           │    └── prune: (12-15)
           └── filters
                └── b = c [type=bool, outer=(13,14), fd=(13)==(14), (14)==(13)]

# --------------------------------------------------
# Upsert operator.
# --------------------------------------------------

# Verify that no ordering is provided once ON CONFLICT clause is added.
opt
SELECT *
FROM
[
	INSERT INTO abc
	SELECT * FROM xyz ORDER BY y, z LIMIT 2
	ON CONFLICT (a, b, c)
	DO UPDATE SET a=10
	RETURNING *
]
ORDER BY b
----
sort
 ├── columns: a:14(int!null) b:15(int!null) c:16(int!null)
 ├── ordering: +15
 └── with &1
      ├── columns: a:14(int!null) b:15(int!null) c:16(int!null)
      ├── upsert abc
      │    ├── columns: abc.a:1(int!null) abc.b:2(int!null) abc.c:3(int!null)
      │    ├── canary column: 7
      │    ├── fetch columns: abc.a:7(int) abc.b:8(int) abc.c:9(int)
      │    ├── insert-mapping:
      │    │    ├──  x:4 => abc.a:1
      │    │    ├──  y:5 => abc.b:2
      │    │    └──  z:6 => abc.c:3
      │    ├── update-mapping:
      │    │    └──  upsert_a:11 => abc.a:1
      │    ├── return-mapping:
      │    │    ├──  upsert_a:11 => abc.a:1
      │    │    ├──  upsert_b:12 => abc.b:2
      │    │    └──  upsert_c:13 => abc.c:3
      │    └── project
      │         ├── columns: upsert_a:11(int) upsert_b:12(int) upsert_c:13(int) x:4(int!null) y:5(int!null) z:6(int!null) abc.a:7(int) abc.b:8(int) abc.c:9(int)
      │         ├── left-join (lookup abc)
      │         │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null) abc.a:7(int) abc.b:8(int) abc.c:9(int)
      │         │    ├── key columns: [4 5 6] = [7 8 9]
      │         │    ├── lookup columns are key
      │         │    ├── limit
      │         │    │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         │    │    ├── internal-ordering: +5,+6
      │         │    │    ├── sort
      │         │    │    │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         │    │    │    ├── ordering: +5,+6
      │         │    │    │    ├── limit hint: 2.00
      │         │    │    │    └── scan xyz
      │         │    │    │         └── columns: x:4(int!null) y:5(int!null) z:6(int!null)
      │         │    │    └── const: 2 [type=int]
      │         │    └── filters (true)
      │         └── projections
      │              ├── CASE WHEN abc.a IS NULL THEN x ELSE 10 END [type=int]
      │              ├── CASE WHEN abc.a IS NULL THEN y ELSE abc.b END [type=int]
      │              └── CASE WHEN abc.a IS NULL THEN z ELSE abc.c END [type=int]
      └── with-scan &1
           ├── columns: a:14(int!null) b:15(int!null) c:16(int!null)
           └── mapping:
                ├──  abc.a:1(int) => a:14(int)
                ├──  abc.b:2(int) => b:15(int)
                └──  abc.c:3(int) => c:16(int)

# --------------------------------------------------
# Delete operator.
# --------------------------------------------------

# Verify that the external ordering is passed through to input.
opt
SELECT * FROM [DELETE FROM abcd RETURNING *] ORDER BY c
----
sort
 ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
 ├── ordering: +13
 └── with &1
      ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
      ├── project
      │    ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int)
      │    └── delete abcd
      │         ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         └── scan abcd
      │              └── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      └── with-scan &1
           ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
           └── mapping:
                ├──  abcd.a:1(int) => a:11(int)
                ├──  abcd.b:2(int) => b:12(int)
                ├──  abcd.c:3(int) => c:13(int)
                └──  abcd.d:4(int) => d:14(int)

# Verify that provided orderings are derived correctly.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [DELETE FROM abcd ORDER BY c LIMIT 10 RETURNING *]
ORDER BY c, d
----
sort
 ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── ordering: +13,+14
 ├── prune: (11-14)
 └── with &1
      ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── prune: (11-14)
      ├── project
      │    ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int)
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    ├── prune: (1-4)
      │    └── delete abcd
      │         ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── scan abcd@cd
      │              ├── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              ├── limit: 10
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9)
      │              ├── prune: (6,7,9,10)
      │              └── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      └── with-scan &1
           ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
           ├── mapping:
           │    ├──  abcd.a:1(int) => a:11(int)
           │    ├──  abcd.b:2(int) => b:12(int)
           │    ├──  abcd.c:3(int) => c:13(int)
           │    └──  abcd.d:4(int) => d:14(int)
           ├── cardinality: [0 - 10]
           └── prune: (11-14)

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt format=(hide-qual,hide-cost,hide-stats,hide-constraints,hide-scalars)
SELECT *
FROM [DELETE FROM abcd ORDER BY c, d LIMIT 10 RETURNING *]
WHERE b=c
ORDER BY b, d
----
sort
 ├── columns: a:11(int) b:12(int!null) c:13(int!null) d:14(int)
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── fd: (12)==(13), (13)==(12)
 ├── ordering: +(12|13),+14 [actual: +12,+14]
 ├── prune: (11,14)
 └── with &1
      ├── columns: a:11(int) b:12(int!null) c:13(int!null) d:14(int)
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── fd: (12)==(13), (13)==(12)
      ├── prune: (11,14)
      ├── project
      │    ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int)
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    ├── prune: (1-4)
      │    └── delete abcd
      │         ├── columns: abcd.a:1(int) abcd.b:2(int) abcd.c:3(int) abcd.d:4(int) rowid:5(int!null)
      │         ├── fetch columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int)
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── scan abcd@cd
      │              ├── columns: abcd.a:6(int) abcd.b:7(int) abcd.c:8(int) abcd.d:9(int) rowid:10(int!null)
      │              ├── limit: 10
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9)
      │              ├── prune: (6,7,10)
      │              └── interesting orderings: (+10) (+6,+7,+10) (+8,+9,+10)
      └── select
           ├── columns: a:11(int) b:12(int!null) c:13(int!null) d:14(int)
           ├── cardinality: [0 - 10]
           ├── fd: (12)==(13), (13)==(12)
           ├── prune: (11,14)
           ├── with-scan &1
           │    ├── columns: a:11(int) b:12(int) c:13(int) d:14(int)
           │    ├── mapping:
           │    │    ├──  abcd.a:1(int) => a:11(int)
           │    │    ├──  abcd.b:2(int) => b:12(int)
           │    │    ├──  abcd.c:3(int) => c:13(int)
           │    │    └──  abcd.d:4(int) => d:14(int)
           │    ├── cardinality: [0 - 10]
           │    └── prune: (11-14)
           └── filters
                └── b = c [type=bool, outer=(12,13), fd=(12)==(13), (13)==(12)]


# Regression test for #36219: lookup join with ON condition that imposes an
# equality on two input columns (which isn't pushed down).
opt disable=(PushFilterIntoJoinLeftAndRight,PushFilterIntoJoinLeft,PushFilterIntoJoinRight,MapFilterIntoJoinLeft,MapFilterIntoJoinRight)
SELECT * FROM abc JOIN xyz ON a=x AND x=z ORDER BY z
----
inner-join (merge)
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) x:4(int!null) y:5(int!null) z:6(int!null)
 ├── left ordering: +1
 ├── right ordering: +4
 ├── ordering: +(1|4|6)
 ├── scan abc
 │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4(int!null) y:5(int!null) z:6(int!null)
 │    └── ordering: +4
 └── filters
      └── x = z [type=bool]

# TODO(justin): figure out when it is that window functions can preserve their
# input ordering.
opt
SELECT *, row_number() OVER() FROM abc ORDER BY a
----
sort
 ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) row_number:4(int)
 ├── ordering: +1
 └── window partition=()
      ├── columns: a:1(int!null) b:2(int!null) c:3(int!null) row_number:4(int)
      ├── scan abc
      │    └── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      └── windows
           └── row-number [type=int]
