exec-ddl
CREATE TABLE a
(
    x INT,
    y FLOAT,
    z DECIMAL,
    s STRING NOT NULL,
    PRIMARY KEY (x, y DESC)
)
----

exec-ddl
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, b, c))
----

exec-ddl
CREATE TABLE xyz (x INT, y INT, z INT, PRIMARY KEY (x, y, z))
----

exec-ddl
CREATE TABLE abcd (a INT, b INT, c INT, d INT, INDEX ab(a, b) STORING (c, d), INDEX cd(c, d) STORING (a, b))
----

# --------------------------------------------------
# Scan operator.
# --------------------------------------------------

# Order by entire key, in same order as key.
opt
SELECT * FROM a ORDER BY x, y DESC
----
scan a
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 └── ordering: +1,-2

# Order by prefix.
opt
SELECT * FROM a ORDER BY x
----
scan a
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 └── ordering: +1

# Order by additional column (should be dropped by optimizer).
opt
SELECT * FROM a ORDER BY x, y DESC, z
----
scan a
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 └── ordering: +1,-2

# Order by suffix (scan shouldn't be able to provide).
opt
SELECT * FROM a ORDER BY y DESC
----
sort
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: -2
 └── scan a
      ├── columns: x:1!null y:2!null z:3 s:4!null
      ├── key: (1,2)
      └── fd: (1,2)-->(3,4)

# Order by suffix, don't project prefix (scan shouldn't be able to provide).
opt
SELECT y FROM a ORDER BY y DESC
----
sort
 ├── columns: y:2!null
 ├── ordering: -2
 └── scan a
      └── columns: y:2!null

# --------------------------------------------------
# Select operator (pass through).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT * FROM a WHERE x>y ORDER BY x, y DESC
----
select
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: +1,-2
 ├── scan a
 │    ├── columns: x:1!null y:2!null z:3 s:4!null
 │    ├── key: (1,2)
 │    ├── fd: (1,2)-->(3,4)
 │    └── ordering: +1,-2
 └── filters
      └── x:1 > y:2 [outer=(1,2)]

# Pass through ordering to scan operator that can't support it.
opt
SELECT * FROM a WHERE x>y ORDER BY z DESC
----
sort
 ├── columns: x:1!null y:2!null z:3 s:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4)
 ├── ordering: -3
 └── select
      ├── columns: x:1!null y:2!null z:3 s:4!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── scan a
      │    ├── columns: x:1!null y:2!null z:3 s:4!null
      │    ├── key: (1,2)
      │    └── fd: (1,2)-->(3,4)
      └── filters
           └── x:1 > y:2 [outer=(1,2)]

# --------------------------------------------------
# Project operator (pass through).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT x+1 AS r, y FROM a ORDER BY x, y DESC
----
project
 ├── columns: r:5!null y:2!null  [hidden: x:1!null]
 ├── key: (1,2)
 ├── fd: (1)-->(5)
 ├── ordering: +1,-2
 ├── scan a
 │    ├── columns: x:1!null y:2!null
 │    ├── key: (1,2)
 │    └── ordering: +1,-2
 └── projections
      └── x:1 + 1 [as=r:5, outer=(1)]

# Pass through ordering to scan operator that can't support it.
opt
SELECT y, x, z+1 AS r FROM a ORDER BY x, y
----
sort (segmented)
 ├── columns: y:2!null x:1!null r:5
 ├── key: (1,2)
 ├── fd: (1,2)-->(5)
 ├── ordering: +1,+2
 └── project
      ├── columns: r:5 x:1!null y:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(5)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: x:1!null y:2!null z:3
      │    ├── key: (1,2)
      │    ├── fd: (1,2)-->(3)
      │    └── ordering: +1
      └── projections
           └── z:3 + 1 [as=r:5, outer=(3)]

# Ordering cannot be passed through because it includes computed column.
opt
SELECT x, y+1 AS computed, y FROM a ORDER BY x, computed
----
sort (segmented)
 ├── columns: x:1!null computed:5!null y:2!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(5)
 ├── ordering: +1,+5
 └── project
      ├── columns: computed:5!null x:1!null y:2!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(5)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: x:1!null y:2!null
      │    ├── key: (1,2)
      │    └── ordering: +1
      └── projections
           └── y:2 + 1.0 [as=computed:5, outer=(2)]

# Ordering on an expression that gets constant-folded to a simple variable.
# Example from #43360: a boolean (possibly a placeholder) indicates the sort
# direction.
opt
SELECT * FROM a ORDER BY CASE WHEN false THEN x END ASC, CASE WHEN NOT false THEN x END DESC
----
project
 ├── columns: x:1!null y:2!null z:3 s:4!null  [hidden: column6:6!null]
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4), (1)==(6), (6)==(1)
 ├── ordering: -(1|6) [actual: -1]
 ├── scan a,rev
 │    ├── columns: x:1!null y:2!null z:3 s:4!null
 │    ├── key: (1,2)
 │    ├── fd: (1,2)-->(3,4)
 │    └── ordering: -1
 └── projections
      └── x:1 [as=column6:6, outer=(1)]

opt
SELECT * FROM a ORDER BY CASE WHEN true THEN x END ASC, CASE WHEN NOT true THEN x END DESC
----
project
 ├── columns: x:1!null y:2!null z:3 s:4!null  [hidden: column5:5!null]
 ├── key: (1,2)
 ├── fd: (1,2)-->(3,4), (1)==(5), (5)==(1)
 ├── ordering: +(1|5) [actual: +1]
 ├── scan a
 │    ├── columns: x:1!null y:2!null z:3 s:4!null
 │    ├── key: (1,2)
 │    ├── fd: (1,2)-->(3,4)
 │    └── ordering: +1
 └── projections
      └── x:1 [as=column5:5, outer=(1)]

# Similar case, except the equivalent input column is not being projected.
opt
SELECT 1 FROM a ORDER BY CASE WHEN false THEN x END ASC, CASE WHEN NOT false THEN x END DESC
----
project
 ├── columns: "?column?":5!null  [hidden: column7:7!null]
 ├── fd: ()-->(5)
 ├── ordering: -7 opt(5) [actual: -7]
 ├── scan a,rev
 │    ├── columns: x:1!null
 │    └── ordering: -1
 └── projections
      ├── 1 [as="?column?":5]
      └── x:1 [as=column7:7, outer=(1)]

# --------------------------------------------------
# Select + Project operators (pass through both).
# --------------------------------------------------

# Pass through ordering to scan operator that can support it.
opt
SELECT y, x-1 AS z FROM a WHERE x>y ORDER BY x, y DESC
----
project
 ├── columns: y:2!null z:5!null  [hidden: x:1!null]
 ├── key: (1,2)
 ├── fd: (1)-->(5)
 ├── ordering: +1,-2
 ├── select
 │    ├── columns: x:1!null y:2!null
 │    ├── key: (1,2)
 │    ├── ordering: +1,-2
 │    ├── scan a
 │    │    ├── columns: x:1!null y:2!null
 │    │    ├── key: (1,2)
 │    │    └── ordering: +1,-2
 │    └── filters
 │         └── x:1 > y:2 [outer=(1,2)]
 └── projections
      └── x:1 - 1 [as=z:5, outer=(1)]

memo
SELECT y, x-1 AS z FROM a WHERE x>y ORDER BY x, y DESC
----
memo (optimized, ~5KB, required=[presentation: y:2,z:5] [ordering: +1,-2])
 ├── G1: (project G2 G3 x y)
 │    ├── [presentation: y:2,z:5] [ordering: +1,-2]
 │    │    ├── best: (project G2="[ordering: +1,-2]" G3 x y)
 │    │    └── cost: 1076.71
 │    └── []
 │         ├── best: (project G2 G3 x y)
 │         └── cost: 1076.71
 ├── G2: (select G4 G5)
 │    ├── [ordering: +1,-2]
 │    │    ├── best: (select G4="[ordering: +1,-2]" G5)
 │    │    └── cost: 1070.03
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1070.03
 ├── G3: (projections G6)
 ├── G4: (scan a,cols=(1,2))
 │    ├── [ordering: +1,-2]
 │    │    ├── best: (scan a,cols=(1,2))
 │    │    └── cost: 1060.02
 │    └── []
 │         ├── best: (scan a,cols=(1,2))
 │         └── cost: 1060.02
 ├── G5: (filters G7)
 ├── G6: (minus G8 G9)
 ├── G7: (gt G8 G10)
 ├── G8: (variable x)
 ├── G9: (const 1)
 └── G10: (variable y)

# Pass through ordering to scan operator that can't support it.
opt
SELECT y, z FROM a WHERE x>y ORDER BY y
----
sort
 ├── columns: y:2!null z:3
 ├── ordering: +2
 └── project
      ├── columns: y:2!null z:3
      └── select
           ├── columns: x:1!null y:2!null z:3
           ├── key: (1,2)
           ├── fd: (1,2)-->(3)
           ├── scan a
           │    ├── columns: x:1!null y:2!null z:3
           │    ├── key: (1,2)
           │    └── fd: (1,2)-->(3)
           └── filters
                └── x:1 > y:2 [outer=(1,2)]

memo
SELECT y, z FROM a WHERE x>y ORDER BY y
----
memo (optimized, ~5KB, required=[presentation: y:2,z:3] [ordering: +2])
 ├── G1: (project G2 G3 y z)
 │    ├── [presentation: y:2,z:3] [ordering: +2]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1145.92
 │    └── []
 │         ├── best: (project G2 G3 y z)
 │         └── cost: 1083.37
 ├── G2: (select G4 G5)
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G2)
 │    │    └── cost: 1142.58
 │    └── []
 │         ├── best: (select G4 G5)
 │         └── cost: 1080.03
 ├── G3: (projections)
 ├── G4: (scan a,cols=(1-3))
 │    ├── [ordering: +2]
 │    │    ├── best: (sort G4)
 │    │    └── cost: 1289.35
 │    └── []
 │         ├── best: (scan a,cols=(1-3))
 │         └── cost: 1070.02
 ├── G5: (filters G6)
 ├── G6: (gt G7 G8)
 ├── G7: (variable x)
 └── G8: (variable y)

# --------------------------------------------------
# GroupBy operator.
# --------------------------------------------------

# Verify that the internal ordering is required of the input.
opt
SELECT array_agg(z) FROM (SELECT * FROM a ORDER BY y)
----
scalar-group-by
 ├── columns: array_agg:5
 ├── internal-ordering: +2
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── sort
 │    ├── columns: y:2!null z:3
 │    ├── ordering: +2
 │    └── scan a
 │         └── columns: y:2!null z:3
 └── aggregations
      └── array-agg [as=array_agg:5, outer=(3)]
           └── z:3

opt
SELECT array_agg(x) FROM (SELECT * FROM a ORDER BY x, y DESC)
----
scalar-group-by
 ├── columns: array_agg:5
 ├── internal-ordering: +1,-2
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── scan a
 │    ├── columns: x:1!null y:2!null
 │    ├── key: (1,2)
 │    └── ordering: +1,-2
 └── aggregations
      └── array-agg [as=array_agg:5, outer=(1)]
           └── x:1

# Pass through ordering on grouping columns.
opt
SELECT a, min(b) FROM abc GROUP BY a ORDER BY a
----
group-by
 ├── columns: a:1!null min:4!null
 ├── grouping columns: a:1!null
 ├── key: (1)
 ├── fd: (1)-->(4)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null
 │    └── ordering: +1
 └── aggregations
      └── min [as=min:4, outer=(2)]
           └── b:2

opt
SELECT a, b, min(c) FROM abc GROUP BY a, b ORDER BY a
----
group-by
 ├── columns: a:1!null b:2!null min:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +1,+2
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [as=min:4, outer=(3)]
           └── c:3

opt
SELECT a, b, min(c) FROM abc GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1!null b:2!null min:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [as=min:4, outer=(3)]
           └── c:3

opt
SELECT a, b, min(c) FROM abc GROUP BY b, a ORDER BY a, b
----
group-by
 ├── columns: a:1!null b:2!null min:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── min [as=min:4, outer=(3)]
           └── c:3

# We can't pass through the ordering if it refers to aggregation results.
opt
SELECT a, b, min(c) AS m FROM abc GROUP BY a, b ORDER BY a, m
----
sort (segmented)
 ├── columns: a:1!null b:2!null m:4!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+4
 └── group-by
      ├── columns: a:1!null b:2!null min:4!null
      ├── grouping columns: a:1!null b:2!null
      ├── internal-ordering: +1,+2
      ├── key: (1,2)
      ├── fd: (1,2)-->(4)
      ├── ordering: +1
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1,+2
      └── aggregations
           └── min [as=min:4, outer=(3)]
                └── c:3

# Satisfy both the required and the internal orderings by requiring a+,b+,c+.
opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY c) GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1!null b:2!null array_agg:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +3 opt(1,2)
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [as=array_agg:4, outer=(3)]
           └── c:3

opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY a, b, c) GROUP BY a, b ORDER BY a, b
----
group-by
 ├── columns: a:1!null b:2!null array_agg:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +3 opt(1,2)
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [as=array_agg:4, outer=(3)]
           └── c:3

opt
SELECT a, b, array_agg(c) FROM (SELECT * FROM abc ORDER BY b, c, a) GROUP BY b, a ORDER BY a, b
----
group-by
 ├── columns: a:1!null b:2!null array_agg:4!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +3 opt(1,2)
 ├── key: (1,2)
 ├── fd: (1,2)-->(4)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2,+3
 └── aggregations
      └── array-agg [as=array_agg:4, outer=(3)]
           └── c:3

# Verify that the GroupBy child ordering is simplified according to the child's
# FD set.
opt
SELECT sum(c) FROM abc WHERE a = 1 GROUP BY b ORDER BY b
----
group-by
 ├── columns: sum:4!null  [hidden: b:2!null]
 ├── grouping columns: b:2!null
 ├── key: (2)
 ├── fd: (2)-->(4)
 ├── ordering: +2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── constraint: /1/2/3: [/1 - /1]
 │    ├── key: (2,3)
 │    ├── fd: ()-->(1)
 │    └── ordering: +2 opt(1) [actual: +2]
 └── aggregations
      └── sum [as=sum:4, outer=(3)]
           └── c:3

# Verify we do a streaming group-by using the a, b ordering.
opt
SELECT sum(d) FROM abcd GROUP BY a, b, c
----
project
 ├── columns: sum:6
 └── group-by
      ├── columns: a:1 b:2 c:3 sum:6
      ├── grouping columns: a:1 b:2 c:3
      ├── internal-ordering: +1,+2
      ├── key: (1-3)
      ├── fd: (1-3)-->(6)
      ├── scan abcd@ab
      │    ├── columns: a:1 b:2 c:3 d:4
      │    └── ordering: +1,+2
      └── aggregations
           └── sum [as=sum:6, outer=(4)]
                └── d:4

# Verify we do a streaming group-by using the c, d ordering.
opt
SELECT sum(a) FROM abcd GROUP BY b, c, d
----
project
 ├── columns: sum:6
 └── group-by
      ├── columns: b:2 c:3 d:4 sum:6
      ├── grouping columns: b:2 c:3 d:4
      ├── internal-ordering: +3,+4
      ├── key: (2-4)
      ├── fd: (2-4)-->(6)
      ├── scan abcd@cd
      │    ├── columns: a:1 b:2 c:3 d:4
      │    └── ordering: +3,+4
      └── aggregations
           └── sum [as=sum:6, outer=(1)]
                └── a:1

opt
SELECT array_agg(d) FROM (SELECT * FROM abcd ORDER BY c) GROUP BY a, b
----
project
 ├── columns: array_agg:6
 └── group-by
      ├── columns: a:1 b:2 array_agg:6
      ├── grouping columns: a:1 b:2
      ├── internal-ordering: +3 opt(1,2)
      ├── key: (1,2)
      ├── fd: (1,2)-->(6)
      ├── scan abcd@cd
      │    ├── columns: a:1 b:2 c:3 d:4
      │    └── ordering: +3 opt(1,2) [actual: +3]
      └── aggregations
           └── array-agg [as=array_agg:6, outer=(4)]
                └── d:4

# --------------------------------------------------
# Explain operator.
# --------------------------------------------------
opt
EXPLAIN (VERBOSE) SELECT * FROM a ORDER BY y
----
explain
 ├── columns: tree:5 field:8 description:9 columns:10 ordering:11  [hidden: level:6 node_type:7]
 ├── mode: verbose
 └── sort
      ├── columns: x:1!null y:2!null z:3 s:4!null
      ├── key: (1,2)
      ├── fd: (1,2)-->(3,4)
      ├── ordering: +2
      └── scan a
           ├── columns: x:1!null y:2!null z:3 s:4!null
           ├── key: (1,2)
           └── fd: (1,2)-->(3,4)

memo
EXPLAIN (VERBOSE) SELECT * FROM a ORDER BY y
----
memo (optimized, ~2KB, required=[presentation: tree:5,field:8,description:9,columns:10,ordering:11])
 ├── G1: (explain G2 [presentation: x:1,y:2,z:3,s:4] [ordering: +2])
 │    └── [presentation: tree:5,field:8,description:9,columns:10,ordering:11]
 │         ├── best: (explain G2="[presentation: x:1,y:2,z:3,s:4] [ordering: +2]" [presentation: x:1,y:2,z:3,s:4] [ordering: +2])
 │         └── cost: 1299.36
 └── G2: (scan a)
      ├── [presentation: x:1,y:2,z:3,s:4] [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1299.35
      └── []
           ├── best: (scan a)
           └── cost: 1080.02

# --------------------------------------------------
# With Ordinality
# --------------------------------------------------

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2)
 │    │    └── cost: 1060.03
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM a WITH ORDINALITY ORDER BY -ordinality
----
memo (optimized, ~5KB, required=[presentation: y:2] [ordering: +6])
 ├── G1: (project G2 G3 y)
 │    ├── [presentation: y:2] [ordering: +6]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1299.37
 │    └── []
 │         ├── best: (project G2 G3 y)
 │         └── cost: 1080.04
 ├── G2: (ordinality G4)
 │    └── []
 │         ├── best: (ordinality G4)
 │         └── cost: 1060.03
 ├── G3: (projections G5)
 ├── G4: (scan a,cols=(2))
 │    └── []
 │         ├── best: (scan a,cols=(2))
 │         └── cost: 1050.02
 ├── G5: (unary-minus G6)
 └── G6: (variable ordinality)

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality, x
----
memo (optimized, ~6KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2)
 │    │    └── cost: 1060.03
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM (SELECT * FROM a ORDER BY y) WITH ORDINALITY ORDER BY y, ordinality
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +2,+5])
 ├── G1: (ordinality G2 ordering=+2)
 │    ├── [presentation: y:2] [ordering: +2,+5]
 │    │    ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │         └── cost: 1279.36
 └── G2: (scan a,cols=(2))
      ├── [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1269.35
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM (SELECT * FROM a ORDER BY y) WITH ORDINALITY ORDER BY ordinality, y
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: +5])
 ├── G1: (ordinality G2 ordering=+2)
 │    ├── [presentation: y:2] [ordering: +5]
 │    │    ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2="[ordering: +2]" ordering=+2)
 │         └── cost: 1279.36
 └── G2: (scan a,cols=(2))
      ├── [ordering: +2]
      │    ├── best: (sort G2)
      │    └── cost: 1269.35
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

memo
SELECT y FROM a WITH ORDINALITY ORDER BY ordinality DESC
----
memo (optimized, ~4KB, required=[presentation: y:2] [ordering: -5])
 ├── G1: (ordinality G2)
 │    ├── [presentation: y:2] [ordering: -5]
 │    │    ├── best: (sort G1)
 │    │    └── cost: 1279.36
 │    └── []
 │         ├── best: (ordinality G2)
 │         └── cost: 1060.03
 └── G2: (scan a,cols=(2))
      └── []
           ├── best: (scan a,cols=(2))
           └── cost: 1050.02

# --------------------------------------------------
# Merge Join
# --------------------------------------------------

opt
SELECT * FROM abc JOIN xyz ON a=x ORDER BY a
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1
 ├── right ordering: +4
 ├── key: (2-6)
 ├── fd: (1)==(4), (4)==(1)
 ├── ordering: +(1|4) [actual: +1]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x ORDER BY x
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1
 ├── right ordering: +4
 ├── key: (2-6)
 ├── fd: (1)==(4), (4)==(1)
 ├── ordering: +(1|4) [actual: +1]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4
 └── filters (true)

# A left join guarantees an ordering on the left side.
opt
SELECT * FROM abc LEFT JOIN xyz ON a=x ORDER BY a
----
left-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4 y:5 z:6
 ├── left ordering: +1
 ├── right ordering: +4
 ├── key: (1-6)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4
 └── filters (true)

# A left join doesn't guarantee an ordering on x (some rows will have NULLs).
opt
SELECT * FROM abc LEFT JOIN xyz ON a=x ORDER BY x
----
sort
 ├── columns: a:1!null b:2!null c:3!null x:4 y:5 z:6
 ├── key: (1-6)
 ├── ordering: +4
 └── left-join (merge)
      ├── columns: a:1!null b:2!null c:3!null x:4 y:5 z:6
      ├── left ordering: +1
      ├── right ordering: +4
      ├── key: (1-6)
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1
      ├── scan xyz
      │    ├── columns: x:4!null y:5!null z:6!null
      │    ├── key: (4-6)
      │    └── ordering: +4
      └── filters (true)

# A right join doesn't guarantee an ordering on a (some rows will have NULLs).
opt
SELECT * FROM abc RIGHT JOIN xyz ON a=x ORDER BY a
----
sort
 ├── columns: a:1 b:2 c:3 x:4!null y:5!null z:6!null
 ├── key: (1-6)
 ├── ordering: +1
 └── left-join (merge)
      ├── columns: a:1 b:2 c:3 x:4!null y:5!null z:6!null
      ├── left ordering: +4
      ├── right ordering: +1
      ├── key: (1-6)
      ├── scan xyz
      │    ├── columns: x:4!null y:5!null z:6!null
      │    ├── key: (4-6)
      │    └── ordering: +4
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1
      └── filters (true)

opt
SELECT * FROM abc RIGHT JOIN xyz ON a=x ORDER BY x
----
left-join (merge)
 ├── columns: a:1 b:2 c:3 x:4!null y:5!null z:6!null
 ├── left ordering: +4
 ├── right ordering: +1
 ├── key: (1-6)
 ├── ordering: +4
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 └── filters (true)

opt
SELECT * FROM abc FULL OUTER JOIN xyz ON a=x ORDER BY a
----
sort
 ├── columns: a:1 b:2 c:3 x:4 y:5 z:6
 ├── key: (1-6)
 ├── ordering: +1
 └── full-join (merge)
      ├── columns: a:1 b:2 c:3 x:4 y:5 z:6
      ├── left ordering: +1
      ├── right ordering: +4
      ├── key: (1-6)
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1
      ├── scan xyz
      │    ├── columns: x:4!null y:5!null z:6!null
      │    ├── key: (4-6)
      │    └── ordering: +4
      └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── key: (3-6)
 ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2)
 ├── ordering: +(1|4) [actual: +1]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4,+5
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a, b
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── key: (3-6)
 ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2)
 ├── ordering: +(1|4),+(2|5) [actual: +1,+2]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4,+5
 └── filters (true)

opt
SELECT * FROM abc JOIN xyz ON a=x AND b=y ORDER BY a, y
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1,+2
 ├── right ordering: +4,+5
 ├── key: (3-6)
 ├── fd: (1)==(4), (4)==(1), (2)==(5), (5)==(2)
 ├── ordering: +(1|4),+(2|5) [actual: +1,+2]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4,+5
 └── filters (true)

# --------------------------------------------------
# Limit / Offset
# --------------------------------------------------

# Basic cases.

opt
SELECT * FROM abc ORDER BY a, b LIMIT 10
----
scan abc
 ├── columns: a:1!null b:2!null c:3!null
 ├── limit: 10
 ├── key: (1-3)
 └── ordering: +1,+2

# The filter prevents pushing of the limit into the scan.
opt
SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10
----
limit
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── cardinality: [0 - 10]
 ├── key: (1-3)
 ├── ordering: +1,+2
 ├── select
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +1,+2
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1!null b:2!null c:3!null
 │    │    ├── key: (1-3)
 │    │    ├── ordering: +1,+2
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c:3 < (a:1 + b:2) [outer=(1-3)]
 └── 10

opt
SELECT * FROM abc ORDER BY a, b OFFSET 10 
----
offset
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── key: (1-3)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── 10


# Cases where the requirement on Limit/Offset is incompatible with the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY b
----
sort
 ├── columns: a:1!null b:2!null c:3!null
 ├── cardinality: [0 - 10]
 ├── key: (1-3)
 ├── ordering: +2
 └── scan abc
      ├── columns: a:1!null b:2!null c:3!null
      ├── limit: 10
      └── key: (1-3)

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY b
----
sort
 ├── columns: a:1!null b:2!null c:3!null
 ├── cardinality: [0 - 10]
 ├── key: (1-3)
 ├── ordering: +2
 └── limit
      ├── columns: a:1!null b:2!null c:3!null
      ├── internal-ordering: +1,+2
      ├── cardinality: [0 - 10]
      ├── key: (1-3)
      ├── select
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    ├── ordering: +1,+2
      │    ├── limit hint: 10.00
      │    ├── scan abc
      │    │    ├── columns: a:1!null b:2!null c:3!null
      │    │    ├── key: (1-3)
      │    │    ├── ordering: +1,+2
      │    │    └── limit hint: 30.00
      │    └── filters
      │         └── c:3 < (a:1 + b:2) [outer=(1-3)]
      └── 10

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY b
----
sort
 ├── columns: a:1!null b:2!null c:3!null
 ├── key: (1-3)
 ├── ordering: +2
 └── offset
      ├── columns: a:1!null b:2!null c:3!null
      ├── internal-ordering: +1,+2
      ├── key: (1-3)
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1,+2
      └── 10


# Cases where the requirement on Limit/Offset is weaker than the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY a
----
scan abc
 ├── columns: a:1!null b:2!null c:3!null
 ├── limit: 10
 ├── key: (1-3)
 └── ordering: +1

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY a
----
limit
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── cardinality: [0 - 10]
 ├── key: (1-3)
 ├── ordering: +1
 ├── select
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +1,+2
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1!null b:2!null c:3!null
 │    │    ├── key: (1-3)
 │    │    ├── ordering: +1,+2
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c:3 < (a:1 + b:2) [outer=(1-3)]
 └── 10

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY a
----
offset
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── key: (1-3)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── 10

# Cases where the requirement on Limit/Offset is stronger than the
# internal requirement.

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b LIMIT 10) ORDER BY a, b, c
----
scan abc
 ├── columns: a:1!null b:2!null c:3!null
 ├── limit: 10
 ├── key: (1-3)
 └── ordering: +1,+2,+3

opt
SELECT * FROM (SELECT * FROM abc WHERE a+b>c ORDER BY a, b LIMIT 10) ORDER BY a, b, c
----
limit
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── cardinality: [0 - 10]
 ├── key: (1-3)
 ├── ordering: +1,+2,+3
 ├── select
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +1,+2,+3
 │    ├── limit hint: 10.00
 │    ├── scan abc
 │    │    ├── columns: a:1!null b:2!null c:3!null
 │    │    ├── key: (1-3)
 │    │    ├── ordering: +1,+2,+3
 │    │    └── limit hint: 30.00
 │    └── filters
 │         └── c:3 < (a:1 + b:2) [outer=(1-3)]
 └── 10

opt
SELECT * FROM (SELECT * FROM abc ORDER BY a, b OFFSET 10) ORDER BY a, b, c
----
offset
 ├── columns: a:1!null b:2!null c:3!null
 ├── internal-ordering: +1,+2
 ├── key: (1-3)
 ├── ordering: +1,+2,+3
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2,+3
 └── 10

# --------------------------------------------------
# DistinctOn
# --------------------------------------------------

# DISTINCT doesn't require any particular ordering of its input. It could pass
# through the requirement, but that doesn't improve the estimated cost in this
# case.
opt
SELECT DISTINCT b, c FROM abc ORDER BY b
----
distinct-on
 ├── columns: b:2!null c:3!null
 ├── grouping columns: b:2!null c:3!null
 ├── key: (2,3)
 ├── ordering: +2
 └── sort
      ├── columns: b:2!null c:3!null
      ├── ordering: +2
      └── scan abc
           └── columns: b:2!null c:3!null

# In this case the ordering is passed through.
opt
SELECT DISTINCT a, b, c FROM abc ORDER BY a, b
----
scan abc
 ├── columns: a:1!null b:2!null c:3!null
 ├── key: (1-3)
 └── ordering: +1,+2

# DISTINCT ON requires the ordering of its input, as it affects the results
# (values of a in this case).
opt
SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY b
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: b:2!null c:3!null
 ├── key: (2,3)
 ├── fd: (2,3)-->(1)
 ├── ordering: +2
 ├── sort
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +2
 │    └── scan abc
 │         ├── columns: a:1!null b:2!null c:3!null
 │         └── key: (1-3)
 └── aggregations
      └── first-agg [as=a:1, outer=(1)]
           └── a:1

opt
SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY b, c, a
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: b:2!null c:3!null
 ├── internal-ordering: +1 opt(2,3)
 ├── key: (2,3)
 ├── fd: (2,3)-->(1)
 ├── ordering: +2,+3
 ├── sort
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +2,+3,+1
 │    └── scan abc
 │         ├── columns: a:1!null b:2!null c:3!null
 │         └── key: (1-3)
 └── aggregations
      └── first-agg [as=a:1, outer=(1)]
           └── a:1

opt
SELECT DISTINCT ON (a) a, c FROM abc ORDER BY a, c DESC, b
----
distinct-on
 ├── columns: a:1!null c:3!null
 ├── grouping columns: a:1!null
 ├── internal-ordering: -3,+2 opt(1)
 ├── key: (1)
 ├── fd: (1)-->(3)
 ├── ordering: +1
 ├── sort (segmented)
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    ├── ordering: +1,-3,+2
 │    └── scan abc
 │         ├── columns: a:1!null b:2!null c:3!null
 │         ├── key: (1-3)
 │         └── ordering: +1
 └── aggregations
      └── first-agg [as=c:3, outer=(3)]
           └── c:3

# Pass through the ordering from above.
opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc) ORDER BY a
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +1,+2
 ├── key: (1,2)
 ├── fd: (1,2)-->(3)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [as=c:3, outer=(3)]
           └── c:3

# Internal orderings that refer just to ON columns can be ignored.
opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc ORDER BY a) ORDER BY a, b
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: a:1!null b:2!null
 ├── key: (1,2)
 ├── fd: (1,2)-->(3)
 ├── ordering: +1,+2
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [as=c:3, outer=(3)]
           └── c:3

opt
SELECT * FROM (SELECT DISTINCT ON (a, b) a, b, c FROM abc ORDER BY a, b) ORDER BY a
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: a:1!null b:2!null
 ├── internal-ordering: +1,+2
 ├── key: (1,2)
 ├── fd: (1,2)-->(3)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1,+2
 └── aggregations
      └── first-agg [as=c:3, outer=(3)]
           └── c:3

# The c,b part of the inner ordering can be ignored.
opt
SELECT * FROM (SELECT DISTINCT ON (b, c) a, b, c FROM abc ORDER BY c, b, a) ORDER BY a
----
distinct-on
 ├── columns: a:1!null b:2!null c:3!null
 ├── grouping columns: b:2!null c:3!null
 ├── internal-ordering: +1 opt(2,3)
 ├── key: (2,3)
 ├── fd: (2,3)-->(1)
 ├── ordering: +1
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 └── aggregations
      └── first-agg [as=a:1, outer=(1)]
           └── a:1

# There is no ordering that satisfies both the intra-group ordering of c+ and the
# inter-group ordering of a+; we have to sort twice.
opt
SELECT * FROM (SELECT DISTINCT ON (b) a, b, c FROM abc ORDER BY b, c) ORDER BY a
----
sort
 ├── columns: a:1!null b:2!null c:3!null
 ├── key: (2)
 ├── fd: (2)-->(1,3)
 ├── ordering: +1
 └── distinct-on
      ├── columns: a:1!null b:2!null c:3!null
      ├── grouping columns: b:2!null
      ├── internal-ordering: +3 opt(2)
      ├── key: (2)
      ├── fd: (2)-->(1,3)
      ├── sort
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    ├── ordering: +3 opt(2) [actual: +3]
      │    └── scan abc
      │         ├── columns: a:1!null b:2!null c:3!null
      │         └── key: (1-3)
      └── aggregations
           ├── first-agg [as=a:1, outer=(1)]
           │    └── a:1
           └── first-agg [as=c:3, outer=(3)]
                └── c:3

# Same as above, except we can use the index ordering for the distinct input.
opt
SELECT * FROM (SELECT DISTINCT ON (a) a, b, c FROM abc ORDER BY a, b) ORDER BY c
----
sort
 ├── columns: a:1!null b:2!null c:3!null
 ├── key: (1)
 ├── fd: (1)-->(2,3)
 ├── ordering: +3
 └── distinct-on
      ├── columns: a:1!null b:2!null c:3!null
      ├── grouping columns: a:1!null
      ├── internal-ordering: +1,+2
      ├── key: (1)
      ├── fd: (1)-->(2,3)
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    ├── key: (1-3)
      │    └── ordering: +1,+2
      └── aggregations
           ├── first-agg [as=b:2, outer=(2)]
           │    └── b:2
           └── first-agg [as=c:3, outer=(3)]
                └── c:3

# Verify that we simplify the child ordering of DistinctOn.
opt
SELECT DISTINCT ON(a) a, b FROM abc WHERE a=c ORDER BY a
----
distinct-on
 ├── columns: a:1!null b:2!null
 ├── grouping columns: a:1!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── ordering: +1
 ├── select
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (2,3)
 │    ├── fd: (1)==(3), (3)==(1)
 │    ├── ordering: +(1|3) [actual: +1]
 │    ├── scan abc
 │    │    ├── columns: a:1!null b:2!null c:3!null
 │    │    ├── key: (1-3)
 │    │    └── ordering: +1
 │    └── filters
 │         └── a:1 = c:3 [outer=(1,3), fd=(1)==(3), (3)==(1)]
 └── aggregations
      └── first-agg [as=b:2, outer=(2)]
           └── b:2

# --------------------------------------------------
# Insert operator.
# --------------------------------------------------

# Verify that external ordering is passed through to input.
opt
SELECT * FROM [INSERT INTO abc SELECT * FROM xyz ORDER BY y, z LIMIT 2 RETURNING *] ORDER BY b
----
sort
 ├── columns: a:7!null b:8!null c:9!null
 ├── cardinality: [0 - 2]
 ├── side-effects, mutations
 ├── key: (7-9)
 ├── ordering: +8
 └── with &1
      ├── columns: a:7!null b:8!null c:9!null
      ├── cardinality: [0 - 2]
      ├── side-effects, mutations
      ├── key: (7-9)
      ├── insert abc
      │    ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null
      │    ├── insert-mapping:
      │    │    ├── x:4 => abc.a:1
      │    │    ├── y:5 => abc.b:2
      │    │    └── z:6 => abc.c:3
      │    ├── cardinality: [0 - 2]
      │    ├── side-effects, mutations
      │    ├── key: (1-3)
      │    └── limit
      │         ├── columns: x:4!null y:5!null z:6!null
      │         ├── internal-ordering: +5,+6
      │         ├── cardinality: [0 - 2]
      │         ├── key: (4-6)
      │         ├── sort
      │         │    ├── columns: x:4!null y:5!null z:6!null
      │         │    ├── key: (4-6)
      │         │    ├── ordering: +5,+6
      │         │    ├── limit hint: 2.00
      │         │    └── scan xyz
      │         │         ├── columns: x:4!null y:5!null z:6!null
      │         │         └── key: (4-6)
      │         └── 2
      └── with-scan &1
           ├── columns: a:7!null b:8!null c:9!null
           ├── mapping:
           │    ├──  abc.a:1 => a:7
           │    ├──  abc.b:2 => b:8
           │    └──  abc.c:3 => c:9
           ├── cardinality: [0 - 2]
           └── key: (7-9)

# Verify that provided orderings are derived correctly.
opt
SELECT *
FROM [INSERT INTO xyz SELECT b, c, d FROM abcd ORDER BY c, d LIMIT 2 RETURNING *]
ORDER BY y
----
sort
 ├── columns: x:9!null y:10!null z:11!null
 ├── cardinality: [0 - 2]
 ├── side-effects, mutations
 ├── ordering: +10
 └── with &1
      ├── columns: x:9!null y:10!null z:11!null
      ├── cardinality: [0 - 2]
      ├── side-effects, mutations
      ├── insert xyz
      │    ├── columns: xyz.x:1!null xyz.y:2!null xyz.z:3!null
      │    ├── insert-mapping:
      │    │    ├── b:5 => xyz.x:1
      │    │    ├── c:6 => xyz.y:2
      │    │    └── d:7 => xyz.z:3
      │    ├── cardinality: [0 - 2]
      │    ├── side-effects, mutations
      │    └── scan abcd@cd
      │         ├── columns: b:5 c:6 d:7
      │         └── limit: 2
      └── with-scan &1
           ├── columns: x:9!null y:10!null z:11!null
           ├── mapping:
           │    ├──  xyz.x:1 => x:9
           │    ├──  xyz.y:2 => y:10
           │    └──  xyz.z:3 => z:11
           └── cardinality: [0 - 2]

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt
SELECT *
FROM [INSERT INTO xyz SELECT b, c, d FROM abcd ORDER BY c, d LIMIT 2 RETURNING *]
WHERE x=y
ORDER BY y
----
sort
 ├── columns: x:9!null y:10!null z:11!null
 ├── cardinality: [0 - 2]
 ├── side-effects, mutations
 ├── fd: (9)==(10), (10)==(9)
 ├── ordering: +(9|10) [actual: +9]
 └── with &1
      ├── columns: x:9!null y:10!null z:11!null
      ├── cardinality: [0 - 2]
      ├── side-effects, mutations
      ├── fd: (9)==(10), (10)==(9)
      ├── insert xyz
      │    ├── columns: xyz.x:1!null xyz.y:2!null xyz.z:3!null
      │    ├── insert-mapping:
      │    │    ├── b:5 => xyz.x:1
      │    │    ├── c:6 => xyz.y:2
      │    │    └── d:7 => xyz.z:3
      │    ├── cardinality: [0 - 2]
      │    ├── side-effects, mutations
      │    └── scan abcd@cd
      │         ├── columns: b:5 c:6 d:7
      │         └── limit: 2
      └── select
           ├── columns: x:9!null y:10!null z:11!null
           ├── cardinality: [0 - 2]
           ├── fd: (9)==(10), (10)==(9)
           ├── with-scan &1
           │    ├── columns: x:9!null y:10!null z:11!null
           │    ├── mapping:
           │    │    ├──  xyz.x:1 => x:9
           │    │    ├──  xyz.y:2 => y:10
           │    │    └──  xyz.z:3 => z:11
           │    └── cardinality: [0 - 2]
           └── filters
                └── x:9 = y:10 [outer=(9,10), fd=(9)==(10), (10)==(9)]

# Ignore internal ordering.
opt
SELECT * FROM [INSERT INTO abc SELECT * FROM xyz ORDER BY y, z RETURNING *]
----
with &1
 ├── columns: a:7!null b:8!null c:9!null
 ├── side-effects, mutations
 ├── key: (7-9)
 ├── insert abc
 │    ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null
 │    ├── insert-mapping:
 │    │    ├── x:4 => abc.a:1
 │    │    ├── y:5 => abc.b:2
 │    │    └── z:6 => abc.c:3
 │    ├── side-effects, mutations
 │    ├── key: (1-3)
 │    └── scan xyz
 │         ├── columns: x:4!null y:5!null z:6!null
 │         └── key: (4-6)
 └── with-scan &1
      ├── columns: a:7!null b:8!null c:9!null
      ├── mapping:
      │    ├──  abc.a:1 => a:7
      │    ├──  abc.b:2 => b:8
      │    └──  abc.c:3 => c:9
      └── key: (7-9)

# --------------------------------------------------
# Update operator.
# --------------------------------------------------

# Verify that the external ordering is passed through to input.
opt
SELECT * FROM [UPDATE abcd SET (a, b)=(1, 2) RETURNING *] ORDER BY c
----
sort
 ├── columns: a:13!null b:14!null c:15 d:16
 ├── side-effects, mutations
 ├── fd: ()-->(13,14)
 ├── ordering: +15 opt(13,14) [actual: +15]
 └── with &1
      ├── columns: a:13!null b:14!null c:15 d:16
      ├── side-effects, mutations
      ├── fd: ()-->(13,14)
      ├── project
      │    ├── columns: abcd.a:1!null abcd.b:2!null abcd.c:3 abcd.d:4
      │    ├── side-effects, mutations
      │    ├── fd: ()-->(1,2)
      │    └── update abcd
      │         ├── columns: abcd.a:1!null abcd.b:2!null abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── update-mapping:
      │         │    ├── column11:11 => abcd.a:1
      │         │    └── column12:12 => abcd.b:2
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: ()-->(1,2), (5)-->(3,4)
      │         └── project
      │              ├── columns: column11:11!null column12:12!null abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── key: (10)
      │              ├── fd: ()-->(11,12), (10)-->(6-9)
      │              ├── scan abcd
      │              │    ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              │    ├── key: (10)
      │              │    └── fd: (10)-->(6-9)
      │              └── projections
      │                   ├── 1 [as=column11:11]
      │                   └── 2 [as=column12:12]
      └── with-scan &1
           ├── columns: a:13!null b:14!null c:15 d:16
           ├── mapping:
           │    ├──  abcd.a:1 => a:13
           │    ├──  abcd.b:2 => b:14
           │    ├──  abcd.c:3 => c:15
           │    └──  abcd.d:4 => d:16
           └── fd: ()-->(13,14)

# Verify that provided orderings are derived correctly.
opt
SELECT *
FROM [UPDATE abcd SET b=b+1 ORDER BY c LIMIT 10 RETURNING *]
ORDER BY c, d
----
sort
 ├── columns: a:12 b:13 c:14 d:15
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── ordering: +14,+15
 └── with &1
      ├── columns: a:12 b:13 c:14 d:15
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── project
      │    ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    └── update abcd
      │         ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── update-mapping:
      │         │    └── column11:11 => abcd.b:2
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── project
      │              ├── columns: column11:11 abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── cardinality: [0 - 10]
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9), (7)-->(11)
      │              ├── scan abcd@cd
      │              │    ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              │    ├── limit: 10
      │              │    ├── key: (10)
      │              │    └── fd: (10)-->(6-9)
      │              └── projections
      │                   └── abcd.b:7 + 1 [as=column11:11, outer=(7)]
      └── with-scan &1
           ├── columns: a:12 b:13 c:14 d:15
           ├── mapping:
           │    ├──  abcd.a:1 => a:12
           │    ├──  abcd.b:2 => b:13
           │    ├──  abcd.c:3 => c:14
           │    └──  abcd.d:4 => d:15
           └── cardinality: [0 - 10]

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt
SELECT *
FROM [UPDATE abcd SET b=b+1 ORDER BY c, d LIMIT 10 RETURNING *]
WHERE b=c
ORDER BY b, d
----
sort
 ├── columns: a:12 b:13!null c:14!null d:15
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── fd: (13)==(14), (14)==(13)
 ├── ordering: +(13|14),+15 [actual: +13,+15]
 └── with &1
      ├── columns: a:12 b:13!null c:14!null d:15
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── fd: (13)==(14), (14)==(13)
      ├── project
      │    ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    └── update abcd
      │         ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── update-mapping:
      │         │    └── column11:11 => abcd.b:2
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── project
      │              ├── columns: column11:11 abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── cardinality: [0 - 10]
      │              ├── key: (10)
      │              ├── fd: (10)-->(6-9), (7)-->(11)
      │              ├── scan abcd@cd
      │              │    ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              │    ├── limit: 10
      │              │    ├── key: (10)
      │              │    └── fd: (10)-->(6-9)
      │              └── projections
      │                   └── abcd.b:7 + 1 [as=column11:11, outer=(7)]
      └── select
           ├── columns: a:12 b:13!null c:14!null d:15
           ├── cardinality: [0 - 10]
           ├── fd: (13)==(14), (14)==(13)
           ├── with-scan &1
           │    ├── columns: a:12 b:13 c:14 d:15
           │    ├── mapping:
           │    │    ├──  abcd.a:1 => a:12
           │    │    ├──  abcd.b:2 => b:13
           │    │    ├──  abcd.c:3 => c:14
           │    │    └──  abcd.d:4 => d:15
           │    └── cardinality: [0 - 10]
           └── filters
                └── b:13 = c:14 [outer=(13,14), fd=(13)==(14), (14)==(13)]

# --------------------------------------------------
# Upsert operator.
# --------------------------------------------------

# Verify that no ordering is provided once ON CONFLICT clause is added.
opt
SELECT *
FROM
[
	INSERT INTO abc
	SELECT * FROM xyz ORDER BY y, z LIMIT 2
	ON CONFLICT (a, b, c)
	DO UPDATE SET a=10
	RETURNING *
]
ORDER BY b
----
sort
 ├── columns: a:14!null b:15!null c:16!null
 ├── side-effects, mutations
 ├── ordering: +15
 └── with &1
      ├── columns: a:14!null b:15!null c:16!null
      ├── side-effects, mutations
      ├── upsert abc
      │    ├── columns: abc.a:1!null abc.b:2!null abc.c:3!null
      │    ├── canary column: 7
      │    ├── fetch columns: abc.a:7 abc.b:8 abc.c:9
      │    ├── insert-mapping:
      │    │    ├── x:4 => abc.a:1
      │    │    ├── y:5 => abc.b:2
      │    │    └── z:6 => abc.c:3
      │    ├── update-mapping:
      │    │    └── upsert_a:11 => abc.a:1
      │    ├── return-mapping:
      │    │    ├── upsert_a:11 => abc.a:1
      │    │    ├── upsert_b:12 => abc.b:2
      │    │    └── upsert_c:13 => abc.c:3
      │    ├── side-effects, mutations
      │    └── project
      │         ├── columns: upsert_a:11!null upsert_b:12 upsert_c:13 x:4!null y:5!null z:6!null abc.a:7 abc.b:8 abc.c:9
      │         ├── key: (4-9)
      │         ├── fd: (4,7)-->(11), (5,7,8)-->(12), (6,7,9)-->(13)
      │         ├── left-join (lookup abc)
      │         │    ├── columns: x:4!null y:5!null z:6!null abc.a:7 abc.b:8 abc.c:9
      │         │    ├── key columns: [4 5 6] = [7 8 9]
      │         │    ├── lookup columns are key
      │         │    ├── key: (4-9)
      │         │    ├── upsert-distinct-on
      │         │    │    ├── columns: x:4!null y:5!null z:6!null
      │         │    │    ├── grouping columns: x:4!null y:5!null z:6!null
      │         │    │    ├── internal-ordering: +5,+6
      │         │    │    ├── error-on-dup
      │         │    │    ├── cardinality: [0 - 2]
      │         │    │    ├── key: (4-6)
      │         │    │    └── limit
      │         │    │         ├── columns: x:4!null y:5!null z:6!null
      │         │    │         ├── internal-ordering: +5,+6
      │         │    │         ├── cardinality: [0 - 2]
      │         │    │         ├── key: (4-6)
      │         │    │         ├── ordering: +5,+6
      │         │    │         ├── sort
      │         │    │         │    ├── columns: x:4!null y:5!null z:6!null
      │         │    │         │    ├── key: (4-6)
      │         │    │         │    ├── ordering: +5,+6
      │         │    │         │    ├── limit hint: 2.00
      │         │    │         │    └── scan xyz
      │         │    │         │         ├── columns: x:4!null y:5!null z:6!null
      │         │    │         │         └── key: (4-6)
      │         │    │         └── 2
      │         │    └── filters (true)
      │         └── projections
      │              ├── CASE WHEN abc.a:7 IS NULL THEN x:4 ELSE 10 END [as=upsert_a:11, outer=(4,7)]
      │              ├── CASE WHEN abc.a:7 IS NULL THEN y:5 ELSE abc.b:8 END [as=upsert_b:12, outer=(5,7,8)]
      │              └── CASE WHEN abc.a:7 IS NULL THEN z:6 ELSE abc.c:9 END [as=upsert_c:13, outer=(6,7,9)]
      └── with-scan &1
           ├── columns: a:14!null b:15!null c:16!null
           └── mapping:
                ├──  abc.a:1 => a:14
                ├──  abc.b:2 => b:15
                └──  abc.c:3 => c:16

# --------------------------------------------------
# Delete operator.
# --------------------------------------------------

# Verify that the external ordering is passed through to input.
opt
SELECT * FROM [DELETE FROM abcd RETURNING *] ORDER BY c
----
sort
 ├── columns: a:11 b:12 c:13 d:14
 ├── side-effects, mutations
 ├── ordering: +13
 └── with &1
      ├── columns: a:11 b:12 c:13 d:14
      ├── side-effects, mutations
      ├── project
      │    ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4
      │    ├── side-effects, mutations
      │    └── delete abcd
      │         ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── scan abcd
      │              ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── key: (10)
      │              └── fd: (10)-->(6-9)
      └── with-scan &1
           ├── columns: a:11 b:12 c:13 d:14
           └── mapping:
                ├──  abcd.a:1 => a:11
                ├──  abcd.b:2 => b:12
                ├──  abcd.c:3 => c:13
                └──  abcd.d:4 => d:14

# Verify that provided orderings are derived correctly.
opt
SELECT *
FROM [DELETE FROM abcd ORDER BY c LIMIT 10 RETURNING *]
ORDER BY c, d
----
sort
 ├── columns: a:11 b:12 c:13 d:14
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── ordering: +13,+14
 └── with &1
      ├── columns: a:11 b:12 c:13 d:14
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── project
      │    ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    └── delete abcd
      │         ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── scan abcd@cd
      │              ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── limit: 10
      │              ├── key: (10)
      │              └── fd: (10)-->(6-9)
      └── with-scan &1
           ├── columns: a:11 b:12 c:13 d:14
           ├── mapping:
           │    ├──  abcd.a:1 => a:11
           │    ├──  abcd.b:2 => b:12
           │    ├──  abcd.c:3 => c:13
           │    └──  abcd.d:4 => d:14
           └── cardinality: [0 - 10]

# Verify that provided orderings are derived correctly with equivalence FD.
# TODO(radu): Use interesting orderings to get rid of top-level sort.
opt
SELECT *
FROM [DELETE FROM abcd ORDER BY c, d LIMIT 10 RETURNING *]
WHERE b=c
ORDER BY b, d
----
sort
 ├── columns: a:11 b:12!null c:13!null d:14
 ├── cardinality: [0 - 10]
 ├── side-effects, mutations
 ├── fd: (12)==(13), (13)==(12)
 ├── ordering: +(12|13),+14 [actual: +12,+14]
 └── with &1
      ├── columns: a:11 b:12!null c:13!null d:14
      ├── cardinality: [0 - 10]
      ├── side-effects, mutations
      ├── fd: (12)==(13), (13)==(12)
      ├── project
      │    ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4
      │    ├── cardinality: [0 - 10]
      │    ├── side-effects, mutations
      │    └── delete abcd
      │         ├── columns: abcd.a:1 abcd.b:2 abcd.c:3 abcd.d:4 rowid:5!null
      │         ├── fetch columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10
      │         ├── cardinality: [0 - 10]
      │         ├── side-effects, mutations
      │         ├── key: (5)
      │         ├── fd: (5)-->(1-4)
      │         └── scan abcd@cd
      │              ├── columns: abcd.a:6 abcd.b:7 abcd.c:8 abcd.d:9 rowid:10!null
      │              ├── limit: 10
      │              ├── key: (10)
      │              └── fd: (10)-->(6-9)
      └── select
           ├── columns: a:11 b:12!null c:13!null d:14
           ├── cardinality: [0 - 10]
           ├── fd: (12)==(13), (13)==(12)
           ├── with-scan &1
           │    ├── columns: a:11 b:12 c:13 d:14
           │    ├── mapping:
           │    │    ├──  abcd.a:1 => a:11
           │    │    ├──  abcd.b:2 => b:12
           │    │    ├──  abcd.c:3 => c:13
           │    │    └──  abcd.d:4 => d:14
           │    └── cardinality: [0 - 10]
           └── filters
                └── b:12 = c:13 [outer=(12,13), fd=(12)==(13), (13)==(12)]


# Regression test for #36219: lookup join with ON condition that imposes an
# equality on two input columns (which isn't pushed down).
opt disable=(PushFilterIntoJoinLeftAndRight,PushFilterIntoJoinLeft,PushFilterIntoJoinRight,MapFilterIntoJoinLeft,MapFilterIntoJoinRight)
SELECT * FROM abc JOIN xyz ON a=x AND x=z ORDER BY z
----
inner-join (merge)
 ├── columns: a:1!null b:2!null c:3!null x:4!null y:5!null z:6!null
 ├── left ordering: +1
 ├── right ordering: +4
 ├── key: (2,3,5,6)
 ├── fd: (1)==(4,6), (4)==(1,6), (6)==(1,4)
 ├── ordering: +(1|4|6) [actual: +1]
 ├── scan abc
 │    ├── columns: a:1!null b:2!null c:3!null
 │    ├── key: (1-3)
 │    └── ordering: +1
 ├── scan xyz
 │    ├── columns: x:4!null y:5!null z:6!null
 │    ├── key: (4-6)
 │    └── ordering: +4
 └── filters
      └── x:4 = z:6 [outer=(4,6), fd=(4)==(6), (6)==(4)]

# TODO(justin): figure out when it is that window functions can preserve their
# input ordering.
opt
SELECT *, row_number() OVER() FROM abc ORDER BY a
----
sort
 ├── columns: a:1!null b:2!null c:3!null row_number:4
 ├── key: (1-3)
 ├── ordering: +1
 └── window partition=()
      ├── columns: a:1!null b:2!null c:3!null row_number:4
      ├── key: (1-3)
      ├── scan abc
      │    ├── columns: a:1!null b:2!null c:3!null
      │    └── key: (1-3)
      └── windows
           └── row-number [as=row_number:4]

# Regression test for #44469 (DistinctOn needs to remap the provided ordering).
exec-ddl
CREATE TABLE t44469_a (a INT, INDEX (a))
----

exec-ddl
CREATE TABLE t44469_b (b INT, INDEX (b))
----

exec-ddl
CREATE TABLE t44469_cd (c INT, d INT, INDEX (c, d));
----

opt
SELECT DISTINCT ON (b) b
FROM t44469_a INNER LOOKUP JOIN t44469_b ON a = b INNER LOOKUP JOIN t44469_cd ON c = 1 AND d = a
ORDER BY b
----
distinct-on
 ├── columns: b:3!null
 ├── grouping columns: b:3!null
 ├── key: (3)
 ├── ordering: +3
 └── inner-join (lookup t44469_cd@secondary)
      ├── columns: a:1!null b:3!null c:5!null d:6!null
      ├── flags: force lookup join (into right side)
      ├── key columns: [8 1] = [5 6]
      ├── fd: ()-->(5), (1)==(3,6), (3)==(1,6), (6)==(1,3)
      ├── ordering: +(1|3|6) opt(5) [actual: +1]
      ├── project
      │    ├── columns: "project_const_col_@5":8!null a:1!null b:3!null
      │    ├── fd: ()-->(8), (1)==(3), (3)==(1)
      │    ├── ordering: +(1|3) [actual: +1]
      │    ├── inner-join (lookup t44469_b@secondary)
      │    │    ├── columns: a:1!null b:3!null
      │    │    ├── flags: force lookup join (into right side)
      │    │    ├── key columns: [1] = [3]
      │    │    ├── fd: (1)==(3), (3)==(1)
      │    │    ├── ordering: +(1|3) [actual: +1]
      │    │    ├── scan t44469_a@secondary
      │    │    │    ├── columns: a:1
      │    │    │    └── ordering: +1
      │    │    └── filters (true)
      │    └── projections
      │         └── 1 [as="project_const_col_@5":8]
      └── filters (true)
