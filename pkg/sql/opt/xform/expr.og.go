// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

type childCountLookupFunc func(ev ExprView) int

var childCountLookup = [...]childCountLookupFunc{
	// UnknownOp
	func(ev ExprView) int {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(ev ExprView) int {
		return 2
	},

	// VariableOp
	func(ev ExprView) int {
		return 0
	},

	// ConstOp
	func(ev ExprView) int {
		return 0
	},

	// TrueOp
	func(ev ExprView) int {
		return 0
	},

	// FalseOp
	func(ev ExprView) int {
		return 0
	},

	// PlaceholderOp
	func(ev ExprView) int {
		return 0
	},

	// TupleOp
	func(ev ExprView) int {
		tupleExpr := (*tupleExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(tupleExpr.elems().Length)
	},

	// ProjectionsOp
	func(ev ExprView) int {
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(projectionsExpr.elems().Length)
	},

	// AggregationsOp
	func(ev ExprView) int {
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(aggregationsExpr.aggs().Length)
	},

	// GroupingsOp
	func(ev ExprView) int {
		groupingsExpr := (*groupingsExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(groupingsExpr.elems().Length)
	},

	// ExistsOp
	func(ev ExprView) int {
		return 1
	},

	// AndOp
	func(ev ExprView) int {
		andExpr := (*andExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(andExpr.conditions().Length)
	},

	// OrOp
	func(ev ExprView) int {
		orExpr := (*orExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(orExpr.conditions().Length)
	},

	// NotOp
	func(ev ExprView) int {
		return 1
	},

	// EqOp
	func(ev ExprView) int {
		return 2
	},

	// LtOp
	func(ev ExprView) int {
		return 2
	},

	// GtOp
	func(ev ExprView) int {
		return 2
	},

	// LeOp
	func(ev ExprView) int {
		return 2
	},

	// GeOp
	func(ev ExprView) int {
		return 2
	},

	// NeOp
	func(ev ExprView) int {
		return 2
	},

	// InOp
	func(ev ExprView) int {
		return 2
	},

	// NotInOp
	func(ev ExprView) int {
		return 2
	},

	// LikeOp
	func(ev ExprView) int {
		return 2
	},

	// NotLikeOp
	func(ev ExprView) int {
		return 2
	},

	// ILikeOp
	func(ev ExprView) int {
		return 2
	},

	// NotILikeOp
	func(ev ExprView) int {
		return 2
	},

	// SimilarToOp
	func(ev ExprView) int {
		return 2
	},

	// NotSimilarToOp
	func(ev ExprView) int {
		return 2
	},

	// RegMatchOp
	func(ev ExprView) int {
		return 2
	},

	// NotRegMatchOp
	func(ev ExprView) int {
		return 2
	},

	// RegIMatchOp
	func(ev ExprView) int {
		return 2
	},

	// NotRegIMatchOp
	func(ev ExprView) int {
		return 2
	},

	// IsOp
	func(ev ExprView) int {
		return 2
	},

	// IsNotOp
	func(ev ExprView) int {
		return 2
	},

	// ContainsOp
	func(ev ExprView) int {
		return 2
	},

	// BitandOp
	func(ev ExprView) int {
		return 2
	},

	// BitorOp
	func(ev ExprView) int {
		return 2
	},

	// BitxorOp
	func(ev ExprView) int {
		return 2
	},

	// PlusOp
	func(ev ExprView) int {
		return 2
	},

	// MinusOp
	func(ev ExprView) int {
		return 2
	},

	// MultOp
	func(ev ExprView) int {
		return 2
	},

	// DivOp
	func(ev ExprView) int {
		return 2
	},

	// FloorDivOp
	func(ev ExprView) int {
		return 2
	},

	// ModOp
	func(ev ExprView) int {
		return 2
	},

	// PowOp
	func(ev ExprView) int {
		return 2
	},

	// ConcatOp
	func(ev ExprView) int {
		return 2
	},

	// LShiftOp
	func(ev ExprView) int {
		return 2
	},

	// RShiftOp
	func(ev ExprView) int {
		return 2
	},

	// FetchValOp
	func(ev ExprView) int {
		return 2
	},

	// FetchTextOp
	func(ev ExprView) int {
		return 2
	},

	// FetchValPathOp
	func(ev ExprView) int {
		return 2
	},

	// FetchTextPathOp
	func(ev ExprView) int {
		return 2
	},

	// UnaryPlusOp
	func(ev ExprView) int {
		return 1
	},

	// UnaryMinusOp
	func(ev ExprView) int {
		return 1
	},

	// UnaryComplementOp
	func(ev ExprView) int {
		return 1
	},

	// FunctionOp
	func(ev ExprView) int {
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(functionExpr.args().Length)
	},

	// UnsupportedExprOp
	func(ev ExprView) int {
		return 0
	},

	// ScanOp
	func(ev ExprView) int {
		return 0
	},

	// ValuesOp
	func(ev ExprView) int {
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(valuesExpr.rows().Length)
	},

	// SelectOp
	func(ev ExprView) int {
		return 2
	},

	// ProjectOp
	func(ev ExprView) int {
		return 2
	},

	// InnerJoinOp
	func(ev ExprView) int {
		return 3
	},

	// LeftJoinOp
	func(ev ExprView) int {
		return 3
	},

	// RightJoinOp
	func(ev ExprView) int {
		return 3
	},

	// FullJoinOp
	func(ev ExprView) int {
		return 3
	},

	// SemiJoinOp
	func(ev ExprView) int {
		return 3
	},

	// AntiJoinOp
	func(ev ExprView) int {
		return 3
	},

	// InnerJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// LeftJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// RightJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// FullJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// SemiJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// AntiJoinApplyOp
	func(ev ExprView) int {
		return 3
	},

	// GroupByOp
	func(ev ExprView) int {
		return 3
	},

	// UnionOp
	func(ev ExprView) int {
		return 2
	},

	// IntersectOp
	func(ev ExprView) int {
		return 2
	},

	// ExceptOp
	func(ev ExprView) int {
		return 2
	},

	// SortOp
	func(ev ExprView) int {
		return 1
	},

	// PresentOp
	func(ev ExprView) int {
		return 1
	},
}

type childGroupLookupFunc func(ev ExprView, n int) opt.GroupID

var childGroupLookup = [...]childGroupLookupFunc{
	// UnknownOp
	func(ev ExprView, n int) opt.GroupID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(ev ExprView, n int) opt.GroupID {
		subqueryExpr := (*subqueryExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return subqueryExpr.input()
		case 1:
			return subqueryExpr.projection()
		default:
			panic("child index out of range")
		}
	},

	// VariableOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// ConstOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// TrueOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// FalseOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// PlaceholderOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// TupleOp
	func(ev ExprView, n int) opt.GroupID {
		tupleExpr := (*tupleExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(tupleExpr.elems())
			return list[n-0]
		}
	},

	// ProjectionsOp
	func(ev ExprView, n int) opt.GroupID {
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(projectionsExpr.elems())
			return list[n-0]
		}
	},

	// AggregationsOp
	func(ev ExprView, n int) opt.GroupID {
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(aggregationsExpr.aggs())
			return list[n-0]
		}
	},

	// GroupingsOp
	func(ev ExprView, n int) opt.GroupID {
		groupingsExpr := (*groupingsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(groupingsExpr.elems())
			return list[n-0]
		}
	},

	// ExistsOp
	func(ev ExprView, n int) opt.GroupID {
		existsExpr := (*existsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return existsExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// AndOp
	func(ev ExprView, n int) opt.GroupID {
		andExpr := (*andExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(andExpr.conditions())
			return list[n-0]
		}
	},

	// OrOp
	func(ev ExprView, n int) opt.GroupID {
		orExpr := (*orExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(orExpr.conditions())
			return list[n-0]
		}
	},

	// NotOp
	func(ev ExprView, n int) opt.GroupID {
		notExpr := (*notExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// EqOp
	func(ev ExprView, n int) opt.GroupID {
		eqExpr := (*eqExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return eqExpr.left()
		case 1:
			return eqExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LtOp
	func(ev ExprView, n int) opt.GroupID {
		ltExpr := (*ltExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return ltExpr.left()
		case 1:
			return ltExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// GtOp
	func(ev ExprView, n int) opt.GroupID {
		gtExpr := (*gtExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return gtExpr.left()
		case 1:
			return gtExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LeOp
	func(ev ExprView, n int) opt.GroupID {
		leExpr := (*leExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leExpr.left()
		case 1:
			return leExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// GeOp
	func(ev ExprView, n int) opt.GroupID {
		geExpr := (*geExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return geExpr.left()
		case 1:
			return geExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NeOp
	func(ev ExprView, n int) opt.GroupID {
		neExpr := (*neExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return neExpr.left()
		case 1:
			return neExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// InOp
	func(ev ExprView, n int) opt.GroupID {
		inExpr := (*inExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return inExpr.left()
		case 1:
			return inExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotInOp
	func(ev ExprView, n int) opt.GroupID {
		notInExpr := (*notInExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notInExpr.left()
		case 1:
			return notInExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LikeOp
	func(ev ExprView, n int) opt.GroupID {
		likeExpr := (*likeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return likeExpr.left()
		case 1:
			return likeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotLikeOp
	func(ev ExprView, n int) opt.GroupID {
		notLikeExpr := (*notLikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notLikeExpr.left()
		case 1:
			return notLikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ILikeOp
	func(ev ExprView, n int) opt.GroupID {
		iLikeExpr := (*iLikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return iLikeExpr.left()
		case 1:
			return iLikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotILikeOp
	func(ev ExprView, n int) opt.GroupID {
		notILikeExpr := (*notILikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notILikeExpr.left()
		case 1:
			return notILikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// SimilarToOp
	func(ev ExprView, n int) opt.GroupID {
		similarToExpr := (*similarToExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return similarToExpr.left()
		case 1:
			return similarToExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotSimilarToOp
	func(ev ExprView, n int) opt.GroupID {
		notSimilarToExpr := (*notSimilarToExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notSimilarToExpr.left()
		case 1:
			return notSimilarToExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RegMatchOp
	func(ev ExprView, n int) opt.GroupID {
		regMatchExpr := (*regMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return regMatchExpr.left()
		case 1:
			return regMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotRegMatchOp
	func(ev ExprView, n int) opt.GroupID {
		notRegMatchExpr := (*notRegMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notRegMatchExpr.left()
		case 1:
			return notRegMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RegIMatchOp
	func(ev ExprView, n int) opt.GroupID {
		regIMatchExpr := (*regIMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return regIMatchExpr.left()
		case 1:
			return regIMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotRegIMatchOp
	func(ev ExprView, n int) opt.GroupID {
		notRegIMatchExpr := (*notRegIMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notRegIMatchExpr.left()
		case 1:
			return notRegIMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsOp
	func(ev ExprView, n int) opt.GroupID {
		isExpr := (*isExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return isExpr.left()
		case 1:
			return isExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsNotOp
	func(ev ExprView, n int) opt.GroupID {
		isNotExpr := (*isNotExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return isNotExpr.left()
		case 1:
			return isNotExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ContainsOp
	func(ev ExprView, n int) opt.GroupID {
		containsExpr := (*containsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return containsExpr.left()
		case 1:
			return containsExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitandOp
	func(ev ExprView, n int) opt.GroupID {
		bitandExpr := (*bitandExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitandExpr.left()
		case 1:
			return bitandExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitorOp
	func(ev ExprView, n int) opt.GroupID {
		bitorExpr := (*bitorExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitorExpr.left()
		case 1:
			return bitorExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitxorOp
	func(ev ExprView, n int) opt.GroupID {
		bitxorExpr := (*bitxorExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitxorExpr.left()
		case 1:
			return bitxorExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// PlusOp
	func(ev ExprView, n int) opt.GroupID {
		plusExpr := (*plusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return plusExpr.left()
		case 1:
			return plusExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// MinusOp
	func(ev ExprView, n int) opt.GroupID {
		minusExpr := (*minusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return minusExpr.left()
		case 1:
			return minusExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// MultOp
	func(ev ExprView, n int) opt.GroupID {
		multExpr := (*multExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return multExpr.left()
		case 1:
			return multExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// DivOp
	func(ev ExprView, n int) opt.GroupID {
		divExpr := (*divExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return divExpr.left()
		case 1:
			return divExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// FloorDivOp
	func(ev ExprView, n int) opt.GroupID {
		floorDivExpr := (*floorDivExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return floorDivExpr.left()
		case 1:
			return floorDivExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ModOp
	func(ev ExprView, n int) opt.GroupID {
		modExpr := (*modExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return modExpr.left()
		case 1:
			return modExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// PowOp
	func(ev ExprView, n int) opt.GroupID {
		powExpr := (*powExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return powExpr.left()
		case 1:
			return powExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ConcatOp
	func(ev ExprView, n int) opt.GroupID {
		concatExpr := (*concatExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return concatExpr.left()
		case 1:
			return concatExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LShiftOp
	func(ev ExprView, n int) opt.GroupID {
		lShiftExpr := (*lShiftExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return lShiftExpr.left()
		case 1:
			return lShiftExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RShiftOp
	func(ev ExprView, n int) opt.GroupID {
		rShiftExpr := (*rShiftExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rShiftExpr.left()
		case 1:
			return rShiftExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// FetchValOp
	func(ev ExprView, n int) opt.GroupID {
		fetchValExpr := (*fetchValExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchValExpr.json()
		case 1:
			return fetchValExpr.index()
		default:
			panic("child index out of range")
		}
	},

	// FetchTextOp
	func(ev ExprView, n int) opt.GroupID {
		fetchTextExpr := (*fetchTextExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchTextExpr.json()
		case 1:
			return fetchTextExpr.index()
		default:
			panic("child index out of range")
		}
	},

	// FetchValPathOp
	func(ev ExprView, n int) opt.GroupID {
		fetchValPathExpr := (*fetchValPathExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchValPathExpr.json()
		case 1:
			return fetchValPathExpr.path()
		default:
			panic("child index out of range")
		}
	},

	// FetchTextPathOp
	func(ev ExprView, n int) opt.GroupID {
		fetchTextPathExpr := (*fetchTextPathExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchTextPathExpr.json()
		case 1:
			return fetchTextPathExpr.path()
		default:
			panic("child index out of range")
		}
	},

	// UnaryPlusOp
	func(ev ExprView, n int) opt.GroupID {
		unaryPlusExpr := (*unaryPlusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryPlusExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// UnaryMinusOp
	func(ev ExprView, n int) opt.GroupID {
		unaryMinusExpr := (*unaryMinusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryMinusExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// UnaryComplementOp
	func(ev ExprView, n int) opt.GroupID {
		unaryComplementExpr := (*unaryComplementExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryComplementExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// FunctionOp
	func(ev ExprView, n int) opt.GroupID {
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(functionExpr.args())
			return list[n-0]
		}
	},

	// UnsupportedExprOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// ScanOp
	func(ev ExprView, n int) opt.GroupID {
		panic("child index out of range")
	},

	// ValuesOp
	func(ev ExprView, n int) opt.GroupID {
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(valuesExpr.rows())
			return list[n-0]
		}
	},

	// SelectOp
	func(ev ExprView, n int) opt.GroupID {
		selectExpr := (*selectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return selectExpr.input()
		case 1:
			return selectExpr.filter()
		default:
			panic("child index out of range")
		}
	},

	// ProjectOp
	func(ev ExprView, n int) opt.GroupID {
		projectExpr := (*projectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return projectExpr.input()
		case 1:
			return projectExpr.projections()
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinOp
	func(ev ExprView, n int) opt.GroupID {
		innerJoinExpr := (*innerJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return innerJoinExpr.left()
		case 1:
			return innerJoinExpr.right()
		case 2:
			return innerJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinOp
	func(ev ExprView, n int) opt.GroupID {
		leftJoinExpr := (*leftJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leftJoinExpr.left()
		case 1:
			return leftJoinExpr.right()
		case 2:
			return leftJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// RightJoinOp
	func(ev ExprView, n int) opt.GroupID {
		rightJoinExpr := (*rightJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rightJoinExpr.left()
		case 1:
			return rightJoinExpr.right()
		case 2:
			return rightJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// FullJoinOp
	func(ev ExprView, n int) opt.GroupID {
		fullJoinExpr := (*fullJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fullJoinExpr.left()
		case 1:
			return fullJoinExpr.right()
		case 2:
			return fullJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinOp
	func(ev ExprView, n int) opt.GroupID {
		semiJoinExpr := (*semiJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return semiJoinExpr.left()
		case 1:
			return semiJoinExpr.right()
		case 2:
			return semiJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinOp
	func(ev ExprView, n int) opt.GroupID {
		antiJoinExpr := (*antiJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return antiJoinExpr.left()
		case 1:
			return antiJoinExpr.right()
		case 2:
			return antiJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		innerJoinApplyExpr := (*innerJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return innerJoinApplyExpr.left()
		case 1:
			return innerJoinApplyExpr.right()
		case 2:
			return innerJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		leftJoinApplyExpr := (*leftJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leftJoinApplyExpr.left()
		case 1:
			return leftJoinApplyExpr.right()
		case 2:
			return leftJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// RightJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		rightJoinApplyExpr := (*rightJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rightJoinApplyExpr.left()
		case 1:
			return rightJoinApplyExpr.right()
		case 2:
			return rightJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// FullJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		fullJoinApplyExpr := (*fullJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fullJoinApplyExpr.left()
		case 1:
			return fullJoinApplyExpr.right()
		case 2:
			return fullJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		semiJoinApplyExpr := (*semiJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return semiJoinApplyExpr.left()
		case 1:
			return semiJoinApplyExpr.right()
		case 2:
			return semiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinApplyOp
	func(ev ExprView, n int) opt.GroupID {
		antiJoinApplyExpr := (*antiJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return antiJoinApplyExpr.left()
		case 1:
			return antiJoinApplyExpr.right()
		case 2:
			return antiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// GroupByOp
	func(ev ExprView, n int) opt.GroupID {
		groupByExpr := (*groupByExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return groupByExpr.input()
		case 1:
			return groupByExpr.groupings()
		case 2:
			return groupByExpr.aggregations()
		default:
			panic("child index out of range")
		}
	},

	// UnionOp
	func(ev ExprView, n int) opt.GroupID {
		unionExpr := (*unionExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unionExpr.left()
		case 1:
			return unionExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IntersectOp
	func(ev ExprView, n int) opt.GroupID {
		intersectExpr := (*intersectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return intersectExpr.left()
		case 1:
			return intersectExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ExceptOp
	func(ev ExprView, n int) opt.GroupID {
		exceptExpr := (*exceptExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return exceptExpr.left()
		case 1:
			return exceptExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// SortOp
	func(ev ExprView, n int) opt.GroupID {
		if n == 0 {
			return ev.loc.group
		}

		panic("child index out of range")
	},

	// PresentOp
	func(ev ExprView, n int) opt.GroupID {
		if n == 0 {
			return ev.loc.group
		}

		panic("child index out of range")
	},
}

type privateLookupFunc func(ev ExprView) opt.PrivateID

var privateLookup = [...]privateLookupFunc{
	// UnknownOp
	func(ev ExprView) opt.PrivateID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// VariableOp
	func(ev ExprView) opt.PrivateID {
		variableExpr := (*variableExpr)(ev.mem.lookupExpr(ev.loc))
		return variableExpr.col()
	},

	// ConstOp
	func(ev ExprView) opt.PrivateID {
		constExpr := (*constExpr)(ev.mem.lookupExpr(ev.loc))
		return constExpr.value()
	},

	// TrueOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FalseOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PlaceholderOp
	func(ev ExprView) opt.PrivateID {
		placeholderExpr := (*placeholderExpr)(ev.mem.lookupExpr(ev.loc))
		return placeholderExpr.value()
	},

	// TupleOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ProjectionsOp
	func(ev ExprView) opt.PrivateID {
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))
		return projectionsExpr.cols()
	},

	// AggregationsOp
	func(ev ExprView) opt.PrivateID {
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))
		return aggregationsExpr.cols()
	},

	// GroupingsOp
	func(ev ExprView) opt.PrivateID {
		groupingsExpr := (*groupingsExpr)(ev.mem.lookupExpr(ev.loc))
		return groupingsExpr.cols()
	},

	// ExistsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AndOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// OrOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// EqOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LtOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GtOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotInOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotLikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ILikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotILikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SimilarToOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotSimilarToOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RegMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotRegMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RegIMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotRegIMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// IsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// IsNotOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ContainsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitandOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitorOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitxorOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PlusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// MinusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// MultOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// DivOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FloorDivOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ModOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PowOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ConcatOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LShiftOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RShiftOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchValOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchTextOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchValPathOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchTextPathOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryPlusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryMinusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryComplementOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FunctionOp
	func(ev ExprView) opt.PrivateID {
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))
		return functionExpr.def()
	},

	// UnsupportedExprOp
	func(ev ExprView) opt.PrivateID {
		unsupportedExprExpr := (*unsupportedExprExpr)(ev.mem.lookupExpr(ev.loc))
		return unsupportedExprExpr.value()
	},

	// ScanOp
	func(ev ExprView) opt.PrivateID {
		scanExpr := (*scanExpr)(ev.mem.lookupExpr(ev.loc))
		return scanExpr.table()
	},

	// ValuesOp
	func(ev ExprView) opt.PrivateID {
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))
		return valuesExpr.cols()
	},

	// SelectOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ProjectOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InnerJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeftJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RightJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FullJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SemiJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AntiJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InnerJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeftJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RightJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FullJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SemiJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AntiJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GroupByOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnionOp
	func(ev ExprView) opt.PrivateID {
		unionExpr := (*unionExpr)(ev.mem.lookupExpr(ev.loc))
		return unionExpr.colMap()
	},

	// IntersectOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ExceptOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SortOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PresentOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},
}

var isScalarLookup = [...]bool{
	false, // UnknownOp

	true,  // SubqueryOp
	true,  // VariableOp
	true,  // ConstOp
	true,  // TrueOp
	true,  // FalseOp
	true,  // PlaceholderOp
	true,  // TupleOp
	true,  // ProjectionsOp
	true,  // AggregationsOp
	true,  // GroupingsOp
	true,  // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	true,  // FunctionOp
	true,  // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isConstValueLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	true,  // ConstOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isBooleanLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isComparisonLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isBinaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isUnaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isRelationalLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	true,  // ScanOp
	true,  // ValuesOp
	true,  // SelectOp
	true,  // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	true,  // GroupByOp
	true,  // UnionOp
	true,  // IntersectOp
	true,  // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isJoinLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isJoinApplyLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // PresentOp
}

var isEnforcerLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // GroupingsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	true,  // SortOp
	true,  // PresentOp
}

func (ev ExprView) IsScalar() bool {
	return isScalarLookup[ev.op]
}

func (ev ExprView) IsConstValue() bool {
	return isConstValueLookup[ev.op]
}

func (ev ExprView) IsBoolean() bool {
	return isBooleanLookup[ev.op]
}

func (ev ExprView) IsComparison() bool {
	return isComparisonLookup[ev.op]
}

func (ev ExprView) IsBinary() bool {
	return isBinaryLookup[ev.op]
}

func (ev ExprView) IsUnary() bool {
	return isUnaryLookup[ev.op]
}

func (ev ExprView) IsRelational() bool {
	return isRelationalLookup[ev.op]
}

func (ev ExprView) IsJoin() bool {
	return isJoinLookup[ev.op]
}

func (ev ExprView) IsJoinApply() bool {
	return isJoinApplyLookup[ev.op]
}

func (ev ExprView) IsEnforcer() bool {
	return isEnforcerLookup[ev.op]
}

type subqueryExpr memoExpr

func makeSubqueryExpr(input opt.GroupID, projection opt.GroupID) subqueryExpr {
	return subqueryExpr{op: opt.SubqueryOp, state: exprState{uint32(input), uint32(projection)}}
}

func (e *subqueryExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *subqueryExpr) projection() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *subqueryExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSubquery() *subqueryExpr {
	if m.op != opt.SubqueryOp {
		return nil
	}
	return (*subqueryExpr)(m)
}

// variableExpr is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnIndex that references the column by index.
type variableExpr memoExpr

func makeVariableExpr(col opt.PrivateID) variableExpr {
	return variableExpr{op: opt.VariableOp, state: exprState{uint32(col)}}
}

func (e *variableExpr) col() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *variableExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asVariable() *variableExpr {
	if m.op != opt.VariableOp {
		return nil
	}
	return (*variableExpr)(m)
}

// constExpr is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
type constExpr memoExpr

func makeConstExpr(value opt.PrivateID) constExpr {
	return constExpr{op: opt.ConstOp, state: exprState{uint32(value)}}
}

func (e *constExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *constExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConst() *constExpr {
	if m.op != opt.ConstOp {
		return nil
	}
	return (*constExpr)(m)
}

// trueExpr is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
type trueExpr memoExpr

func makeTrueExpr() trueExpr {
	return trueExpr{op: opt.TrueOp, state: exprState{}}
}

func (e *trueExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTrue() *trueExpr {
	if m.op != opt.TrueOp {
		return nil
	}
	return (*trueExpr)(m)
}

// falseExpr is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
type falseExpr memoExpr

func makeFalseExpr() falseExpr {
	return falseExpr{op: opt.FalseOp, state: exprState{}}
}

func (e *falseExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFalse() *falseExpr {
	if m.op != opt.FalseOp {
		return nil
	}
	return (*falseExpr)(m)
}

type placeholderExpr memoExpr

func makePlaceholderExpr(value opt.PrivateID) placeholderExpr {
	return placeholderExpr{op: opt.PlaceholderOp, state: exprState{uint32(value)}}
}

func (e *placeholderExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *placeholderExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlaceholder() *placeholderExpr {
	if m.op != opt.PlaceholderOp {
		return nil
	}
	return (*placeholderExpr)(m)
}

type tupleExpr memoExpr

func makeTupleExpr(elems opt.ListID) tupleExpr {
	return tupleExpr{op: opt.TupleOp, state: exprState{elems.Offset, elems.Length}}
}

func (e *tupleExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *tupleExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTuple() *tupleExpr {
	if m.op != opt.TupleOp {
		return nil
	}
	return (*tupleExpr)(m)
}

// projectionsExpr is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the set of column indexes returned by the expression, as a *ColList.
type projectionsExpr memoExpr

func makeProjectionsExpr(elems opt.ListID, cols opt.PrivateID) projectionsExpr {
	return projectionsExpr{op: opt.ProjectionsOp, state: exprState{elems.Offset, elems.Length, uint32(cols)}}
}

func (e *projectionsExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *projectionsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *projectionsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProjections() *projectionsExpr {
	if m.op != opt.ProjectionsOp {
		return nil
	}
	return (*projectionsExpr)(m)
}

// aggregationsExpr is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the set of column indexes returned by the expression, as a *ColList.
type aggregationsExpr memoExpr

func makeAggregationsExpr(aggs opt.ListID, cols opt.PrivateID) aggregationsExpr {
	return aggregationsExpr{op: opt.AggregationsOp, state: exprState{aggs.Offset, aggs.Length, uint32(cols)}}
}

func (e *aggregationsExpr) aggs() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *aggregationsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *aggregationsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAggregations() *aggregationsExpr {
	if m.op != opt.AggregationsOp {
		return nil
	}
	return (*aggregationsExpr)(m)
}

// groupingsExpr is a set of grouping expressions that will become output columns
// for a containing GroupBy operator. The GroupBy operator groups its input by
// the value of these expressions, and may compute aggregates over the groups.
// The private Cols field contains the set of column indexes returned by the
// expression, as a *ColList.
type groupingsExpr memoExpr

func makeGroupingsExpr(elems opt.ListID, cols opt.PrivateID) groupingsExpr {
	return groupingsExpr{op: opt.GroupingsOp, state: exprState{elems.Offset, elems.Length, uint32(cols)}}
}

func (e *groupingsExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *groupingsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *groupingsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGroupings() *groupingsExpr {
	if m.op != opt.GroupingsOp {
		return nil
	}
	return (*groupingsExpr)(m)
}

type existsExpr memoExpr

func makeExistsExpr(input opt.GroupID) existsExpr {
	return existsExpr{op: opt.ExistsOp, state: exprState{uint32(input)}}
}

func (e *existsExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *existsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExists() *existsExpr {
	if m.op != opt.ExistsOp {
		return nil
	}
	return (*existsExpr)(m)
}

// andExpr is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
type andExpr memoExpr

func makeAndExpr(conditions opt.ListID) andExpr {
	return andExpr{op: opt.AndOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *andExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *andExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAnd() *andExpr {
	if m.op != opt.AndOp {
		return nil
	}
	return (*andExpr)(m)
}

// orExpr is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
type orExpr memoExpr

func makeOrExpr(conditions opt.ListID) orExpr {
	return orExpr{op: opt.OrOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *orExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *orExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOr() *orExpr {
	if m.op != opt.OrOp {
		return nil
	}
	return (*orExpr)(m)
}

// notExpr is the boolean negation operator that evaluates to true if its input
// evalutes to false.
type notExpr memoExpr

func makeNotExpr(input opt.GroupID) notExpr {
	return notExpr{op: opt.NotOp, state: exprState{uint32(input)}}
}

func (e *notExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNot() *notExpr {
	if m.op != opt.NotOp {
		return nil
	}
	return (*notExpr)(m)
}

type eqExpr memoExpr

func makeEqExpr(left opt.GroupID, right opt.GroupID) eqExpr {
	return eqExpr{op: opt.EqOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *eqExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *eqExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *eqExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asEq() *eqExpr {
	if m.op != opt.EqOp {
		return nil
	}
	return (*eqExpr)(m)
}

type ltExpr memoExpr

func makeLtExpr(left opt.GroupID, right opt.GroupID) ltExpr {
	return ltExpr{op: opt.LtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ltExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *ltExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *ltExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLt() *ltExpr {
	if m.op != opt.LtOp {
		return nil
	}
	return (*ltExpr)(m)
}

type gtExpr memoExpr

func makeGtExpr(left opt.GroupID, right opt.GroupID) gtExpr {
	return gtExpr{op: opt.GtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *gtExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *gtExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *gtExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGt() *gtExpr {
	if m.op != opt.GtOp {
		return nil
	}
	return (*gtExpr)(m)
}

type leExpr memoExpr

func makeLeExpr(left opt.GroupID, right opt.GroupID) leExpr {
	return leExpr{op: opt.LeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *leExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLe() *leExpr {
	if m.op != opt.LeOp {
		return nil
	}
	return (*leExpr)(m)
}

type geExpr memoExpr

func makeGeExpr(left opt.GroupID, right opt.GroupID) geExpr {
	return geExpr{op: opt.GeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *geExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *geExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *geExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGe() *geExpr {
	if m.op != opt.GeOp {
		return nil
	}
	return (*geExpr)(m)
}

type neExpr memoExpr

func makeNeExpr(left opt.GroupID, right opt.GroupID) neExpr {
	return neExpr{op: opt.NeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *neExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *neExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *neExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNe() *neExpr {
	if m.op != opt.NeOp {
		return nil
	}
	return (*neExpr)(m)
}

type inExpr memoExpr

func makeInExpr(left opt.GroupID, right opt.GroupID) inExpr {
	return inExpr{op: opt.InOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *inExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *inExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *inExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIn() *inExpr {
	if m.op != opt.InOp {
		return nil
	}
	return (*inExpr)(m)
}

type notInExpr memoExpr

func makeNotInExpr(left opt.GroupID, right opt.GroupID) notInExpr {
	return notInExpr{op: opt.NotInOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notInExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notInExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notInExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotIn() *notInExpr {
	if m.op != opt.NotInOp {
		return nil
	}
	return (*notInExpr)(m)
}

type likeExpr memoExpr

func makeLikeExpr(left opt.GroupID, right opt.GroupID) likeExpr {
	return likeExpr{op: opt.LikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *likeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *likeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *likeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLike() *likeExpr {
	if m.op != opt.LikeOp {
		return nil
	}
	return (*likeExpr)(m)
}

type notLikeExpr memoExpr

func makeNotLikeExpr(left opt.GroupID, right opt.GroupID) notLikeExpr {
	return notLikeExpr{op: opt.NotLikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotLike() *notLikeExpr {
	if m.op != opt.NotLikeOp {
		return nil
	}
	return (*notLikeExpr)(m)
}

type iLikeExpr memoExpr

func makeILikeExpr(left opt.GroupID, right opt.GroupID) iLikeExpr {
	return iLikeExpr{op: opt.ILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *iLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *iLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *iLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asILike() *iLikeExpr {
	if m.op != opt.ILikeOp {
		return nil
	}
	return (*iLikeExpr)(m)
}

type notILikeExpr memoExpr

func makeNotILikeExpr(left opt.GroupID, right opt.GroupID) notILikeExpr {
	return notILikeExpr{op: opt.NotILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notILikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notILikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notILikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotILike() *notILikeExpr {
	if m.op != opt.NotILikeOp {
		return nil
	}
	return (*notILikeExpr)(m)
}

type similarToExpr memoExpr

func makeSimilarToExpr(left opt.GroupID, right opt.GroupID) similarToExpr {
	return similarToExpr{op: opt.SimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *similarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *similarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *similarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSimilarTo() *similarToExpr {
	if m.op != opt.SimilarToOp {
		return nil
	}
	return (*similarToExpr)(m)
}

type notSimilarToExpr memoExpr

func makeNotSimilarToExpr(left opt.GroupID, right opt.GroupID) notSimilarToExpr {
	return notSimilarToExpr{op: opt.NotSimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notSimilarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notSimilarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notSimilarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotSimilarTo() *notSimilarToExpr {
	if m.op != opt.NotSimilarToOp {
		return nil
	}
	return (*notSimilarToExpr)(m)
}

type regMatchExpr memoExpr

func makeRegMatchExpr(left opt.GroupID, right opt.GroupID) regMatchExpr {
	return regMatchExpr{op: opt.RegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegMatch() *regMatchExpr {
	if m.op != opt.RegMatchOp {
		return nil
	}
	return (*regMatchExpr)(m)
}

type notRegMatchExpr memoExpr

func makeNotRegMatchExpr(left opt.GroupID, right opt.GroupID) notRegMatchExpr {
	return notRegMatchExpr{op: opt.NotRegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegMatch() *notRegMatchExpr {
	if m.op != opt.NotRegMatchOp {
		return nil
	}
	return (*notRegMatchExpr)(m)
}

type regIMatchExpr memoExpr

func makeRegIMatchExpr(left opt.GroupID, right opt.GroupID) regIMatchExpr {
	return regIMatchExpr{op: opt.RegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegIMatch() *regIMatchExpr {
	if m.op != opt.RegIMatchOp {
		return nil
	}
	return (*regIMatchExpr)(m)
}

type notRegIMatchExpr memoExpr

func makeNotRegIMatchExpr(left opt.GroupID, right opt.GroupID) notRegIMatchExpr {
	return notRegIMatchExpr{op: opt.NotRegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegIMatch() *notRegIMatchExpr {
	if m.op != opt.NotRegIMatchOp {
		return nil
	}
	return (*notRegIMatchExpr)(m)
}

type isExpr memoExpr

func makeIsExpr(left opt.GroupID, right opt.GroupID) isExpr {
	return isExpr{op: opt.IsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIs() *isExpr {
	if m.op != opt.IsOp {
		return nil
	}
	return (*isExpr)(m)
}

type isNotExpr memoExpr

func makeIsNotExpr(left opt.GroupID, right opt.GroupID) isNotExpr {
	return isNotExpr{op: opt.IsNotOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isNotExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isNotExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isNotExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsNot() *isNotExpr {
	if m.op != opt.IsNotOp {
		return nil
	}
	return (*isNotExpr)(m)
}

type containsExpr memoExpr

func makeContainsExpr(left opt.GroupID, right opt.GroupID) containsExpr {
	return containsExpr{op: opt.ContainsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *containsExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *containsExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *containsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asContains() *containsExpr {
	if m.op != opt.ContainsOp {
		return nil
	}
	return (*containsExpr)(m)
}

type bitandExpr memoExpr

func makeBitandExpr(left opt.GroupID, right opt.GroupID) bitandExpr {
	return bitandExpr{op: opt.BitandOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitandExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitandExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitandExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitand() *bitandExpr {
	if m.op != opt.BitandOp {
		return nil
	}
	return (*bitandExpr)(m)
}

type bitorExpr memoExpr

func makeBitorExpr(left opt.GroupID, right opt.GroupID) bitorExpr {
	return bitorExpr{op: opt.BitorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitor() *bitorExpr {
	if m.op != opt.BitorOp {
		return nil
	}
	return (*bitorExpr)(m)
}

type bitxorExpr memoExpr

func makeBitxorExpr(left opt.GroupID, right opt.GroupID) bitxorExpr {
	return bitxorExpr{op: opt.BitxorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitxorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitxorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitxorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitxor() *bitxorExpr {
	if m.op != opt.BitxorOp {
		return nil
	}
	return (*bitxorExpr)(m)
}

type plusExpr memoExpr

func makePlusExpr(left opt.GroupID, right opt.GroupID) plusExpr {
	return plusExpr{op: opt.PlusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *plusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *plusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *plusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlus() *plusExpr {
	if m.op != opt.PlusOp {
		return nil
	}
	return (*plusExpr)(m)
}

type minusExpr memoExpr

func makeMinusExpr(left opt.GroupID, right opt.GroupID) minusExpr {
	return minusExpr{op: opt.MinusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *minusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *minusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *minusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMinus() *minusExpr {
	if m.op != opt.MinusOp {
		return nil
	}
	return (*minusExpr)(m)
}

type multExpr memoExpr

func makeMultExpr(left opt.GroupID, right opt.GroupID) multExpr {
	return multExpr{op: opt.MultOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *multExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *multExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *multExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMult() *multExpr {
	if m.op != opt.MultOp {
		return nil
	}
	return (*multExpr)(m)
}

type divExpr memoExpr

func makeDivExpr(left opt.GroupID, right opt.GroupID) divExpr {
	return divExpr{op: opt.DivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *divExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *divExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *divExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asDiv() *divExpr {
	if m.op != opt.DivOp {
		return nil
	}
	return (*divExpr)(m)
}

type floorDivExpr memoExpr

func makeFloorDivExpr(left opt.GroupID, right opt.GroupID) floorDivExpr {
	return floorDivExpr{op: opt.FloorDivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *floorDivExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *floorDivExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *floorDivExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFloorDiv() *floorDivExpr {
	if m.op != opt.FloorDivOp {
		return nil
	}
	return (*floorDivExpr)(m)
}

type modExpr memoExpr

func makeModExpr(left opt.GroupID, right opt.GroupID) modExpr {
	return modExpr{op: opt.ModOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *modExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *modExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *modExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMod() *modExpr {
	if m.op != opt.ModOp {
		return nil
	}
	return (*modExpr)(m)
}

type powExpr memoExpr

func makePowExpr(left opt.GroupID, right opt.GroupID) powExpr {
	return powExpr{op: opt.PowOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *powExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *powExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *powExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPow() *powExpr {
	if m.op != opt.PowOp {
		return nil
	}
	return (*powExpr)(m)
}

type concatExpr memoExpr

func makeConcatExpr(left opt.GroupID, right opt.GroupID) concatExpr {
	return concatExpr{op: opt.ConcatOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *concatExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *concatExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *concatExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConcat() *concatExpr {
	if m.op != opt.ConcatOp {
		return nil
	}
	return (*concatExpr)(m)
}

type lShiftExpr memoExpr

func makeLShiftExpr(left opt.GroupID, right opt.GroupID) lShiftExpr {
	return lShiftExpr{op: opt.LShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *lShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *lShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *lShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLShift() *lShiftExpr {
	if m.op != opt.LShiftOp {
		return nil
	}
	return (*lShiftExpr)(m)
}

type rShiftExpr memoExpr

func makeRShiftExpr(left opt.GroupID, right opt.GroupID) rShiftExpr {
	return rShiftExpr{op: opt.RShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *rShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRShift() *rShiftExpr {
	if m.op != opt.RShiftOp {
		return nil
	}
	return (*rShiftExpr)(m)
}

type fetchValExpr memoExpr

func makeFetchValExpr(json opt.GroupID, index opt.GroupID) fetchValExpr {
	return fetchValExpr{op: opt.FetchValOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchValExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchVal() *fetchValExpr {
	if m.op != opt.FetchValOp {
		return nil
	}
	return (*fetchValExpr)(m)
}

type fetchTextExpr memoExpr

func makeFetchTextExpr(json opt.GroupID, index opt.GroupID) fetchTextExpr {
	return fetchTextExpr{op: opt.FetchTextOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchTextExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchText() *fetchTextExpr {
	if m.op != opt.FetchTextOp {
		return nil
	}
	return (*fetchTextExpr)(m)
}

type fetchValPathExpr memoExpr

func makeFetchValPathExpr(json opt.GroupID, path opt.GroupID) fetchValPathExpr {
	return fetchValPathExpr{op: opt.FetchValPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchValPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchValPath() *fetchValPathExpr {
	if m.op != opt.FetchValPathOp {
		return nil
	}
	return (*fetchValPathExpr)(m)
}

type fetchTextPathExpr memoExpr

func makeFetchTextPathExpr(json opt.GroupID, path opt.GroupID) fetchTextPathExpr {
	return fetchTextPathExpr{op: opt.FetchTextPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchTextPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchTextPath() *fetchTextPathExpr {
	if m.op != opt.FetchTextPathOp {
		return nil
	}
	return (*fetchTextPathExpr)(m)
}

type unaryPlusExpr memoExpr

func makeUnaryPlusExpr(input opt.GroupID) unaryPlusExpr {
	return unaryPlusExpr{op: opt.UnaryPlusOp, state: exprState{uint32(input)}}
}

func (e *unaryPlusExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryPlusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryPlus() *unaryPlusExpr {
	if m.op != opt.UnaryPlusOp {
		return nil
	}
	return (*unaryPlusExpr)(m)
}

type unaryMinusExpr memoExpr

func makeUnaryMinusExpr(input opt.GroupID) unaryMinusExpr {
	return unaryMinusExpr{op: opt.UnaryMinusOp, state: exprState{uint32(input)}}
}

func (e *unaryMinusExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryMinusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryMinus() *unaryMinusExpr {
	if m.op != opt.UnaryMinusOp {
		return nil
	}
	return (*unaryMinusExpr)(m)
}

type unaryComplementExpr memoExpr

func makeUnaryComplementExpr(input opt.GroupID) unaryComplementExpr {
	return unaryComplementExpr{op: opt.UnaryComplementOp, state: exprState{uint32(input)}}
}

func (e *unaryComplementExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryComplementExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryComplement() *unaryComplementExpr {
	if m.op != opt.UnaryComplementOp {
		return nil
	}
	return (*unaryComplementExpr)(m)
}

// functionExpr invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The private field is an opt.FuncDef struct that provides the name
// of the function as well as a pointer to the builtin overload definition.
type functionExpr memoExpr

func makeFunctionExpr(args opt.ListID, def opt.PrivateID) functionExpr {
	return functionExpr{op: opt.FunctionOp, state: exprState{args.Offset, args.Length, uint32(def)}}
}

func (e *functionExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *functionExpr) def() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *functionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFunction() *functionExpr {
	if m.op != opt.FunctionOp {
		return nil
	}
	return (*functionExpr)(m)
}

// unsupportedExprExpr is used for interfacing with the old planner code. It can
// encapsulate a TypedExpr that is otherwise not supported by the optimizer.
type unsupportedExprExpr memoExpr

func makeUnsupportedExprExpr(value opt.PrivateID) unsupportedExprExpr {
	return unsupportedExprExpr{op: opt.UnsupportedExprOp, state: exprState{uint32(value)}}
}

func (e *unsupportedExprExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *unsupportedExprExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnsupportedExpr() *unsupportedExprExpr {
	if m.op != opt.UnsupportedExprOp {
		return nil
	}
	return (*unsupportedExprExpr)(m)
}

// scanExpr returns a result set containing every row in the specified table. Rows
// and columns are not expected to have any particular ordering. The private
// Table field is a Metadata.TableIndex that references an optbase.Table
// definition in the query's metadata.
type scanExpr memoExpr

func makeScanExpr(table opt.PrivateID) scanExpr {
	return scanExpr{op: opt.ScanOp, state: exprState{uint32(table)}}
}

func (e *scanExpr) table() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *scanExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asScan() *scanExpr {
	if m.op != opt.ScanOp {
		return nil
	}
	return (*scanExpr)(m)
}

// valuesExpr returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as a *ColList. It is legal for Cols to be empty.
type valuesExpr memoExpr

func makeValuesExpr(rows opt.ListID, cols opt.PrivateID) valuesExpr {
	return valuesExpr{op: opt.ValuesOp, state: exprState{rows.Offset, rows.Length, uint32(cols)}}
}

func (e *valuesExpr) rows() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *valuesExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *valuesExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asValues() *valuesExpr {
	if m.op != opt.ValuesOp {
		return nil
	}
	return (*valuesExpr)(m)
}

// selectExpr filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded.
type selectExpr memoExpr

func makeSelectExpr(input opt.GroupID, filter opt.GroupID) selectExpr {
	return selectExpr{op: opt.SelectOp, state: exprState{uint32(input), uint32(filter)}}
}

func (e *selectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *selectExpr) filter() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *selectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSelect() *selectExpr {
	if m.op != opt.SelectOp {
		return nil
	}
	return (*selectExpr)(m)
}

type projectExpr memoExpr

func makeProjectExpr(input opt.GroupID, projections opt.GroupID) projectExpr {
	return projectExpr{op: opt.ProjectOp, state: exprState{uint32(input), uint32(projections)}}
}

func (e *projectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *projectExpr) projections() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *projectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProject() *projectExpr {
	if m.op != opt.ProjectOp {
		return nil
	}
	return (*projectExpr)(m)
}

// innerJoinExpr creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
type innerJoinExpr memoExpr

func makeInnerJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinExpr {
	return innerJoinExpr{op: opt.InnerJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoin() *innerJoinExpr {
	if m.op != opt.InnerJoinOp {
		return nil
	}
	return (*innerJoinExpr)(m)
}

type leftJoinExpr memoExpr

func makeLeftJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinExpr {
	return leftJoinExpr{op: opt.LeftJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoin() *leftJoinExpr {
	if m.op != opt.LeftJoinOp {
		return nil
	}
	return (*leftJoinExpr)(m)
}

type rightJoinExpr memoExpr

func makeRightJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinExpr {
	return rightJoinExpr{op: opt.RightJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoin() *rightJoinExpr {
	if m.op != opt.RightJoinOp {
		return nil
	}
	return (*rightJoinExpr)(m)
}

type fullJoinExpr memoExpr

func makeFullJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinExpr {
	return fullJoinExpr{op: opt.FullJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoin() *fullJoinExpr {
	if m.op != opt.FullJoinOp {
		return nil
	}
	return (*fullJoinExpr)(m)
}

type semiJoinExpr memoExpr

func makeSemiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinExpr {
	return semiJoinExpr{op: opt.SemiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoin() *semiJoinExpr {
	if m.op != opt.SemiJoinOp {
		return nil
	}
	return (*semiJoinExpr)(m)
}

type antiJoinExpr memoExpr

func makeAntiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinExpr {
	return antiJoinExpr{op: opt.AntiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoin() *antiJoinExpr {
	if m.op != opt.AntiJoinOp {
		return nil
	}
	return (*antiJoinExpr)(m)
}

// innerJoinApplyExpr has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
type innerJoinApplyExpr memoExpr

func makeInnerJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinApplyExpr {
	return innerJoinApplyExpr{op: opt.InnerJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoinApply() *innerJoinApplyExpr {
	if m.op != opt.InnerJoinApplyOp {
		return nil
	}
	return (*innerJoinApplyExpr)(m)
}

type leftJoinApplyExpr memoExpr

func makeLeftJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinApplyExpr {
	return leftJoinApplyExpr{op: opt.LeftJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoinApply() *leftJoinApplyExpr {
	if m.op != opt.LeftJoinApplyOp {
		return nil
	}
	return (*leftJoinApplyExpr)(m)
}

type rightJoinApplyExpr memoExpr

func makeRightJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinApplyExpr {
	return rightJoinApplyExpr{op: opt.RightJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoinApply() *rightJoinApplyExpr {
	if m.op != opt.RightJoinApplyOp {
		return nil
	}
	return (*rightJoinApplyExpr)(m)
}

type fullJoinApplyExpr memoExpr

func makeFullJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinApplyExpr {
	return fullJoinApplyExpr{op: opt.FullJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoinApply() *fullJoinApplyExpr {
	if m.op != opt.FullJoinApplyOp {
		return nil
	}
	return (*fullJoinApplyExpr)(m)
}

type semiJoinApplyExpr memoExpr

func makeSemiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinApplyExpr {
	return semiJoinApplyExpr{op: opt.SemiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoinApply() *semiJoinApplyExpr {
	if m.op != opt.SemiJoinApplyOp {
		return nil
	}
	return (*semiJoinApplyExpr)(m)
}

type antiJoinApplyExpr memoExpr

func makeAntiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinApplyExpr {
	return antiJoinApplyExpr{op: opt.AntiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoinApply() *antiJoinApplyExpr {
	if m.op != opt.AntiJoinApplyOp {
		return nil
	}
	return (*antiJoinApplyExpr)(m)
}

type groupByExpr memoExpr

func makeGroupByExpr(input opt.GroupID, groupings opt.GroupID, aggregations opt.GroupID) groupByExpr {
	return groupByExpr{op: opt.GroupByOp, state: exprState{uint32(input), uint32(groupings), uint32(aggregations)}}
}

func (e *groupByExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *groupByExpr) groupings() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *groupByExpr) aggregations() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *groupByExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGroupBy() *groupByExpr {
	if m.op != opt.GroupByOp {
		return nil
	}
	return (*groupByExpr)(m)
}

type unionExpr memoExpr

func makeUnionExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) unionExpr {
	return unionExpr{op: opt.UnionOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unionExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *unionExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *unionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnion() *unionExpr {
	if m.op != opt.UnionOp {
		return nil
	}
	return (*unionExpr)(m)
}

type intersectExpr memoExpr

func makeIntersectExpr(left opt.GroupID, right opt.GroupID) intersectExpr {
	return intersectExpr{op: opt.IntersectOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *intersectExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *intersectExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *intersectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersect() *intersectExpr {
	if m.op != opt.IntersectOp {
		return nil
	}
	return (*intersectExpr)(m)
}

type exceptExpr memoExpr

func makeExceptExpr(left opt.GroupID, right opt.GroupID) exceptExpr {
	return exceptExpr{op: opt.ExceptOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *exceptExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *exceptExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *exceptExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExcept() *exceptExpr {
	if m.op != opt.ExceptOp {
		return nil
	}
	return (*exceptExpr)(m)
}
