// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ChildCount returns the number of expressions that are inputs to this
// parent expression.
func (ev ExprView) ChildCount() int {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.SubqueryOp:
		return 2

	case opt.VariableOp:
		return 0

	case opt.ConstOp:
		return 0

	case opt.NullOp:
		return 0

	case opt.TrueOp:
		return 0

	case opt.FalseOp:
		return 0

	case opt.PlaceholderOp:
		return 0

	case opt.TupleOp:
		tupleExpr := (*tupleExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(tupleExpr.elems().Length)

	case opt.ProjectionsOp:
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(projectionsExpr.elems().Length)

	case opt.AggregationsOp:
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(aggregationsExpr.aggs().Length)

	case opt.ExistsOp:
		return 1

	case opt.AndOp:
		andExpr := (*andExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(andExpr.conditions().Length)

	case opt.OrOp:
		orExpr := (*orExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(orExpr.conditions().Length)

	case opt.NotOp:
		return 1

	case opt.EqOp:
		return 2

	case opt.LtOp:
		return 2

	case opt.GtOp:
		return 2

	case opt.LeOp:
		return 2

	case opt.GeOp:
		return 2

	case opt.NeOp:
		return 2

	case opt.InOp:
		return 2

	case opt.NotInOp:
		return 2

	case opt.LikeOp:
		return 2

	case opt.NotLikeOp:
		return 2

	case opt.ILikeOp:
		return 2

	case opt.NotILikeOp:
		return 2

	case opt.SimilarToOp:
		return 2

	case opt.NotSimilarToOp:
		return 2

	case opt.RegMatchOp:
		return 2

	case opt.NotRegMatchOp:
		return 2

	case opt.RegIMatchOp:
		return 2

	case opt.NotRegIMatchOp:
		return 2

	case opt.IsOp:
		return 2

	case opt.IsNotOp:
		return 2

	case opt.ContainsOp:
		return 2

	case opt.BitandOp:
		return 2

	case opt.BitorOp:
		return 2

	case opt.BitxorOp:
		return 2

	case opt.PlusOp:
		return 2

	case opt.MinusOp:
		return 2

	case opt.MultOp:
		return 2

	case opt.DivOp:
		return 2

	case opt.FloorDivOp:
		return 2

	case opt.ModOp:
		return 2

	case opt.PowOp:
		return 2

	case opt.ConcatOp:
		return 2

	case opt.LShiftOp:
		return 2

	case opt.RShiftOp:
		return 2

	case opt.FetchValOp:
		return 2

	case opt.FetchTextOp:
		return 2

	case opt.FetchValPathOp:
		return 2

	case opt.FetchTextPathOp:
		return 2

	case opt.UnaryPlusOp:
		return 1

	case opt.UnaryMinusOp:
		return 1

	case opt.UnaryComplementOp:
		return 1

	case opt.CastOp:
		return 1

	case opt.FunctionOp:
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(functionExpr.args().Length)

	case opt.CoalesceOp:
		coalesceExpr := (*coalesceExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(coalesceExpr.args().Length)

	case opt.UnsupportedExprOp:
		return 0

	case opt.ScanOp:
		return 0

	case opt.ValuesOp:
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))
		return 0 + int(valuesExpr.rows().Length)

	case opt.SelectOp:
		return 2

	case opt.ProjectOp:
		return 2

	case opt.InnerJoinOp:
		return 3

	case opt.LeftJoinOp:
		return 3

	case opt.RightJoinOp:
		return 3

	case opt.FullJoinOp:
		return 3

	case opt.SemiJoinOp:
		return 3

	case opt.AntiJoinOp:
		return 3

	case opt.InnerJoinApplyOp:
		return 3

	case opt.LeftJoinApplyOp:
		return 3

	case opt.RightJoinApplyOp:
		return 3

	case opt.FullJoinApplyOp:
		return 3

	case opt.SemiJoinApplyOp:
		return 3

	case opt.AntiJoinApplyOp:
		return 3

	case opt.GroupByOp:
		return 2

	case opt.UnionOp:
		return 2

	case opt.IntersectOp:
		return 2

	case opt.ExceptOp:
		return 2

	case opt.UnionAllOp:
		return 2

	case opt.IntersectAllOp:
		return 2

	case opt.ExceptAllOp:
		return 2

	case opt.SortOp:
		return 1

	default:
		panic("invalid op")
	}

}

// ChildGroup returns the memo group containing the nth child of this parent
// expression.
func (ev ExprView) ChildGroup(n int) opt.GroupID {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.SubqueryOp:
		subqueryExpr := (*subqueryExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return subqueryExpr.input()
		case 1:
			return subqueryExpr.projection()
		default:
			panic("child index out of range")
		}

	case opt.VariableOp:
		panic("child index out of range")

	case opt.ConstOp:
		panic("child index out of range")

	case opt.NullOp:
		panic("child index out of range")

	case opt.TrueOp:
		panic("child index out of range")

	case opt.FalseOp:
		panic("child index out of range")

	case opt.PlaceholderOp:
		panic("child index out of range")

	case opt.TupleOp:
		tupleExpr := (*tupleExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(tupleExpr.elems())
			return list[n-0]
		}

	case opt.ProjectionsOp:
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(projectionsExpr.elems())
			return list[n-0]
		}

	case opt.AggregationsOp:
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(aggregationsExpr.aggs())
			return list[n-0]
		}

	case opt.ExistsOp:
		existsExpr := (*existsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return existsExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.AndOp:
		andExpr := (*andExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(andExpr.conditions())
			return list[n-0]
		}

	case opt.OrOp:
		orExpr := (*orExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(orExpr.conditions())
			return list[n-0]
		}

	case opt.NotOp:
		notExpr := (*notExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.EqOp:
		eqExpr := (*eqExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return eqExpr.left()
		case 1:
			return eqExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.LtOp:
		ltExpr := (*ltExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return ltExpr.left()
		case 1:
			return ltExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.GtOp:
		gtExpr := (*gtExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return gtExpr.left()
		case 1:
			return gtExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.LeOp:
		leExpr := (*leExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leExpr.left()
		case 1:
			return leExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.GeOp:
		geExpr := (*geExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return geExpr.left()
		case 1:
			return geExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NeOp:
		neExpr := (*neExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return neExpr.left()
		case 1:
			return neExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.InOp:
		inExpr := (*inExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return inExpr.left()
		case 1:
			return inExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotInOp:
		notInExpr := (*notInExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notInExpr.left()
		case 1:
			return notInExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.LikeOp:
		likeExpr := (*likeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return likeExpr.left()
		case 1:
			return likeExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotLikeOp:
		notLikeExpr := (*notLikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notLikeExpr.left()
		case 1:
			return notLikeExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ILikeOp:
		iLikeExpr := (*iLikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return iLikeExpr.left()
		case 1:
			return iLikeExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotILikeOp:
		notILikeExpr := (*notILikeExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notILikeExpr.left()
		case 1:
			return notILikeExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.SimilarToOp:
		similarToExpr := (*similarToExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return similarToExpr.left()
		case 1:
			return similarToExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotSimilarToOp:
		notSimilarToExpr := (*notSimilarToExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notSimilarToExpr.left()
		case 1:
			return notSimilarToExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.RegMatchOp:
		regMatchExpr := (*regMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return regMatchExpr.left()
		case 1:
			return regMatchExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotRegMatchOp:
		notRegMatchExpr := (*notRegMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notRegMatchExpr.left()
		case 1:
			return notRegMatchExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.RegIMatchOp:
		regIMatchExpr := (*regIMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return regIMatchExpr.left()
		case 1:
			return regIMatchExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.NotRegIMatchOp:
		notRegIMatchExpr := (*notRegIMatchExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return notRegIMatchExpr.left()
		case 1:
			return notRegIMatchExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.IsOp:
		isExpr := (*isExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return isExpr.left()
		case 1:
			return isExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.IsNotOp:
		isNotExpr := (*isNotExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return isNotExpr.left()
		case 1:
			return isNotExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ContainsOp:
		containsExpr := (*containsExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return containsExpr.left()
		case 1:
			return containsExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.BitandOp:
		bitandExpr := (*bitandExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitandExpr.left()
		case 1:
			return bitandExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.BitorOp:
		bitorExpr := (*bitorExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitorExpr.left()
		case 1:
			return bitorExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.BitxorOp:
		bitxorExpr := (*bitxorExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return bitxorExpr.left()
		case 1:
			return bitxorExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.PlusOp:
		plusExpr := (*plusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return plusExpr.left()
		case 1:
			return plusExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.MinusOp:
		minusExpr := (*minusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return minusExpr.left()
		case 1:
			return minusExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.MultOp:
		multExpr := (*multExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return multExpr.left()
		case 1:
			return multExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.DivOp:
		divExpr := (*divExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return divExpr.left()
		case 1:
			return divExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.FloorDivOp:
		floorDivExpr := (*floorDivExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return floorDivExpr.left()
		case 1:
			return floorDivExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ModOp:
		modExpr := (*modExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return modExpr.left()
		case 1:
			return modExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.PowOp:
		powExpr := (*powExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return powExpr.left()
		case 1:
			return powExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ConcatOp:
		concatExpr := (*concatExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return concatExpr.left()
		case 1:
			return concatExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.LShiftOp:
		lShiftExpr := (*lShiftExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return lShiftExpr.left()
		case 1:
			return lShiftExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.RShiftOp:
		rShiftExpr := (*rShiftExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rShiftExpr.left()
		case 1:
			return rShiftExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.FetchValOp:
		fetchValExpr := (*fetchValExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchValExpr.json()
		case 1:
			return fetchValExpr.index()
		default:
			panic("child index out of range")
		}

	case opt.FetchTextOp:
		fetchTextExpr := (*fetchTextExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchTextExpr.json()
		case 1:
			return fetchTextExpr.index()
		default:
			panic("child index out of range")
		}

	case opt.FetchValPathOp:
		fetchValPathExpr := (*fetchValPathExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchValPathExpr.json()
		case 1:
			return fetchValPathExpr.path()
		default:
			panic("child index out of range")
		}

	case opt.FetchTextPathOp:
		fetchTextPathExpr := (*fetchTextPathExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fetchTextPathExpr.json()
		case 1:
			return fetchTextPathExpr.path()
		default:
			panic("child index out of range")
		}

	case opt.UnaryPlusOp:
		unaryPlusExpr := (*unaryPlusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryPlusExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.UnaryMinusOp:
		unaryMinusExpr := (*unaryMinusExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryMinusExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.UnaryComplementOp:
		unaryComplementExpr := (*unaryComplementExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unaryComplementExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.CastOp:
		castExpr := (*castExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return castExpr.input()
		default:
			panic("child index out of range")
		}

	case opt.FunctionOp:
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(functionExpr.args())
			return list[n-0]
		}

	case opt.CoalesceOp:
		coalesceExpr := (*coalesceExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(coalesceExpr.args())
			return list[n-0]
		}

	case opt.UnsupportedExprOp:
		panic("child index out of range")

	case opt.ScanOp:
		panic("child index out of range")

	case opt.ValuesOp:
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		default:
			list := ev.mem.lookupList(valuesExpr.rows())
			return list[n-0]
		}

	case opt.SelectOp:
		selectExpr := (*selectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return selectExpr.input()
		case 1:
			return selectExpr.filter()
		default:
			panic("child index out of range")
		}

	case opt.ProjectOp:
		projectExpr := (*projectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return projectExpr.input()
		case 1:
			return projectExpr.projections()
		default:
			panic("child index out of range")
		}

	case opt.InnerJoinOp:
		innerJoinExpr := (*innerJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return innerJoinExpr.left()
		case 1:
			return innerJoinExpr.right()
		case 2:
			return innerJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.LeftJoinOp:
		leftJoinExpr := (*leftJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leftJoinExpr.left()
		case 1:
			return leftJoinExpr.right()
		case 2:
			return leftJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.RightJoinOp:
		rightJoinExpr := (*rightJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rightJoinExpr.left()
		case 1:
			return rightJoinExpr.right()
		case 2:
			return rightJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.FullJoinOp:
		fullJoinExpr := (*fullJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fullJoinExpr.left()
		case 1:
			return fullJoinExpr.right()
		case 2:
			return fullJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.SemiJoinOp:
		semiJoinExpr := (*semiJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return semiJoinExpr.left()
		case 1:
			return semiJoinExpr.right()
		case 2:
			return semiJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.AntiJoinOp:
		antiJoinExpr := (*antiJoinExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return antiJoinExpr.left()
		case 1:
			return antiJoinExpr.right()
		case 2:
			return antiJoinExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.InnerJoinApplyOp:
		innerJoinApplyExpr := (*innerJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return innerJoinApplyExpr.left()
		case 1:
			return innerJoinApplyExpr.right()
		case 2:
			return innerJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.LeftJoinApplyOp:
		leftJoinApplyExpr := (*leftJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return leftJoinApplyExpr.left()
		case 1:
			return leftJoinApplyExpr.right()
		case 2:
			return leftJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.RightJoinApplyOp:
		rightJoinApplyExpr := (*rightJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return rightJoinApplyExpr.left()
		case 1:
			return rightJoinApplyExpr.right()
		case 2:
			return rightJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.FullJoinApplyOp:
		fullJoinApplyExpr := (*fullJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return fullJoinApplyExpr.left()
		case 1:
			return fullJoinApplyExpr.right()
		case 2:
			return fullJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.SemiJoinApplyOp:
		semiJoinApplyExpr := (*semiJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return semiJoinApplyExpr.left()
		case 1:
			return semiJoinApplyExpr.right()
		case 2:
			return semiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.AntiJoinApplyOp:
		antiJoinApplyExpr := (*antiJoinApplyExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return antiJoinApplyExpr.left()
		case 1:
			return antiJoinApplyExpr.right()
		case 2:
			return antiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}

	case opt.GroupByOp:
		groupByExpr := (*groupByExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return groupByExpr.input()
		case 1:
			return groupByExpr.aggregations()
		default:
			panic("child index out of range")
		}

	case opt.UnionOp:
		unionExpr := (*unionExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unionExpr.left()
		case 1:
			return unionExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.IntersectOp:
		intersectExpr := (*intersectExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return intersectExpr.left()
		case 1:
			return intersectExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ExceptOp:
		exceptExpr := (*exceptExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return exceptExpr.left()
		case 1:
			return exceptExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.UnionAllOp:
		unionAllExpr := (*unionAllExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return unionAllExpr.left()
		case 1:
			return unionAllExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.IntersectAllOp:
		intersectAllExpr := (*intersectAllExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return intersectAllExpr.left()
		case 1:
			return intersectAllExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.ExceptAllOp:
		exceptAllExpr := (*exceptAllExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return exceptAllExpr.left()
		case 1:
			return exceptAllExpr.right()
		default:
			panic("child index out of range")
		}

	case opt.SortOp:
		if n == 0 {
			return ev.loc.group
		}

		panic("child index out of range")

	default:
		panic("invalid op")
	}

}

type privateLookupFunc func(ev ExprView) opt.PrivateID

var privateLookup = [...]privateLookupFunc{
	// UnknownOp
	func(ev ExprView) opt.PrivateID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// VariableOp
	func(ev ExprView) opt.PrivateID {
		variableExpr := (*variableExpr)(ev.mem.lookupExpr(ev.loc))
		return variableExpr.col()
	},

	// ConstOp
	func(ev ExprView) opt.PrivateID {
		constExpr := (*constExpr)(ev.mem.lookupExpr(ev.loc))
		return constExpr.value()
	},

	// NullOp
	func(ev ExprView) opt.PrivateID {
		nullExpr := (*nullExpr)(ev.mem.lookupExpr(ev.loc))
		return nullExpr.typ()
	},

	// TrueOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FalseOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PlaceholderOp
	func(ev ExprView) opt.PrivateID {
		placeholderExpr := (*placeholderExpr)(ev.mem.lookupExpr(ev.loc))
		return placeholderExpr.value()
	},

	// TupleOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ProjectionsOp
	func(ev ExprView) opt.PrivateID {
		projectionsExpr := (*projectionsExpr)(ev.mem.lookupExpr(ev.loc))
		return projectionsExpr.cols()
	},

	// AggregationsOp
	func(ev ExprView) opt.PrivateID {
		aggregationsExpr := (*aggregationsExpr)(ev.mem.lookupExpr(ev.loc))
		return aggregationsExpr.cols()
	},

	// ExistsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AndOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// OrOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// EqOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LtOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GtOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotInOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotLikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ILikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotILikeOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SimilarToOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotSimilarToOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RegMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotRegMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RegIMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// NotRegIMatchOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// IsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// IsNotOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ContainsOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitandOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitorOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// BitxorOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PlusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// MinusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// MultOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// DivOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FloorDivOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ModOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// PowOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ConcatOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LShiftOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RShiftOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchValOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchTextOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchValPathOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FetchTextPathOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryPlusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryMinusOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnaryComplementOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// CastOp
	func(ev ExprView) opt.PrivateID {
		castExpr := (*castExpr)(ev.mem.lookupExpr(ev.loc))
		return castExpr.typ()
	},

	// FunctionOp
	func(ev ExprView) opt.PrivateID {
		functionExpr := (*functionExpr)(ev.mem.lookupExpr(ev.loc))
		return functionExpr.def()
	},

	// CoalesceOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// UnsupportedExprOp
	func(ev ExprView) opt.PrivateID {
		unsupportedExprExpr := (*unsupportedExprExpr)(ev.mem.lookupExpr(ev.loc))
		return unsupportedExprExpr.value()
	},

	// ScanOp
	func(ev ExprView) opt.PrivateID {
		scanExpr := (*scanExpr)(ev.mem.lookupExpr(ev.loc))
		return scanExpr.table()
	},

	// ValuesOp
	func(ev ExprView) opt.PrivateID {
		valuesExpr := (*valuesExpr)(ev.mem.lookupExpr(ev.loc))
		return valuesExpr.cols()
	},

	// SelectOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// ProjectOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InnerJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeftJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RightJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FullJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SemiJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AntiJoinOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// InnerJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// LeftJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// RightJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// FullJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// SemiJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// AntiJoinApplyOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},

	// GroupByOp
	func(ev ExprView) opt.PrivateID {
		groupByExpr := (*groupByExpr)(ev.mem.lookupExpr(ev.loc))
		return groupByExpr.groupingColumns()
	},

	// UnionOp
	func(ev ExprView) opt.PrivateID {
		unionExpr := (*unionExpr)(ev.mem.lookupExpr(ev.loc))
		return unionExpr.colMap()
	},

	// IntersectOp
	func(ev ExprView) opt.PrivateID {
		intersectExpr := (*intersectExpr)(ev.mem.lookupExpr(ev.loc))
		return intersectExpr.colMap()
	},

	// ExceptOp
	func(ev ExprView) opt.PrivateID {
		exceptExpr := (*exceptExpr)(ev.mem.lookupExpr(ev.loc))
		return exceptExpr.colMap()
	},

	// UnionAllOp
	func(ev ExprView) opt.PrivateID {
		unionAllExpr := (*unionAllExpr)(ev.mem.lookupExpr(ev.loc))
		return unionAllExpr.colMap()
	},

	// IntersectAllOp
	func(ev ExprView) opt.PrivateID {
		intersectAllExpr := (*intersectAllExpr)(ev.mem.lookupExpr(ev.loc))
		return intersectAllExpr.colMap()
	},

	// ExceptAllOp
	func(ev ExprView) opt.PrivateID {
		exceptAllExpr := (*exceptAllExpr)(ev.mem.lookupExpr(ev.loc))
		return exceptAllExpr.colMap()
	},

	// SortOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},
}

var isScalarLookup = [...]bool{
	false, // UnknownOp

	true,  // SubqueryOp
	true,  // VariableOp
	true,  // ConstOp
	true,  // NullOp
	true,  // TrueOp
	true,  // FalseOp
	true,  // PlaceholderOp
	true,  // TupleOp
	true,  // ProjectionsOp
	true,  // AggregationsOp
	true,  // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	true,  // CastOp
	true,  // FunctionOp
	true,  // CoalesceOp
	true,  // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isConstValueLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	true,  // ConstOp
	true,  // NullOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isBooleanLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isComparisonLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isBinaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isUnaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isRelationalLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	true,  // ScanOp
	true,  // ValuesOp
	true,  // SelectOp
	true,  // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	true,  // GroupByOp
	true,  // UnionOp
	true,  // IntersectOp
	true,  // ExceptOp
	true,  // UnionAllOp
	true,  // IntersectAllOp
	true,  // ExceptAllOp
	false, // SortOp
}

var isJoinLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isJoinApplyLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // SortOp
}

var isEnforcerLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	true,  // SortOp
}

func (ev ExprView) IsScalar() bool {
	return isScalarLookup[ev.op]
}

func (ev ExprView) IsConstValue() bool {
	return isConstValueLookup[ev.op]
}

func (ev ExprView) IsBoolean() bool {
	return isBooleanLookup[ev.op]
}

func (ev ExprView) IsComparison() bool {
	return isComparisonLookup[ev.op]
}

func (ev ExprView) IsBinary() bool {
	return isBinaryLookup[ev.op]
}

func (ev ExprView) IsUnary() bool {
	return isUnaryLookup[ev.op]
}

func (ev ExprView) IsRelational() bool {
	return isRelationalLookup[ev.op]
}

func (ev ExprView) IsJoin() bool {
	return isJoinLookup[ev.op]
}

func (ev ExprView) IsJoinApply() bool {
	return isJoinApplyLookup[ev.op]
}

func (ev ExprView) IsEnforcer() bool {
	return isEnforcerLookup[ev.op]
}

func (me *memoExpr) isScalar() bool {
	return isScalarLookup[me.op]
}

func (me *memoExpr) isConstValue() bool {
	return isConstValueLookup[me.op]
}

func (me *memoExpr) isBoolean() bool {
	return isBooleanLookup[me.op]
}

func (me *memoExpr) isComparison() bool {
	return isComparisonLookup[me.op]
}

func (me *memoExpr) isBinary() bool {
	return isBinaryLookup[me.op]
}

func (me *memoExpr) isUnary() bool {
	return isUnaryLookup[me.op]
}

func (me *memoExpr) isRelational() bool {
	return isRelationalLookup[me.op]
}

func (me *memoExpr) isJoin() bool {
	return isJoinLookup[me.op]
}

func (me *memoExpr) isJoinApply() bool {
	return isJoinApplyLookup[me.op]
}

func (me *memoExpr) isEnforcer() bool {
	return isEnforcerLookup[me.op]
}

type subqueryExpr memoExpr

func makeSubqueryExpr(input opt.GroupID, projection opt.GroupID) subqueryExpr {
	return subqueryExpr{op: opt.SubqueryOp, state: exprState{uint32(input), uint32(projection)}}
}

func (e *subqueryExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *subqueryExpr) projection() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *subqueryExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSubquery() *subqueryExpr {
	if m.op != opt.SubqueryOp {
		return nil
	}
	return (*subqueryExpr)(m)
}

// variableExpr is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnIndex that references the column by index.
type variableExpr memoExpr

func makeVariableExpr(col opt.PrivateID) variableExpr {
	return variableExpr{op: opt.VariableOp, state: exprState{uint32(col)}}
}

func (e *variableExpr) col() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *variableExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asVariable() *variableExpr {
	if m.op != opt.VariableOp {
		return nil
	}
	return (*variableExpr)(m)
}

// constExpr is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
type constExpr memoExpr

func makeConstExpr(value opt.PrivateID) constExpr {
	return constExpr{op: opt.ConstOp, state: exprState{uint32(value)}}
}

func (e *constExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *constExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConst() *constExpr {
	if m.op != opt.ConstOp {
		return nil
	}
	return (*constExpr)(m)
}

// nullExpr is the constant SQL null value that has "unknown value" semantics. If
// the Typ field is not types.Unknown, then the value is known to be in the
// domain of that type. This is important for preserving correct types in
// replacement patterns. For example:
//   (Plus (Function ...) (Const 1))
//
// If the function in that expression has a static type of Int, but then it gets
// constant folded to (Null), then its type must remain as Int. Any other type
// violates logical equivalence of the expression, breaking type inference and
// possibly changing the results of execution. The solution is to tag the null
// with the correct type:
//   (Plus (Null (Int)) (Const 1))
//
// Null is its own operator rather than a Const datum in order to make matching
// and replacement easier and more efficient, as patterns can contain (Null)
// expressions.
type nullExpr memoExpr

func makeNullExpr(typ opt.PrivateID) nullExpr {
	return nullExpr{op: opt.NullOp, state: exprState{uint32(typ)}}
}

func (e *nullExpr) typ() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *nullExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNull() *nullExpr {
	if m.op != opt.NullOp {
		return nil
	}
	return (*nullExpr)(m)
}

// trueExpr is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
type trueExpr memoExpr

func makeTrueExpr() trueExpr {
	return trueExpr{op: opt.TrueOp, state: exprState{}}
}

func (e *trueExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTrue() *trueExpr {
	if m.op != opt.TrueOp {
		return nil
	}
	return (*trueExpr)(m)
}

// falseExpr is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
type falseExpr memoExpr

func makeFalseExpr() falseExpr {
	return falseExpr{op: opt.FalseOp, state: exprState{}}
}

func (e *falseExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFalse() *falseExpr {
	if m.op != opt.FalseOp {
		return nil
	}
	return (*falseExpr)(m)
}

type placeholderExpr memoExpr

func makePlaceholderExpr(value opt.PrivateID) placeholderExpr {
	return placeholderExpr{op: opt.PlaceholderOp, state: exprState{uint32(value)}}
}

func (e *placeholderExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *placeholderExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlaceholder() *placeholderExpr {
	if m.op != opt.PlaceholderOp {
		return nil
	}
	return (*placeholderExpr)(m)
}

type tupleExpr memoExpr

func makeTupleExpr(elems opt.ListID) tupleExpr {
	return tupleExpr{op: opt.TupleOp, state: exprState{elems.Offset, elems.Length}}
}

func (e *tupleExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *tupleExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTuple() *tupleExpr {
	if m.op != opt.TupleOp {
		return nil
	}
	return (*tupleExpr)(m)
}

// projectionsExpr is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *opt.ColList. It
// is not legal for Cols to be empty.
type projectionsExpr memoExpr

func makeProjectionsExpr(elems opt.ListID, cols opt.PrivateID) projectionsExpr {
	return projectionsExpr{op: opt.ProjectionsOp, state: exprState{elems.Offset, elems.Length, uint32(cols)}}
}

func (e *projectionsExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *projectionsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *projectionsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProjections() *projectionsExpr {
	if m.op != opt.ProjectionsOp {
		return nil
	}
	return (*projectionsExpr)(m)
}

// aggregationsExpr is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *ColList. It
// is legal for Cols to be empty.
type aggregationsExpr memoExpr

func makeAggregationsExpr(aggs opt.ListID, cols opt.PrivateID) aggregationsExpr {
	return aggregationsExpr{op: opt.AggregationsOp, state: exprState{aggs.Offset, aggs.Length, uint32(cols)}}
}

func (e *aggregationsExpr) aggs() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *aggregationsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *aggregationsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAggregations() *aggregationsExpr {
	if m.op != opt.AggregationsOp {
		return nil
	}
	return (*aggregationsExpr)(m)
}

type existsExpr memoExpr

func makeExistsExpr(input opt.GroupID) existsExpr {
	return existsExpr{op: opt.ExistsOp, state: exprState{uint32(input)}}
}

func (e *existsExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *existsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExists() *existsExpr {
	if m.op != opt.ExistsOp {
		return nil
	}
	return (*existsExpr)(m)
}

// andExpr is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
type andExpr memoExpr

func makeAndExpr(conditions opt.ListID) andExpr {
	return andExpr{op: opt.AndOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *andExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *andExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAnd() *andExpr {
	if m.op != opt.AndOp {
		return nil
	}
	return (*andExpr)(m)
}

// orExpr is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
type orExpr memoExpr

func makeOrExpr(conditions opt.ListID) orExpr {
	return orExpr{op: opt.OrOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *orExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *orExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOr() *orExpr {
	if m.op != opt.OrOp {
		return nil
	}
	return (*orExpr)(m)
}

// notExpr is the boolean negation operator that evaluates to true if its input
// evalutes to false.
type notExpr memoExpr

func makeNotExpr(input opt.GroupID) notExpr {
	return notExpr{op: opt.NotOp, state: exprState{uint32(input)}}
}

func (e *notExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNot() *notExpr {
	if m.op != opt.NotOp {
		return nil
	}
	return (*notExpr)(m)
}

type eqExpr memoExpr

func makeEqExpr(left opt.GroupID, right opt.GroupID) eqExpr {
	return eqExpr{op: opt.EqOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *eqExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *eqExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *eqExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asEq() *eqExpr {
	if m.op != opt.EqOp {
		return nil
	}
	return (*eqExpr)(m)
}

type ltExpr memoExpr

func makeLtExpr(left opt.GroupID, right opt.GroupID) ltExpr {
	return ltExpr{op: opt.LtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ltExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *ltExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *ltExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLt() *ltExpr {
	if m.op != opt.LtOp {
		return nil
	}
	return (*ltExpr)(m)
}

type gtExpr memoExpr

func makeGtExpr(left opt.GroupID, right opt.GroupID) gtExpr {
	return gtExpr{op: opt.GtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *gtExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *gtExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *gtExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGt() *gtExpr {
	if m.op != opt.GtOp {
		return nil
	}
	return (*gtExpr)(m)
}

type leExpr memoExpr

func makeLeExpr(left opt.GroupID, right opt.GroupID) leExpr {
	return leExpr{op: opt.LeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *leExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLe() *leExpr {
	if m.op != opt.LeOp {
		return nil
	}
	return (*leExpr)(m)
}

type geExpr memoExpr

func makeGeExpr(left opt.GroupID, right opt.GroupID) geExpr {
	return geExpr{op: opt.GeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *geExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *geExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *geExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGe() *geExpr {
	if m.op != opt.GeOp {
		return nil
	}
	return (*geExpr)(m)
}

type neExpr memoExpr

func makeNeExpr(left opt.GroupID, right opt.GroupID) neExpr {
	return neExpr{op: opt.NeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *neExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *neExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *neExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNe() *neExpr {
	if m.op != opt.NeOp {
		return nil
	}
	return (*neExpr)(m)
}

type inExpr memoExpr

func makeInExpr(left opt.GroupID, right opt.GroupID) inExpr {
	return inExpr{op: opt.InOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *inExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *inExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *inExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIn() *inExpr {
	if m.op != opt.InOp {
		return nil
	}
	return (*inExpr)(m)
}

type notInExpr memoExpr

func makeNotInExpr(left opt.GroupID, right opt.GroupID) notInExpr {
	return notInExpr{op: opt.NotInOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notInExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notInExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notInExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotIn() *notInExpr {
	if m.op != opt.NotInOp {
		return nil
	}
	return (*notInExpr)(m)
}

type likeExpr memoExpr

func makeLikeExpr(left opt.GroupID, right opt.GroupID) likeExpr {
	return likeExpr{op: opt.LikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *likeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *likeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *likeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLike() *likeExpr {
	if m.op != opt.LikeOp {
		return nil
	}
	return (*likeExpr)(m)
}

type notLikeExpr memoExpr

func makeNotLikeExpr(left opt.GroupID, right opt.GroupID) notLikeExpr {
	return notLikeExpr{op: opt.NotLikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotLike() *notLikeExpr {
	if m.op != opt.NotLikeOp {
		return nil
	}
	return (*notLikeExpr)(m)
}

type iLikeExpr memoExpr

func makeILikeExpr(left opt.GroupID, right opt.GroupID) iLikeExpr {
	return iLikeExpr{op: opt.ILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *iLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *iLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *iLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asILike() *iLikeExpr {
	if m.op != opt.ILikeOp {
		return nil
	}
	return (*iLikeExpr)(m)
}

type notILikeExpr memoExpr

func makeNotILikeExpr(left opt.GroupID, right opt.GroupID) notILikeExpr {
	return notILikeExpr{op: opt.NotILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notILikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notILikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notILikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotILike() *notILikeExpr {
	if m.op != opt.NotILikeOp {
		return nil
	}
	return (*notILikeExpr)(m)
}

type similarToExpr memoExpr

func makeSimilarToExpr(left opt.GroupID, right opt.GroupID) similarToExpr {
	return similarToExpr{op: opt.SimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *similarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *similarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *similarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSimilarTo() *similarToExpr {
	if m.op != opt.SimilarToOp {
		return nil
	}
	return (*similarToExpr)(m)
}

type notSimilarToExpr memoExpr

func makeNotSimilarToExpr(left opt.GroupID, right opt.GroupID) notSimilarToExpr {
	return notSimilarToExpr{op: opt.NotSimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notSimilarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notSimilarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notSimilarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotSimilarTo() *notSimilarToExpr {
	if m.op != opt.NotSimilarToOp {
		return nil
	}
	return (*notSimilarToExpr)(m)
}

type regMatchExpr memoExpr

func makeRegMatchExpr(left opt.GroupID, right opt.GroupID) regMatchExpr {
	return regMatchExpr{op: opt.RegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegMatch() *regMatchExpr {
	if m.op != opt.RegMatchOp {
		return nil
	}
	return (*regMatchExpr)(m)
}

type notRegMatchExpr memoExpr

func makeNotRegMatchExpr(left opt.GroupID, right opt.GroupID) notRegMatchExpr {
	return notRegMatchExpr{op: opt.NotRegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegMatch() *notRegMatchExpr {
	if m.op != opt.NotRegMatchOp {
		return nil
	}
	return (*notRegMatchExpr)(m)
}

type regIMatchExpr memoExpr

func makeRegIMatchExpr(left opt.GroupID, right opt.GroupID) regIMatchExpr {
	return regIMatchExpr{op: opt.RegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegIMatch() *regIMatchExpr {
	if m.op != opt.RegIMatchOp {
		return nil
	}
	return (*regIMatchExpr)(m)
}

type notRegIMatchExpr memoExpr

func makeNotRegIMatchExpr(left opt.GroupID, right opt.GroupID) notRegIMatchExpr {
	return notRegIMatchExpr{op: opt.NotRegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegIMatch() *notRegIMatchExpr {
	if m.op != opt.NotRegIMatchOp {
		return nil
	}
	return (*notRegIMatchExpr)(m)
}

type isExpr memoExpr

func makeIsExpr(left opt.GroupID, right opt.GroupID) isExpr {
	return isExpr{op: opt.IsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIs() *isExpr {
	if m.op != opt.IsOp {
		return nil
	}
	return (*isExpr)(m)
}

type isNotExpr memoExpr

func makeIsNotExpr(left opt.GroupID, right opt.GroupID) isNotExpr {
	return isNotExpr{op: opt.IsNotOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isNotExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isNotExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isNotExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsNot() *isNotExpr {
	if m.op != opt.IsNotOp {
		return nil
	}
	return (*isNotExpr)(m)
}

type containsExpr memoExpr

func makeContainsExpr(left opt.GroupID, right opt.GroupID) containsExpr {
	return containsExpr{op: opt.ContainsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *containsExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *containsExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *containsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asContains() *containsExpr {
	if m.op != opt.ContainsOp {
		return nil
	}
	return (*containsExpr)(m)
}

type bitandExpr memoExpr

func makeBitandExpr(left opt.GroupID, right opt.GroupID) bitandExpr {
	return bitandExpr{op: opt.BitandOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitandExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitandExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitandExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitand() *bitandExpr {
	if m.op != opt.BitandOp {
		return nil
	}
	return (*bitandExpr)(m)
}

type bitorExpr memoExpr

func makeBitorExpr(left opt.GroupID, right opt.GroupID) bitorExpr {
	return bitorExpr{op: opt.BitorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitor() *bitorExpr {
	if m.op != opt.BitorOp {
		return nil
	}
	return (*bitorExpr)(m)
}

type bitxorExpr memoExpr

func makeBitxorExpr(left opt.GroupID, right opt.GroupID) bitxorExpr {
	return bitxorExpr{op: opt.BitxorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitxorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitxorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitxorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitxor() *bitxorExpr {
	if m.op != opt.BitxorOp {
		return nil
	}
	return (*bitxorExpr)(m)
}

type plusExpr memoExpr

func makePlusExpr(left opt.GroupID, right opt.GroupID) plusExpr {
	return plusExpr{op: opt.PlusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *plusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *plusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *plusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlus() *plusExpr {
	if m.op != opt.PlusOp {
		return nil
	}
	return (*plusExpr)(m)
}

type minusExpr memoExpr

func makeMinusExpr(left opt.GroupID, right opt.GroupID) minusExpr {
	return minusExpr{op: opt.MinusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *minusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *minusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *minusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMinus() *minusExpr {
	if m.op != opt.MinusOp {
		return nil
	}
	return (*minusExpr)(m)
}

type multExpr memoExpr

func makeMultExpr(left opt.GroupID, right opt.GroupID) multExpr {
	return multExpr{op: opt.MultOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *multExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *multExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *multExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMult() *multExpr {
	if m.op != opt.MultOp {
		return nil
	}
	return (*multExpr)(m)
}

type divExpr memoExpr

func makeDivExpr(left opt.GroupID, right opt.GroupID) divExpr {
	return divExpr{op: opt.DivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *divExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *divExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *divExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asDiv() *divExpr {
	if m.op != opt.DivOp {
		return nil
	}
	return (*divExpr)(m)
}

type floorDivExpr memoExpr

func makeFloorDivExpr(left opt.GroupID, right opt.GroupID) floorDivExpr {
	return floorDivExpr{op: opt.FloorDivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *floorDivExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *floorDivExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *floorDivExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFloorDiv() *floorDivExpr {
	if m.op != opt.FloorDivOp {
		return nil
	}
	return (*floorDivExpr)(m)
}

type modExpr memoExpr

func makeModExpr(left opt.GroupID, right opt.GroupID) modExpr {
	return modExpr{op: opt.ModOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *modExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *modExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *modExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMod() *modExpr {
	if m.op != opt.ModOp {
		return nil
	}
	return (*modExpr)(m)
}

type powExpr memoExpr

func makePowExpr(left opt.GroupID, right opt.GroupID) powExpr {
	return powExpr{op: opt.PowOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *powExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *powExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *powExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPow() *powExpr {
	if m.op != opt.PowOp {
		return nil
	}
	return (*powExpr)(m)
}

type concatExpr memoExpr

func makeConcatExpr(left opt.GroupID, right opt.GroupID) concatExpr {
	return concatExpr{op: opt.ConcatOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *concatExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *concatExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *concatExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConcat() *concatExpr {
	if m.op != opt.ConcatOp {
		return nil
	}
	return (*concatExpr)(m)
}

type lShiftExpr memoExpr

func makeLShiftExpr(left opt.GroupID, right opt.GroupID) lShiftExpr {
	return lShiftExpr{op: opt.LShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *lShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *lShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *lShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLShift() *lShiftExpr {
	if m.op != opt.LShiftOp {
		return nil
	}
	return (*lShiftExpr)(m)
}

type rShiftExpr memoExpr

func makeRShiftExpr(left opt.GroupID, right opt.GroupID) rShiftExpr {
	return rShiftExpr{op: opt.RShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *rShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRShift() *rShiftExpr {
	if m.op != opt.RShiftOp {
		return nil
	}
	return (*rShiftExpr)(m)
}

type fetchValExpr memoExpr

func makeFetchValExpr(json opt.GroupID, index opt.GroupID) fetchValExpr {
	return fetchValExpr{op: opt.FetchValOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchValExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchVal() *fetchValExpr {
	if m.op != opt.FetchValOp {
		return nil
	}
	return (*fetchValExpr)(m)
}

type fetchTextExpr memoExpr

func makeFetchTextExpr(json opt.GroupID, index opt.GroupID) fetchTextExpr {
	return fetchTextExpr{op: opt.FetchTextOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchTextExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchText() *fetchTextExpr {
	if m.op != opt.FetchTextOp {
		return nil
	}
	return (*fetchTextExpr)(m)
}

type fetchValPathExpr memoExpr

func makeFetchValPathExpr(json opt.GroupID, path opt.GroupID) fetchValPathExpr {
	return fetchValPathExpr{op: opt.FetchValPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchValPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchValPath() *fetchValPathExpr {
	if m.op != opt.FetchValPathOp {
		return nil
	}
	return (*fetchValPathExpr)(m)
}

type fetchTextPathExpr memoExpr

func makeFetchTextPathExpr(json opt.GroupID, path opt.GroupID) fetchTextPathExpr {
	return fetchTextPathExpr{op: opt.FetchTextPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchTextPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchTextPath() *fetchTextPathExpr {
	if m.op != opt.FetchTextPathOp {
		return nil
	}
	return (*fetchTextPathExpr)(m)
}

type unaryPlusExpr memoExpr

func makeUnaryPlusExpr(input opt.GroupID) unaryPlusExpr {
	return unaryPlusExpr{op: opt.UnaryPlusOp, state: exprState{uint32(input)}}
}

func (e *unaryPlusExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryPlusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryPlus() *unaryPlusExpr {
	if m.op != opt.UnaryPlusOp {
		return nil
	}
	return (*unaryPlusExpr)(m)
}

type unaryMinusExpr memoExpr

func makeUnaryMinusExpr(input opt.GroupID) unaryMinusExpr {
	return unaryMinusExpr{op: opt.UnaryMinusOp, state: exprState{uint32(input)}}
}

func (e *unaryMinusExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryMinusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryMinus() *unaryMinusExpr {
	if m.op != opt.UnaryMinusOp {
		return nil
	}
	return (*unaryMinusExpr)(m)
}

type unaryComplementExpr memoExpr

func makeUnaryComplementExpr(input opt.GroupID) unaryComplementExpr {
	return unaryComplementExpr{op: opt.UnaryComplementOp, state: exprState{uint32(input)}}
}

func (e *unaryComplementExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryComplementExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryComplement() *unaryComplementExpr {
	if m.op != opt.UnaryComplementOp {
		return nil
	}
	return (*unaryComplementExpr)(m)
}

type castExpr memoExpr

func makeCastExpr(input opt.GroupID, typ opt.PrivateID) castExpr {
	return castExpr{op: opt.CastOp, state: exprState{uint32(input), uint32(typ)}}
}

func (e *castExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *castExpr) typ() opt.PrivateID {
	return opt.PrivateID(e.state[1])
}

func (e *castExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asCast() *castExpr {
	if m.op != opt.CastOp {
		return nil
	}
	return (*castExpr)(m)
}

// functionExpr invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The private field is an opt.FuncDef struct that provides the name
// of the function as well as a pointer to the builtin overload definition.
type functionExpr memoExpr

func makeFunctionExpr(args opt.ListID, def opt.PrivateID) functionExpr {
	return functionExpr{op: opt.FunctionOp, state: exprState{args.Offset, args.Length, uint32(def)}}
}

func (e *functionExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *functionExpr) def() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *functionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFunction() *functionExpr {
	if m.op != opt.FunctionOp {
		return nil
	}
	return (*functionExpr)(m)
}

type coalesceExpr memoExpr

func makeCoalesceExpr(args opt.ListID) coalesceExpr {
	return coalesceExpr{op: opt.CoalesceOp, state: exprState{args.Offset, args.Length}}
}

func (e *coalesceExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *coalesceExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asCoalesce() *coalesceExpr {
	if m.op != opt.CoalesceOp {
		return nil
	}
	return (*coalesceExpr)(m)
}

// unsupportedExprExpr is used for interfacing with the old planner code. It can
// encapsulate a TypedExpr that is otherwise not supported by the optimizer.
type unsupportedExprExpr memoExpr

func makeUnsupportedExprExpr(value opt.PrivateID) unsupportedExprExpr {
	return unsupportedExprExpr{op: opt.UnsupportedExprOp, state: exprState{uint32(value)}}
}

func (e *unsupportedExprExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *unsupportedExprExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnsupportedExpr() *unsupportedExprExpr {
	if m.op != opt.UnsupportedExprOp {
		return nil
	}
	return (*unsupportedExprExpr)(m)
}

// scanExpr returns a result set containing every row in the specified table. Rows
// and columns are not expected to have any particular ordering. The private
// Table field is a Metadata.TableIndex that references an optbase.Table
// definition in the query's metadata.
type scanExpr memoExpr

func makeScanExpr(table opt.PrivateID) scanExpr {
	return scanExpr{op: opt.ScanOp, state: exprState{uint32(table)}}
}

func (e *scanExpr) table() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *scanExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asScan() *scanExpr {
	if m.op != opt.ScanOp {
		return nil
	}
	return (*scanExpr)(m)
}

// valuesExpr returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as a *ColList. It is legal for Cols to be empty.
type valuesExpr memoExpr

func makeValuesExpr(rows opt.ListID, cols opt.PrivateID) valuesExpr {
	return valuesExpr{op: opt.ValuesOp, state: exprState{rows.Offset, rows.Length, uint32(cols)}}
}

func (e *valuesExpr) rows() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *valuesExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *valuesExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asValues() *valuesExpr {
	if m.op != opt.ValuesOp {
		return nil
	}
	return (*valuesExpr)(m)
}

// selectExpr filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded.
type selectExpr memoExpr

func makeSelectExpr(input opt.GroupID, filter opt.GroupID) selectExpr {
	return selectExpr{op: opt.SelectOp, state: exprState{uint32(input), uint32(filter)}}
}

func (e *selectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *selectExpr) filter() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *selectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSelect() *selectExpr {
	if m.op != opt.SelectOp {
		return nil
	}
	return (*selectExpr)(m)
}

// projectExpr modifies the set of columns returned by the input result set. Columns
// can be removed, reordered, or renamed. In addition, new columns can be
// synthesized. Projections is a scalar Projections list operator that contains
// the list of expressions that describe the output columns. The Cols field of
// the Projections operator provides the indexes of each of the output columns.
type projectExpr memoExpr

func makeProjectExpr(input opt.GroupID, projections opt.GroupID) projectExpr {
	return projectExpr{op: opt.ProjectOp, state: exprState{uint32(input), uint32(projections)}}
}

func (e *projectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *projectExpr) projections() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *projectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProject() *projectExpr {
	if m.op != opt.ProjectOp {
		return nil
	}
	return (*projectExpr)(m)
}

// innerJoinExpr creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
type innerJoinExpr memoExpr

func makeInnerJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinExpr {
	return innerJoinExpr{op: opt.InnerJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoin() *innerJoinExpr {
	if m.op != opt.InnerJoinOp {
		return nil
	}
	return (*innerJoinExpr)(m)
}

type leftJoinExpr memoExpr

func makeLeftJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinExpr {
	return leftJoinExpr{op: opt.LeftJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoin() *leftJoinExpr {
	if m.op != opt.LeftJoinOp {
		return nil
	}
	return (*leftJoinExpr)(m)
}

type rightJoinExpr memoExpr

func makeRightJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinExpr {
	return rightJoinExpr{op: opt.RightJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoin() *rightJoinExpr {
	if m.op != opt.RightJoinOp {
		return nil
	}
	return (*rightJoinExpr)(m)
}

type fullJoinExpr memoExpr

func makeFullJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinExpr {
	return fullJoinExpr{op: opt.FullJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoin() *fullJoinExpr {
	if m.op != opt.FullJoinOp {
		return nil
	}
	return (*fullJoinExpr)(m)
}

type semiJoinExpr memoExpr

func makeSemiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinExpr {
	return semiJoinExpr{op: opt.SemiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoin() *semiJoinExpr {
	if m.op != opt.SemiJoinOp {
		return nil
	}
	return (*semiJoinExpr)(m)
}

type antiJoinExpr memoExpr

func makeAntiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinExpr {
	return antiJoinExpr{op: opt.AntiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoin() *antiJoinExpr {
	if m.op != opt.AntiJoinOp {
		return nil
	}
	return (*antiJoinExpr)(m)
}

// innerJoinApplyExpr has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
type innerJoinApplyExpr memoExpr

func makeInnerJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinApplyExpr {
	return innerJoinApplyExpr{op: opt.InnerJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoinApply() *innerJoinApplyExpr {
	if m.op != opt.InnerJoinApplyOp {
		return nil
	}
	return (*innerJoinApplyExpr)(m)
}

type leftJoinApplyExpr memoExpr

func makeLeftJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinApplyExpr {
	return leftJoinApplyExpr{op: opt.LeftJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoinApply() *leftJoinApplyExpr {
	if m.op != opt.LeftJoinApplyOp {
		return nil
	}
	return (*leftJoinApplyExpr)(m)
}

type rightJoinApplyExpr memoExpr

func makeRightJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinApplyExpr {
	return rightJoinApplyExpr{op: opt.RightJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoinApply() *rightJoinApplyExpr {
	if m.op != opt.RightJoinApplyOp {
		return nil
	}
	return (*rightJoinApplyExpr)(m)
}

type fullJoinApplyExpr memoExpr

func makeFullJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinApplyExpr {
	return fullJoinApplyExpr{op: opt.FullJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoinApply() *fullJoinApplyExpr {
	if m.op != opt.FullJoinApplyOp {
		return nil
	}
	return (*fullJoinApplyExpr)(m)
}

type semiJoinApplyExpr memoExpr

func makeSemiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinApplyExpr {
	return semiJoinApplyExpr{op: opt.SemiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoinApply() *semiJoinApplyExpr {
	if m.op != opt.SemiJoinApplyOp {
		return nil
	}
	return (*semiJoinApplyExpr)(m)
}

type antiJoinApplyExpr memoExpr

func makeAntiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinApplyExpr {
	return antiJoinApplyExpr{op: opt.AntiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoinApply() *antiJoinApplyExpr {
	if m.op != opt.AntiJoinApplyOp {
		return nil
	}
	return (*antiJoinApplyExpr)(m)
}

// groupByExpr is an operator that is used for performing aggregations (for queries
// with aggregate functions, HAVING clauses and/or group by expressions). It
// groups results that are equal on the grouping columns and computes
// aggregations as described by Aggregations (which is always an Aggregations
// operator). The arguments of the aggregations are columns from the input.
type groupByExpr memoExpr

func makeGroupByExpr(input opt.GroupID, aggregations opt.GroupID, groupingColumns opt.PrivateID) groupByExpr {
	return groupByExpr{op: opt.GroupByOp, state: exprState{uint32(input), uint32(aggregations), uint32(groupingColumns)}}
}

func (e *groupByExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *groupByExpr) aggregations() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *groupByExpr) groupingColumns() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *groupByExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGroupBy() *groupByExpr {
	if m.op != opt.GroupByOp {
		return nil
	}
	return (*groupByExpr)(m)
}

// unionExpr is an operator used to combine the Left and Right input relations into
// a single set containing rows from both inputs. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Union with the output columns. See the comment above opt.SetOpColMap
// for more details.
type unionExpr memoExpr

func makeUnionExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) unionExpr {
	return unionExpr{op: opt.UnionOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unionExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *unionExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *unionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnion() *unionExpr {
	if m.op != opt.UnionOp {
		return nil
	}
	return (*unionExpr)(m)
}

// intersectExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that are also present in the Right relation. Duplicate rows are
// discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Intersect with the output columns. See the comment above
// opt.SetOpColMap for more details.
type intersectExpr memoExpr

func makeIntersectExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) intersectExpr {
	return intersectExpr{op: opt.IntersectOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *intersectExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *intersectExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *intersectExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *intersectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersect() *intersectExpr {
	if m.op != opt.IntersectOp {
		return nil
	}
	return (*intersectExpr)(m)
}

// exceptExpr is an operator used to perform a set difference between the Left and
// Right input relations. The result consists only of rows in the Left relation
// that are not present in the Right relation. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Except with the output columns. See the comment above opt.SetOpColMap
// for more details.
type exceptExpr memoExpr

func makeExceptExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) exceptExpr {
	return exceptExpr{op: opt.ExceptOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *exceptExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *exceptExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *exceptExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *exceptExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExcept() *exceptExpr {
	if m.op != opt.ExceptOp {
		return nil
	}
	return (*exceptExpr)(m)
}

// unionAllExpr is an operator used to combine the Left and Right input relations
// into a single set containing rows from both inputs. Duplicate rows are
// not discarded. For example:
//   SELECT x FROM xx UNION ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       2    ->    1
//     2       3          1
//                        2
//                        2
//                        3
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the UnionAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type unionAllExpr memoExpr

func makeUnionAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) unionAllExpr {
	return unionAllExpr{op: opt.UnionAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unionAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *unionAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *unionAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnionAll() *unionAllExpr {
	if m.op != opt.UnionAllOp {
		return nil
	}
	return (*unionAllExpr)(m)
}

// intersectAllExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that have a corresponding row in the Right relation. Duplicate rows
// are not discarded. This effectively creates a one-to-one mapping between the
// Left and Right rows. For example:
//   SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       1    ->    1
//     1       2          2
//     2       2          2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the IntersectAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type intersectAllExpr memoExpr

func makeIntersectAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) intersectAllExpr {
	return intersectAllExpr{op: opt.IntersectAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *intersectAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *intersectAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *intersectAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *intersectAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersectAll() *intersectAllExpr {
	if m.op != opt.IntersectAllOp {
		return nil
	}
	return (*intersectAllExpr)(m)
}

// exceptAllExpr is an operator used to perform a set difference between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that do not have a corresponding row in the Right relation.
// Duplicate rows are not discarded. This effectively creates a one-to-one
// mapping between the Left and Right rows. For example:
//   SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1    ->    1
//     1       1          4
//     1       2
//     2       2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the ExceptAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type exceptAllExpr memoExpr

func makeExceptAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) exceptAllExpr {
	return exceptAllExpr{op: opt.ExceptAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *exceptAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *exceptAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *exceptAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *exceptAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExceptAll() *exceptAllExpr {
	if m.op != opt.ExceptAllOp {
		return nil
	}
	return (*exceptAllExpr)(m)
}
