// Code generated by optgen; DO NOT EDIT.

package xform

type childCountLookupFunc func(e *Expr) int

var childCountLookup = []childCountLookupFunc{
	// UnknownOp
	func(e *Expr) int {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr) int {
		return 2
	},

	// VariableOp
	func(e *Expr) int {
		return 0
	},

	// ConstOp
	func(e *Expr) int {
		return 0
	},

	// PlaceholderOp
	func(e *Expr) int {
		return 0
	},

	// ListOp
	func(e *Expr) int {
		listExpr := (*listExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(listExpr.items().len)
	},

	// OrderedListOp
	func(e *Expr) int {
		orderedListExpr := (*orderedListExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(orderedListExpr.items().len)
	},

	// TupleOp
	func(e *Expr) int {
		tupleExpr := (*tupleExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(tupleExpr.elems().len)
	},

	// FiltersOp
	func(e *Expr) int {
		filtersExpr := (*filtersExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(filtersExpr.conditions().len)
	},

	// ProjectionsOp
	func(e *Expr) int {
		projectionsExpr := (*projectionsExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(projectionsExpr.items().len)
	},

	// ExistsOp
	func(e *Expr) int {
		return 1
	},

	// AndOp
	func(e *Expr) int {
		return 2
	},

	// OrOp
	func(e *Expr) int {
		return 2
	},

	// NotOp
	func(e *Expr) int {
		return 1
	},

	// EqOp
	func(e *Expr) int {
		return 2
	},

	// LtOp
	func(e *Expr) int {
		return 2
	},

	// GtOp
	func(e *Expr) int {
		return 2
	},

	// LeOp
	func(e *Expr) int {
		return 2
	},

	// GeOp
	func(e *Expr) int {
		return 2
	},

	// NeOp
	func(e *Expr) int {
		return 2
	},

	// InOp
	func(e *Expr) int {
		return 2
	},

	// NotInOp
	func(e *Expr) int {
		return 2
	},

	// LikeOp
	func(e *Expr) int {
		return 2
	},

	// NotLikeOp
	func(e *Expr) int {
		return 2
	},

	// ILikeOp
	func(e *Expr) int {
		return 2
	},

	// NotILikeOp
	func(e *Expr) int {
		return 2
	},

	// SimilarToOp
	func(e *Expr) int {
		return 2
	},

	// NotSimilarToOp
	func(e *Expr) int {
		return 2
	},

	// RegMatchOp
	func(e *Expr) int {
		return 2
	},

	// NotRegMatchOp
	func(e *Expr) int {
		return 2
	},

	// RegIMatchOp
	func(e *Expr) int {
		return 2
	},

	// NotRegIMatchOp
	func(e *Expr) int {
		return 2
	},

	// IsDistinctFromOp
	func(e *Expr) int {
		return 2
	},

	// IsNotDistinctFromOp
	func(e *Expr) int {
		return 2
	},

	// IsOp
	func(e *Expr) int {
		return 2
	},

	// IsNotOp
	func(e *Expr) int {
		return 2
	},

	// AnyOp
	func(e *Expr) int {
		return 2
	},

	// SomeOp
	func(e *Expr) int {
		return 2
	},

	// AllOp
	func(e *Expr) int {
		return 2
	},

	// BitandOp
	func(e *Expr) int {
		return 2
	},

	// BitorOp
	func(e *Expr) int {
		return 2
	},

	// BitxorOp
	func(e *Expr) int {
		return 2
	},

	// PlusOp
	func(e *Expr) int {
		return 2
	},

	// MinusOp
	func(e *Expr) int {
		return 2
	},

	// MultOp
	func(e *Expr) int {
		return 2
	},

	// DivOp
	func(e *Expr) int {
		return 2
	},

	// FloorDivOp
	func(e *Expr) int {
		return 2
	},

	// ModOp
	func(e *Expr) int {
		return 2
	},

	// PowOp
	func(e *Expr) int {
		return 2
	},

	// ConcatOp
	func(e *Expr) int {
		return 2
	},

	// LShiftOp
	func(e *Expr) int {
		return 2
	},

	// RShiftOp
	func(e *Expr) int {
		return 2
	},

	// UnaryPlusOp
	func(e *Expr) int {
		return 1
	},

	// UnaryMinusOp
	func(e *Expr) int {
		return 1
	},

	// UnaryComplementOp
	func(e *Expr) int {
		return 1
	},

	// FunctionOp
	func(e *Expr) int {
		functionExpr := (*functionExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(functionExpr.args().len)
	},

	// TrueOp
	func(e *Expr) int {
		return 0
	},

	// FalseOp
	func(e *Expr) int {
		return 0
	},

	// ScanOp
	func(e *Expr) int {
		return 0
	},

	// ValuesOp
	func(e *Expr) int {
		valuesExpr := (*valuesExpr)(e.mem.lookupExpr(e.loc))
		return 0 + int(valuesExpr.rows().len)
	},

	// SelectOp
	func(e *Expr) int {
		return 2
	},

	// ProjectOp
	func(e *Expr) int {
		return 2
	},

	// InnerJoinOp
	func(e *Expr) int {
		return 3
	},

	// LeftJoinOp
	func(e *Expr) int {
		return 3
	},

	// RightJoinOp
	func(e *Expr) int {
		return 3
	},

	// FullJoinOp
	func(e *Expr) int {
		return 3
	},

	// SemiJoinOp
	func(e *Expr) int {
		return 3
	},

	// AntiJoinOp
	func(e *Expr) int {
		return 3
	},

	// InnerJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// LeftJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// RightJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// FullJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// SemiJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// AntiJoinApplyOp
	func(e *Expr) int {
		return 3
	},

	// GroupByOp
	func(e *Expr) int {
		return 3
	},

	// UnionOp
	func(e *Expr) int {
		return 2
	},

	// IntersectOp
	func(e *Expr) int {
		return 2
	},

	// ExceptOp
	func(e *Expr) int {
		return 2
	},

	// SortOp
	func(e *Expr) int {
		return 1
	},

	// ArrangeOp
	func(e *Expr) int {
		return 1
	},
}

type childGroupLookupFunc func(e *Expr, n int) GroupID

var childGroupLookup = []childGroupLookupFunc{
	// UnknownOp
	func(e *Expr, n int) GroupID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr, n int) GroupID {
		subqueryExpr := (*subqueryExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return subqueryExpr.input()
		case 1:
			return subqueryExpr.projection()
		default:
			panic("child index out of range")
		}
	},

	// VariableOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ConstOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// PlaceholderOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ListOp
	func(e *Expr, n int) GroupID {
		listExpr := (*listExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(listExpr.items())
			return list[n-0]
		}
	},

	// OrderedListOp
	func(e *Expr, n int) GroupID {
		orderedListExpr := (*orderedListExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(orderedListExpr.items())
			return list[n-0]
		}
	},

	// TupleOp
	func(e *Expr, n int) GroupID {
		tupleExpr := (*tupleExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(tupleExpr.elems())
			return list[n-0]
		}
	},

	// FiltersOp
	func(e *Expr, n int) GroupID {
		filtersExpr := (*filtersExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(filtersExpr.conditions())
			return list[n-0]
		}
	},

	// ProjectionsOp
	func(e *Expr, n int) GroupID {
		projectionsExpr := (*projectionsExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(projectionsExpr.items())
			return list[n-0]
		}
	},

	// ExistsOp
	func(e *Expr, n int) GroupID {
		existsExpr := (*existsExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return existsExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// AndOp
	func(e *Expr, n int) GroupID {
		andExpr := (*andExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return andExpr.left()
		case 1:
			return andExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// OrOp
	func(e *Expr, n int) GroupID {
		orExpr := (*orExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return orExpr.left()
		case 1:
			return orExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotOp
	func(e *Expr, n int) GroupID {
		notExpr := (*notExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// EqOp
	func(e *Expr, n int) GroupID {
		eqExpr := (*eqExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return eqExpr.left()
		case 1:
			return eqExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LtOp
	func(e *Expr, n int) GroupID {
		ltExpr := (*ltExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return ltExpr.left()
		case 1:
			return ltExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// GtOp
	func(e *Expr, n int) GroupID {
		gtExpr := (*gtExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return gtExpr.left()
		case 1:
			return gtExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LeOp
	func(e *Expr, n int) GroupID {
		leExpr := (*leExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return leExpr.left()
		case 1:
			return leExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// GeOp
	func(e *Expr, n int) GroupID {
		geExpr := (*geExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return geExpr.left()
		case 1:
			return geExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NeOp
	func(e *Expr, n int) GroupID {
		neExpr := (*neExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return neExpr.left()
		case 1:
			return neExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// InOp
	func(e *Expr, n int) GroupID {
		inExpr := (*inExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return inExpr.left()
		case 1:
			return inExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotInOp
	func(e *Expr, n int) GroupID {
		notInExpr := (*notInExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notInExpr.left()
		case 1:
			return notInExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LikeOp
	func(e *Expr, n int) GroupID {
		likeExpr := (*likeExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return likeExpr.left()
		case 1:
			return likeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotLikeOp
	func(e *Expr, n int) GroupID {
		notLikeExpr := (*notLikeExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notLikeExpr.left()
		case 1:
			return notLikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ILikeOp
	func(e *Expr, n int) GroupID {
		iLikeExpr := (*iLikeExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return iLikeExpr.left()
		case 1:
			return iLikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotILikeOp
	func(e *Expr, n int) GroupID {
		notILikeExpr := (*notILikeExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notILikeExpr.left()
		case 1:
			return notILikeExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// SimilarToOp
	func(e *Expr, n int) GroupID {
		similarToExpr := (*similarToExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return similarToExpr.left()
		case 1:
			return similarToExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotSimilarToOp
	func(e *Expr, n int) GroupID {
		notSimilarToExpr := (*notSimilarToExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notSimilarToExpr.left()
		case 1:
			return notSimilarToExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RegMatchOp
	func(e *Expr, n int) GroupID {
		regMatchExpr := (*regMatchExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return regMatchExpr.left()
		case 1:
			return regMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotRegMatchOp
	func(e *Expr, n int) GroupID {
		notRegMatchExpr := (*notRegMatchExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notRegMatchExpr.left()
		case 1:
			return notRegMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RegIMatchOp
	func(e *Expr, n int) GroupID {
		regIMatchExpr := (*regIMatchExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return regIMatchExpr.left()
		case 1:
			return regIMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// NotRegIMatchOp
	func(e *Expr, n int) GroupID {
		notRegIMatchExpr := (*notRegIMatchExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return notRegIMatchExpr.left()
		case 1:
			return notRegIMatchExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsDistinctFromOp
	func(e *Expr, n int) GroupID {
		isDistinctFromExpr := (*isDistinctFromExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return isDistinctFromExpr.left()
		case 1:
			return isDistinctFromExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsNotDistinctFromOp
	func(e *Expr, n int) GroupID {
		isNotDistinctFromExpr := (*isNotDistinctFromExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return isNotDistinctFromExpr.left()
		case 1:
			return isNotDistinctFromExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsOp
	func(e *Expr, n int) GroupID {
		isExpr := (*isExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return isExpr.left()
		case 1:
			return isExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IsNotOp
	func(e *Expr, n int) GroupID {
		isNotExpr := (*isNotExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return isNotExpr.left()
		case 1:
			return isNotExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// AnyOp
	func(e *Expr, n int) GroupID {
		anyExpr := (*anyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return anyExpr.left()
		case 1:
			return anyExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// SomeOp
	func(e *Expr, n int) GroupID {
		someExpr := (*someExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return someExpr.left()
		case 1:
			return someExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// AllOp
	func(e *Expr, n int) GroupID {
		allExpr := (*allExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return allExpr.left()
		case 1:
			return allExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitandOp
	func(e *Expr, n int) GroupID {
		bitandExpr := (*bitandExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return bitandExpr.left()
		case 1:
			return bitandExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitorOp
	func(e *Expr, n int) GroupID {
		bitorExpr := (*bitorExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return bitorExpr.left()
		case 1:
			return bitorExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// BitxorOp
	func(e *Expr, n int) GroupID {
		bitxorExpr := (*bitxorExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return bitxorExpr.left()
		case 1:
			return bitxorExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// PlusOp
	func(e *Expr, n int) GroupID {
		plusExpr := (*plusExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return plusExpr.left()
		case 1:
			return plusExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// MinusOp
	func(e *Expr, n int) GroupID {
		minusExpr := (*minusExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return minusExpr.left()
		case 1:
			return minusExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// MultOp
	func(e *Expr, n int) GroupID {
		multExpr := (*multExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return multExpr.left()
		case 1:
			return multExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// DivOp
	func(e *Expr, n int) GroupID {
		divExpr := (*divExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return divExpr.left()
		case 1:
			return divExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// FloorDivOp
	func(e *Expr, n int) GroupID {
		floorDivExpr := (*floorDivExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return floorDivExpr.left()
		case 1:
			return floorDivExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ModOp
	func(e *Expr, n int) GroupID {
		modExpr := (*modExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return modExpr.left()
		case 1:
			return modExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// PowOp
	func(e *Expr, n int) GroupID {
		powExpr := (*powExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return powExpr.left()
		case 1:
			return powExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ConcatOp
	func(e *Expr, n int) GroupID {
		concatExpr := (*concatExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return concatExpr.left()
		case 1:
			return concatExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// LShiftOp
	func(e *Expr, n int) GroupID {
		lShiftExpr := (*lShiftExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return lShiftExpr.left()
		case 1:
			return lShiftExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// RShiftOp
	func(e *Expr, n int) GroupID {
		rShiftExpr := (*rShiftExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return rShiftExpr.left()
		case 1:
			return rShiftExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// UnaryPlusOp
	func(e *Expr, n int) GroupID {
		unaryPlusExpr := (*unaryPlusExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return unaryPlusExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// UnaryMinusOp
	func(e *Expr, n int) GroupID {
		unaryMinusExpr := (*unaryMinusExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return unaryMinusExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// UnaryComplementOp
	func(e *Expr, n int) GroupID {
		unaryComplementExpr := (*unaryComplementExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return unaryComplementExpr.input()
		default:
			panic("child index out of range")
		}
	},

	// FunctionOp
	func(e *Expr, n int) GroupID {
		functionExpr := (*functionExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(functionExpr.args())
			return list[n-0]
		}
	},

	// TrueOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// FalseOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ScanOp
	func(e *Expr, n int) GroupID {
		panic("child index out of range")
	},

	// ValuesOp
	func(e *Expr, n int) GroupID {
		valuesExpr := (*valuesExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		default:
			list := e.mem.lookupList(valuesExpr.rows())
			return list[n-0]
		}
	},

	// SelectOp
	func(e *Expr, n int) GroupID {
		selectExpr := (*selectExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return selectExpr.input()
		case 1:
			return selectExpr.filter()
		default:
			panic("child index out of range")
		}
	},

	// ProjectOp
	func(e *Expr, n int) GroupID {
		projectExpr := (*projectExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return projectExpr.input()
		case 1:
			return projectExpr.projections()
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinOp
	func(e *Expr, n int) GroupID {
		innerJoinExpr := (*innerJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return innerJoinExpr.left()
		case 1:
			return innerJoinExpr.right()
		case 2:
			return innerJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinOp
	func(e *Expr, n int) GroupID {
		leftJoinExpr := (*leftJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return leftJoinExpr.left()
		case 1:
			return leftJoinExpr.right()
		case 2:
			return leftJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// RightJoinOp
	func(e *Expr, n int) GroupID {
		rightJoinExpr := (*rightJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return rightJoinExpr.left()
		case 1:
			return rightJoinExpr.right()
		case 2:
			return rightJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// FullJoinOp
	func(e *Expr, n int) GroupID {
		fullJoinExpr := (*fullJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return fullJoinExpr.left()
		case 1:
			return fullJoinExpr.right()
		case 2:
			return fullJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinOp
	func(e *Expr, n int) GroupID {
		semiJoinExpr := (*semiJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return semiJoinExpr.left()
		case 1:
			return semiJoinExpr.right()
		case 2:
			return semiJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinOp
	func(e *Expr, n int) GroupID {
		antiJoinExpr := (*antiJoinExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return antiJoinExpr.left()
		case 1:
			return antiJoinExpr.right()
		case 2:
			return antiJoinExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// InnerJoinApplyOp
	func(e *Expr, n int) GroupID {
		innerJoinApplyExpr := (*innerJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return innerJoinApplyExpr.left()
		case 1:
			return innerJoinApplyExpr.right()
		case 2:
			return innerJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// LeftJoinApplyOp
	func(e *Expr, n int) GroupID {
		leftJoinApplyExpr := (*leftJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return leftJoinApplyExpr.left()
		case 1:
			return leftJoinApplyExpr.right()
		case 2:
			return leftJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// RightJoinApplyOp
	func(e *Expr, n int) GroupID {
		rightJoinApplyExpr := (*rightJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return rightJoinApplyExpr.left()
		case 1:
			return rightJoinApplyExpr.right()
		case 2:
			return rightJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// FullJoinApplyOp
	func(e *Expr, n int) GroupID {
		fullJoinApplyExpr := (*fullJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return fullJoinApplyExpr.left()
		case 1:
			return fullJoinApplyExpr.right()
		case 2:
			return fullJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// SemiJoinApplyOp
	func(e *Expr, n int) GroupID {
		semiJoinApplyExpr := (*semiJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return semiJoinApplyExpr.left()
		case 1:
			return semiJoinApplyExpr.right()
		case 2:
			return semiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// AntiJoinApplyOp
	func(e *Expr, n int) GroupID {
		antiJoinApplyExpr := (*antiJoinApplyExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return antiJoinApplyExpr.left()
		case 1:
			return antiJoinApplyExpr.right()
		case 2:
			return antiJoinApplyExpr.on()
		default:
			panic("child index out of range")
		}
	},

	// GroupByOp
	func(e *Expr, n int) GroupID {
		groupByExpr := (*groupByExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return groupByExpr.input()
		case 1:
			return groupByExpr.groupings()
		case 2:
			return groupByExpr.aggregations()
		default:
			panic("child index out of range")
		}
	},

	// UnionOp
	func(e *Expr, n int) GroupID {
		unionExpr := (*unionExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return unionExpr.left()
		case 1:
			return unionExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// IntersectOp
	func(e *Expr, n int) GroupID {
		intersectExpr := (*intersectExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return intersectExpr.left()
		case 1:
			return intersectExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// ExceptOp
	func(e *Expr, n int) GroupID {
		exceptExpr := (*exceptExpr)(e.mem.lookupExpr(e.loc))

		switch n {
		case 0:
			return exceptExpr.left()
		case 1:
			return exceptExpr.right()
		default:
			panic("child index out of range")
		}
	},

	// SortOp
	func(e *Expr, n int) GroupID {
		if n == 0 {
			return e.loc.group
		}

		panic("child index out of range")
	},

	// ArrangeOp
	func(e *Expr, n int) GroupID {
		if n == 0 {
			return e.loc.group
		}

		panic("child index out of range")
	},
}

type privateLookupFunc func(e *Expr) PrivateID

var privateLookup = []privateLookupFunc{
	// UnknownOp
	func(e *Expr) PrivateID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(e *Expr) PrivateID {
		return 0
	},

	// VariableOp
	func(e *Expr) PrivateID {
		variableExpr := (*variableExpr)(e.mem.lookupExpr(e.loc))
		return variableExpr.col()
	},

	// ConstOp
	func(e *Expr) PrivateID {
		constExpr := (*constExpr)(e.mem.lookupExpr(e.loc))
		return constExpr.value()
	},

	// PlaceholderOp
	func(e *Expr) PrivateID {
		placeholderExpr := (*placeholderExpr)(e.mem.lookupExpr(e.loc))
		return placeholderExpr.value()
	},

	// ListOp
	func(e *Expr) PrivateID {
		return 0
	},

	// OrderedListOp
	func(e *Expr) PrivateID {
		return 0
	},

	// TupleOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FiltersOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ProjectionsOp
	func(e *Expr) PrivateID {
		projectionsExpr := (*projectionsExpr)(e.mem.lookupExpr(e.loc))
		return projectionsExpr.cols()
	},

	// ExistsOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AndOp
	func(e *Expr) PrivateID {
		return 0
	},

	// OrOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotOp
	func(e *Expr) PrivateID {
		return 0
	},

	// EqOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LtOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GtOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotInOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotLikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ILikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotILikeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SimilarToOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotSimilarToOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RegMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotRegMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RegIMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// NotRegIMatchOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsDistinctFromOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsNotDistinctFromOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsOp
	func(e *Expr) PrivateID {
		return 0
	},

	// IsNotOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AnyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SomeOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AllOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitandOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitorOp
	func(e *Expr) PrivateID {
		return 0
	},

	// BitxorOp
	func(e *Expr) PrivateID {
		return 0
	},

	// PlusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// MinusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// MultOp
	func(e *Expr) PrivateID {
		return 0
	},

	// DivOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FloorDivOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ModOp
	func(e *Expr) PrivateID {
		return 0
	},

	// PowOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ConcatOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LShiftOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RShiftOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryPlusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryMinusOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnaryComplementOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FunctionOp
	func(e *Expr) PrivateID {
		functionExpr := (*functionExpr)(e.mem.lookupExpr(e.loc))
		return functionExpr.def()
	},

	// TrueOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FalseOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ScanOp
	func(e *Expr) PrivateID {
		scanExpr := (*scanExpr)(e.mem.lookupExpr(e.loc))
		return scanExpr.table()
	},

	// ValuesOp
	func(e *Expr) PrivateID {
		valuesExpr := (*valuesExpr)(e.mem.lookupExpr(e.loc))
		return valuesExpr.cols()
	},

	// SelectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ProjectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InnerJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeftJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RightJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FullJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SemiJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AntiJoinOp
	func(e *Expr) PrivateID {
		return 0
	},

	// InnerJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// LeftJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// RightJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// FullJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SemiJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// AntiJoinApplyOp
	func(e *Expr) PrivateID {
		return 0
	},

	// GroupByOp
	func(e *Expr) PrivateID {
		return 0
	},

	// UnionOp
	func(e *Expr) PrivateID {
		unionExpr := (*unionExpr)(e.mem.lookupExpr(e.loc))
		return unionExpr.colMap()
	},

	// IntersectOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ExceptOp
	func(e *Expr) PrivateID {
		return 0
	},

	// SortOp
	func(e *Expr) PrivateID {
		return 0
	},

	// ArrangeOp
	func(e *Expr) PrivateID {
		return 0
	},
}

var isScalarLookup = []bool{
	false, // UnknownOp

	true,  // SubqueryOp
	true,  // VariableOp
	true,  // ConstOp
	true,  // PlaceholderOp
	true,  // ListOp
	true,  // OrderedListOp
	true,  // TupleOp
	true,  // FiltersOp
	true,  // ProjectionsOp
	true,  // ExistsOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsDistinctFromOp
	true,  // IsNotDistinctFromOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // AnyOp
	true,  // SomeOp
	true,  // AllOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // UnaryPlusOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	true,  // FunctionOp
	true,  // TrueOp
	true,  // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isRelationalLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // TupleOp
	false, // FiltersOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	true,  // ScanOp
	true,  // ValuesOp
	true,  // SelectOp
	true,  // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	true,  // GroupByOp
	true,  // UnionOp
	true,  // IntersectOp
	true,  // ExceptOp
	true,  // SortOp
	true,  // ArrangeOp
}

var isJoinLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // TupleOp
	false, // FiltersOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isJoinApplyLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // TupleOp
	false, // FiltersOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // SortOp
	false, // ArrangeOp
}

var isEnforcerLookup = []bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // PlaceholderOp
	false, // ListOp
	false, // OrderedListOp
	false, // TupleOp
	false, // FiltersOp
	false, // ProjectionsOp
	false, // ExistsOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsDistinctFromOp
	false, // IsNotDistinctFromOp
	false, // IsOp
	false, // IsNotOp
	false, // AnyOp
	false, // SomeOp
	false, // AllOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // UnaryPlusOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // FunctionOp
	false, // TrueOp
	false, // FalseOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	true,  // SortOp
	true,  // ArrangeOp
}

func (e *Expr) IsScalar() bool {
	return isScalarLookup[e.op]
}

func (e *Expr) IsRelational() bool {
	return isRelationalLookup[e.op]
}

func (e *Expr) IsJoin() bool {
	return isJoinLookup[e.op]
}

func (e *Expr) IsJoinApply() bool {
	return isJoinApplyLookup[e.op]
}

func (e *Expr) IsEnforcer() bool {
	return isEnforcerLookup[e.op]
}

type subqueryExpr memoExpr

func makeSubqueryExpr(input GroupID, projection GroupID) subqueryExpr {
	return subqueryExpr{op: SubqueryOp, state: exprState{uint32(input), uint32(projection)}}
}

func (e *subqueryExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *subqueryExpr) projection() GroupID {
	return GroupID(e.state[1])
}

func (e *subqueryExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSubquery() *subqueryExpr {
	if m.op != SubqueryOp {
		return nil
	}
	return (*subqueryExpr)(m)
}

type variableExpr memoExpr

func makeVariableExpr(col PrivateID) variableExpr {
	return variableExpr{op: VariableOp, state: exprState{uint32(col)}}
}

func (e *variableExpr) col() PrivateID {
	return PrivateID(e.state[0])
}

func (e *variableExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asVariable() *variableExpr {
	if m.op != VariableOp {
		return nil
	}
	return (*variableExpr)(m)
}

type constExpr memoExpr

func makeConstExpr(value PrivateID) constExpr {
	return constExpr{op: ConstOp, state: exprState{uint32(value)}}
}

func (e *constExpr) value() PrivateID {
	return PrivateID(e.state[0])
}

func (e *constExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConst() *constExpr {
	if m.op != ConstOp {
		return nil
	}
	return (*constExpr)(m)
}

type placeholderExpr memoExpr

func makePlaceholderExpr(value PrivateID) placeholderExpr {
	return placeholderExpr{op: PlaceholderOp, state: exprState{uint32(value)}}
}

func (e *placeholderExpr) value() PrivateID {
	return PrivateID(e.state[0])
}

func (e *placeholderExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlaceholder() *placeholderExpr {
	if m.op != PlaceholderOp {
		return nil
	}
	return (*placeholderExpr)(m)
}

type listExpr memoExpr

func makeListExpr(items ListID) listExpr {
	return listExpr{op: ListOp, state: exprState{items.offset, items.len}}
}

func (e *listExpr) items() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *listExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asList() *listExpr {
	if m.op != ListOp {
		return nil
	}
	return (*listExpr)(m)
}

type orderedListExpr memoExpr

func makeOrderedListExpr(items ListID) orderedListExpr {
	return orderedListExpr{op: OrderedListOp, state: exprState{items.offset, items.len}}
}

func (e *orderedListExpr) items() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *orderedListExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOrderedList() *orderedListExpr {
	if m.op != OrderedListOp {
		return nil
	}
	return (*orderedListExpr)(m)
}

type tupleExpr memoExpr

func makeTupleExpr(elems ListID) tupleExpr {
	return tupleExpr{op: TupleOp, state: exprState{elems.offset, elems.len}}
}

func (e *tupleExpr) elems() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *tupleExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTuple() *tupleExpr {
	if m.op != TupleOp {
		return nil
	}
	return (*tupleExpr)(m)
}

type filtersExpr memoExpr

func makeFiltersExpr(conditions ListID) filtersExpr {
	return filtersExpr{op: FiltersOp, state: exprState{conditions.offset, conditions.len}}
}

func (e *filtersExpr) conditions() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *filtersExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFilters() *filtersExpr {
	if m.op != FiltersOp {
		return nil
	}
	return (*filtersExpr)(m)
}

type projectionsExpr memoExpr

func makeProjectionsExpr(items ListID, cols PrivateID) projectionsExpr {
	return projectionsExpr{op: ProjectionsOp, state: exprState{items.offset, items.len, uint32(cols)}}
}

func (e *projectionsExpr) items() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *projectionsExpr) cols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *projectionsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProjections() *projectionsExpr {
	if m.op != ProjectionsOp {
		return nil
	}
	return (*projectionsExpr)(m)
}

type existsExpr memoExpr

func makeExistsExpr(input GroupID) existsExpr {
	return existsExpr{op: ExistsOp, state: exprState{uint32(input)}}
}

func (e *existsExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *existsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExists() *existsExpr {
	if m.op != ExistsOp {
		return nil
	}
	return (*existsExpr)(m)
}

type andExpr memoExpr

func makeAndExpr(left GroupID, right GroupID) andExpr {
	return andExpr{op: AndOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *andExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *andExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *andExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAnd() *andExpr {
	if m.op != AndOp {
		return nil
	}
	return (*andExpr)(m)
}

type orExpr memoExpr

func makeOrExpr(left GroupID, right GroupID) orExpr {
	return orExpr{op: OrOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *orExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *orExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *orExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOr() *orExpr {
	if m.op != OrOp {
		return nil
	}
	return (*orExpr)(m)
}

type notExpr memoExpr

func makeNotExpr(input GroupID) notExpr {
	return notExpr{op: NotOp, state: exprState{uint32(input)}}
}

func (e *notExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *notExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNot() *notExpr {
	if m.op != NotOp {
		return nil
	}
	return (*notExpr)(m)
}

type eqExpr memoExpr

func makeEqExpr(left GroupID, right GroupID) eqExpr {
	return eqExpr{op: EqOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *eqExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *eqExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *eqExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asEq() *eqExpr {
	if m.op != EqOp {
		return nil
	}
	return (*eqExpr)(m)
}

type ltExpr memoExpr

func makeLtExpr(left GroupID, right GroupID) ltExpr {
	return ltExpr{op: LtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ltExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *ltExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *ltExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLt() *ltExpr {
	if m.op != LtOp {
		return nil
	}
	return (*ltExpr)(m)
}

type gtExpr memoExpr

func makeGtExpr(left GroupID, right GroupID) gtExpr {
	return gtExpr{op: GtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *gtExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *gtExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *gtExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGt() *gtExpr {
	if m.op != GtOp {
		return nil
	}
	return (*gtExpr)(m)
}

type leExpr memoExpr

func makeLeExpr(left GroupID, right GroupID) leExpr {
	return leExpr{op: LeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *leExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *leExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *leExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLe() *leExpr {
	if m.op != LeOp {
		return nil
	}
	return (*leExpr)(m)
}

type geExpr memoExpr

func makeGeExpr(left GroupID, right GroupID) geExpr {
	return geExpr{op: GeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *geExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *geExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *geExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGe() *geExpr {
	if m.op != GeOp {
		return nil
	}
	return (*geExpr)(m)
}

type neExpr memoExpr

func makeNeExpr(left GroupID, right GroupID) neExpr {
	return neExpr{op: NeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *neExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *neExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *neExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNe() *neExpr {
	if m.op != NeOp {
		return nil
	}
	return (*neExpr)(m)
}

type inExpr memoExpr

func makeInExpr(left GroupID, right GroupID) inExpr {
	return inExpr{op: InOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *inExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *inExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *inExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIn() *inExpr {
	if m.op != InOp {
		return nil
	}
	return (*inExpr)(m)
}

type notInExpr memoExpr

func makeNotInExpr(left GroupID, right GroupID) notInExpr {
	return notInExpr{op: NotInOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notInExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notInExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notInExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotIn() *notInExpr {
	if m.op != NotInOp {
		return nil
	}
	return (*notInExpr)(m)
}

type likeExpr memoExpr

func makeLikeExpr(left GroupID, right GroupID) likeExpr {
	return likeExpr{op: LikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *likeExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *likeExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *likeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLike() *likeExpr {
	if m.op != LikeOp {
		return nil
	}
	return (*likeExpr)(m)
}

type notLikeExpr memoExpr

func makeNotLikeExpr(left GroupID, right GroupID) notLikeExpr {
	return notLikeExpr{op: NotLikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notLikeExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notLikeExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotLike() *notLikeExpr {
	if m.op != NotLikeOp {
		return nil
	}
	return (*notLikeExpr)(m)
}

type iLikeExpr memoExpr

func makeILikeExpr(left GroupID, right GroupID) iLikeExpr {
	return iLikeExpr{op: ILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *iLikeExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *iLikeExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *iLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asILike() *iLikeExpr {
	if m.op != ILikeOp {
		return nil
	}
	return (*iLikeExpr)(m)
}

type notILikeExpr memoExpr

func makeNotILikeExpr(left GroupID, right GroupID) notILikeExpr {
	return notILikeExpr{op: NotILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notILikeExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notILikeExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notILikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotILike() *notILikeExpr {
	if m.op != NotILikeOp {
		return nil
	}
	return (*notILikeExpr)(m)
}

type similarToExpr memoExpr

func makeSimilarToExpr(left GroupID, right GroupID) similarToExpr {
	return similarToExpr{op: SimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *similarToExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *similarToExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *similarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSimilarTo() *similarToExpr {
	if m.op != SimilarToOp {
		return nil
	}
	return (*similarToExpr)(m)
}

type notSimilarToExpr memoExpr

func makeNotSimilarToExpr(left GroupID, right GroupID) notSimilarToExpr {
	return notSimilarToExpr{op: NotSimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notSimilarToExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notSimilarToExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notSimilarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotSimilarTo() *notSimilarToExpr {
	if m.op != NotSimilarToOp {
		return nil
	}
	return (*notSimilarToExpr)(m)
}

type regMatchExpr memoExpr

func makeRegMatchExpr(left GroupID, right GroupID) regMatchExpr {
	return regMatchExpr{op: RegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regMatchExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *regMatchExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *regMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegMatch() *regMatchExpr {
	if m.op != RegMatchOp {
		return nil
	}
	return (*regMatchExpr)(m)
}

type notRegMatchExpr memoExpr

func makeNotRegMatchExpr(left GroupID, right GroupID) notRegMatchExpr {
	return notRegMatchExpr{op: NotRegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegMatchExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notRegMatchExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notRegMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegMatch() *notRegMatchExpr {
	if m.op != NotRegMatchOp {
		return nil
	}
	return (*notRegMatchExpr)(m)
}

type regIMatchExpr memoExpr

func makeRegIMatchExpr(left GroupID, right GroupID) regIMatchExpr {
	return regIMatchExpr{op: RegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regIMatchExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *regIMatchExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *regIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegIMatch() *regIMatchExpr {
	if m.op != RegIMatchOp {
		return nil
	}
	return (*regIMatchExpr)(m)
}

type notRegIMatchExpr memoExpr

func makeNotRegIMatchExpr(left GroupID, right GroupID) notRegIMatchExpr {
	return notRegIMatchExpr{op: NotRegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegIMatchExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *notRegIMatchExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *notRegIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegIMatch() *notRegIMatchExpr {
	if m.op != NotRegIMatchOp {
		return nil
	}
	return (*notRegIMatchExpr)(m)
}

type isDistinctFromExpr memoExpr

func makeIsDistinctFromExpr(left GroupID, right GroupID) isDistinctFromExpr {
	return isDistinctFromExpr{op: IsDistinctFromOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isDistinctFromExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *isDistinctFromExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *isDistinctFromExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsDistinctFrom() *isDistinctFromExpr {
	if m.op != IsDistinctFromOp {
		return nil
	}
	return (*isDistinctFromExpr)(m)
}

type isNotDistinctFromExpr memoExpr

func makeIsNotDistinctFromExpr(left GroupID, right GroupID) isNotDistinctFromExpr {
	return isNotDistinctFromExpr{op: IsNotDistinctFromOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isNotDistinctFromExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *isNotDistinctFromExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *isNotDistinctFromExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsNotDistinctFrom() *isNotDistinctFromExpr {
	if m.op != IsNotDistinctFromOp {
		return nil
	}
	return (*isNotDistinctFromExpr)(m)
}

type isExpr memoExpr

func makeIsExpr(left GroupID, right GroupID) isExpr {
	return isExpr{op: IsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *isExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *isExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIs() *isExpr {
	if m.op != IsOp {
		return nil
	}
	return (*isExpr)(m)
}

type isNotExpr memoExpr

func makeIsNotExpr(left GroupID, right GroupID) isNotExpr {
	return isNotExpr{op: IsNotOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isNotExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *isNotExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *isNotExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsNot() *isNotExpr {
	if m.op != IsNotOp {
		return nil
	}
	return (*isNotExpr)(m)
}

type anyExpr memoExpr

func makeAnyExpr(left GroupID, right GroupID) anyExpr {
	return anyExpr{op: AnyOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *anyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *anyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *anyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAny() *anyExpr {
	if m.op != AnyOp {
		return nil
	}
	return (*anyExpr)(m)
}

type someExpr memoExpr

func makeSomeExpr(left GroupID, right GroupID) someExpr {
	return someExpr{op: SomeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *someExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *someExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *someExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSome() *someExpr {
	if m.op != SomeOp {
		return nil
	}
	return (*someExpr)(m)
}

type allExpr memoExpr

func makeAllExpr(left GroupID, right GroupID) allExpr {
	return allExpr{op: AllOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *allExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *allExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *allExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAll() *allExpr {
	if m.op != AllOp {
		return nil
	}
	return (*allExpr)(m)
}

type bitandExpr memoExpr

func makeBitandExpr(left GroupID, right GroupID) bitandExpr {
	return bitandExpr{op: BitandOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitandExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *bitandExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *bitandExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitand() *bitandExpr {
	if m.op != BitandOp {
		return nil
	}
	return (*bitandExpr)(m)
}

type bitorExpr memoExpr

func makeBitorExpr(left GroupID, right GroupID) bitorExpr {
	return bitorExpr{op: BitorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitorExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *bitorExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *bitorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitor() *bitorExpr {
	if m.op != BitorOp {
		return nil
	}
	return (*bitorExpr)(m)
}

type bitxorExpr memoExpr

func makeBitxorExpr(left GroupID, right GroupID) bitxorExpr {
	return bitxorExpr{op: BitxorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitxorExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *bitxorExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *bitxorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitxor() *bitxorExpr {
	if m.op != BitxorOp {
		return nil
	}
	return (*bitxorExpr)(m)
}

type plusExpr memoExpr

func makePlusExpr(left GroupID, right GroupID) plusExpr {
	return plusExpr{op: PlusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *plusExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *plusExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *plusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlus() *plusExpr {
	if m.op != PlusOp {
		return nil
	}
	return (*plusExpr)(m)
}

type minusExpr memoExpr

func makeMinusExpr(left GroupID, right GroupID) minusExpr {
	return minusExpr{op: MinusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *minusExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *minusExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *minusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMinus() *minusExpr {
	if m.op != MinusOp {
		return nil
	}
	return (*minusExpr)(m)
}

type multExpr memoExpr

func makeMultExpr(left GroupID, right GroupID) multExpr {
	return multExpr{op: MultOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *multExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *multExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *multExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMult() *multExpr {
	if m.op != MultOp {
		return nil
	}
	return (*multExpr)(m)
}

type divExpr memoExpr

func makeDivExpr(left GroupID, right GroupID) divExpr {
	return divExpr{op: DivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *divExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *divExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *divExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asDiv() *divExpr {
	if m.op != DivOp {
		return nil
	}
	return (*divExpr)(m)
}

type floorDivExpr memoExpr

func makeFloorDivExpr(left GroupID, right GroupID) floorDivExpr {
	return floorDivExpr{op: FloorDivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *floorDivExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *floorDivExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *floorDivExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFloorDiv() *floorDivExpr {
	if m.op != FloorDivOp {
		return nil
	}
	return (*floorDivExpr)(m)
}

type modExpr memoExpr

func makeModExpr(left GroupID, right GroupID) modExpr {
	return modExpr{op: ModOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *modExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *modExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *modExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMod() *modExpr {
	if m.op != ModOp {
		return nil
	}
	return (*modExpr)(m)
}

type powExpr memoExpr

func makePowExpr(left GroupID, right GroupID) powExpr {
	return powExpr{op: PowOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *powExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *powExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *powExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPow() *powExpr {
	if m.op != PowOp {
		return nil
	}
	return (*powExpr)(m)
}

type concatExpr memoExpr

func makeConcatExpr(left GroupID, right GroupID) concatExpr {
	return concatExpr{op: ConcatOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *concatExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *concatExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *concatExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConcat() *concatExpr {
	if m.op != ConcatOp {
		return nil
	}
	return (*concatExpr)(m)
}

type lShiftExpr memoExpr

func makeLShiftExpr(left GroupID, right GroupID) lShiftExpr {
	return lShiftExpr{op: LShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *lShiftExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *lShiftExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *lShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLShift() *lShiftExpr {
	if m.op != LShiftOp {
		return nil
	}
	return (*lShiftExpr)(m)
}

type rShiftExpr memoExpr

func makeRShiftExpr(left GroupID, right GroupID) rShiftExpr {
	return rShiftExpr{op: RShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *rShiftExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *rShiftExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *rShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRShift() *rShiftExpr {
	if m.op != RShiftOp {
		return nil
	}
	return (*rShiftExpr)(m)
}

type unaryPlusExpr memoExpr

func makeUnaryPlusExpr(input GroupID) unaryPlusExpr {
	return unaryPlusExpr{op: UnaryPlusOp, state: exprState{uint32(input)}}
}

func (e *unaryPlusExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *unaryPlusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryPlus() *unaryPlusExpr {
	if m.op != UnaryPlusOp {
		return nil
	}
	return (*unaryPlusExpr)(m)
}

type unaryMinusExpr memoExpr

func makeUnaryMinusExpr(input GroupID) unaryMinusExpr {
	return unaryMinusExpr{op: UnaryMinusOp, state: exprState{uint32(input)}}
}

func (e *unaryMinusExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *unaryMinusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryMinus() *unaryMinusExpr {
	if m.op != UnaryMinusOp {
		return nil
	}
	return (*unaryMinusExpr)(m)
}

type unaryComplementExpr memoExpr

func makeUnaryComplementExpr(input GroupID) unaryComplementExpr {
	return unaryComplementExpr{op: UnaryComplementOp, state: exprState{uint32(input)}}
}

func (e *unaryComplementExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *unaryComplementExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryComplement() *unaryComplementExpr {
	if m.op != UnaryComplementOp {
		return nil
	}
	return (*unaryComplementExpr)(m)
}

type functionExpr memoExpr

func makeFunctionExpr(args ListID, def PrivateID) functionExpr {
	return functionExpr{op: FunctionOp, state: exprState{args.offset, args.len, uint32(def)}}
}

func (e *functionExpr) args() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *functionExpr) def() PrivateID {
	return PrivateID(e.state[2])
}

func (e *functionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFunction() *functionExpr {
	if m.op != FunctionOp {
		return nil
	}
	return (*functionExpr)(m)
}

type trueExpr memoExpr

func makeTrueExpr() trueExpr {
	return trueExpr{op: TrueOp, state: exprState{}}
}

func (e *trueExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTrue() *trueExpr {
	if m.op != TrueOp {
		return nil
	}
	return (*trueExpr)(m)
}

type falseExpr memoExpr

func makeFalseExpr() falseExpr {
	return falseExpr{op: FalseOp, state: exprState{}}
}

func (e *falseExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFalse() *falseExpr {
	if m.op != FalseOp {
		return nil
	}
	return (*falseExpr)(m)
}

type scanExpr memoExpr

func makeScanExpr(table PrivateID) scanExpr {
	return scanExpr{op: ScanOp, state: exprState{uint32(table)}}
}

func (e *scanExpr) table() PrivateID {
	return PrivateID(e.state[0])
}

func (e *scanExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asScan() *scanExpr {
	if m.op != ScanOp {
		return nil
	}
	return (*scanExpr)(m)
}

type valuesExpr memoExpr

func makeValuesExpr(rows ListID, cols PrivateID) valuesExpr {
	return valuesExpr{op: ValuesOp, state: exprState{rows.offset, rows.len, uint32(cols)}}
}

func (e *valuesExpr) rows() ListID {
	return ListID{offset: e.state[0], len: e.state[1]}
}

func (e *valuesExpr) cols() PrivateID {
	return PrivateID(e.state[2])
}

func (e *valuesExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asValues() *valuesExpr {
	if m.op != ValuesOp {
		return nil
	}
	return (*valuesExpr)(m)
}

type selectExpr memoExpr

func makeSelectExpr(input GroupID, filter GroupID) selectExpr {
	return selectExpr{op: SelectOp, state: exprState{uint32(input), uint32(filter)}}
}

func (e *selectExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *selectExpr) filter() GroupID {
	return GroupID(e.state[1])
}

func (e *selectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSelect() *selectExpr {
	if m.op != SelectOp {
		return nil
	}
	return (*selectExpr)(m)
}

type projectExpr memoExpr

func makeProjectExpr(input GroupID, projections GroupID) projectExpr {
	return projectExpr{op: ProjectOp, state: exprState{uint32(input), uint32(projections)}}
}

func (e *projectExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *projectExpr) projections() GroupID {
	return GroupID(e.state[1])
}

func (e *projectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProject() *projectExpr {
	if m.op != ProjectOp {
		return nil
	}
	return (*projectExpr)(m)
}

type innerJoinExpr memoExpr

func makeInnerJoinExpr(left GroupID, right GroupID, on GroupID) innerJoinExpr {
	return innerJoinExpr{op: InnerJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *innerJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *innerJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *innerJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoin() *innerJoinExpr {
	if m.op != InnerJoinOp {
		return nil
	}
	return (*innerJoinExpr)(m)
}

type leftJoinExpr memoExpr

func makeLeftJoinExpr(left GroupID, right GroupID, on GroupID) leftJoinExpr {
	return leftJoinExpr{op: LeftJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *leftJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *leftJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *leftJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoin() *leftJoinExpr {
	if m.op != LeftJoinOp {
		return nil
	}
	return (*leftJoinExpr)(m)
}

type rightJoinExpr memoExpr

func makeRightJoinExpr(left GroupID, right GroupID, on GroupID) rightJoinExpr {
	return rightJoinExpr{op: RightJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *rightJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *rightJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *rightJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoin() *rightJoinExpr {
	if m.op != RightJoinOp {
		return nil
	}
	return (*rightJoinExpr)(m)
}

type fullJoinExpr memoExpr

func makeFullJoinExpr(left GroupID, right GroupID, on GroupID) fullJoinExpr {
	return fullJoinExpr{op: FullJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *fullJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *fullJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *fullJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoin() *fullJoinExpr {
	if m.op != FullJoinOp {
		return nil
	}
	return (*fullJoinExpr)(m)
}

type semiJoinExpr memoExpr

func makeSemiJoinExpr(left GroupID, right GroupID, on GroupID) semiJoinExpr {
	return semiJoinExpr{op: SemiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *semiJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *semiJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *semiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoin() *semiJoinExpr {
	if m.op != SemiJoinOp {
		return nil
	}
	return (*semiJoinExpr)(m)
}

type antiJoinExpr memoExpr

func makeAntiJoinExpr(left GroupID, right GroupID, on GroupID) antiJoinExpr {
	return antiJoinExpr{op: AntiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *antiJoinExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *antiJoinExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *antiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoin() *antiJoinExpr {
	if m.op != AntiJoinOp {
		return nil
	}
	return (*antiJoinExpr)(m)
}

type innerJoinApplyExpr memoExpr

func makeInnerJoinApplyExpr(left GroupID, right GroupID, on GroupID) innerJoinApplyExpr {
	return innerJoinApplyExpr{op: InnerJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *innerJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *innerJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *innerJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoinApply() *innerJoinApplyExpr {
	if m.op != InnerJoinApplyOp {
		return nil
	}
	return (*innerJoinApplyExpr)(m)
}

type leftJoinApplyExpr memoExpr

func makeLeftJoinApplyExpr(left GroupID, right GroupID, on GroupID) leftJoinApplyExpr {
	return leftJoinApplyExpr{op: LeftJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *leftJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *leftJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *leftJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoinApply() *leftJoinApplyExpr {
	if m.op != LeftJoinApplyOp {
		return nil
	}
	return (*leftJoinApplyExpr)(m)
}

type rightJoinApplyExpr memoExpr

func makeRightJoinApplyExpr(left GroupID, right GroupID, on GroupID) rightJoinApplyExpr {
	return rightJoinApplyExpr{op: RightJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *rightJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *rightJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *rightJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoinApply() *rightJoinApplyExpr {
	if m.op != RightJoinApplyOp {
		return nil
	}
	return (*rightJoinApplyExpr)(m)
}

type fullJoinApplyExpr memoExpr

func makeFullJoinApplyExpr(left GroupID, right GroupID, on GroupID) fullJoinApplyExpr {
	return fullJoinApplyExpr{op: FullJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *fullJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *fullJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *fullJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoinApply() *fullJoinApplyExpr {
	if m.op != FullJoinApplyOp {
		return nil
	}
	return (*fullJoinApplyExpr)(m)
}

type semiJoinApplyExpr memoExpr

func makeSemiJoinApplyExpr(left GroupID, right GroupID, on GroupID) semiJoinApplyExpr {
	return semiJoinApplyExpr{op: SemiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *semiJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *semiJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *semiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoinApply() *semiJoinApplyExpr {
	if m.op != SemiJoinApplyOp {
		return nil
	}
	return (*semiJoinApplyExpr)(m)
}

type antiJoinApplyExpr memoExpr

func makeAntiJoinApplyExpr(left GroupID, right GroupID, on GroupID) antiJoinApplyExpr {
	return antiJoinApplyExpr{op: AntiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinApplyExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *antiJoinApplyExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *antiJoinApplyExpr) on() GroupID {
	return GroupID(e.state[2])
}

func (e *antiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoinApply() *antiJoinApplyExpr {
	if m.op != AntiJoinApplyOp {
		return nil
	}
	return (*antiJoinApplyExpr)(m)
}

type groupByExpr memoExpr

func makeGroupByExpr(input GroupID, groupings GroupID, aggregations GroupID) groupByExpr {
	return groupByExpr{op: GroupByOp, state: exprState{uint32(input), uint32(groupings), uint32(aggregations)}}
}

func (e *groupByExpr) input() GroupID {
	return GroupID(e.state[0])
}

func (e *groupByExpr) groupings() GroupID {
	return GroupID(e.state[1])
}

func (e *groupByExpr) aggregations() GroupID {
	return GroupID(e.state[2])
}

func (e *groupByExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGroupBy() *groupByExpr {
	if m.op != GroupByOp {
		return nil
	}
	return (*groupByExpr)(m)
}

type unionExpr memoExpr

func makeUnionExpr(left GroupID, right GroupID, colMap PrivateID) unionExpr {
	return unionExpr{op: UnionOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *unionExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *unionExpr) colMap() PrivateID {
	return PrivateID(e.state[2])
}

func (e *unionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnion() *unionExpr {
	if m.op != UnionOp {
		return nil
	}
	return (*unionExpr)(m)
}

type intersectExpr memoExpr

func makeIntersectExpr(left GroupID, right GroupID) intersectExpr {
	return intersectExpr{op: IntersectOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *intersectExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *intersectExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *intersectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersect() *intersectExpr {
	if m.op != IntersectOp {
		return nil
	}
	return (*intersectExpr)(m)
}

type exceptExpr memoExpr

func makeExceptExpr(left GroupID, right GroupID) exceptExpr {
	return exceptExpr{op: ExceptOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *exceptExpr) left() GroupID {
	return GroupID(e.state[0])
}

func (e *exceptExpr) right() GroupID {
	return GroupID(e.state[1])
}

func (e *exceptExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExcept() *exceptExpr {
	if m.op != ExceptOp {
		return nil
	}
	return (*exceptExpr)(m)
}
